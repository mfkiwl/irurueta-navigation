<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>IMUBiasEstimator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.irurueta:irurueta-navigation</a> &gt; <a href="index.source.html" class="el_package">com.irurueta.navigation.inertial.calibration</a> &gt; <span class="el_source">IMUBiasEstimator.java</span></div><h1>IMUBiasEstimator.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2020 Alberto Irurueta Carro (alberto@irurueta.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.irurueta.navigation.inertial.calibration;

import com.irurueta.algebra.Matrix;
import com.irurueta.algebra.WrongSizeException;
import com.irurueta.geometry.Point3D;
import com.irurueta.navigation.LockedException;
import com.irurueta.navigation.frames.CoordinateTransformation;
import com.irurueta.navigation.frames.ECEFFrame;
import com.irurueta.navigation.frames.InvalidSourceAndDestinationFrameTypeException;
import com.irurueta.navigation.frames.NEDFrame;
import com.irurueta.navigation.frames.converters.ECEFtoNEDFrameConverter;
import com.irurueta.navigation.frames.converters.NEDtoECEFFrameConverter;
import com.irurueta.navigation.inertial.BodyKinematics;
import com.irurueta.navigation.inertial.ECEFPosition;
import com.irurueta.navigation.inertial.NEDPosition;
import com.irurueta.navigation.inertial.estimators.ECEFKinematicsEstimator;
import com.irurueta.units.Acceleration;
import com.irurueta.units.AccelerationUnit;
import com.irurueta.units.Angle;
import com.irurueta.units.AngularSpeed;
import com.irurueta.units.AngularSpeedUnit;
import com.irurueta.units.Distance;
import com.irurueta.units.Time;
import com.irurueta.units.TimeConverter;
import com.irurueta.units.TimeUnit;

/**
 * This class estimates IMU accelerometer and gyroscope biases and noise PSD's by
 * averaging all provided samples when body position and orientation is known.
 * &lt;p&gt;
 * This estimator must be used when the body where the IMU is attached remains static
 * on the same position with zero velocity while capturing data.
 * &lt;p&gt;
 * To compute PSD's, this estimator assumes that IMU samples are obtained at a constant
 * provided rate equal to {@link #getTimeInterval()} seconds.
 * If not available, IMU sampling rate average can be estimated using
 * {@link IMUTimeIntervalEstimator}.
 * &lt;p&gt;
 * Notice that in order to compute accelerometer and gyroscope biases, body position
 * and orientation must be known to account for gravity and Earth rotation effects.
 * If only noise PSD's levels are required {@link IMUNoiseEstimator} can be used
 * instead, if body position and orientation is not available.
 */
public class IMUBiasEstimator {

    /**
     * Default total samples to be processed.
     */
    public static final int DEFAULT_TOTAL_SAMPLES = 100000;

    /**
     * Default time interval between body kinematics samples expressed in seconds (s).
     */
    public static final double DEFAULT_TIME_INTERVAL_SECONDS = 0.02;

    /**
     * Total samples to be processed to finish estimation.
     */
<span class="fc" id="L74">    private int mTotalSamples = DEFAULT_TOTAL_SAMPLES;</span>

    /**
     * Time interval expressed in seconds (s) between body kinematics samples.
     */
<span class="fc" id="L79">    private double mTimeInterval = DEFAULT_TIME_INTERVAL_SECONDS;</span>

    /**
     * Contains body position, velocity (which will always be zero) and orientation
     * resolved around ECEF axes.
     * By default it is assumed that body is located at zero NED coordinates (latitude,
     * longitude and height) and with zero Euler angles representing rotation (roll = 0,
     * pith = 0, yaw = 0), which for Android devices it means that the device is flat
     * on a horizontal surface with the screen facing down.
     */
    private ECEFFrame mFrame;

    /**
     * Listener to handle events raised by this estimator.
     */
    private IMUBiasEstimatorListener mListener;

    /**
     * Last provided body kinematics values.
     */
    private BodyKinematics mLastBodyKinematics;

    /**
     * Contains estimated bias of x coordinate of accelerometer sensed specific force
     * expressed in meters per squared second (m/s^2).
     */
    private double mBiasFx;

    /**
     * Contains estimated bias of y coordinate of accelerometer sensed specific force
     * expressed in meters per squared second (m/s^2).
     */
    private double mBiasFy;

    /**
     * Contains estimated bias of z coordinate of accelerometer sensed specific force
     * expressed in meters per squared second (m/s^2).
     */
    private double mBiasFz;

    /**
     * Contains estimated bias of x coordinate of gyroscope sensed angular rate
     * expressed in radians per second (rad/s).
     */
    private double mBiasAngularRateX;

    /**
     * Contains estimated bias of y coordinate of gyroscope sensed angular rate
     * expressed in radians per second (rad/s).
     */
    private double mBiasAngularRateY;

    /**
     * Contains estimated bias of z coordinate of gyroscope sensed angular rate
     * expressed in radians per second (rad/s).
     */
    private double mBiasAngularRateZ;

    /**
     * Contains estimated variance of x coordinate of accelerometer sensed specific
     * force expressed in (m^2/s^4).
     */
    private double mVarianceFx;

    /**
     * Contains estimated variance of y coordinate of accelerometer sensed specific
     * force expressed in (m^2/s^4).
     */
    private double mVarianceFy;

    /**
     * Contains estimated variance of z coordinate of accelerometer sensed specific
     * force expressed in (m^2/s4).
     */
    private double mVarianceFz;

    /**
     * Contains estimated variance of x coordinate of gyroscope sensed angular rate
     * expressed in (rad^2/s^2).
     */
    private double mVarianceAngularRateX;

    /**
     * Contains estimated variance of y coordinate of gyroscope sensed angular rate
     * expressed in (rad^2/s^2).
     */
    private double mVarianceAngularRateY;

    /**
     * Contains estimated variance of z coordinate of gyroscope sensed angular rate
     * expressed in (rad^2/s^2).
     */
    private double mVarianceAngularRateZ;

    /**
     * Number of processed body kinematics samples.
     */
    private int mNumberOfProcessedSamples;

    /**
     * Number of processed timestamp samples plus one.
     */
<span class="fc" id="L181">    private int mNumberOfProcessedSamplesPlusOne = 1;</span>

    /**
     * Indicates that estimator is running.
     */
    private boolean mRunning;

    /**
     * Theoretical expected body kinematics for provided body position and orientation,
     * and provided time interval, assuming that body remains at the same position
     * (zero velocity).
     * When body remains static, sensed specific force and angular rates will remain
     * constant due to gravity and Earth rotation.
     */
    private BodyKinematics mExpectedKinematics;

    /**
     * Constructor.
     * It is assumed that body is located at zero NED coordinates (latitude = 0,
     * longitude = 0 and height = 0) and with zero Euler angles representing rotation
     * (roll = 0, pith = 0, yaw = 0), which for Android devices it means that the
     * device is flat on a horizontal surface with the screen facing down.
     */
<span class="fc" id="L204">    public IMUBiasEstimator() {</span>
<span class="fc" id="L205">        mFrame = NEDtoECEFFrameConverter.convertNEDtoECEFAndReturnNew(new NEDFrame());</span>
<span class="fc" id="L206">        rebuildExpectedKinematics();</span>
<span class="fc" id="L207">    }</span>

    /**
     * Constructor.
     * It is assumed that body is located at zero NED coordinates (latitude = 0,
     * longitude = 0, and height = 0) with provided orientation.
     *
     * @param nedC coordinate transformation from body to local navigation
     *             (NED) coordinates. This contains orientation respect the horizon
     *             at current body location.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not
     *                                                       from body to local
     *                                                       navigation coordinates.
     */
    public IMUBiasEstimator(final CoordinateTransformation nedC)
<span class="fc" id="L223">            throws InvalidSourceAndDestinationFrameTypeException {</span>
<span class="fc" id="L224">        mFrame = NEDtoECEFFrameConverter.convertNEDtoECEFAndReturnNew(</span>
                new NEDFrame(nedC));
<span class="fc" id="L226">        rebuildExpectedKinematics();</span>
<span class="fc" id="L227">    }</span>

    /**
     * Constructor.
     * It is assumed that body has zero Euler angles representing rotation (roll = 0,
     * pitch = 0, yaw = 0) respect the horizon at provided body location.
     * For Android devices this means that the device is flat on a horizontal surface
     * with the screen facing down.
     *
     * @param latitude  latitude expressed in radians (rad).
     * @param longitude longitude expressed in radians (rad).
     * @param height    height expressed in meters (m).
     */
    public IMUBiasEstimator(
<span class="fc" id="L241">            final double latitude, final double longitude, final double height) {</span>
<span class="fc" id="L242">        mFrame = NEDtoECEFFrameConverter.convertNEDtoECEFAndReturnNew(</span>
                new NEDFrame(latitude, longitude, height));
<span class="fc" id="L244">        rebuildExpectedKinematics();</span>
<span class="fc" id="L245">    }</span>

    /**
     * Constructor.
     * It is assumed that body has zero Euler angles representing rotation (roll = 0,
     * pitch = 0, yaw = 0) respect the horizon at provided body location.
     * For Android devices this means that the device is flat on a horizontal surface
     * with the screen facing down.
     *
     * @param latitude  latitude.
     * @param longitude longitude.
     * @param height    height expressed in meters (m).
     */
    public IMUBiasEstimator(
<span class="fc" id="L259">            final Angle latitude, final Angle longitude, final double height) {</span>
<span class="fc" id="L260">        mFrame = NEDtoECEFFrameConverter.convertNEDtoECEFAndReturnNew(</span>
                new NEDFrame(latitude, longitude, height));
<span class="fc" id="L262">        rebuildExpectedKinematics();</span>
<span class="fc" id="L263">    }</span>

    /**
     * Constructor.
     * It is assumed that body has zero Euler angles representing rotation (roll = 0,
     * pitch = 0, yaw = 0) respect the horizon at provided body location.
     * For Android devices this means that the device is flat on a horizontal surface
     * with the screen facing down.
     *
     * @param latitude  latitude.
     * @param longitude longitude.
     * @param height    height.
     */
    public IMUBiasEstimator(
<span class="fc" id="L277">            final Angle latitude, final Angle longitude, final Distance height) {</span>
<span class="fc" id="L278">        mFrame = NEDtoECEFFrameConverter.convertNEDtoECEFAndReturnNew(</span>
                new NEDFrame(latitude, longitude, height));
<span class="fc" id="L280">        rebuildExpectedKinematics();</span>
<span class="fc" id="L281">    }</span>

    /**
     * Constructor.
     *
     * @param position body position expressed in NED coordinates.
     * @param nedC     coordinate transformation from body to local navigation
     *                 (NED) coordinates. This contains orientation respect the
     *                 horizon at current body location.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not
     *                                                       from body to local
     *                                                       navigation coordinates.
     */
    public IMUBiasEstimator(
            final NEDPosition position, final CoordinateTransformation nedC)
<span class="fc" id="L297">            throws InvalidSourceAndDestinationFrameTypeException {</span>
<span class="fc" id="L298">        mFrame = NEDtoECEFFrameConverter.convertNEDtoECEFAndReturnNew(</span>
                new NEDFrame(position, nedC));
<span class="fc" id="L300">        rebuildExpectedKinematics();</span>
<span class="fc" id="L301">    }</span>

    /**
     * Constructor.
     *
     * @param position body position expressed in ECEF coordinates.
     * @param nedC     coordinate transformation from body to local navigation
     *                 (NED) coordinates. This contains orientation respect the
     *                 horizon at current body location.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not
     *                                                       from body to local
     *                                                       navigation coordinates.
     */
    public IMUBiasEstimator(
            final ECEFPosition position, final CoordinateTransformation nedC)
<span class="fc" id="L317">            throws InvalidSourceAndDestinationFrameTypeException {</span>
<span class="fc" id="L318">        mFrame = new ECEFFrame(position);</span>
<span class="fc" id="L319">        final NEDFrame nedFrame = ECEFtoNEDFrameConverter</span>
<span class="fc" id="L320">                .convertECEFtoNEDAndReturnNew(mFrame);</span>
<span class="fc" id="L321">        nedFrame.setCoordinateTransformation(nedC);</span>
<span class="fc" id="L322">        NEDtoECEFFrameConverter.convertNEDtoECEF(nedFrame, mFrame);</span>
<span class="fc" id="L323">        rebuildExpectedKinematics();</span>
<span class="fc" id="L324">    }</span>

    /**
     * Constructor.
     * It is assumed that body is located at zero NED coordinates (latitude = 0,
     * longitude = 0 and height = 0) and with zero Euler angles representing rotation
     * (roll = 0, pith = 0, yaw = 0), which for Android devices it means that the
     * device is flat on a horizontal surface with the screen facing down.
     *
     * @param listener listener to handle events raised by this estimator.
     */
    public IMUBiasEstimator(final IMUBiasEstimatorListener listener) {
<span class="fc" id="L336">        this();</span>
<span class="fc" id="L337">        mListener = listener;</span>
<span class="fc" id="L338">    }</span>

    /**
     * Constructor.
     * It is assumed that body is located at zero NED coordinates (latitude = 0,
     * longitude = 0, and height = 0) with provided orientation.
     *
     * @param nedC     coordinate transformation from body to local navigation
     *                 (NED) coordinates. This contains orientation respect the
     *                 horizon at current body location.
     * @param listener listener to handle events raised by this estimator.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not
     *                                                       from body to local
     *                                                       navigation coordinates.
     */
    public IMUBiasEstimator(
            final CoordinateTransformation nedC,
            final IMUBiasEstimatorListener listener)
            throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L358">        this(nedC);</span>
<span class="fc" id="L359">        mListener = listener;</span>
<span class="fc" id="L360">    }</span>

    /**
     * Constructor.
     * It is assumed that body has zero Euler angles representing rotation (roll = 0,
     * pitch = 0, yaw = 0) respect the horizon at provided body location.
     * For Android devices this means that the device is flat on a horizontal surface
     * with the screen facing down.
     *
     * @param latitude  latitude expressed in radians (rad).
     * @param longitude longitude expressed in radians (rad).
     * @param height    height expressed in meters (m).
     * @param listener  listener to handle events raised by this estimator.
     */
    public IMUBiasEstimator(
            final double latitude, final double longitude, final double height,
            final IMUBiasEstimatorListener listener) {
<span class="fc" id="L377">        this(latitude, longitude, height);</span>
<span class="fc" id="L378">        mListener = listener;</span>
<span class="fc" id="L379">    }</span>

    /**
     * Constructor.
     * It is assumed that body has zero Euler angles representing rotation (roll = 0,
     * pitch = 0, yaw = 0) respect the horizon at provided body location.
     * For Android devices this means that the device is flat on a horizontal surface
     * with the screen facing down.
     *
     * @param latitude  latitude.
     * @param longitude longitude.
     * @param height    height expressed in meters (m).
     * @param listener  listener to handle events raised by this estimator.
     */
    public IMUBiasEstimator(
            final Angle latitude, final Angle longitude, final double height,
            final IMUBiasEstimatorListener listener) {
<span class="fc" id="L396">        this(latitude, longitude, height);</span>
<span class="fc" id="L397">        mListener = listener;</span>
<span class="fc" id="L398">    }</span>

    /**
     * Constructor.
     * It is assumed that body has zero Euler angles representing rotation (roll = 0,
     * pitch = 0, yaw = 0) respect the horizon at provided body location.
     * For Android devices this means that the device is flat on a horizontal surface
     * with the screen facing down.
     *
     * @param latitude  latitude.
     * @param longitude longitude.
     * @param height    height.
     * @param listener  listener to handle events raised by this estimator.
     */
    public IMUBiasEstimator(
            final Angle latitude, final Angle longitude, final Distance height,
            final IMUBiasEstimatorListener listener) {
<span class="fc" id="L415">        this(latitude, longitude, height);</span>
<span class="fc" id="L416">        mListener = listener;</span>
<span class="fc" id="L417">    }</span>

    /**
     * Constructor.
     *
     * @param position body position expressed in NED coordinates.
     * @param nedC     coordinate transformation from body to local navigation
     *                 (NED) coordinates. This contains orientation respect the
     *                 horizon at current body location.
     * @param listener listener to handle events raised by this estimator.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not
     *                                                       from body to local
     *                                                       navigation coordinates.
     */
    public IMUBiasEstimator(
            final NEDPosition position, final CoordinateTransformation nedC,
            final IMUBiasEstimatorListener listener)
            throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L436">        this(position, nedC);</span>
<span class="fc" id="L437">        mListener = listener;</span>
<span class="fc" id="L438">    }</span>

    /**
     * Constructor.
     *
     * @param position body position expressed in ECEF coordinates.
     * @param nedC     coordinate transformation from body to local navigation
     *                 (NED) coordinates. This contains orientation respect the
     *                 horizon at current body location.
     * @param listener listener to handle events raised by this estimator.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not
     *                                                       from body to local
     *                                                       navigation coordinates.
     */
    public IMUBiasEstimator(
            final ECEFPosition position, final CoordinateTransformation nedC,
            final IMUBiasEstimatorListener listener)
            throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L457">        this(position, nedC);</span>
<span class="fc" id="L458">        mListener = listener;</span>
<span class="fc" id="L459">    }</span>

    /**
     * Constructor.
     * It is assumed that body is located at zero NED coordinates (latitude = 0,
     * longitude = 0 and height = 0) and with zero Euler angles representing rotation
     * (roll = 0, pith = 0, yaw = 0), which for Android devices it means that the
     * device is flat on a horizontal surface with the screen facing down.
     *
     * @param totalSamples total samples to be processed to finish estimation.
     * @throws IllegalArgumentException if provided total samples is zero or negative.
     */
    public IMUBiasEstimator(final int totalSamples) {
<span class="fc" id="L472">        this();</span>

<span class="fc bfc" id="L474" title="All 2 branches covered.">        if (totalSamples &lt;= 0) {</span>
<span class="fc" id="L475">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L478">        mTotalSamples = totalSamples;</span>
<span class="fc" id="L479">    }</span>

    /**
     * Constructor.
     * It is assumed that body is located at zero NED coordinates (latitude = 0,
     * longitude = 0, and height = 0) with provided orientation.
     *
     * @param nedC         coordinate transformation from body to local navigation
     *                     (NED) coordinates. This contains orientation respect the
     *                     horizon at current body location.
     * @param totalSamples total samples to be processed to finish estimation.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not
     *                                                       from body to local
     *                                                       navigation coordinates.
     * @throws IllegalArgumentException                      if provided total samples
     *                                                       is zero or negative.
     */
    public IMUBiasEstimator(
            final CoordinateTransformation nedC, final int totalSamples)
            throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L500">        this(totalSamples);</span>
<span class="fc" id="L501">        mFrame = NEDtoECEFFrameConverter.convertNEDtoECEFAndReturnNew(</span>
                new NEDFrame(nedC));
<span class="fc" id="L503">        rebuildExpectedKinematics();</span>
<span class="fc" id="L504">    }</span>

    /**
     * Constructor.
     * It is assumed that body has zero Euler angles representing rotation (roll = 0,
     * pitch = 0, yaw = 0) respect the horizon at provided body location.
     * For Android devices this means that the device is flat on a horizontal surface
     * with the screen facing down.
     *
     * @param latitude     latitude expressed in radians (rad).
     * @param longitude    longitude expressed in radians (rad).
     * @param height       height expressed in meters (m).
     * @param totalSamples total samples to be processed to finish estimation.
     * @throws IllegalArgumentException if provided total samples is zero or negative.
     */
    public IMUBiasEstimator(
            final double latitude, final double longitude, final double height,
            final int totalSamples) {
<span class="fc" id="L522">        this(totalSamples);</span>
<span class="fc" id="L523">        mFrame = NEDtoECEFFrameConverter.convertNEDtoECEFAndReturnNew(</span>
                new NEDFrame(latitude, longitude, height));
<span class="fc" id="L525">        rebuildExpectedKinematics();</span>
<span class="fc" id="L526">    }</span>

    /**
     * Constructor.
     * It is assumed that body has zero Euler angles representing rotation (roll = 0,
     * pitch = 0, yaw = 0) respect the horizon at provided body location.
     * For Android devices this means that the device is flat on a horizontal surface
     * with the screen facing down.
     *
     * @param latitude     latitude.
     * @param longitude    longitude.
     * @param height       height expressed in meters (m).
     * @param totalSamples total samples to be processed to finish estimation.
     * @throws IllegalArgumentException if provided total samples is zero or negative.
     */
    public IMUBiasEstimator(
            final Angle latitude, final Angle longitude, final double height,
            final int totalSamples) {
<span class="fc" id="L544">        this(totalSamples);</span>
<span class="fc" id="L545">        mFrame = NEDtoECEFFrameConverter.convertNEDtoECEFAndReturnNew(</span>
                new NEDFrame(latitude, longitude, height));
<span class="fc" id="L547">        rebuildExpectedKinematics();</span>
<span class="fc" id="L548">    }</span>

    /**
     * Constructor.
     * It is assumed that body has zero Euler angles representing rotation (roll = 0,
     * pitch = 0, yaw = 0) respect the horizon at provided body location.
     * For Android devices this means that the device is flat on a horizontal surface
     * with the screen facing down.
     *
     * @param latitude     latitude.
     * @param longitude    longitude.
     * @param height       height.
     * @param totalSamples total samples to be processed to finish estimation.
     * @throws IllegalArgumentException if provided total samples is zero or negative.
     */
    public IMUBiasEstimator(
            final Angle latitude, final Angle longitude, final Distance height,
            final int totalSamples) {
<span class="fc" id="L566">        this(totalSamples);</span>
<span class="fc" id="L567">        mFrame = NEDtoECEFFrameConverter.convertNEDtoECEFAndReturnNew(</span>
                new NEDFrame(latitude, longitude, height));
<span class="fc" id="L569">        rebuildExpectedKinematics();</span>
<span class="fc" id="L570">    }</span>

    /**
     * Constructor.
     *
     * @param position     body position expressed in NED coordinates.
     * @param nedC         coordinate transformation from body to local navigation
     *                     (NED) coordinates. This contains orientation respect the
     *                     horizon at current body location.
     * @param totalSamples total samples to be processed to finish estimation.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not
     *                                                       from body to local
     *                                                       navigation coordinates.
     * @throws IllegalArgumentException                      if provided total samples
     *                                                       is zero or negative.
     */
    public IMUBiasEstimator(
            final NEDPosition position, final CoordinateTransformation nedC,
            final int totalSamples)
            throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L591">        this(totalSamples);</span>
<span class="fc" id="L592">        mFrame = NEDtoECEFFrameConverter.convertNEDtoECEFAndReturnNew(</span>
                new NEDFrame(position, nedC));
<span class="fc" id="L594">        rebuildExpectedKinematics();</span>
<span class="fc" id="L595">    }</span>

    /**
     * Constructor.
     *
     * @param position     body position expressed in ECEF coordinates.
     * @param nedC         coordinate transformation from body to local navigation
     *                     (NED) coordinates. This contains orientation respect the
     *                     horizon at current body location.
     * @param totalSamples total samples to be processed to finish estimation.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not
     *                                                       from body to local
     *                                                       navigation coordinates.
     * @throws IllegalArgumentException                      if provided total samples
     *                                                       is zero or negative.
     */
    public IMUBiasEstimator(
            final ECEFPosition position, final CoordinateTransformation nedC,
            final int totalSamples)
            throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L616">        this(position, nedC);</span>

<span class="fc bfc" id="L618" title="All 2 branches covered.">        if (totalSamples &lt;= 0) {</span>
<span class="fc" id="L619">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L622">        mTotalSamples = totalSamples;</span>
<span class="fc" id="L623">    }</span>

    /**
     * Constructor.
     * It is assumed that body is located at zero NED coordinates (latitude = 0,
     * longitude = 0 and height = 0) and with zero Euler angles representing rotation
     * (roll = 0, pith = 0, yaw = 0), which for Android devices it means that the
     * device is flat on a horizontal surface with the screen facing down.
     *
     * @param totalSamples total samples to be processed to finish estimation.
     * @param listener     listener to handle events raised by this estimator.
     * @throws IllegalArgumentException if provided total samples is zero or negative.
     */
    public IMUBiasEstimator(
            final int totalSamples, final IMUBiasEstimatorListener listener) {
<span class="fc" id="L638">        this(totalSamples);</span>
<span class="fc" id="L639">        mListener = listener;</span>
<span class="fc" id="L640">    }</span>

    /**
     * Constructor.
     * It is assumed that body is located at zero NED coordinates (latitude = 0,
     * longitude = 0, and height = 0) with provided orientation.
     *
     * @param nedC         coordinate transformation from body to local navigation
     *                     (NED) coordinates. This contains orientation respect the
     *                     horizon at current body location.
     * @param totalSamples total samples to be processed to finish estimation.
     * @param listener     listener to handle events raised by this estimator.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not
     *                                                       from body to local
     *                                                       navigation coordinates.
     * @throws IllegalArgumentException                      if provided total samples
     *                                                       is zero or negative.
     */
    public IMUBiasEstimator(
            final CoordinateTransformation nedC, final int totalSamples,
            final IMUBiasEstimatorListener listener)
            throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L663">        this(nedC, totalSamples);</span>
<span class="fc" id="L664">        mListener = listener;</span>
<span class="fc" id="L665">    }</span>

    /**
     * Constructor.
     * It is assumed that body has zero Euler angles representing rotation (roll = 0,
     * pitch = 0, yaw = 0) respect the horizon at provided body location.
     * For Android devices this means that the device is flat on a horizontal surface
     * with the screen facing down.
     *
     * @param latitude     latitude expressed in radians (rad).
     * @param longitude    longitude expressed in radians (rad).
     * @param height       height expressed in meters (m).
     * @param totalSamples total samples to be processed to finish estimation.
     * @param listener     listener to handle events raised by this estimator.
     * @throws IllegalArgumentException if provided total samples is zero or negative.
     */
    public IMUBiasEstimator(
            final double latitude, final double longitude, final double height,
            final int totalSamples, final IMUBiasEstimatorListener listener) {
<span class="fc" id="L684">        this(latitude, longitude, height, totalSamples);</span>
<span class="fc" id="L685">        mListener = listener;</span>
<span class="fc" id="L686">    }</span>

    /**
     * Constructor.
     * It is assumed that body has zero Euler angles representing rotation (roll = 0,
     * pitch = 0, yaw = 0) respect the horizon at provided body location.
     * For Android devices this means that the device is flat on a horizontal surface
     * with the screen facing down.
     *
     * @param latitude     latitude.
     * @param longitude    longitude.
     * @param height       height expressed in meters (m).
     * @param totalSamples total samples to be processed to finish estimation.
     * @param listener     listener to handle events raised by this estimator.
     * @throws IllegalArgumentException if provided total samples is zero or negative.
     */
    public IMUBiasEstimator(
            final Angle latitude, final Angle longitude, final double height,
            int totalSamples, final IMUBiasEstimatorListener listener) {
<span class="fc" id="L705">        this(latitude, longitude, height, totalSamples);</span>
<span class="fc" id="L706">        mListener = listener;</span>
<span class="fc" id="L707">    }</span>

    /**
     * Constructor.
     * It is assumed that body has zero Euler angles representing rotation (roll = 0,
     * pitch = 0, yaw = 0) respect the horizon at provided body location.
     * For Android devices this means that the device is flat on a horizontal surface
     * with the screen facing down.
     *
     * @param latitude     latitude.
     * @param longitude    longitude.
     * @param height       height.
     * @param totalSamples total samples to be processed to finish estimation.
     * @param listener     listener to handle events raised by this estimator.
     * @throws IllegalArgumentException if provided total samples is zero or negative.
     */
    public IMUBiasEstimator(
            final Angle latitude, final Angle longitude, final Distance height,
            final int totalSamples, final IMUBiasEstimatorListener listener) {
<span class="fc" id="L726">        this(latitude, longitude, height, totalSamples);</span>
<span class="fc" id="L727">        mListener = listener;</span>
<span class="fc" id="L728">    }</span>

    /**
     * Constructor.
     *
     * @param position     body position expressed in NED coordinates.
     * @param nedC         coordinate transformation from body to local navigation
     *                     (NED) coordinates. This contains orientation respect the
     *                     horizon at current body location.
     * @param totalSamples total samples to be processed to finish estimation.
     * @param listener     listener to handle events raised by this estimator.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not
     *                                                       from body to local
     *                                                       navigation coordinates.
     * @throws IllegalArgumentException                      if provided total samples
     *                                                       is zero or negative.
     */
    public IMUBiasEstimator(
            final NEDPosition position, final CoordinateTransformation nedC,
            final int totalSamples, final IMUBiasEstimatorListener listener)
            throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L750">        this(position, nedC, totalSamples);</span>
<span class="fc" id="L751">        mListener = listener;</span>
<span class="fc" id="L752">    }</span>

    /**
     * Constructor.
     *
     * @param position     body position expressed in ECEF coordinates.
     * @param nedC         coordinate transformation from body to local navigation
     *                     (NED) coordinates. This contains orientation respect the
     *                     horizon at current body location.
     * @param totalSamples total samples to be processed to finish estimation.
     * @param listener     listener to handle events raised by this estimator.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not
     *                                                       from body to local
     *                                                       navigation coordinates.
     * @throws IllegalArgumentException                      if provided total samples
     *                                                       is zero or negative.
     */
    public IMUBiasEstimator(
            final ECEFPosition position, final CoordinateTransformation nedC,
            final int totalSamples, final IMUBiasEstimatorListener listener)
            throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L774">        this(position, nedC, totalSamples);</span>
<span class="fc" id="L775">        mListener = listener;</span>
<span class="fc" id="L776">    }</span>

    /**
     * Constructor.
     * It is assumed that body is located at zero NED coordinates (latitude = 0,
     * longitude = 0 and height = 0) and with zero Euler angles representing rotation
     * (roll = 0, pith = 0, yaw = 0), which for Android devices it means that the
     * device is flat on a horizontal surface with the screen facing down.
     *
     * @param timeInterval time interval between body kinematics
     *                     (IMU acceleration + gyroscope) samples
     *                     expressed in seconds (s).
     * @throws IllegalArgumentException if provided time interval is negative.
     */
    public IMUBiasEstimator(final double timeInterval) {
<span class="fc" id="L791">        this();</span>
        try {
<span class="fc" id="L793">            setTimeInterval(timeInterval);</span>
<span class="nc" id="L794">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L796">        }</span>
<span class="fc" id="L797">    }</span>

    /**
     * Constructor.
     * It is assumed that body is located at zero NED coordinates (latitude = 0,
     * longitude = 0, and height = 0) with provided orientation.
     *
     * @param nedC         coordinate transformation from body to local navigation
     *                     (NED) coordinates. This contains orientation respect the
     *                     horizon at current body location.
     * @param timeInterval time interval between body kinematics
     *                     (IMU acceleration + gyroscope) samples
     *                     expressed in seconds (s).
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not
     *                                                       from body to local
     *                                                       navigation coordinates.
     * @throws IllegalArgumentException                      if provided time interval
     *                                                       is negative.
     */
    public IMUBiasEstimator(
            final CoordinateTransformation nedC, final double timeInterval)
            throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L820">        this(nedC);</span>
        try {
<span class="fc" id="L822">            setTimeInterval(timeInterval);</span>
<span class="nc" id="L823">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L825">        }</span>
<span class="fc" id="L826">    }</span>

    /**
     * Constructor.
     * It is assumed that body has zero Euler angles representing rotation (roll = 0,
     * pitch = 0, yaw = 0) respect the horizon at provided body location.
     * For Android devices this means that the device is flat on a horizontal surface
     * with the screen facing down.
     *
     * @param latitude     latitude expressed in radians (rad).
     * @param longitude    longitude expressed in radians (rad).
     * @param height       height expressed in meters (m).
     * @param timeInterval time interval between body kinematics
     *                     (IMU acceleration + gyroscope) samples
     *                     expressed in seconds (s).
     * @throws IllegalArgumentException if provided time interval is negative.
     */
    public IMUBiasEstimator(final double latitude, final double longitude,
                            final double height, final double timeInterval) {
<span class="fc" id="L845">        this(latitude, longitude, height);</span>
        try {
<span class="fc" id="L847">            setTimeInterval(timeInterval);</span>
<span class="nc" id="L848">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L850">        }</span>
<span class="fc" id="L851">    }</span>

    /**
     * Constructor.
     * It is assumed that body has zero Euler angles representing rotation (roll = 0,
     * pitch = 0, yaw = 0) respect the horizon at provided body location.
     * For Android devices this means that the device is flat on a horizontal surface
     * with the screen facing down.
     *
     * @param latitude     latitude.
     * @param longitude    longitude.
     * @param height       height expressed in meters (m).
     * @param timeInterval time interval between body kinematics
     *                     (IMU acceleration + gyroscope) samples
     *                     expressed in seconds (s).
     * @throws IllegalArgumentException if provided time interval is negative.
     */
    public IMUBiasEstimator(final Angle latitude, final Angle longitude,
                            final double height, final double timeInterval) {
<span class="fc" id="L870">        this(latitude, longitude, height);</span>
        try {
<span class="fc" id="L872">            setTimeInterval(timeInterval);</span>
<span class="nc" id="L873">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L875">        }</span>
<span class="fc" id="L876">    }</span>

    /**
     * Constructor.
     * It is assumed that body has zero Euler angles representing rotation (roll = 0,
     * pitch = 0, yaw = 0) respect the horizon at provided body location.
     * For Android devices this means that the device is flat on a horizontal surface
     * with the screen facing down.
     *
     * @param latitude     latitude.
     * @param longitude    longitude.
     * @param height       height.
     * @param timeInterval time interval between body kinematics
     *                     (IMU acceleration + gyroscope) samples
     *                     expressed in seconds (s).
     * @throws IllegalArgumentException if provided time interval is negative.
     */
    public IMUBiasEstimator(final Angle latitude, final Angle longitude,
                            final Distance height, final double timeInterval) {
<span class="fc" id="L895">        this(latitude, longitude, height);</span>
        try {
<span class="fc" id="L897">            setTimeInterval(timeInterval);</span>
<span class="nc" id="L898">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L900">        }</span>
<span class="fc" id="L901">    }</span>

    /**
     * Constructor.
     *
     * @param position     body position expressed in NED coordinates.
     * @param nedC         coordinate transformation from body to local navigation
     *                     (NED) coordinates. This contains orientation respect the
     *                     horizon at current body location.
     * @param timeInterval time interval between body kinematics
     *                     (IMU acceleration + gyroscope) samples
     *                     expressed in seconds (s).
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not
     *                                                       from body to local
     *                                                       navigation coordinates.
     * @throws IllegalArgumentException                      if provided time interval
     *                                                       is negative.
     */
    public IMUBiasEstimator(
            final NEDPosition position, final CoordinateTransformation nedC,
            final double timeInterval)
            throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L924">        this(position, nedC);</span>
        try {
<span class="fc" id="L926">            setTimeInterval(timeInterval);</span>
<span class="nc" id="L927">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L929">        }</span>
<span class="fc" id="L930">    }</span>

    /**
     * Constructor.
     *
     * @param position     body position expressed in ECEF coordinates.
     * @param nedC         coordinate transformation from body to local navigation
     *                     (NED) coordinates. This contains orientation respect the
     *                     horizon at current body location.
     * @param timeInterval time interval between body kinematics
     *                     (IMU acceleration + gyroscope) samples
     *                     expressed in seconds (s).
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not
     *                                                       from body to local
     *                                                       navigation coordinates.
     * @throws IllegalArgumentException                      if provided time interval
     *                                                       is negative.
     */
    public IMUBiasEstimator(
            final ECEFPosition position, final CoordinateTransformation nedC,
            final double timeInterval)
            throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L953">        this(position, nedC);</span>
        try {
<span class="fc" id="L955">            setTimeInterval(timeInterval);</span>
<span class="nc" id="L956">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L958">        }</span>
<span class="fc" id="L959">    }</span>

    /**
     * Constructor.
     * It is assumed that body is located at zero NED coordinates (latitude = 0,
     * longitude = 0 and height = 0) and with zero Euler angles representing rotation
     * (roll = 0, pith = 0, yaw = 0), which for Android devices it means that the
     * device is flat on a horizontal surface with the screen facing down.
     *
     * @param timeInterval time interval between body kinematics
     *                     (IMU acceleration + gyroscope) samples
     *                     expressed in seconds (s).
     * @param listener     listener to handle events raised by this estimator.
     * @throws IllegalArgumentException if provided time interval is negative.
     */
    public IMUBiasEstimator(final double timeInterval,
                            final IMUBiasEstimatorListener listener) {
<span class="fc" id="L976">        this(timeInterval);</span>
<span class="fc" id="L977">        mListener = listener;</span>
<span class="fc" id="L978">    }</span>

    /**
     * Constructor.
     * It is assumed that body is located at zero NED coordinates (latitude = 0,
     * longitude = 0, and height = 0) with provided orientation.
     *
     * @param nedC         coordinate transformation from body to local navigation
     *                     (NED) coordinates. This contains orientation respect the
     *                     horizon at current body location.
     * @param timeInterval time interval between body kinematics
     *                     (IMU acceleration + gyroscope) samples
     *                     expressed in seconds (s).
     * @param listener     listener to handle events raised by this estimator.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not
     *                                                       from body to local
     *                                                       navigation coordinates.
     * @throws IllegalArgumentException                      if provided time interval
     *                                                       is negative.
     */
    public IMUBiasEstimator(
            final CoordinateTransformation nedC, final double timeInterval,
            final IMUBiasEstimatorListener listener)
            throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L1003">        this(nedC, timeInterval);</span>
<span class="fc" id="L1004">        mListener = listener;</span>
<span class="fc" id="L1005">    }</span>

    /**
     * Constructor.
     * It is assumed that body has zero Euler angles representing rotation (roll = 0,
     * pitch = 0, yaw = 0) respect the horizon at provided body location.
     * For Android devices this means that the device is flat on a horizontal surface
     * with the screen facing down.
     *
     * @param latitude     latitude expressed in radians (rad).
     * @param longitude    longitude expressed in radians (rad).
     * @param height       height expressed in meters (m).
     * @param timeInterval time interval between body kinematics
     *                     (IMU acceleration + gyroscope) samples
     *                     expressed in seconds (s).
     * @param listener     listener to handle events raised by this estimator.
     * @throws IllegalArgumentException if provided time interval is negative.
     */
    public IMUBiasEstimator(
            final double latitude, final double longitude, final double height,
            final double timeInterval, final IMUBiasEstimatorListener listener) {
<span class="fc" id="L1026">        this(latitude, longitude, height, timeInterval);</span>
<span class="fc" id="L1027">        mListener = listener;</span>
<span class="fc" id="L1028">    }</span>

    /**
     * Constructor.
     * It is assumed that body has zero Euler angles representing rotation (roll = 0,
     * pitch = 0, yaw = 0) respect the horizon at provided body location.
     * For Android devices this means that the device is flat on a horizontal surface
     * with the screen facing down.
     *
     * @param latitude     latitude.
     * @param longitude    longitude.
     * @param height       height expressed in meters (m).
     * @param timeInterval time interval between body kinematics
     *                     (IMU acceleration + gyroscope) samples
     *                     expressed in seconds (s).
     * @param listener     listener to handle events raised by this estimator.
     * @throws IllegalArgumentException if provided time interval is negative.
     */
    public IMUBiasEstimator(
            final Angle latitude, final Angle longitude, final double height,
            final double timeInterval, final IMUBiasEstimatorListener listener) {
<span class="fc" id="L1049">        this(latitude, longitude, height, timeInterval);</span>
<span class="fc" id="L1050">        mListener = listener;</span>
<span class="fc" id="L1051">    }</span>

    /**
     * Constructor.
     * It is assumed that body has zero Euler angles representing rotation (roll = 0,
     * pitch = 0, yaw = 0) respect the horizon at provided body location.
     * For Android devices this means that the device is flat on a horizontal surface
     * with the screen facing down.
     *
     * @param latitude     latitude.
     * @param longitude    longitude.
     * @param height       height.
     * @param timeInterval time interval between body kinematics
     *                     (IMU acceleration + gyroscope) samples
     *                     expressed in seconds (s).
     * @param listener     listener to handle events raised by this estimator.
     * @throws IllegalArgumentException if provided time interval is negative.
     */
    public IMUBiasEstimator(
            final Angle latitude, final Angle longitude, final Distance height,
            final double timeInterval, final IMUBiasEstimatorListener listener) {
<span class="fc" id="L1072">        this(latitude, longitude, height, timeInterval);</span>
<span class="fc" id="L1073">        mListener = listener;</span>
<span class="fc" id="L1074">    }</span>

    /**
     * Constructor.
     *
     * @param position     body position expressed in NED coordinates.
     * @param nedC         coordinate transformation from body to local navigation
     *                     (NED) coordinates. This contains orientation respect the
     *                     horizon at current body location.
     * @param timeInterval time interval between body kinematics
     *                     (IMU acceleration + gyroscope) samples
     *                     expressed in seconds (s).
     * @param listener     listener to handle events raised by this estimator.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not
     *                                                       from body to local
     *                                                       navigation coordinates.
     * @throws IllegalArgumentException                      if provided time interval
     *                                                       is negative.
     */
    public IMUBiasEstimator(
            final NEDPosition position, final CoordinateTransformation nedC,
            final double timeInterval, final IMUBiasEstimatorListener listener)
            throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L1098">        this(position, nedC, timeInterval);</span>
<span class="fc" id="L1099">        mListener = listener;</span>
<span class="fc" id="L1100">    }</span>

    /**
     * Constructor.
     *
     * @param position     body position expressed in ECEF coordinates.
     * @param nedC         coordinate transformation from body to local navigation
     *                     (NED) coordinates. This contains orientation respect the
     *                     horizon at current body location.
     * @param timeInterval time interval between body kinematics
     *                     (IMU acceleration + gyroscope) samples
     *                     expressed in seconds (s).
     * @param listener     listener to handle events raised by this estimator.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not
     *                                                       from body to local
     *                                                       navigation coordinates.
     * @throws IllegalArgumentException                      if provided time interval
     *                                                       is negative.
     */
    public IMUBiasEstimator(
            final ECEFPosition position, final CoordinateTransformation nedC,
            final double timeInterval, final IMUBiasEstimatorListener listener)
            throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L1124">        this(position, nedC, timeInterval);</span>
<span class="fc" id="L1125">        mListener = listener;</span>
<span class="fc" id="L1126">    }</span>

    /**
     * Constructor.
     * It is assumed that body is located at zero NED coordinates (latitude = 0,
     * longitude = 0 and height = 0) and with zero Euler angles representing rotation
     * (roll = 0, pith = 0, yaw = 0), which for Android devices it means that the
     * device is flat on a horizontal surface with the screen facing down.
     *
     * @param totalSamples total samples to be processed to finish estimation.
     * @param timeInterval time interval between body kinematics
     *                     (IMU acceleration + gyroscope) samples
     *                     expressed in seconds (s).
     * @throws IllegalArgumentException if provided total samples is zero or negative, or
     *                                  if provided time interval is negative.
     */
    public IMUBiasEstimator(final int totalSamples, final double timeInterval) {
<span class="fc" id="L1143">        this(totalSamples);</span>
        try {
<span class="fc" id="L1145">            setTimeInterval(timeInterval);</span>
<span class="nc" id="L1146">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L1148">        }</span>
<span class="fc" id="L1149">    }</span>

    /**
     * Constructor.
     * It is assumed that body is located at zero NED coordinates (latitude = 0,
     * longitude = 0, and height = 0) with provided orientation.
     *
     * @param nedC         coordinate transformation from body to local navigation
     *                     (NED) coordinates. This contains orientation respect the
     *                     horizon at current body location.
     * @param totalSamples total samples to be processed to finish estimation.
     * @param timeInterval time interval between body kinematics
     *                     (IMU acceleration + gyroscope) samples
     *                     expressed in seconds (s).
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not
     *                                                       from body to local
     *                                                       navigation coordinates.
     * @throws IllegalArgumentException                      if provided total samples
     *                                                       is zero or negative, or
     *                                                       if provided time interval
     *                                                       is negative.
     */
    public IMUBiasEstimator(
            final CoordinateTransformation nedC, final int totalSamples,
            final double timeInterval)
            throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L1176">        this(nedC, totalSamples);</span>
        try {
<span class="fc" id="L1178">            setTimeInterval(timeInterval);</span>
<span class="nc" id="L1179">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L1181">        }</span>
<span class="fc" id="L1182">    }</span>

    /**
     * Constructor.
     * It is assumed that body has zero Euler angles representing rotation (roll = 0,
     * pitch = 0, yaw = 0) respect the horizon at provided body location.
     * For Android devices this means that the device is flat on a horizontal surface
     * with the screen facing down.
     *
     * @param latitude     latitude expressed in radians (rad).
     * @param longitude    longitude expressed in radians (rad).
     * @param height       height expressed in meters (m).
     * @param totalSamples total samples to be processed to finish estimation.
     * @param timeInterval time interval between body kinematics
     *                     (IMU acceleration + gyroscope) samples
     *                     expressed in seconds (s).
     * @throws IllegalArgumentException if provided total samples is zero or negative, or
     *                                  if provided time interval is negative.
     */
    public IMUBiasEstimator(
            final double latitude, final double longitude, final double height,
            final int totalSamples, final double timeInterval) {
<span class="fc" id="L1204">        this(latitude, longitude, height, totalSamples);</span>
        try {
<span class="fc" id="L1206">            setTimeInterval(timeInterval);</span>
<span class="nc" id="L1207">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L1209">        }</span>
<span class="fc" id="L1210">    }</span>

    /**
     * Constructor.
     * It is assumed that body has zero Euler angles representing rotation (roll = 0,
     * pitch = 0, yaw = 0) respect the horizon at provided body location.
     * For Android devices this means that the device is flat on a horizontal surface
     * with the screen facing down.
     *
     * @param latitude     latitude.
     * @param longitude    longitude.
     * @param height       height expressed in meters (m).
     * @param totalSamples total samples to be processed to finish estimation.
     * @param timeInterval time interval between body kinematics
     *                     (IMU acceleration + gyroscope) samples
     *                     expressed in seconds (s).
     * @throws IllegalArgumentException if provided total samples is zero or negative, or
     *                                  if provided time interval is negative.
     */
    public IMUBiasEstimator(
            final Angle latitude, final Angle longitude, final double height,
            final int totalSamples, final double timeInterval) {
<span class="fc" id="L1232">        this(latitude, longitude, height, totalSamples);</span>
        try {
<span class="fc" id="L1234">            setTimeInterval(timeInterval);</span>
<span class="nc" id="L1235">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L1237">        }</span>
<span class="fc" id="L1238">    }</span>

    /**
     * Constructor.
     * It is assumed that body has zero Euler angles representing rotation (roll = 0,
     * pitch = 0, yaw = 0) respect the horizon at provided body location.
     * For Android devices this means that the device is flat on a horizontal surface
     * with the screen facing down.
     *
     * @param latitude     latitude.
     * @param longitude    longitude.
     * @param height       height.
     * @param totalSamples total samples to be processed to finish estimation.
     * @param timeInterval time interval between body kinematics
     *                     (IMU acceleration + gyroscope) samples
     *                     expressed in seconds (s).
     * @throws IllegalArgumentException if provided total samples is zero or negative, or
     *                                  if provided time interval is negative.
     */
    public IMUBiasEstimator(
            final Angle latitude, final Angle longitude, final Distance height,
            final int totalSamples, final double timeInterval) {
<span class="fc" id="L1260">        this(latitude, longitude, height, totalSamples);</span>
        try {
<span class="fc" id="L1262">            setTimeInterval(timeInterval);</span>
<span class="nc" id="L1263">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L1265">        }</span>
<span class="fc" id="L1266">    }</span>

    /**
     * Constructor.
     *
     * @param position     body position expressed in NED coordinates.
     * @param nedC         coordinate transformation from body to local navigation
     *                     (NED) coordinates. This contains orientation respect the
     *                     horizon at current body location.
     * @param totalSamples total samples to be processed to finish estimation.
     * @param timeInterval time interval between body kinematics
     *                     (IMU acceleration + gyroscope) samples
     *                     expressed in seconds (s).
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not
     *                                                       from body to local
     *                                                       navigation coordinates.
     * @throws IllegalArgumentException                      if provided total samples
     *                                                       is zero or negative, or
     *                                                       if provided time interval
     *                                                       is negative.
     */
    public IMUBiasEstimator(
            final NEDPosition position, final CoordinateTransformation nedC,
            final int totalSamples, final double timeInterval)
            throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L1292">        this(position, nedC, totalSamples);</span>
        try {
<span class="fc" id="L1294">            setTimeInterval(timeInterval);</span>
<span class="nc" id="L1295">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L1297">        }</span>
<span class="fc" id="L1298">    }</span>

    /**
     * Constructor.
     *
     * @param position     body position expressed in ECEF coordinates.
     * @param nedC         coordinate transformation from body to local navigation
     *                     (NED) coordinates. This contains orientation respect the
     *                     horizon at current body location.
     * @param totalSamples total samples to be processed to finish estimation.
     * @param timeInterval time interval between body kinematics
     *                     (IMU acceleration + gyroscope) samples
     *                     expressed in seconds (s).
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not
     *                                                       from body to local
     *                                                       navigation coordinates.
     * @throws IllegalArgumentException                      if provided total samples
     *                                                       is zero or negative, or
     *                                                       if provided time interval
     *                                                       is negative.
     */
    public IMUBiasEstimator(
            final ECEFPosition position, final CoordinateTransformation nedC,
            final int totalSamples, final double timeInterval)
            throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L1324">        this(position, nedC, totalSamples);</span>
        try {
<span class="fc" id="L1326">            setTimeInterval(timeInterval);</span>
<span class="nc" id="L1327">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L1329">        }</span>
<span class="fc" id="L1330">    }</span>

    /**
     * Constructor.
     * It is assumed that body is located at zero NED coordinates (latitude = 0,
     * longitude = 0 and height = 0) and with zero Euler angles representing rotation
     * (roll = 0, pith = 0, yaw = 0), which for Android devices it means that the
     * device is flat on a horizontal surface with the screen facing down.
     *
     * @param totalSamples total samples to be processed to finish estimation.
     * @param timeInterval time interval between body kinematics
     *                     (IMU acceleration + gyroscope) samples
     *                     expressed in seconds (s).
     * @param listener     listener to handle events raised by this estimator.
     * @throws IllegalArgumentException if provided total samples is zero or negative,
     *                                  or if provided time interval is negative.
     */
    public IMUBiasEstimator(final int totalSamples, final double timeInterval,
                            final IMUBiasEstimatorListener listener) {
<span class="fc" id="L1349">        this(totalSamples, timeInterval);</span>
<span class="fc" id="L1350">        mListener = listener;</span>
<span class="fc" id="L1351">    }</span>

    /**
     * Constructor.
     * It is assumed that body is located at zero NED coordinates (latitude = 0,
     * longitude = 0, and height = 0) with provided orientation.
     *
     * @param nedC         coordinate transformation from body to local navigation
     *                     (NED) coordinates. This contains orientation respect the
     *                     horizon at current body location.
     * @param totalSamples total samples to be processed to finish estimation.
     * @param timeInterval time interval between body kinematics
     *                     (IMU acceleration + gyroscope) samples
     *                     expressed in seconds (s).
     * @param listener     listener to handle events raised by this estimator.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not
     *                                                       from body to local
     *                                                       navigation coordinates.
     * @throws IllegalArgumentException                      if provided total samples
     *                                                       is zero or negative,
     *                                                       or if provided time
     *                                                       interval is negative.
     */
    public IMUBiasEstimator(
            final CoordinateTransformation nedC, final int totalSamples,
            final double timeInterval, final IMUBiasEstimatorListener listener)
            throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L1379">        this(nedC, totalSamples, timeInterval);</span>
<span class="fc" id="L1380">        mListener = listener;</span>
<span class="fc" id="L1381">    }</span>

    /**
     * Constructor.
     * It is assumed that body has zero Euler angles representing rotation (roll = 0,
     * pitch = 0, yaw = 0) respect the horizon at provided body location.
     * For Android devices this means that the device is flat on a horizontal surface
     * with the screen facing down.
     *
     * @param latitude     latitude expressed in radians (rad).
     * @param longitude    longitude expressed in radians (rad).
     * @param height       height expressed in meters (m).
     * @param totalSamples total samples to be processed to finish estimation.
     * @param timeInterval time interval between body kinematics
     *                     (IMU acceleration + gyroscope) samples
     *                     expressed in seconds (s).
     * @param listener     listener to handle events raised by this estimator.
     * @throws IllegalArgumentException if provided total samples is zero or negative,
     *                                  or if provided time interval is negative.
     */
    public IMUBiasEstimator(
            final double latitude, final double longitude, final double height,
            final int totalSamples, final double timeInterval,
            final IMUBiasEstimatorListener listener) {
<span class="fc" id="L1405">        this(latitude, longitude, height, totalSamples, timeInterval);</span>
<span class="fc" id="L1406">        mListener = listener;</span>
<span class="fc" id="L1407">    }</span>

    /**
     * Constructor.
     * It is assumed that body has zero Euler angles representing rotation (roll = 0,
     * pitch = 0, yaw = 0) respect the horizon at provided body location.
     * For Android devices this means that the device is flat on a horizontal surface
     * with the screen facing down.
     *
     * @param latitude     latitude.
     * @param longitude    longitude.
     * @param height       height expressed in meters (m).
     * @param totalSamples total samples to be processed to finish estimation.
     * @param timeInterval time interval between body kinematics
     *                     (IMU acceleration + gyroscope) samples
     *                     expressed in seconds (s).
     * @param listener     listener to handle events raised by this estimator.
     * @throws IllegalArgumentException if provided total samples is zero or negative,
     *                                  or if provided time interval is negative.
     */
    public IMUBiasEstimator(
            final Angle latitude, final Angle longitude, final double height,
            final int totalSamples, final double timeInterval,
            final IMUBiasEstimatorListener listener) {
<span class="fc" id="L1431">        this(latitude, longitude, height, totalSamples, timeInterval);</span>
<span class="fc" id="L1432">        mListener = listener;</span>
<span class="fc" id="L1433">    }</span>

    /**
     * Constructor.
     * It is assumed that body has zero Euler angles representing rotation (roll = 0,
     * pitch = 0, yaw = 0) respect the horizon at provided body location.
     * For Android devices this means that the device is flat on a horizontal surface
     * with the screen facing down.
     *
     * @param latitude     latitude.
     * @param longitude    longitude.
     * @param height       height.
     * @param totalSamples total samples to be processed to finish estimation.
     * @param timeInterval time interval between body kinematics
     *                     (IMU acceleration + gyroscope) samples
     *                     expressed in seconds (s).
     * @param listener     listener to handle events raised by this estimator.
     * @throws IllegalArgumentException if provided total samples is zero or negative,
     *                                  or if provided time interval is negative.
     */
    public IMUBiasEstimator(
            final Angle latitude, final Angle longitude, final Distance height,
            final int totalSamples, final double timeInterval,
            final IMUBiasEstimatorListener listener) {
<span class="fc" id="L1457">        this(latitude, longitude, height, totalSamples, timeInterval);</span>
<span class="fc" id="L1458">        mListener = listener;</span>
<span class="fc" id="L1459">    }</span>

    /**
     * Constructor.
     *
     * @param position     body position expressed in NED coordinates.
     * @param nedC         coordinate transformation from body to local navigation
     *                     (NED) coordinates. This contains orientation respect the
     *                     horizon at current body location.
     * @param totalSamples total samples to be processed to finish estimation.
     * @param timeInterval time interval between body kinematics
     *                     (IMU acceleration + gyroscope) samples
     *                     expressed in seconds (s).
     * @param listener     listener to handle events raised by this estimator.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not
     *                                                       from body to local
     *                                                       navigation coordinates.
     * @throws IllegalArgumentException                      if provided total samples
     *                                                       is zero or negative,
     *                                                       or if provided time
     *                                                       interval is negative.
     */
    public IMUBiasEstimator(
            final NEDPosition position, final CoordinateTransformation nedC,
            final int totalSamples, final double timeInterval,
            final IMUBiasEstimatorListener listener)
            throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L1487">        this(position, nedC, totalSamples, timeInterval);</span>
<span class="fc" id="L1488">        mListener = listener;</span>
<span class="fc" id="L1489">    }</span>

    /**
     * Constructor.
     *
     * @param position     body position expressed in ECEF coordinates.
     * @param nedC         coordinate transformation from body to local navigation
     *                     (NED) coordinates. This contains orientation respect the
     *                     horizon at current body location.
     * @param totalSamples total samples to be processed to finish estimation.
     * @param timeInterval time interval between body kinematics
     *                     (IMU acceleration + gyroscope) samples
     *                     expressed in seconds (s).
     * @param listener     listener to handle events raised by this estimator.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not
     *                                                       from body to local
     *                                                       navigation coordinates.
     * @throws IllegalArgumentException                      if provided total samples
     *                                                       is zero or negative,
     *                                                       or if provided time
     *                                                       interval is negative.
     */
    public IMUBiasEstimator(
            final ECEFPosition position, final CoordinateTransformation nedC,
            final int totalSamples, final double timeInterval,
            final IMUBiasEstimatorListener listener)
            throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L1517">        this(position, nedC, totalSamples, timeInterval);</span>
<span class="fc" id="L1518">        mListener = listener;</span>
<span class="fc" id="L1519">    }</span>

    /**
     * Constructor.
     * It is assumed that body is located at zero NED coordinates (latitude = 0,
     * longitude = 0 and height = 0) and with zero Euler angles representing rotation
     * (roll = 0, pith = 0, yaw = 0), which for Android devices it means that the
     * device is flat on a horizontal surface with the screen facing down.
     *
     * @param timeInterval time interval between body kinematics
     *                     (IMU acceleration + gyroscope) samples.
     * @throws IllegalArgumentException if provided time interval is negative.
     */
    public IMUBiasEstimator(final Time timeInterval) {
<span class="fc" id="L1533">        this(convertTime(timeInterval));</span>
<span class="fc" id="L1534">    }</span>

    /**
     * Constructor.
     * It is assumed that body is located at zero NED coordinates (latitude = 0,
     * longitude = 0, and height = 0) with provided orientation.
     *
     * @param nedC         coordinate transformation from body to local navigation
     *                     (NED) coordinates. This contains orientation respect the
     *                     horizon at current body location.
     * @param timeInterval time interval between body kinematics
     *                     (IMU acceleration + gyroscope) samples.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not
     *                                                       from body to local
     *                                                       navigation coordinates.
     * @throws IllegalArgumentException                      if provided time interval
     *                                                       is negative.
     */
    public IMUBiasEstimator(
            final CoordinateTransformation nedC, final Time timeInterval)
            throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L1556">        this(nedC, convertTime(timeInterval));</span>
<span class="fc" id="L1557">    }</span>

    /**
     * Constructor.
     * It is assumed that body has zero Euler angles representing rotation (roll = 0,
     * pitch = 0, yaw = 0) respect the horizon at provided body location.
     * For Android devices this means that the device is flat on a horizontal surface
     * with the screen facing down.
     *
     * @param latitude     latitude expressed in radians (rad).
     * @param longitude    longitude expressed in radians (rad).
     * @param height       height expressed in meters (m).
     * @param timeInterval time interval between body kinematics
     *                     (IMU acceleration + gyroscope) samples.
     * @throws IllegalArgumentException if provided time interval is negative.
     */
    public IMUBiasEstimator(final double latitude, final double longitude,
                            final double height, final Time timeInterval) {
<span class="fc" id="L1575">        this(latitude, longitude, height, convertTime(timeInterval));</span>
<span class="fc" id="L1576">    }</span>

    /**
     * Constructor.
     * It is assumed that body has zero Euler angles representing rotation (roll = 0,
     * pitch = 0, yaw = 0) respect the horizon at provided body location.
     * For Android devices this means that the device is flat on a horizontal surface
     * with the screen facing down.
     *
     * @param latitude     latitude.
     * @param longitude    longitude.
     * @param height       height expressed in meters (m).
     * @param timeInterval time interval between body kinematics
     *                     (IMU acceleration + gyroscope) samples.
     * @throws IllegalArgumentException if provided time interval is negative.
     */
    public IMUBiasEstimator(final Angle latitude, final Angle longitude,
                            final double height, final Time timeInterval) {
<span class="fc" id="L1594">        this(latitude, longitude, height, convertTime(timeInterval));</span>
<span class="fc" id="L1595">    }</span>

    /**
     * Constructor.
     * It is assumed that body has zero Euler angles representing rotation (roll = 0,
     * pitch = 0, yaw = 0) respect the horizon at provided body location.
     * For Android devices this means that the device is flat on a horizontal surface
     * with the screen facing down.
     *
     * @param latitude     latitude.
     * @param longitude    longitude.
     * @param height       height.
     * @param timeInterval time interval between body kinematics
     *                     (IMU acceleration + gyroscope) samples.
     * @throws IllegalArgumentException if provided time interval is negative.
     */
    public IMUBiasEstimator(final Angle latitude, final Angle longitude,
                            final Distance height, final Time timeInterval) {
<span class="fc" id="L1613">        this(latitude, longitude, height, convertTime(timeInterval));</span>
<span class="fc" id="L1614">    }</span>

    /**
     * Constructor.
     *
     * @param position     body position expressed in NED coordinates.
     * @param nedC         coordinate transformation from body to local navigation
     *                     (NED) coordinates. This contains orientation respect the
     *                     horizon at current body location.
     * @param timeInterval time interval between body kinematics
     *                     (IMU acceleration + gyroscope) samples.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not
     *                                                       from body to local
     *                                                       navigation coordinates.
     * @throws IllegalArgumentException                      if provided time interval
     *                                                       is negative.
     */
    public IMUBiasEstimator(
            final NEDPosition position, final CoordinateTransformation nedC,
            final Time timeInterval)
            throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L1636">        this(position, nedC, convertTime(timeInterval));</span>
<span class="fc" id="L1637">    }</span>

    /**
     * Constructor.
     *
     * @param position     body position expressed in ECEF coordinates.
     * @param nedC         coordinate transformation from body to local navigation
     *                     (NED) coordinates. This contains orientation respect the
     *                     horizon at current body location.
     * @param timeInterval time interval between body kinematics
     *                     (IMU acceleration + gyroscope) samples.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not
     *                                                       from body to local
     *                                                       navigation coordinates.
     * @throws IllegalArgumentException                      if provided time interval
     *                                                       is negative.
     */
    public IMUBiasEstimator(
            final ECEFPosition position, final CoordinateTransformation nedC,
            final Time timeInterval)
            throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L1659">        this(position, nedC, convertTime(timeInterval));</span>
<span class="fc" id="L1660">    }</span>

    /**
     * Constructor.
     * It is assumed that body is located at zero NED coordinates (latitude = 0,
     * longitude = 0 and height = 0) and with zero Euler angles representing rotation
     * (roll = 0, pith = 0, yaw = 0), which for Android devices it means that the
     * device is flat on a horizontal surface with the screen facing down.
     *
     * @param timeInterval time interval between body kinematics
     *                     (IMU acceleration + gyroscope) samples.
     * @param listener     listener to handle events raised by this estimator.
     * @throws IllegalArgumentException if provided time interval is negative.
     */
    public IMUBiasEstimator(final Time timeInterval,
                            final IMUBiasEstimatorListener listener) {
<span class="fc" id="L1676">        this(convertTime(timeInterval), listener);</span>
<span class="fc" id="L1677">    }</span>

    /**
     * Constructor.
     * It is assumed that body is located at zero NED coordinates (latitude = 0,
     * longitude = 0, and height = 0) with provided orientation.
     *
     * @param nedC         coordinate transformation from body to local navigation
     *                     (NED) coordinates. This contains orientation respect the
     *                     horizon at current body location.
     * @param timeInterval time interval between body kinematics
     *                     (IMU acceleration + gyroscope) samples.
     * @param listener     listener to handle events raised by this estimator.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not
     *                                                       from body to local
     *                                                       navigation coordinates.
     * @throws IllegalArgumentException                      if provided time interval
     *                                                       is negative.
     */
    public IMUBiasEstimator(
            final CoordinateTransformation nedC, final Time timeInterval,
            final IMUBiasEstimatorListener listener)
            throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L1701">        this(nedC, convertTime(timeInterval), listener);</span>
<span class="fc" id="L1702">    }</span>

    /**
     * Constructor.
     * It is assumed that body has zero Euler angles representing rotation (roll = 0,
     * pitch = 0, yaw = 0) respect the horizon at provided body location.
     * For Android devices this means that the device is flat on a horizontal surface
     * with the screen facing down.
     *
     * @param latitude     latitude expressed in radians (rad).
     * @param longitude    longitude expressed in radians (rad).
     * @param height       height expressed in meters (m).
     * @param timeInterval time interval between body kinematics
     *                     (IMU acceleration + gyroscope) samples.
     * @param listener     listener to handle events raised by this estimator.
     * @throws IllegalArgumentException if provided time interval is negative.
     */
    public IMUBiasEstimator(
            final double latitude, final double longitude, final double height,
            final Time timeInterval, final IMUBiasEstimatorListener listener) {
<span class="fc" id="L1722">        this(latitude, longitude, height, convertTime(timeInterval), listener);</span>
<span class="fc" id="L1723">    }</span>

    /**
     * Constructor.
     * It is assumed that body has zero Euler angles representing rotation (roll = 0,
     * pitch = 0, yaw = 0) respect the horizon at provided body location.
     * For Android devices this means that the device is flat on a horizontal surface
     * with the screen facing down.
     *
     * @param latitude     latitude.
     * @param longitude    longitude.
     * @param height       height expressed in meters (m).
     * @param timeInterval time interval between body kinematics
     *                     (IMU acceleration + gyroscope) samples.
     * @param listener     listener to handle events raised by this estimator.
     * @throws IllegalArgumentException if provided time interval is negative.
     */
    public IMUBiasEstimator(
            final Angle latitude, final Angle longitude, final double height,
            final Time timeInterval, final IMUBiasEstimatorListener listener) {
<span class="fc" id="L1743">        this(latitude, longitude, height, convertTime(timeInterval), listener);</span>
<span class="fc" id="L1744">    }</span>

    /**
     * Constructor.
     * It is assumed that body has zero Euler angles representing rotation (roll = 0,
     * pitch = 0, yaw = 0) respect the horizon at provided body location.
     * For Android devices this means that the device is flat on a horizontal surface
     * with the screen facing down.
     *
     * @param latitude     latitude.
     * @param longitude    longitude.
     * @param height       height.
     * @param timeInterval time interval between body kinematics
     *                     (IMU acceleration + gyroscope) samples.
     * @param listener     listener to handle events raised by this estimator.
     * @throws IllegalArgumentException if provided time interval is negative.
     */
    public IMUBiasEstimator(
            final Angle latitude, final Angle longitude, final Distance height,
            final Time timeInterval, final IMUBiasEstimatorListener listener) {
<span class="fc" id="L1764">        this(latitude, longitude, height, convertTime(timeInterval), listener);</span>
<span class="fc" id="L1765">    }</span>

    /**
     * Constructor.
     *
     * @param position     body position expressed in NED coordinates.
     * @param nedC         coordinate transformation from body to local navigation
     *                     (NED) coordinates. This contains orientation respect the
     *                     horizon at current body location.
     * @param timeInterval time interval between body kinematics
     *                     (IMU acceleration + gyroscope) samples.
     * @param listener     listener to handle events raised by this estimator.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not
     *                                                       from body to local
     *                                                       navigation coordinates.
     * @throws IllegalArgumentException                      if provided time interval
     *                                                       is negative.
     */
    public IMUBiasEstimator(
            final NEDPosition position, final CoordinateTransformation nedC,
            final Time timeInterval, final IMUBiasEstimatorListener listener)
            throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L1788">        this(position, nedC, convertTime(timeInterval), listener);</span>
<span class="fc" id="L1789">    }</span>

    /**
     * Constructor.
     *
     * @param position     body position expressed in ECEF coordinates.
     * @param nedC         coordinate transformation from body to local navigation
     *                     (NED) coordinates. This contains orientation respect the
     *                     horizon at current body location.
     * @param timeInterval time interval between body kinematics
     *                     (IMU acceleration + gyroscope) samples.
     * @param listener     listener to handle events raised by this estimator.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not
     *                                                       from body to local
     *                                                       navigation coordinates.
     * @throws IllegalArgumentException                      if provided time interval
     *                                                       is negative.
     */
    public IMUBiasEstimator(
            final ECEFPosition position, final CoordinateTransformation nedC,
            final Time timeInterval, final IMUBiasEstimatorListener listener)
            throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L1812">        this(position, nedC, convertTime(timeInterval), listener);</span>
<span class="fc" id="L1813">    }</span>

    /**
     * Constructor.
     * It is assumed that body is located at zero NED coordinates (latitude = 0,
     * longitude = 0 and height = 0) and with zero Euler angles representing rotation
     * (roll = 0, pith = 0, yaw = 0), which for Android devices it means that the
     * device is flat on a horizontal surface with the screen facing down.
     *
     * @param totalSamples total samples to be processed to finish estimation.
     * @param timeInterval time interval between body kinematics
     *                     (IMU acceleration + gyroscope) samples.
     * @throws IllegalArgumentException if provided total samples is zero or negative,
     *                                  or if provided time interval is negative.
     */
    public IMUBiasEstimator(final int totalSamples, final Time timeInterval) {
<span class="fc" id="L1829">        this(totalSamples, convertTime(timeInterval));</span>
<span class="fc" id="L1830">    }</span>

    /**
     * Constructor.
     * It is assumed that body is located at zero NED coordinates (latitude = 0,
     * longitude = 0, and height = 0) with provided orientation.
     *
     * @param nedC         coordinate transformation from body to local navigation
     *                     (NED) coordinates. This contains orientation respect the
     *                     horizon at current body location.
     * @param totalSamples total samples to be processed to finish estimation.
     * @param timeInterval time interval between body kinematics
     *                     (IMU acceleration + gyroscope) samples.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not
     *                                                       from body to local
     *                                                       navigation coordinates.
     * @throws IllegalArgumentException                      if provided total samples
     *                                                       is zero or negative, or
     *                                                       if provided time interval
     *                                                       is negative.
     */
    public IMUBiasEstimator(
            final CoordinateTransformation nedC, final int totalSamples,
            final Time timeInterval)
            throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L1856">        this(nedC, totalSamples, convertTime(timeInterval));</span>
<span class="fc" id="L1857">    }</span>

    /**
     * Constructor.
     * It is assumed that body has zero Euler angles representing rotation (roll = 0,
     * pitch = 0, yaw = 0) respect the horizon at provided body location.
     * For Android devices this means that the device is flat on a horizontal surface
     * with the screen facing down.
     *
     * @param latitude     latitude expressed in radians (rad).
     * @param longitude    longitude expressed in radians (rad).
     * @param height       height expressed in meters (m).
     * @param totalSamples total samples to be processed to finish estimation.
     * @param timeInterval time interval between body kinematics
     *                     (IMU acceleration + gyroscope) samples.
     * @throws IllegalArgumentException if provided total samples is zero or negative, or
     *                                  if provided time interval is negative.
     */
    public IMUBiasEstimator(
            final double latitude, final double longitude, final double height,
            final int totalSamples, final Time timeInterval) {
<span class="fc" id="L1878">        this(latitude, longitude, height, totalSamples, convertTime(timeInterval));</span>
<span class="fc" id="L1879">    }</span>

    /**
     * Constructor.
     * It is assumed that body has zero Euler angles representing rotation (roll = 0,
     * pitch = 0, yaw = 0) respect the horizon at provided body location.
     * For Android devices this means that the device is flat on a horizontal surface
     * with the screen facing down.
     *
     * @param latitude     latitude.
     * @param longitude    longitude.
     * @param height       height expressed in meters (m).
     * @param totalSamples total samples to be processed to finish estimation.
     * @param timeInterval time interval between body kinematics
     *                     (IMU acceleration + gyroscope) samples.
     * @throws IllegalArgumentException if provided total samples is zero or negative, or
     *                                  if provided time interval is negative.
     */
    public IMUBiasEstimator(
            final Angle latitude, final Angle longitude, final double height,
            final int totalSamples, final Time timeInterval) {
<span class="fc" id="L1900">        this(latitude, longitude, height, totalSamples, convertTime(timeInterval));</span>
<span class="fc" id="L1901">    }</span>

    /**
     * Constructor.
     * It is assumed that body has zero Euler angles representing rotation (roll = 0,
     * pitch = 0, yaw = 0) respect the horizon at provided body location.
     * For Android devices this means that the device is flat on a horizontal surface
     * with the screen facing down.
     *
     * @param latitude     latitude.
     * @param longitude    longitude.
     * @param height       height.
     * @param totalSamples total samples to be processed to finish estimation.
     * @param timeInterval time interval between body kinematics
     *                     (IMU acceleration + gyroscope) samples.
     * @throws IllegalArgumentException if provided total samples is zero or negative,
     *                                  or if provided time interval is negative.
     */
    public IMUBiasEstimator(
            final Angle latitude, final Angle longitude, final Distance height,
            final int totalSamples, final Time timeInterval) {
<span class="fc" id="L1922">        this(latitude, longitude, height, totalSamples, convertTime(timeInterval));</span>
<span class="fc" id="L1923">    }</span>

    /**
     * Constructor.
     *
     * @param position     body position expressed in NED coordinates.
     * @param nedC         coordinate transformation from body to local navigation
     *                     (NED) coordinates. This contains orientation respect the
     *                     horizon at current body location.
     * @param totalSamples total samples to be processed to finish estimation.
     * @param timeInterval time interval between body kinematics
     *                     (IMU acceleration + gyroscope) samples.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not
     *                                                       from body to local
     *                                                       navigation coordinates.
     * @throws IllegalArgumentException                      if provided total samples
     *                                                       is zero or negative, or
     *                                                       if provided time interval
     *                                                       is negative.
     */
    public IMUBiasEstimator(
            final NEDPosition position, final CoordinateTransformation nedC,
            final int totalSamples, final Time timeInterval)
            throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L1948">        this(position, nedC, totalSamples, convertTime(timeInterval));</span>
<span class="fc" id="L1949">    }</span>

    /**
     * Constructor.
     *
     * @param position     body position expressed in ECEF coordinates.
     * @param nedC         coordinate transformation from body to local navigation
     *                     (NED) coordinates. This contains orientation respect the
     *                     horizon at current body location.
     * @param totalSamples total samples to be processed to finish estimation.
     * @param timeInterval time interval between body kinematics
     *                     (IMU acceleration + gyroscope) samples.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not
     *                                                       from body to local
     *                                                       navigation coordinates.
     * @throws IllegalArgumentException                      if provided total samples
     *                                                       is zero or negative, or
     *                                                       if provided time interval
     *                                                       is negative.
     */
    public IMUBiasEstimator(
            final ECEFPosition position, final CoordinateTransformation nedC,
            final int totalSamples, final Time timeInterval)
            throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L1974">        this(position, nedC, totalSamples, convertTime(timeInterval));</span>
<span class="fc" id="L1975">    }</span>

    /**
     * Constructor.
     * It is assumed that body is located at zero NED coordinates (latitude = 0,
     * longitude = 0 and height = 0) and with zero Euler angles representing rotation
     * (roll = 0, pith = 0, yaw = 0), which for Android devices it means that the
     * device is flat on a horizontal surface with the screen facing down.
     *
     * @param totalSamples total samples to be processed to finish estimation.
     * @param timeInterval time interval between body kinematics
     *                     (IMU acceleration + gyroscope) samples.
     * @param listener     listener to handle events raised by this estimator.
     * @throws IllegalArgumentException if provided total samples is zero or negative,
     *                                  or if provided time interval is negative.
     */
    public IMUBiasEstimator(final int totalSamples, final Time timeInterval,
                            final IMUBiasEstimatorListener listener) {
<span class="fc" id="L1993">        this(totalSamples, convertTime(timeInterval), listener);</span>
<span class="fc" id="L1994">    }</span>

    /**
     * Constructor.
     * It is assumed that body is located at zero NED coordinates (latitude = 0,
     * longitude = 0, and height = 0) with provided orientation.
     *
     * @param nedC         coordinate transformation from body to local navigation
     *                     (NED) coordinates. This contains orientation respect the
     *                     horizon at current body location.
     * @param totalSamples total samples to be processed to finish estimation.
     * @param timeInterval time interval between body kinematics
     *                     (IMU acceleration + gyroscope) samples.
     * @param listener     listener to handle events raised by this estimator.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not
     *                                                       from body to local
     *                                                       navigation coordinates.
     * @throws IllegalArgumentException                      if provided total samples
     *                                                       is zero or negative,
     *                                                       or if provided time
     *                                                       interval is negative.
     */
    public IMUBiasEstimator(
            final CoordinateTransformation nedC, final int totalSamples,
            final Time timeInterval, final IMUBiasEstimatorListener listener)
            throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L2021">        this(nedC, totalSamples, convertTime(timeInterval), listener);</span>
<span class="fc" id="L2022">    }</span>

    /**
     * Constructor.
     * It is assumed that body has zero Euler angles representing rotation (roll = 0,
     * pitch = 0, yaw = 0) respect the horizon at provided body location.
     * For Android devices this means that the device is flat on a horizontal surface
     * with the screen facing down.
     *
     * @param latitude     latitude expressed in radians (rad).
     * @param longitude    longitude expressed in radians (rad).
     * @param height       height expressed in meters (m).
     * @param totalSamples total samples to be processed to finish estimation.
     * @param timeInterval time interval between body kinematics
     *                     (IMU acceleration + gyroscope) samples.
     * @param listener     listener to handle events raised by this estimator.
     * @throws IllegalArgumentException if provided total samples is zero or negative,
     *                                  or if provided time interval is negative.
     */
    public IMUBiasEstimator(
            final double latitude, final double longitude, final double height,
            final int totalSamples, final Time timeInterval,
            final IMUBiasEstimatorListener listener) {
<span class="fc" id="L2045">        this(latitude, longitude, height, totalSamples, convertTime(timeInterval),</span>
                listener);
<span class="fc" id="L2047">    }</span>

    /**
     * Constructor.
     * It is assumed that body has zero Euler angles representing rotation (roll = 0,
     * pitch = 0, yaw = 0) respect the horizon at provided body location.
     * For Android devices this means that the device is flat on a horizontal surface
     * with the screen facing down.
     *
     * @param latitude     latitude.
     * @param longitude    longitude.
     * @param height       height expressed in meters (m).
     * @param totalSamples total samples to be processed to finish estimation.
     * @param timeInterval time interval between body kinematics
     *                     (IMU acceleration + gyroscope) samples.
     * @param listener     listener to handle events raised by this estimator.
     * @throws IllegalArgumentException if provided total samples is zero or negative,
     *                                  or if provided time interval is negative.
     */
    public IMUBiasEstimator(
            final Angle latitude, final Angle longitude, final double height,
            final int totalSamples, final Time timeInterval,
            final IMUBiasEstimatorListener listener) {
<span class="fc" id="L2070">        this(latitude, longitude, height, totalSamples, convertTime(timeInterval),</span>
                listener);
<span class="fc" id="L2072">    }</span>

    /**
     * Constructor.
     * It is assumed that body has zero Euler angles representing rotation (roll = 0,
     * pitch = 0, yaw = 0) respect the horizon at provided body location.
     * For Android devices this means that the device is flat on a horizontal surface
     * with the screen facing down.
     *
     * @param latitude     latitude.
     * @param longitude    longitude.
     * @param height       height.
     * @param totalSamples total samples to be processed to finish estimation.
     * @param timeInterval time interval between body kinematics
     *                     (IMU acceleration + gyroscope) samples.
     * @param listener     listener to handle events raised by this estimator.
     * @throws IllegalArgumentException if provided total samples is zero or negative,
     *                                  or if provided time interval is negative.
     */
    public IMUBiasEstimator(
            final Angle latitude, final Angle longitude, final Distance height,
            final int totalSamples, final Time timeInterval,
            final IMUBiasEstimatorListener listener) {
<span class="fc" id="L2095">        this(latitude, longitude, height, totalSamples, convertTime(timeInterval),</span>
                listener);
<span class="fc" id="L2097">    }</span>

    /**
     * Constructor.
     *
     * @param position     body position expressed in NED coordinates.
     * @param nedC         coordinate transformation from body to local navigation
     *                     (NED) coordinates. This contains orientation respect the
     *                     horizon at current body location.
     * @param totalSamples total samples to be processed to finish estimation.
     * @param timeInterval time interval between body kinematics
     *                     (IMU acceleration + gyroscope) samples.
     * @param listener     listener to handle events raised by this estimator.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not
     *                                                       from body to local
     *                                                       navigation coordinates.
     * @throws IllegalArgumentException                      if provided total samples
     *                                                       is zero or negative,
     *                                                       or if provided time
     *                                                       interval is negative.
     */
    public IMUBiasEstimator(
            final NEDPosition position, final CoordinateTransformation nedC,
            final int totalSamples, final Time timeInterval,
            final IMUBiasEstimatorListener listener)
            throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L2124">        this(position, nedC, totalSamples, convertTime(timeInterval), listener);</span>
<span class="fc" id="L2125">    }</span>

    /**
     * Constructor.
     *
     * @param position     body position expressed in ECEF coordinates.
     * @param nedC         coordinate transformation from body to local navigation
     *                     (NED) coordinates. This contains orientation respect the
     *                     horizon at current body location.
     * @param totalSamples total samples to be processed to finish estimation.
     * @param timeInterval time interval between body kinematics
     *                     (IMU acceleration + gyroscope) samples.
     * @param listener     listener to handle events raised by this estimator.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not
     *                                                       from body to local
     *                                                       navigation coordinates.
     * @throws IllegalArgumentException                      if provided total samples
     *                                                       is zero or negative,
     *                                                       or if provided time
     *                                                       interval is negative.
     */
    public IMUBiasEstimator(
            final ECEFPosition position, final CoordinateTransformation nedC,
            final int totalSamples, final Time timeInterval,
            final IMUBiasEstimatorListener listener)
            throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L2152">        this(position, nedC, totalSamples, convertTime(timeInterval), listener);</span>
<span class="fc" id="L2153">    }</span>

    /**
     * Gets total samples to be processed to finish estimation.
     *
     * @return total samples to be processed to finish estimation.
     */
    public int getTotalSamples() {
<span class="fc" id="L2161">        return mTotalSamples;</span>
    }

    /**
     * Sets total samples to be processed to finish estimation.
     *
     * @param totalSamples total samples to be processed to finish estimation.
     * @throws LockedException if estimator is currently running.
     */
    public void setTotalSamples(final int totalSamples) throws LockedException {
<span class="fc bfc" id="L2171" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L2172">            throw new LockedException();</span>
        }

<span class="fc bfc" id="L2175" title="All 2 branches covered.">        if (totalSamples &lt;= 0) {</span>
<span class="fc" id="L2176">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L2179">        mTotalSamples = totalSamples;</span>
<span class="fc" id="L2180">    }</span>

    /**
     * Gets time interval between body kinematics (IMU acceleration + gyroscope)
     * samples expressed in seconds (s).
     *
     * @return time interval between body kinematics samples.
     */
    public double getTimeInterval() {
<span class="fc" id="L2189">        return mTimeInterval;</span>
    }

    /**
     * Sets time interval between body kinematics (IMU acceleration + gyroscope)
     * samples expressed in seconds (s).
     *
     * @param timeInterval time interval between body kinematics samples.
     * @throws LockedException if estimator is currently running.
     */
    public void setTimeInterval(final double timeInterval) throws LockedException {
<span class="fc bfc" id="L2200" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L2201">            throw new LockedException();</span>
        }

<span class="fc bfc" id="L2204" title="All 2 branches covered.">        if (timeInterval &lt; 0.0) {</span>
<span class="fc" id="L2205">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L2208">        mTimeInterval = timeInterval;</span>

<span class="fc" id="L2210">        rebuildExpectedKinematics();</span>
<span class="fc" id="L2211">    }</span>

    /**
     * Gets time interval between body kinematics (IMU acceleration + gyroscope)
     * samples.
     *
     * @return time interval between body kinematics samples.
     */
    public Time getTimeIntervalAsTime() {
<span class="fc" id="L2220">        return new Time(mTimeInterval, TimeUnit.SECOND);</span>
    }

    /**
     * Gets time interval between body kinematics (IMU acceleration + gyroscope)
     * samples.
     *
     * @param result instance where time interval will be stored.
     */
    public void getTimeIntervalAsTime(final Time result) {
<span class="fc" id="L2230">        result.setValue(mTimeInterval);</span>
<span class="fc" id="L2231">        result.setUnit(TimeUnit.SECOND);</span>
<span class="fc" id="L2232">    }</span>

    /**
     * Sets time interval between body kinematics (IMU acceleration + gyroscope)
     * samples.
     *
     * @param timeInterval time interval between body kinematics samples.
     * @throws LockedException if estimator is currently running.
     */
    public void setTimeInterval(final Time timeInterval) throws LockedException {
<span class="fc" id="L2242">        setTimeInterval(convertTime(timeInterval));</span>
<span class="fc" id="L2243">    }</span>

    /**
     * Gets current body position expressed in ECEF coordinates.
     *
     * @return current body position expressed in ECEF coordinates.
     */
    public ECEFPosition getEcefPosition() {
<span class="fc" id="L2251">        return mFrame.getECEFPosition();</span>
    }

    /**
     * Gets current body position expressed in ECEF coordinates.
     *
     * @param result instance where current body position will be stored.
     */
    public void getEcefPosition(final ECEFPosition result) {
<span class="fc" id="L2260">        mFrame.getECEFPosition(result);</span>
<span class="fc" id="L2261">    }</span>

    /**
     * Sets current body position expressed in ECEF coordinates.
     *
     * @param position current body position to be set.
     * @throws LockedException if estimator is currently running.
     */
    public void setEcefPosition(final ECEFPosition position) throws LockedException {
<span class="fc bfc" id="L2270" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L2271">            throw new LockedException();</span>
        }

<span class="fc" id="L2274">        mFrame.setPosition(position);</span>
<span class="fc" id="L2275">        rebuildExpectedKinematics();</span>
<span class="fc" id="L2276">    }</span>

    /**
     * Sets current body position expressed in ECEF coordinates.
     *
     * @param x x position resolved around ECEF axes and expressed in meters (m).
     * @param y y position resolved around ECEF axes and expressed in meters (m).
     * @param z z position resolved around ECEF axes and expressed in meters (m).
     * @throws LockedException if estimator is currently running.
     */
    public void setEcefPosition(final double x, final double y, final double z)
            throws LockedException {
<span class="fc bfc" id="L2288" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L2289">            throw new LockedException();</span>
        }

<span class="fc" id="L2292">        mFrame.setCoordinates(x, y, z);</span>
<span class="fc" id="L2293">        rebuildExpectedKinematics();</span>
<span class="fc" id="L2294">    }</span>

    /**
     * Sets current body position expressed in ECEF coordinates.
     *
     * @param x x position resolved around ECEF axes.
     * @param y y position resolved around ECEF axes.
     * @param z z position resolved around ECEF axes.
     * @throws LockedException if estimator is currently running.
     */
    public void setEcefPosition(final Distance x, final Distance y, final Distance z)
            throws LockedException {
<span class="fc bfc" id="L2306" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L2307">            throw new LockedException();</span>
        }

<span class="fc" id="L2310">        mFrame.setPositionCoordinates(x, y, z);</span>
<span class="fc" id="L2311">        rebuildExpectedKinematics();</span>
<span class="fc" id="L2312">    }</span>

    /**
     * Sets current body position expressed in ECEF coordinates.
     *
     * @param position position resolved around ECEF axes and expressed in meters (m).
     * @throws LockedException if estimator is currently running.
     */
    public void setEcefPosition(final Point3D position) throws LockedException {
<span class="fc bfc" id="L2321" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L2322">            throw new LockedException();</span>
        }

<span class="fc" id="L2325">        mFrame.setPosition(position);</span>
<span class="fc" id="L2326">        rebuildExpectedKinematics();</span>
<span class="fc" id="L2327">    }</span>

    /**
     * Gets ECEF frame containing current body position and orientation expressed
     * in ECEF coordinates. Frame also contains body velocity, but it is always
     * assumed to be zero during calibration.
     *
     * @return ECEF frame containing current body position and orientation resolved
     * around ECEF axes.
     */
    public ECEFFrame getEcefFrame() {
<span class="fc" id="L2338">        return new ECEFFrame(mFrame);</span>
    }

    /**
     * Gets ECEF frame containing current body position and orientation expressed
     * in ECEF coordinates. Frame also contains body velocity, but it is always
     * assumed to be zero during calibration.
     *
     * @param result instance where ECEF frame containing current body position and
     *               orientation resolved around ECEF axes will be stored.
     */
    public void getEcefFrame(final ECEFFrame result) {
<span class="fc" id="L2350">        mFrame.copyTo(result);</span>
<span class="fc" id="L2351">    }</span>

    /**
     * Gets NED frame containing current body position and orientation expressed
     * in NED coordinates. Frame also contains body velocity, but it is always
     * assumed to be zero during calibration.
     *
     * @return NED frame containing current body position and orientation resolved
     * around NED axes.
     */
    public NEDFrame getNedFrame() {
<span class="fc" id="L2362">        return ECEFtoNEDFrameConverter.convertECEFtoNEDAndReturnNew(mFrame);</span>
    }

    /**
     * Gets NED frame containing current body position and orientation expressed
     * in NED coordinates. Frame also contains body velocity, but it is always
     * assumed to be zero during calibration.
     *
     * @param result instance where NED frame containing current body position and
     *               orientation resolved around NED axes will be stored.
     */
    public void getNedFrame(final NEDFrame result) {
<span class="fc" id="L2374">        ECEFtoNEDFrameConverter.convertECEFtoNED(mFrame, result);</span>
<span class="fc" id="L2375">    }</span>

    /**
     * Gets current body position expressed in NED coordinates.
     *
     * @return current body position expressed in NED coordinates.
     */
    public NEDPosition getNedPosition() {
<span class="fc" id="L2383">        return getNedFrame().getPosition();</span>
    }

    /**
     * Gets current body position expressed in NED coordinates.
     *
     * @param result instance where current body position will be stored.
     */
    public void getNedPosition(final NEDPosition result) {
<span class="fc" id="L2392">        getNedFrame().getPosition(result);</span>
<span class="fc" id="L2393">    }</span>

    /**
     * Sets current body position expressed in NED coordinates.
     *
     * @param position current body position to be set.
     * @throws LockedException if estimator is currently running.
     */
    public void setNedPosition(final NEDPosition position) throws LockedException {
<span class="fc bfc" id="L2402" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L2403">            throw new LockedException();</span>
        }

<span class="fc" id="L2406">        final NEDFrame nedFrame = getNedFrame();</span>
<span class="fc" id="L2407">        nedFrame.setPosition(position);</span>
<span class="fc" id="L2408">        NEDtoECEFFrameConverter.convertNEDtoECEF(nedFrame, mFrame);</span>
<span class="fc" id="L2409">        rebuildExpectedKinematics();</span>
<span class="fc" id="L2410">    }</span>

    /**
     * Sets current body position expressed in NED coordinates.
     *
     * @param latitude  latitude NED coordinate expressed in radians (rad).
     * @param longitude longitude NED coordinate expressed in radians (rad).
     * @param height    height NED coordinate expressed in meters (m).
     * @throws LockedException if estimator is currently running.
     */
    public void setNedPosition(
            final double latitude, final double longitude, final double height)
            throws LockedException {
<span class="fc bfc" id="L2423" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L2424">            throw new LockedException();</span>
        }

<span class="fc" id="L2427">        final NEDFrame nedFrame = getNedFrame();</span>
<span class="fc" id="L2428">        nedFrame.setPosition(latitude, longitude, height);</span>
<span class="fc" id="L2429">        NEDtoECEFFrameConverter.convertNEDtoECEF(nedFrame, mFrame);</span>
<span class="fc" id="L2430">        rebuildExpectedKinematics();</span>
<span class="fc" id="L2431">    }</span>

    /**
     * Sets current body position expressed in NED coordinates.
     *
     * @param latitude  latitude NED coordinate.
     * @param longitude longitude NED coordinate.
     * @param height    height NED coordinate expressed in meters (m).
     * @throws LockedException if estimator is currently running.
     */
    public void setNedPosition(
            final Angle latitude, final Angle longitude, final double height)
            throws LockedException {
<span class="fc bfc" id="L2444" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L2445">            throw new LockedException();</span>
        }

<span class="fc" id="L2448">        final NEDFrame nedFrame = getNedFrame();</span>
<span class="fc" id="L2449">        nedFrame.setPosition(latitude, longitude, height);</span>
<span class="fc" id="L2450">        NEDtoECEFFrameConverter.convertNEDtoECEF(nedFrame, mFrame);</span>
<span class="fc" id="L2451">        rebuildExpectedKinematics();</span>
<span class="fc" id="L2452">    }</span>

    /**
     * Sets current body position expressed in NED coordinates.
     *
     * @param latitude  latitude NED coordinate.
     * @param longitude longitude NED coordinate.
     * @param height    height NED coordinate.
     * @throws LockedException if estimator is currently running.
     */
    public void setNedPosition(
            final Angle latitude, final Angle longitude, final Distance height)
            throws LockedException {
<span class="fc bfc" id="L2465" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L2466">            throw new LockedException();</span>
        }

<span class="fc" id="L2469">        final NEDFrame nedFrame = getNedFrame();</span>
<span class="fc" id="L2470">        nedFrame.setPosition(latitude, longitude, height);</span>
<span class="fc" id="L2471">        NEDtoECEFFrameConverter.convertNEDtoECEF(nedFrame, mFrame);</span>
<span class="fc" id="L2472">        rebuildExpectedKinematics();</span>
<span class="fc" id="L2473">    }</span>

    /**
     * Gets current body orientation as a transformation from body to ECEF coordinates.
     * Notice that returned orientation refers to ECEF Earth axes, which means that
     * orientation is not relative to the ground or horizon at current body position.
     * Typically it is more convenient to use {@link #getNedC()} to obtain orientation
     * relative to the ground or horizon at current body position. For instance, on
     * Android devices a NED orientation with Euler angles (roll = 0, pitch = 0,
     * yaw = 0) means that the device is laying flat on a horizontal surface with the
     * screen facing down towards the ground.
     *
     * @return current body orientation resolved on ECEF axes.
     */
    public CoordinateTransformation getEcefC() {
<span class="fc" id="L2488">        return mFrame.getCoordinateTransformation();</span>
    }

    /**
     * Gets current body orientation as a transformation from body to ECEF coordinates.
     * Notice that returned orientation refers to ECEF Earth axes, which means that
     * orientation is not relative to the ground or horizon at current body position.
     * Typically it is more convenient to use {@link #getNedC()} to obtain orientation
     * relative to the ground or horizon at current body position. For instance, on
     * Android devices a NED orientation with Euler angles (roll = 0, pitch = 0,
     * yaw = 0) means that the device is laying flat on a horizontal surface with the
     * screen facing down towards the ground.
     *
     * @param result instance where current body orientation resolved on ECEF axes
     *               will be stored.
     */
    public void getEcefC(final CoordinateTransformation result) {
<span class="fc" id="L2505">        mFrame.getCoordinateTransformation(result);</span>
<span class="fc" id="L2506">    }</span>

    /**
     * Sets current body orientation as a transformation from body to ECEF coordinates.
     * Notice that ECEF orientation refers to ECEF Earth axes, which means that
     * orientation is not relative to the ground or horizont at current body position.
     * Typically it is more convenient to use
     * {@link #setNedC(CoordinateTransformation)} to specify orientation relative to
     * the ground or horizon at current body position.
     * For instance, on Android devices a NED orientation with Euler angles (roll = 0,
     * pitch = 0, yaw = 0) means that the device is laying flat on a horizontal surface
     * with the screen facing down towards the ground.
     *
     * @param ecefC body orientation resolved on ECEF axes to be set.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not from
     *                                                       body to ECEF coordinates.
     * @throws LockedException                               if estimator is currently
     *                                                       running.
     */
    public void setEcefC(final CoordinateTransformation ecefC)
            throws InvalidSourceAndDestinationFrameTypeException, LockedException {
<span class="fc bfc" id="L2528" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L2529">            throw new LockedException();</span>
        }

<span class="fc" id="L2532">        mFrame.setCoordinateTransformation(ecefC);</span>
<span class="fc" id="L2533">        rebuildExpectedKinematics();</span>
<span class="fc" id="L2534">    }</span>

    /**
     * Gets current body orientation as a transformation from body to NED coordinates.
     * Notice that returned orientation refers to current local position. This means
     * that two equal NED orientations will transform into different ECEF orientations
     * if the body is located at different positions.
     * As a reference, on Android devices a NED orientation with Euler angles
     * (roll = 0, pitch = 0, yaw = 0) means that the device is laying flat on a
     * horizontal surface with the screen facing down towards the ground.
     *
     * @return current body orientation resolved on NED axes.
     */
    public CoordinateTransformation getNedC() {
<span class="fc" id="L2548">        return getNedFrame().getCoordinateTransformation();</span>
    }

    /**
     * Gets current body orientation as a transformation from body to NED coordinates.
     * Notice that returned orientation refers to current local position. This means
     * that two equal NED orientations will transform into different ECEF orientations
     * if the body is located at different positions.
     * As a reference, on Android devices a NED orientation with Euler angles
     * (roll = 0, pitch = 0, yaw = 0) means that the device is laying flat on a
     * horizontal surface with the screen facing down towards the ground.
     *
     * @param result instance where current body orientation resolved on NED axes
     *               will be stored.
     */
    public void getNedC(final CoordinateTransformation result) {
<span class="fc" id="L2564">        getNedFrame().getCoordinateTransformation(result);</span>
<span class="fc" id="L2565">    }</span>

    /**
     * Sets current body orientation as a transformation from body to NED coordinates.
     * Notice that provided orientation refers to current local position. This means
     * that two equal NED orientations will transform into different ECEF orientations
     * if the body is located at different positions.
     * As a reference, on Android devices a NED orientation with Euler angles
     * (roll = 0, pitch = 0, yaw = 0) means that the device is laying flat on a
     * horizontal surface with the screen facing down towards the ground.
     *
     * @param nedC orientation resolved on NED axes to be set.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not from
     *                                                       body to NED coordinates.
     * @throws LockedException                               if estimator is currently
     *                                                       running.
     */
    public void setNedC(final CoordinateTransformation nedC)
            throws InvalidSourceAndDestinationFrameTypeException, LockedException {
<span class="fc bfc" id="L2585" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L2586">            throw new LockedException();</span>
        }

<span class="fc" id="L2589">        final NEDFrame nedFrame = getNedFrame();</span>
<span class="fc" id="L2590">        nedFrame.setCoordinateTransformation(nedC);</span>
<span class="fc" id="L2591">        NEDtoECEFFrameConverter.convertNEDtoECEF(nedFrame, mFrame);</span>
<span class="fc" id="L2592">        rebuildExpectedKinematics();</span>
<span class="fc" id="L2593">    }</span>

    /**
     * Sets position and orientation both expressed on NED coordinates.
     *
     * @param nedPosition position expressed on NED coordinates.
     * @param nedC        body to NED coordinate transformation indicating
     *                    body orientation.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not from
     *                                                       body to NED coordinates.
     * @throws LockedException                               if estimator is currently
     *                                                       running.
     * @see #setNedPosition(NEDPosition)
     * @see #setNedC(CoordinateTransformation)
     */
    public void setNedPositionAndNedOrientation(
            final NEDPosition nedPosition, final CoordinateTransformation nedC)
            throws InvalidSourceAndDestinationFrameTypeException, LockedException {
<span class="fc bfc" id="L2612" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L2613">            throw new LockedException();</span>
        }

<span class="fc" id="L2616">        final NEDFrame nedFrame = getNedFrame();</span>
<span class="fc" id="L2617">        nedFrame.setPosition(nedPosition);</span>
<span class="fc" id="L2618">        nedFrame.setCoordinateTransformation(nedC);</span>
<span class="fc" id="L2619">        NEDtoECEFFrameConverter.convertNEDtoECEF(nedFrame, mFrame);</span>
<span class="fc" id="L2620">        rebuildExpectedKinematics();</span>
<span class="fc" id="L2621">    }</span>

    /**
     * Sets position and orientation both expressed on NED coordinates.
     *
     * @param latitude  latitude expressed in radians (rad).
     * @param longitude longitude expressed in radians (rad).
     * @param height    height expressed in meters (m).
     * @param nedC      body to NED coordinate transformation indicating
     *                  body orientation.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not from
     *                                                       body to NED coordinates.
     * @throws LockedException                               if estimator is currently
     *                                                       running.
     * @see #setNedPosition(double, double, double)
     * @see #setNedC(CoordinateTransformation)
     */
    public void setNedPositionAndNedOrientation(
            final double latitude, final double longitude, final double height,
            final CoordinateTransformation nedC)
            throws InvalidSourceAndDestinationFrameTypeException, LockedException {
<span class="fc bfc" id="L2643" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L2644">            throw new LockedException();</span>
        }

<span class="fc" id="L2647">        final NEDFrame nedFrame = getNedFrame();</span>
<span class="fc" id="L2648">        nedFrame.setPosition(latitude, longitude, height);</span>
<span class="fc" id="L2649">        nedFrame.setCoordinateTransformation(nedC);</span>
<span class="fc" id="L2650">        NEDtoECEFFrameConverter.convertNEDtoECEF(nedFrame, mFrame);</span>
<span class="fc" id="L2651">        rebuildExpectedKinematics();</span>
<span class="fc" id="L2652">    }</span>

    /**
     * Sets position and orientation both expressed on NED coordinates.
     *
     * @param latitude  latitude.
     * @param longitude longitude.
     * @param height    height expressed in meters (m).
     * @param nedC      body to NED coordinate transformation indicating
     *                  body orientation.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not from
     *                                                       body to NED coordinates.
     * @throws LockedException                               if estimator is currently
     *                                                       running.
     * @see #setNedPosition(Angle, Angle, double)
     * @see #setNedC(CoordinateTransformation)
     */
    public void setNedPositionAndNedOrientation(
            final Angle latitude, final Angle longitude, final double height,
            final CoordinateTransformation nedC)
            throws InvalidSourceAndDestinationFrameTypeException, LockedException {
<span class="fc bfc" id="L2674" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L2675">            throw new LockedException();</span>
        }

<span class="fc" id="L2678">        final NEDFrame nedFrame = getNedFrame();</span>
<span class="fc" id="L2679">        nedFrame.setPosition(latitude, longitude, height);</span>
<span class="fc" id="L2680">        nedFrame.setCoordinateTransformation(nedC);</span>
<span class="fc" id="L2681">        NEDtoECEFFrameConverter.convertNEDtoECEF(nedFrame, mFrame);</span>
<span class="fc" id="L2682">        rebuildExpectedKinematics();</span>
<span class="fc" id="L2683">    }</span>

    /**
     * Sets position and orientation both expressed on NED coordinates.
     *
     * @param latitude  latitude.
     * @param longitude longitude.
     * @param height    height.
     * @param nedC      body to NED coordinate transformation indicating
     *                  body orientation.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not from
     *                                                       body to NED coordinates.
     * @throws LockedException                               if estimator is currently
     *                                                       running.
     * @see #setNedPosition(Angle, Angle, Distance)
     * @see #setNedC(CoordinateTransformation)
     */
    public void setNedPositionAndNedOrientation(
            final Angle latitude, final Angle longitude, final Distance height,
            final CoordinateTransformation nedC)
            throws InvalidSourceAndDestinationFrameTypeException, LockedException {
<span class="fc bfc" id="L2705" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L2706">            throw new LockedException();</span>
        }

<span class="fc" id="L2709">        final NEDFrame nedFrame = getNedFrame();</span>
<span class="fc" id="L2710">        nedFrame.setPosition(latitude, longitude, height);</span>
<span class="fc" id="L2711">        nedFrame.setCoordinateTransformation(nedC);</span>
<span class="fc" id="L2712">        NEDtoECEFFrameConverter.convertNEDtoECEF(nedFrame, mFrame);</span>
<span class="fc" id="L2713">        rebuildExpectedKinematics();</span>
<span class="fc" id="L2714">    }</span>

    /**
     * Sets position and orientation both expressed on ECEF coordinates.
     *
     * @param ecefPosition position expressed on ECEF coordinates.
     * @param ecefC        body to ECEF coordinate transformation indicating body
     *                     orientation.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not from
     *                                                       body to ECEF coordinates.
     * @throws LockedException                               if estimator is currently
     *                                                       running.
     * @see #setEcefPosition(ECEFPosition)
     * @see #setEcefC(CoordinateTransformation)
     */
    public void setEcefPositionAndEcefOrientation(
            final ECEFPosition ecefPosition, final CoordinateTransformation ecefC)
            throws InvalidSourceAndDestinationFrameTypeException, LockedException {
<span class="fc bfc" id="L2733" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L2734">            throw new LockedException();</span>
        }

<span class="fc" id="L2737">        mFrame.setPosition(ecefPosition);</span>
<span class="fc" id="L2738">        mFrame.setCoordinateTransformation(ecefC);</span>
<span class="fc" id="L2739">        rebuildExpectedKinematics();</span>
<span class="fc" id="L2740">    }</span>

    /**
     * Sets position and orientation both expressed on ECEF coordinates.
     *
     * @param x     x coordinate of ECEF position expressed in meters (m).
     * @param y     y coordinate of ECEF position expressed in meters (m).
     * @param z     z coordinate of ECEF position expressed in meters (m).
     * @param ecefC body to ECEF coordinate transformation indicating body
     *              orientation.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not from
     *                                                       body to ECEF coordinates.
     * @throws LockedException                               if estimator is currently
     *                                                       running.
     * @see #setEcefPosition(double, double, double)
     * @see #setEcefC(CoordinateTransformation)
     */
    public void setEcefPositionAndEcefOrientation(
            final double x, final double y, final double z,
            final CoordinateTransformation ecefC)
            throws InvalidSourceAndDestinationFrameTypeException, LockedException {
<span class="fc bfc" id="L2762" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L2763">            throw new LockedException();</span>
        }

<span class="fc" id="L2766">        mFrame.setCoordinates(x, y, z);</span>
<span class="fc" id="L2767">        mFrame.setCoordinateTransformation(ecefC);</span>
<span class="fc" id="L2768">        rebuildExpectedKinematics();</span>
<span class="fc" id="L2769">    }</span>

    /**
     * Sets position and orientation both expressed on ECEF coordinates.
     *
     * @param x     x coordinate of ECEF position.
     * @param y     y coordinate of ECEF position.
     * @param z     z coordinate of ECEF position.
     * @param ecefC body to ECEF coordinate transformation indicating body
     *              orientation.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not from
     *                                                       body to ECEF coordinates.
     * @throws LockedException                               if estimator is currently
     *                                                       running.
     * @see #setEcefPosition(Distance, Distance, Distance)
     * @see #setEcefC(CoordinateTransformation)
     */
    public void setEcefPositionAndEcefOrientation(
            final Distance x, final Distance y, final Distance z,
            final CoordinateTransformation ecefC)
            throws InvalidSourceAndDestinationFrameTypeException, LockedException {
<span class="fc bfc" id="L2791" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L2792">            throw new LockedException();</span>
        }

<span class="fc" id="L2795">        mFrame.setPositionCoordinates(x, y, z);</span>
<span class="fc" id="L2796">        mFrame.setCoordinateTransformation(ecefC);</span>
<span class="fc" id="L2797">        rebuildExpectedKinematics();</span>
<span class="fc" id="L2798">    }</span>

    /**
     * Sets position and orientation both expressed on ECEF coordinates.
     *
     * @param position position resolved around ECEF axes and expressed in meters (m).
     * @param ecefC    body to ECEF coordinate transformation indicating body
     *                 orientation.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not from
     *                                                       body to ECEF coordinates.
     * @throws LockedException                               if estimator is currently
     *                                                       running.
     * @see #setEcefPosition(Point3D)
     * @see #setEcefC(CoordinateTransformation)
     */
    public void setEcefPositionAndEcefOrientation(
            final Point3D position, final CoordinateTransformation ecefC)
            throws InvalidSourceAndDestinationFrameTypeException, LockedException {
<span class="fc bfc" id="L2817" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L2818">            throw new LockedException();</span>
        }

<span class="fc" id="L2821">        mFrame.setPosition(position);</span>
<span class="fc" id="L2822">        mFrame.setCoordinateTransformation(ecefC);</span>
<span class="fc" id="L2823">        rebuildExpectedKinematics();</span>
<span class="fc" id="L2824">    }</span>

    /**
     * Sets position expressed on NED coordinates and orientation respect to ECEF
     * axes.
     *
     * @param position position expressed on NED coordinates.
     * @param ecefC    body to ECEF coordinate transformation indicating body
     *                 orientation.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not from
     *                                                       body to ECEF coordinates.
     * @throws LockedException                               if estimator is currently
     *                                                       running.
     * @see #setNedPosition(NEDPosition)
     * @see #setEcefC(CoordinateTransformation)
     */
    public void setNedPositionAndEcefOrientation(
            final NEDPosition position,
            final CoordinateTransformation ecefC)
            throws InvalidSourceAndDestinationFrameTypeException, LockedException {
<span class="fc bfc" id="L2845" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L2846">            throw new LockedException();</span>
        }

<span class="fc" id="L2849">        final NEDFrame nedFrame = getNedFrame();</span>
<span class="fc" id="L2850">        nedFrame.setPosition(position);</span>
<span class="fc" id="L2851">        NEDtoECEFFrameConverter.convertNEDtoECEF(nedFrame, mFrame);</span>
<span class="fc" id="L2852">        mFrame.setCoordinateTransformation(ecefC);</span>
<span class="fc" id="L2853">        rebuildExpectedKinematics();</span>
<span class="fc" id="L2854">    }</span>

    /**
     * Sets position expressed on NED coordinates and orientation respect to ECEF
     * axes.
     *
     * @param latitude  latitude expressed in radians (rad).
     * @param longitude longitude expressed in radians (rad).
     * @param height    height expressed in meters (m).
     * @param ecefC     body to ECEF coordinate transformation indicating body
     *                  orientation.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not from
     *                                                       body to ECEF coordinates.
     * @throws LockedException                               if estimator is currently
     *                                                       running.
     * @see #setNedPosition(double, double, double)
     * @see #setEcefC(CoordinateTransformation)
     */
    public void setNedPositionAndEcefOrientation(
            final double latitude, final double longitude, final double height,
            final CoordinateTransformation ecefC)
            throws InvalidSourceAndDestinationFrameTypeException, LockedException {
<span class="fc bfc" id="L2877" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L2878">            throw new LockedException();</span>
        }

<span class="fc" id="L2881">        final NEDFrame nedFrame = getNedFrame();</span>
<span class="fc" id="L2882">        nedFrame.setPosition(latitude, longitude, height);</span>
<span class="fc" id="L2883">        NEDtoECEFFrameConverter.convertNEDtoECEF(nedFrame, mFrame);</span>
<span class="fc" id="L2884">        mFrame.setCoordinateTransformation(ecefC);</span>
<span class="fc" id="L2885">        rebuildExpectedKinematics();</span>
<span class="fc" id="L2886">    }</span>

    /**
     * Sets position expressed on NED coordinates and orientation respect to ECEF
     * axes.
     *
     * @param latitude  latitude.
     * @param longitude longitude.
     * @param height    height expressed in meters (m).
     * @param ecefC     body to ECEF coordinate transformation indicating body
     *                  orientation.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not from
     *                                                       body to ECEF coordinates.
     * @throws LockedException                               if estimator is currently
     *                                                       running.
     * @see #setNedPosition(Angle, Angle, double)
     * @see #setEcefC(CoordinateTransformation)
     */
    public void setNedPositionAndEcefOrientation(
            final Angle latitude, final Angle longitude, final double height,
            final CoordinateTransformation ecefC)
            throws InvalidSourceAndDestinationFrameTypeException, LockedException {
<span class="fc bfc" id="L2909" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L2910">            throw new LockedException();</span>
        }

<span class="fc" id="L2913">        final NEDFrame nedFrame = getNedFrame();</span>
<span class="fc" id="L2914">        nedFrame.setPosition(latitude, longitude, height);</span>
<span class="fc" id="L2915">        NEDtoECEFFrameConverter.convertNEDtoECEF(nedFrame, mFrame);</span>
<span class="fc" id="L2916">        mFrame.setCoordinateTransformation(ecefC);</span>
<span class="fc" id="L2917">        rebuildExpectedKinematics();</span>
<span class="fc" id="L2918">    }</span>

    /**
     * Sets position expressed on NED coordinates and orientation respect to ECEF
     * axes.
     *
     * @param latitude  latitude.
     * @param longitude longitude.
     * @param height    height.
     * @param ecefC     body to ECEF coordinate transformation indicating body
     *                  orientation.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not from
     *                                                       body to ECEF coordinates.
     * @throws LockedException                               if estimator is currently
     *                                                       running.
     * @see #setNedPosition(Angle, Angle, Distance)
     * @see #setEcefC(CoordinateTransformation)
     */
    public void setNedPositionAndEcefOrientation(
            final Angle latitude, final Angle longitude, final Distance height,
            final CoordinateTransformation ecefC)
            throws InvalidSourceAndDestinationFrameTypeException, LockedException {
<span class="fc bfc" id="L2941" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L2942">            throw new LockedException();</span>
        }

<span class="fc" id="L2945">        final NEDFrame nedFrame = getNedFrame();</span>
<span class="fc" id="L2946">        nedFrame.setPosition(latitude, longitude, height);</span>
<span class="fc" id="L2947">        NEDtoECEFFrameConverter.convertNEDtoECEF(nedFrame, mFrame);</span>
<span class="fc" id="L2948">        mFrame.setCoordinateTransformation(ecefC);</span>
<span class="fc" id="L2949">        rebuildExpectedKinematics();</span>
<span class="fc" id="L2950">    }</span>

    /**
     * Sets position expressed on ECEF coordinates and orientation respect to
     * NED axes.
     * In order to preserve provided orientation, first position is set and
     * then orientation is applied.
     *
     * @param ecefPosition position expressed on ECEF coordinates.
     * @param nedC         body to NED coordinate transformation indicating body
     *                     orientation.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not from
     *                                                       body to NED coordinates.
     * @throws LockedException                               if estimator is currently
     *                                                       running.
     * @see #setEcefPosition(ECEFPosition)
     * @see #setNedC(CoordinateTransformation)
     */
    public void setEcefPositionAndNedOrientation(
            final ECEFPosition ecefPosition, final CoordinateTransformation nedC)
            throws InvalidSourceAndDestinationFrameTypeException, LockedException {
<span class="fc bfc" id="L2972" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L2973">            throw new LockedException();</span>
        }

<span class="fc" id="L2976">        mFrame.setPosition(ecefPosition);</span>

<span class="fc" id="L2978">        final NEDFrame nedFrame = getNedFrame();</span>
<span class="fc" id="L2979">        nedFrame.setCoordinateTransformation(nedC);</span>
<span class="fc" id="L2980">        NEDtoECEFFrameConverter.convertNEDtoECEF(nedFrame, mFrame);</span>
<span class="fc" id="L2981">        rebuildExpectedKinematics();</span>
<span class="fc" id="L2982">    }</span>

    /**
     * Sets position expressed on ECEF coordinates and orientation respect to
     * NED axes.
     * In order to preserve provided orientation, first position is set and
     * then orientation is applied.
     *
     * @param x    x coordinate of ECEF position expressed in meters (m).
     * @param y    y coordinate of ECEF position expressed in meters (m).
     * @param z    z coordinate of ECEF position expressed in meters (m).
     * @param nedC body to NED coordinate transformation indicating body
     *             orientation.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not from
     *                                                       body to NED coordinates.
     * @throws LockedException                               if estimator is currently
     *                                                       running.
     * @see #setEcefPosition(double, double, double)
     * @see #setNedC(CoordinateTransformation)
     */
    public void setEcefPositionAndNedOrientation(
            final double x, final double y, final double z,
            final CoordinateTransformation nedC)
            throws InvalidSourceAndDestinationFrameTypeException, LockedException {
<span class="fc bfc" id="L3007" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L3008">            throw new LockedException();</span>
        }

<span class="fc" id="L3011">        mFrame.setCoordinates(x, y, z);</span>

<span class="fc" id="L3013">        final NEDFrame nedFrame = getNedFrame();</span>
<span class="fc" id="L3014">        nedFrame.setCoordinateTransformation(nedC);</span>
<span class="fc" id="L3015">        NEDtoECEFFrameConverter.convertNEDtoECEF(nedFrame, mFrame);</span>
<span class="fc" id="L3016">        rebuildExpectedKinematics();</span>
<span class="fc" id="L3017">    }</span>

    /**
     * Sets position expressed on ECEF coordinates and orientation respect to
     * NED axes.
     * In order to preserve provided orientation, first position is set and
     * then orientation is applied.
     *
     * @param x    x coordinate of ECEF position.
     * @param y    y coordinate of ECEF position.
     * @param z    z coordinate of ECEF position.
     * @param nedC body to NED coordinate transformation indicating body
     *             orientation.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not from
     *                                                       body to NED coordinates.
     * @throws LockedException                               if estimator is currently
     *                                                       running.
     * @see #setEcefPosition(Distance, Distance, Distance)
     * @see #setNedC(CoordinateTransformation)
     */
    public void setEcefPositionAndNedOrientation(
            final Distance x, final Distance y, final Distance z,
            final CoordinateTransformation nedC)
            throws InvalidSourceAndDestinationFrameTypeException, LockedException {
<span class="fc bfc" id="L3042" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L3043">            throw new LockedException();</span>
        }

<span class="fc" id="L3046">        mFrame.setPositionCoordinates(x, y, z);</span>

<span class="fc" id="L3048">        final NEDFrame nedFrame = getNedFrame();</span>
<span class="fc" id="L3049">        nedFrame.setCoordinateTransformation(nedC);</span>
<span class="fc" id="L3050">        NEDtoECEFFrameConverter.convertNEDtoECEF(nedFrame, mFrame);</span>
<span class="fc" id="L3051">        rebuildExpectedKinematics();</span>
<span class="fc" id="L3052">    }</span>

    /**
     * Sets position expressed on ECEF coordinates and orientation respect to
     * NED axes.
     * In order to preserve provided orientation, first position is set and
     * then orientation is applied.
     *
     * @param position position resolved around ECEF axes and expressed in meters (m).
     * @param nedC     body to NED coordinate transformation indicating body
     *                 orientation.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not from
     *                                                       body to NED coordinates.
     * @throws LockedException                               if estimator is currently
     *                                                       running.
     * @see #setEcefPosition(Point3D)
     * @see #setNedC(CoordinateTransformation)
     */
    public void setEcefPositionAndNedOrientation(
            final Point3D position, final CoordinateTransformation nedC)
            throws InvalidSourceAndDestinationFrameTypeException, LockedException {
<span class="fc bfc" id="L3074" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L3075">            throw new LockedException();</span>
        }

<span class="fc" id="L3078">        mFrame.setPosition(position);</span>

<span class="fc" id="L3080">        final NEDFrame nedFrame = getNedFrame();</span>
<span class="fc" id="L3081">        nedFrame.setCoordinateTransformation(nedC);</span>
<span class="fc" id="L3082">        NEDtoECEFFrameConverter.convertNEDtoECEF(nedFrame, mFrame);</span>
<span class="fc" id="L3083">        rebuildExpectedKinematics();</span>
<span class="fc" id="L3084">    }</span>

    /**
     * Gets listener to handle events raised by this estimator.
     *
     * @return listener to handle events raised by this estimator.
     */
    public IMUBiasEstimatorListener getListener() {
<span class="fc" id="L3092">        return mListener;</span>
    }

    /**
     * Sets listener to handle events raised by this estimator.
     *
     * @param listener listener to handle events raised by this estimator.
     * @throws LockedException if this estimator is running.
     */
    public void setListener(final IMUBiasEstimatorListener listener)
            throws LockedException {
<span class="fc bfc" id="L3103" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L3104">            throw new LockedException();</span>
        }

<span class="fc" id="L3107">        mListener = listener;</span>
<span class="fc" id="L3108">    }</span>

    /**
     * Gets last provided body kinematics values or null if not available.
     *
     * @return last provided body kinematics values or null.
     */
    public BodyKinematics getLastBodyKinematics() {
<span class="fc bfc" id="L3116" title="All 2 branches covered.">        return mLastBodyKinematics != null ?</span>
<span class="fc" id="L3117">                new BodyKinematics(mLastBodyKinematics) : null;</span>
    }

    /**
     * Gets last provided body kinematics values.
     *
     * @param result instance where last provided body kinematics will be stored.
     * @return true if result instance was updated, false otherwise.
     */
    public boolean getLastBodyKinematics(final BodyKinematics result) {
<span class="fc bfc" id="L3127" title="All 2 branches covered.">        if (mLastBodyKinematics != null) {</span>
<span class="fc" id="L3128">            mLastBodyKinematics.copyTo(result);</span>
<span class="fc" id="L3129">            return true;</span>
        } else {
<span class="fc" id="L3131">            return false;</span>
        }
    }

    /**
     * Gets estimated bias of x coordinate of accelerometer sensed specific force
     * expressed in meters per squared second (m/s^2).
     *
     * @return bias of x coordinate of sensed specific force.
     */
    public double getBiasFx() {
<span class="fc" id="L3142">        return mBiasFx;</span>
    }

    /**
     * Gets estimated bias of x coordinate of accelerometer sensed specific force.
     *
     * @return bias of x coordinate of sensed specific force.
     */
    public Acceleration getBiasFxAsAcceleration() {
<span class="fc" id="L3151">        return new Acceleration(mBiasFx, AccelerationUnit.METERS_PER_SQUARED_SECOND);</span>
    }

    /**
     * Gets estimated bias of x coordinate of accelerometer sensed specific force.
     *
     * @param result instance where bias of x coordinate of sensed specific force
     *               will be stored.
     */
    public void getBiasFxAsAcceleration(final Acceleration result) {
<span class="fc" id="L3161">        result.setValue(mBiasFx);</span>
<span class="fc" id="L3162">        result.setUnit(AccelerationUnit.METERS_PER_SQUARED_SECOND);</span>
<span class="fc" id="L3163">    }</span>

    /**
     * Gets estimated bias of x coordinate of accelerometer sensed specific force
     * expressed in meters per squared second (m/s^2).
     *
     * @return bias of y coordinate of sensed specific force.
     */
    public double getBiasFy() {
<span class="fc" id="L3172">        return mBiasFy;</span>
    }

    /**
     * Gets estimated bias of y coordinate of accelerometer sensed specific force.
     *
     * @return bias of y coordinate of sensed specific force.
     */
    public Acceleration getBiasFyAsAcceleration() {
<span class="fc" id="L3181">        return new Acceleration(mBiasFy, AccelerationUnit.METERS_PER_SQUARED_SECOND);</span>
    }

    /**
     * Gets estimated bias of y coordinate of accelerometer sensed specific force.
     *
     * @param result instance where bias of y coordinate of sensed specific force
     *               will be stored.
     */
    public void getBiasFyAsAcceleration(final Acceleration result) {
<span class="fc" id="L3191">        result.setValue(mBiasFy);</span>
<span class="fc" id="L3192">        result.setUnit(AccelerationUnit.METERS_PER_SQUARED_SECOND);</span>
<span class="fc" id="L3193">    }</span>

    /**
     * Gets estimated bias of z coordinate of accelerometer sensed specific force
     * expressed in meters per squared second (m/s^2).
     *
     * @return bias of z coordinate of sensed specific force.
     */
    public double getBiasFz() {
<span class="fc" id="L3202">        return mBiasFz;</span>
    }

    /**
     * Gets estimated bias of z coordinate of accelerometer sensed specific force.
     *
     * @return bias of z coordinate of sensed specific force.
     */
    public Acceleration getBiasFzAsAcceleration() {
<span class="fc" id="L3211">        return new Acceleration(mBiasFz, AccelerationUnit.METERS_PER_SQUARED_SECOND);</span>
    }

    /**
     * Gets estimated bias of z coordinate of accelerometer sensed specific force.
     *
     * @param result instance where bias of z coordinate of sensed specific force
     *               will be stored.
     */
    public void getBiasFzAsAcceleration(final Acceleration result) {
<span class="fc" id="L3221">        result.setValue(mBiasFz);</span>
<span class="fc" id="L3222">        result.setUnit(AccelerationUnit.METERS_PER_SQUARED_SECOND);</span>
<span class="fc" id="L3223">    }</span>

    /**
     * Gets estimated bias of x coordinate of gyroscope sensed angular rate
     * expressed in radians per second (rad/s).
     *
     * @return bias of x coordinate of sensed angular rate.
     */
    public double getBiasAngularRateX() {
<span class="fc" id="L3232">        return mBiasAngularRateX;</span>
    }

    /**
     * Gets estimated bias of x coordinate of gyroscope sensed angular rate.
     *
     * @return bias of x coordinate of sensed angular rate.
     */
    public AngularSpeed getBiasAngularRateXAsAngularSpeed() {
<span class="fc" id="L3241">        return new AngularSpeed(mBiasAngularRateX,</span>
                AngularSpeedUnit.RADIANS_PER_SECOND);
    }

    /**
     * Gets estimated bias of x coordinate of gyroscope sensed angular rate.
     *
     * @param result instance where bias of x coordinate of sensed angular rate
     *               will be stored.
     */
    public void getBiasAngularRateXAsAngularSpeed(final AngularSpeed result) {
<span class="fc" id="L3252">        result.setValue(mBiasAngularRateX);</span>
<span class="fc" id="L3253">        result.setUnit(AngularSpeedUnit.RADIANS_PER_SECOND);</span>
<span class="fc" id="L3254">    }</span>

    /**
     * Gets estimated bias of y coordinate of gyroscope sensed angular rate
     * expressed in radians per second (rad/s).
     *
     * @return bias of y coordinate of sensed angular rate.
     */
    public double getBiasAngularRateY() {
<span class="fc" id="L3263">        return mBiasAngularRateY;</span>
    }

    /**
     * Gets estimated bias of y coordinate of gyroscope sensed angular rate.
     *
     * @return bias of y coordinate of sensed angular rate.
     */
    public AngularSpeed getBiasAngularRateYAsAngularSpeed() {
<span class="fc" id="L3272">        return new AngularSpeed(mBiasAngularRateY,</span>
                AngularSpeedUnit.RADIANS_PER_SECOND);
    }

    /**
     * Gets estimated bias of y coordinate of gyroscope sensed angular rate.
     *
     * @param result instance where bias of y coordinate of sensed angular rate
     *               will be stored.
     */
    public void getBiasAngularRateYAsAngularSpeed(final AngularSpeed result) {
<span class="fc" id="L3283">        result.setValue(mBiasAngularRateY);</span>
<span class="fc" id="L3284">        result.setUnit(AngularSpeedUnit.RADIANS_PER_SECOND);</span>
<span class="fc" id="L3285">    }</span>

    /**
     * Gets estimated bias of z coordinate of gyroscope sensed angular rate
     * expressed in radians per second (rad/s).
     *
     * @return bias of z coordinate of sensed angular rate.
     */
    public double getBiasAngularRateZ() {
<span class="fc" id="L3294">        return mBiasAngularRateZ;</span>
    }

    /**
     * Gets estimated bias of z coordinate of gyroscope sensed angular rate.
     *
     * @return bias of z coordinate of sensed angular rate.
     */
    public AngularSpeed getBiasAngularRateZAsAngularSpeed() {
<span class="fc" id="L3303">        return new AngularSpeed(mBiasAngularRateZ,</span>
                AngularSpeedUnit.RADIANS_PER_SECOND);
    }

    /**
     * Gets estimated bias of z coordinate of gyroscope sensed angular rate.
     *
     * @param result instance where bias of z coordinate of sensed angular rate
     *               will be stored.
     */
    public void getBiasAngularRateZAsAngularSpeed(final AngularSpeed result) {
<span class="fc" id="L3314">        result.setValue(mBiasAngularRateZ);</span>
<span class="fc" id="L3315">        result.setUnit(AngularSpeedUnit.RADIANS_PER_SECOND);</span>
<span class="fc" id="L3316">    }</span>

    /**
     * Gets body kinematics containing estimated bias values for accelerometer
     * and gyroscope.
     *
     * @return body kinematics containing estimated bias values.
     */
    public BodyKinematics getBiasesAsBodyKinematics() {
<span class="fc" id="L3325">        final BodyKinematics result = new BodyKinematics();</span>
<span class="fc" id="L3326">        getBiasesAsBodyKinematics(result);</span>
<span class="fc" id="L3327">        return result;</span>
    }

    /**
     * Gets body kinematics containing estimated bias values for accelerometer
     * and gyroscope.
     *
     * @param result instance where body kinematics containing estimated bias
     *               values will be stored.
     */
    public void getBiasesAsBodyKinematics(final BodyKinematics result) {
<span class="fc" id="L3338">        result.setSpecificForceCoordinates(mBiasFx, mBiasFy, mBiasFz);</span>
<span class="fc" id="L3339">        result.setAngularRateCoordinates(</span>
                mBiasAngularRateX, mBiasAngularRateY, mBiasAngularRateZ);
<span class="fc" id="L3341">    }</span>

    /**
     * Gets estimated variance of x coordinate of accelerometer sensed specific
     * force expressed in (m^2/s^4).
     *
     * @return estimated variance of x coordinate of sensed specific force.
     */
    public double getVarianceFx() {
<span class="fc" id="L3350">        return mVarianceFx;</span>
    }

    /**
     * Gets estimated variance of y coordinate of accelerometer sensed specific
     * force expressed in (m^2/s^4).
     *
     * @return estimated variance of y coordinate of sensed specific force.
     */
    public double getVarianceFy() {
<span class="fc" id="L3360">        return mVarianceFy;</span>
    }

    /**
     * Gets estimated variance of z coordinate of accelerometer sensed specific
     * force expressed in (m^2/s^4).
     *
     * @return estimated variance of z coordinate of sensed specific force.
     */
    public double getVarianceFz() {
<span class="fc" id="L3370">        return mVarianceFz;</span>
    }

    /**
     * Gets estimated variance of x coordinate of gyroscope sensed angular rate
     * expressed in (rad^2/s^2).
     *
     * @return estimated variance of x coordinate of sensed angular rate.
     */
    public double getVarianceAngularRateX() {
<span class="fc" id="L3380">        return mVarianceAngularRateX;</span>
    }

    /**
     * Gets estimated variance of y coordinate of gyroscope sensed angular rate
     * expressed in (rad^2/s^2).
     *
     * @return estimated variance of y coordinate of sensed angular rate.
     */
    public double getVarianceAngularRateY() {
<span class="fc" id="L3390">        return mVarianceAngularRateY;</span>
    }

    /**
     * Gets estimated variance of z coordinate of gyroscope sensed angular rate
     * expressed in (rad^2/s^2).
     *
     * @return estimated variance of z coordinate of sensed angular rate.
     */
    public double getVarianceAngularRateZ() {
<span class="fc" id="L3400">        return mVarianceAngularRateZ;</span>
    }

    /**
     * Gets estimated standard deviation of x coordinate of accelerometer
     * sensed specific force expressed in (m/s^2).
     *
     * @return estimated standard deviation of x coordinate of sensed specific force.
     */
    public double getStandardDeviationFx() {
<span class="fc" id="L3410">        return Math.sqrt(mVarianceFx);</span>
    }

    /**
     * Gets estimated standard deviation of x coordinate of accelerometer
     * sensed specific force.
     *
     * @return estimated standard deviation of x coordinate of sensed specific force.
     */
    public Acceleration getStandardDeviationFxAsAcceleration() {
<span class="fc" id="L3420">        return new Acceleration(getStandardDeviationFx(),</span>
                AccelerationUnit.METERS_PER_SQUARED_SECOND);
    }

    /**
     * Gets estimated standard deviation of x coordinate of accelerometer
     * sensed specific force.
     *
     * @param result instance where estimated standard deviation of x coordinate
     *               of sensed specific force will be stored.
     */
    public void getStandardDeviationFxAsAcceleration(final Acceleration result) {
<span class="fc" id="L3432">        result.setValue(getStandardDeviationFx());</span>
<span class="fc" id="L3433">        result.setUnit(AccelerationUnit.METERS_PER_SQUARED_SECOND);</span>
<span class="fc" id="L3434">    }</span>

    /**
     * Gets estimated standard deviation of y coordinate of accelerometer
     * sensed specific force expressed in (m/s^2).
     *
     * @return estimated standard deviation of y coordinate of sensed specific
     * force.
     */
    public double getStandardDeviationFy() {
<span class="fc" id="L3444">        return Math.sqrt(mVarianceFy);</span>
    }

    /**
     * Gets estimated standard deviation of y coordinate of accelerometer
     * sensed specific force.
     *
     * @return estimated standard deviation of y coordinate of sensed specific
     * force.
     */
    public Acceleration getStandardDeviationFyAsAcceleration() {
<span class="fc" id="L3455">        return new Acceleration(getStandardDeviationFy(),</span>
                AccelerationUnit.METERS_PER_SQUARED_SECOND);
    }

    /**
     * Gets estimated standard deviation of y coordinate of accelerometer
     * sensed specific force.
     *
     * @param result instance where estimated standard deviation of y coordinate
     *               of sensed specific force will be stored.
     */
    public void getStandardDeviationFyAsAcceleration(final Acceleration result) {
<span class="fc" id="L3467">        result.setValue(getStandardDeviationFy());</span>
<span class="fc" id="L3468">        result.setUnit(AccelerationUnit.METERS_PER_SQUARED_SECOND);</span>
<span class="fc" id="L3469">    }</span>

    /**
     * Gets estimated standard deviation of z coordinate of accelerometer
     * sensed specific force expressed in (m/s^2).
     *
     * @return estimated standard deviation of z coordinate of sensed specific
     * force.
     */
    public double getStandardDeviationFz() {
<span class="fc" id="L3479">        return Math.sqrt(mVarianceFz);</span>
    }

    /**
     * Gets estimated standard deviation of z coordinate of accelerometer
     * sensed specific force.
     *
     * @return estimated standard deviation of z coordinate of sensed specific
     * force.
     */
    public Acceleration getStandardDeviationFzAsAcceleration() {
<span class="fc" id="L3490">        return new Acceleration(getStandardDeviationFz(),</span>
                AccelerationUnit.METERS_PER_SQUARED_SECOND);
    }

    /**
     * Gets estimated standard deviation of z coordinate of accelerometer
     * sensed specific force.
     *
     * @param result instance where estimated standard deviation of z coordinate
     *               of sensed specific force will be stored.
     */
    public void getStandardDeviationFzAsAcceleration(final Acceleration result) {
<span class="fc" id="L3502">        result.setValue(getStandardDeviationFz());</span>
<span class="fc" id="L3503">        result.setUnit(AccelerationUnit.METERS_PER_SQUARED_SECOND);</span>
<span class="fc" id="L3504">    }</span>

    /**
     * Gets average of estimated standard deviation of accelerometer sensed specific
     * force for all coordinates expressed in meters per squared second (m/s^2).
     *
     * @return average of estimated standard deviation of accelerometer.
     */
    public double getAverageAccelerometerStandardDeviation() {
<span class="fc" id="L3513">        return (getStandardDeviationFx() + getStandardDeviationFy()</span>
<span class="fc" id="L3514">                + getStandardDeviationFz()) / 3.0;</span>
    }

    /**
     * Gets average of estimated standard deviation of accelerometer sensed specific
     * force for all coordinates.
     *
     * @return average of estimated standard deviation of accelerometer.
     */
    public Acceleration getAverageAccelerometerStandardDeviationAsAcceleration() {
<span class="fc" id="L3524">        return new Acceleration(getAverageAccelerometerStandardDeviation(),</span>
                AccelerationUnit.METERS_PER_SQUARED_SECOND);
    }

    /**
     * Gets average of estimated standard deviation of accelerometer sensed specific
     * force for all coordinates.
     *
     * @param result instance where result data will be copied to.
     */
    public void getAverageAccelerometerStandardDeviationAsAcceleration(
            final Acceleration result) {
<span class="fc" id="L3536">        result.setValue(getAverageAccelerometerStandardDeviation());</span>
<span class="fc" id="L3537">        result.setUnit(AccelerationUnit.METERS_PER_SQUARED_SECOND);</span>
<span class="fc" id="L3538">    }</span>

    /**
     * Gets estimated standard deviation of x coordinate of gyroscope sensed angular
     * rate expressed in (rad/s).
     *
     * @return estimated standard deviaton of x coordinate of sensed angular rate.
     */
    public double getStandardDeviationAngularRateX() {
<span class="fc" id="L3547">        return Math.sqrt(mVarianceAngularRateX);</span>
    }

    /**
     * Gets estimated standard deviation of x coordinate of gyroscope sensed angular
     * rate.
     *
     * @return estimated standard deviation of x coordinate of sensed angular rate.
     */
    public AngularSpeed getStandardDeviationAngularRateXAsAngularSpeed() {
<span class="fc" id="L3557">        return new AngularSpeed(getStandardDeviationAngularRateX(),</span>
                AngularSpeedUnit.RADIANS_PER_SECOND);
    }

    /**
     * Gets estimated standard deviation of x coordinate of gyroscope sensed angular
     * rate.
     *
     * @param result instance where estimated standard deviation of x coordinate of
     *               sensed angular rate will be stored.
     */
    public void getStandardDeviationAngularRateXAsAngularSpeed(
            final AngularSpeed result) {
<span class="fc" id="L3570">        result.setValue(getStandardDeviationAngularRateX());</span>
<span class="fc" id="L3571">        result.setUnit(AngularSpeedUnit.RADIANS_PER_SECOND);</span>
<span class="fc" id="L3572">    }</span>

    /**
     * Gets estimated standard deviation of y coordinate of gyroscope sensed angular
     * rate expressed in (rad/s).
     *
     * @return estimated standard deviation of y coordinate of sensed angular rate.
     */
    public double getStandardDeviationAngularRateY() {
<span class="fc" id="L3581">        return Math.sqrt(mVarianceAngularRateY);</span>
    }

    /**
     * Gets estimated standard deviation of y coordinate of gyroscope sensed angular
     * rate.
     *
     * @return estimated standard deviation of y coordinate of sensed angular rate.
     */
    public AngularSpeed getStandardDeviationAngularRateYAsAngularSpeed() {
<span class="fc" id="L3591">        return new AngularSpeed(getStandardDeviationAngularRateY(),</span>
                AngularSpeedUnit.RADIANS_PER_SECOND);
    }

    /**
     * Gets estimated standard deviation of y coordinate of gyroscope sensed angular
     * rate.
     *
     * @param result instance where estimated standard deviation of y coordinate of
     *               sensed angular rate will be stored.
     */
    public void getStandardDeviationAngularRateYAsAngularSpeed(
            final AngularSpeed result) {
<span class="fc" id="L3604">        result.setValue(getStandardDeviationAngularRateY());</span>
<span class="fc" id="L3605">        result.setUnit(AngularSpeedUnit.RADIANS_PER_SECOND);</span>
<span class="fc" id="L3606">    }</span>

    /**
     * Gets estimated standard deviation of z coordinate of gyroscope sensed angular
     * rate expressed in (rad/s).
     *
     * @return estimated standard deviation of z coordinate of sensed angular rate.
     */
    public double getStandardDeviationAngularRateZ() {
<span class="fc" id="L3615">        return Math.sqrt(mVarianceAngularRateZ);</span>
    }

    /**
     * Gets estimated standard deviation of z coordinate of gyroscope sensed angular
     * rate.
     *
     * @return estimated standard deviation of z coordinate of sensed angular rate.
     */
    public AngularSpeed getStandardDeviationAngularRateZAsAngularSpeed() {
<span class="fc" id="L3625">        return new AngularSpeed(getStandardDeviationAngularRateZ(),</span>
                AngularSpeedUnit.RADIANS_PER_SECOND);
    }

    /**
     * Gets estimated standard deviation of z coordinate of gyroscope sensed angular
     * rate.
     *
     * @param result instance where estimated standard deviation of z coordinate of
     *               sensed angular rate will be stored.
     */
    public void getStandardDeviationAngularRateZAsAngularSpeed(
            final AngularSpeed result) {
<span class="fc" id="L3638">        result.setValue(getStandardDeviationAngularRateZ());</span>
<span class="fc" id="L3639">        result.setUnit(AngularSpeedUnit.RADIANS_PER_SECOND);</span>
<span class="fc" id="L3640">    }</span>

    /**
     * Gets average of estimated standard deviation of gyroscope sensed angular rate
     * for all coordinates expressed in radians per second (rad/s).
     *
     * @return average of estimated standard deviation of gyroscope.
     */
    public double getAverageGyroscopeStandardDeviation() {
<span class="fc" id="L3649">        return (getStandardDeviationAngularRateX() + getStandardDeviationAngularRateY()</span>
<span class="fc" id="L3650">                + getStandardDeviationAngularRateZ()) / 3.0;</span>
    }

    /**
     * Gets average of estimated standard deviation of gyroscope sensed angular rate
     * for all coordinates.
     *
     * @return average of estimated standard deviation of gyroscope.
     */
    public AngularSpeed getAverageGyroscopeStandardDeviationAsAngularSpeed() {
<span class="fc" id="L3660">        return new AngularSpeed(getAverageGyroscopeStandardDeviation(),</span>
                AngularSpeedUnit.RADIANS_PER_SECOND);
    }

    /**
     * Gets average of estimated standard deviation of gyroscope sensed angular rate
     * for all coordinates.
     *
     * @param result instance where result data will be copied to.
     */
    public void getAverageGyroscopeStandardDeviationAsAngularSpeed(final AngularSpeed result) {
<span class="fc" id="L3671">        result.setValue(getAverageGyroscopeStandardDeviation());</span>
<span class="fc" id="L3672">        result.setUnit(AngularSpeedUnit.RADIANS_PER_SECOND);</span>
<span class="fc" id="L3673">    }</span>

    /**
     * Gets estimated standard deviations of accelerometer and gyroscope components
     * as a body kinematics instance.
     *
     * @return a body kinematics instance containing standard deviation values.
     */
    public BodyKinematics getStandardDeviationsAsBodyKinematics() {
<span class="fc" id="L3682">        return new BodyKinematics(getStandardDeviationFx(),</span>
<span class="fc" id="L3683">                getStandardDeviationFy(),</span>
<span class="fc" id="L3684">                getStandardDeviationFz(),</span>
<span class="fc" id="L3685">                getStandardDeviationAngularRateX(),</span>
<span class="fc" id="L3686">                getStandardDeviationAngularRateY(),</span>
<span class="fc" id="L3687">                getStandardDeviationAngularRateZ());</span>
    }

    /**
     * Gets estimated standard deviations of accelerometer and gyroscope components
     * as a body kinematics instance.
     *
     * @param result instance where data will be stored.
     */
    public void getStandardDeviationsAsBodyKinematics(final BodyKinematics result) {
<span class="fc" id="L3697">        result.setSpecificForceCoordinates(getStandardDeviationFx(),</span>
<span class="fc" id="L3698">                getStandardDeviationFy(), getStandardDeviationFz());</span>
<span class="fc" id="L3699">        result.setAngularRateCoordinates(getStandardDeviationAngularRateX(),</span>
<span class="fc" id="L3700">                getStandardDeviationAngularRateY(),</span>
<span class="fc" id="L3701">                getStandardDeviationAngularRateZ());</span>
<span class="fc" id="L3702">    }</span>

    /**
     * Gets accelerometer noise PSD (Power Spectral Density) on x axis expressed
     * in (m^2 * s^-3).
     *
     * @return accelerometer noise PSD on x axis.
     */
    public double getPSDFx() {
<span class="fc" id="L3711">        return mVarianceFx * mTimeInterval;</span>
    }

    /**
     * Gets accelerometer noise PSD (Power Spectral Density) on y axis expressed
     * in (m^2 * s^-3).
     *
     * @return accelerometer noise PSD on y axis.
     */
    public double getPSDFy() {
<span class="fc" id="L3721">        return mVarianceFy * mTimeInterval;</span>
    }

    /**
     * Gets accelerometer noise PSD (Power Spectral Density) on z axis expressed
     * in (m^2 * s^-3).
     *
     * @return accelerometer noise PSD on z axis.
     */
    public double getPSDFz() {
<span class="fc" id="L3731">        return mVarianceFz * mTimeInterval;</span>
    }

    /**
     * Gets gyroscope noise PSD (Power Spectral Density) on x axis expressed
     * in (rad^2/s).
     *
     * @return gyroscope noise PSD on x axis.
     */
    public double getPSDAngularRateX() {
<span class="fc" id="L3741">        return mVarianceAngularRateX * mTimeInterval;</span>
    }

    /**
     * Gets gyroscope noise PSD (Power Spectral Density) on y axis expressed
     * in (rad^2/s).
     *
     * @return gyroscope noise PSD on y axis.
     */
    public double getPSDAngularRateY() {
<span class="fc" id="L3751">        return mVarianceAngularRateY * mTimeInterval;</span>
    }

    /**
     * Gets gyroscope noise PSD (Power Spectral Density) on z axis expressed
     * in (rad^2/s).
     *
     * @return gyroscope noise PSD on z axis.
     */
    public double getPSDAngularRateZ() {
<span class="fc" id="L3761">        return mVarianceAngularRateZ * mTimeInterval;</span>
    }

    /**
     * Gets accelerometer noise root PSD (Power Spectral Density) on x axis
     * expressed in (m * s^-1.5).
     *
     * @return accelerometer noise root PSD on x axis.
     */
    public double getRootPSDFx() {
<span class="fc" id="L3771">        return Math.sqrt(getPSDFx());</span>
    }

    /**
     * Gets accelerometer noise root PSD (Power Spectral Density) on y axis
     * expressed in (m * s^-1.5).
     *
     * @return accelerometer noise root PSD on y axis.
     */
    public double getRootPSDFy() {
<span class="fc" id="L3781">        return Math.sqrt(getPSDFy());</span>
    }

    /**
     * Gets accelerometer noise root PSD (Power Spectral Density) on z axis
     * expressed in (m * s^-1.5).
     *
     * @return accelerometer noise root PSD on z axis.
     */
    public double getRootPSDFz() {
<span class="fc" id="L3791">        return Math.sqrt(getPSDFz());</span>
    }

    /**
     * Gets gyroscope noise root PSD (Power Spectral Density) on x axis
     * expressed in (rad * s^-0.5).
     *
     * @return gyroscope noise root PSD on x axis.
     */
    public double getRootPSDAngularRateX() {
<span class="fc" id="L3801">        return Math.sqrt(getPSDAngularRateX());</span>
    }

    /**
     * Gets gyroscope noise root PSD (Power Spectral Density) on y axis
     * expressed in (rad * s^-0.5).
     *
     * @return gyroscope noise root PSD on y axis.
     */
    public double getRootPSDAngularRateY() {
<span class="fc" id="L3811">        return Math.sqrt(getPSDAngularRateY());</span>
    }

    /**
     * Gets gyroscope noise root PSD (Power Spectral Density) on z axis
     * expressed in (rad * s^-0.5).
     *
     * @return gyroscope noise root PSD on z axis.
     */
    public double getRootPSDAngularRateZ() {
<span class="fc" id="L3821">        return Math.sqrt(getPSDAngularRateZ());</span>
    }

    /**
     * Gets average accelerometer noise PSD (Power Spectral Density) among
     * x,y,z components expressed as (m^2/s^3).
     *
     * @return average accelerometer noise PSD.
     */
    public double getAccelerometerNoisePSD() {
<span class="fc" id="L3831">        return (getPSDFx() + getPSDFy() + getPSDFz()) / 3.0;</span>
    }

    /**
     * Gets average accelerometer noise root PSD (Power Spectral Density) among
     * x,y,z components expressed as (m * s^-1.5).
     *
     * @return average accelerometer noise root PSD.
     */
    public double getAccelerometerNoiseRootPSD() {
<span class="fc" id="L3841">        return Math.sqrt(getAccelerometerNoisePSD());</span>
    }

    /**
     * Gets average gyroscope noise PSD (Power Spectral Density) among
     * x,y,z components expressed in (rad^2/s).
     *
     * @return average gyroscope noise PSD.
     */
    public double getGyroNoisePSD() {
<span class="fc" id="L3851">        return (getPSDAngularRateX() + getPSDAngularRateY() + getPSDAngularRateZ())</span>
                / 3.0;
    }

    /**
     * Gets average gyroscope noise root PSD (Power Spectral Density) among
     * x,y,z components expressed in (rad * s^-0.5).
     *
     * @return average gyroscope noise root PSD.
     */
    public double getGyroNoiseRootPSD() {
<span class="fc" id="L3862">        return Math.sqrt(getGyroNoisePSD());</span>
    }

    /**
     * Gets estimated bias of accelerometer sensed specific force
     * expressed in meters per squared second (m/s^2) as a 3x1 matrix column vector.
     *
     * @return estimated bias of accelerometer sensed specific force.
     */
    public Matrix getAccelerometerBias() {
        Matrix result;
        try {
<span class="fc" id="L3874">            result = new Matrix(BodyKinematics.COMPONENTS, 1);</span>
<span class="fc" id="L3875">            getAccelerometerBias(result);</span>
<span class="nc" id="L3876">        } catch (final WrongSizeException ignore) {</span>
            // never happens
<span class="nc" id="L3878">            result = null;</span>
<span class="fc" id="L3879">        }</span>

<span class="fc" id="L3881">        return result;</span>
    }

    /**
     * Gets estimated bias of accelerometer sensed specific force
     * expressed in meters per squared second (m/s^2) as a 3x1 matrix column vector.
     *
     * @param result instance where data will be copied to. Must be 3x1.
     * @throws IllegalArgumentException if provided result matrix is not 3x1.
     */
    public void getAccelerometerBias(final Matrix result) {
<span class="fc bfc" id="L3892" title="All 2 branches covered.">        if (result.getRows() != BodyKinematics.COMPONENTS</span>
<span class="fc bfc" id="L3893" title="All 2 branches covered.">                || result.getColumns() != 1) {</span>
<span class="fc" id="L3894">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L3897">        result.setElementAtIndex(0, mBiasFx);</span>
<span class="fc" id="L3898">        result.setElementAtIndex(1, mBiasFy);</span>
<span class="fc" id="L3899">        result.setElementAtIndex(2, mBiasFz);</span>
<span class="fc" id="L3900">    }</span>

    /**
     * Gets estimated bias of gyroscope sensed angular rates
     * expressed in radians per second (rad/s) as a 3x1 matrix column vector.
     *
     * @return estimated bias of gyroscope sensed angular rates.
     */
    public Matrix getGyroBias() {
        Matrix result;
        try {
<span class="fc" id="L3911">            result = new Matrix(BodyKinematics.COMPONENTS, 1);</span>
<span class="fc" id="L3912">            getGyroBias(result);</span>
<span class="nc" id="L3913">        } catch (final WrongSizeException ignore) {</span>
            // never happens
<span class="nc" id="L3915">            result = null;</span>
<span class="fc" id="L3916">        }</span>

<span class="fc" id="L3918">        return result;</span>
    }

    /**
     * Gets estimated bias of gyroscope sensed angular rates
     * expressed in radians per second (rad/s) as a 3x1 matrix column vector.
     *
     * @param result instance where data will be copied to. Must be 3x1.
     * @throws IllegalArgumentException if provided result matrix is not 3x1.
     */
    public void getGyroBias(final Matrix result) {
<span class="fc bfc" id="L3929" title="All 2 branches covered.">        if (result.getRows() != BodyKinematics.COMPONENTS</span>
<span class="fc bfc" id="L3930" title="All 2 branches covered.">                || result.getColumns() != 1) {</span>
<span class="fc" id="L3931">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L3934">        result.setElementAtIndex(0, mBiasAngularRateX);</span>
<span class="fc" id="L3935">        result.setElementAtIndex(1, mBiasAngularRateY);</span>
<span class="fc" id="L3936">        result.setElementAtIndex(2, mBiasAngularRateZ);</span>
<span class="fc" id="L3937">    }</span>

    /**
     * Gets number of samples that have been processed so far.
     *
     * @return number of samples that have been processed so far.
     */
    public int getNumberOfProcessedSamples() {
<span class="fc" id="L3945">        return mNumberOfProcessedSamples;</span>
    }

    /**
     * Indicates whether estimator is currently running or not.
     *
     * @return true if estimator is running, false otherwise.
     */
    public boolean isRunning() {
<span class="fc" id="L3954">        return mRunning;</span>
    }

    /**
     * Indicates whether estimator has finished the estimation.
     *
     * @return true if estimator has finished, false otherwise.
     */
    public boolean isFinished() {
<span class="fc bfc" id="L3963" title="All 2 branches covered.">        return mNumberOfProcessedSamples == mTotalSamples;</span>
    }

    /**
     * Gets theoretically expected body kinematics for provided body position and
     * orientation, and provided time interval, assuming that body remains at the
     * same position (zero velocity).
     * When body remains static, sensed specific force and angular rates will remain
     * constant due to gravity and Earth rotation.
     *
     * @return expected body kinematics.
     */
    public BodyKinematics getExpectedKinematics() {
<span class="fc" id="L3976">        return new BodyKinematics(mExpectedKinematics);</span>
    }

    /**
     * Gets theoretically expected body kinematics for provided body position and
     * orientation, and provided time interval, assuming that body remains at the
     * same position (zero velocity).
     * When body remains static, sensed specific force and angular rates will remain
     * constant due to gravity and Earth rotation.
     *
     * @param result instance where expected body kinematics will be stored.
     */
    public void getExpectedKinematics(final BodyKinematics result) {
<span class="fc" id="L3989">        mExpectedKinematics.copyTo(result);</span>
<span class="fc" id="L3990">    }</span>

    /**
     * Adds a sample of body kinematics (accelerometer + gyroscope readings) obtained
     * from an IMU.
     * If estimator is already finished, provided sample will be ignored.
     *
     * @param kinematics kinematics instance to be added and processed.
     * @return true if provided kinematics instance has been processed, false if it has
     * been ignored.
     * @throws LockedException if estimator is currently running.
     */
    public boolean addBodyKinematics(final BodyKinematics kinematics)
            throws LockedException {

<span class="fc bfc" id="L4005" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L4006">            throw new LockedException();</span>
        }

<span class="pc bpc" id="L4009" title="1 of 2 branches missed.">        if (isFinished()) {</span>
<span class="nc" id="L4010">            return true;</span>
        }

<span class="fc" id="L4013">        mRunning = true;</span>

<span class="pc bpc" id="L4015" title="1 of 4 branches missed.">        if (mLastBodyKinematics == null &amp;&amp; mListener != null) {</span>
<span class="fc" id="L4016">            mListener.onStart(this);</span>
        }

<span class="fc" id="L4019">        final double fx = kinematics.getFx();</span>
<span class="fc" id="L4020">        final double fy = kinematics.getFy();</span>
<span class="fc" id="L4021">        final double fz = kinematics.getFz();</span>
<span class="fc" id="L4022">        final double angularRateX = kinematics.getAngularRateX();</span>
<span class="fc" id="L4023">        final double angularRateY = kinematics.getAngularRateY();</span>
<span class="fc" id="L4024">        final double angularRateZ = kinematics.getAngularRateZ();</span>

<span class="fc" id="L4026">        final double expectedFx = mExpectedKinematics.getFx();</span>
<span class="fc" id="L4027">        final double expectedFy = mExpectedKinematics.getFy();</span>
<span class="fc" id="L4028">        final double expectedFz = mExpectedKinematics.getFz();</span>
<span class="fc" id="L4029">        final double expectedAngularRateX = mExpectedKinematics.getAngularRateX();</span>
<span class="fc" id="L4030">        final double expectedAngularRateY = mExpectedKinematics.getAngularRateY();</span>
<span class="fc" id="L4031">        final double expectedAngularRateZ = mExpectedKinematics.getAngularRateZ();</span>

<span class="fc" id="L4033">        final double diffFx = fx - expectedFx;</span>
<span class="fc" id="L4034">        final double diffFy = fy - expectedFy;</span>
<span class="fc" id="L4035">        final double diffFz = fz - expectedFz;</span>
<span class="fc" id="L4036">        final double diffAngularRateX = angularRateX - expectedAngularRateX;</span>
<span class="fc" id="L4037">        final double diffAngularRateY = angularRateY - expectedAngularRateY;</span>
<span class="fc" id="L4038">        final double diffAngularRateZ = angularRateZ - expectedAngularRateZ;</span>

        // compute biases
<span class="fc" id="L4041">        mBiasFx = mBiasFx * (double) mNumberOfProcessedSamples</span>
                / (double) mNumberOfProcessedSamplesPlusOne
                + diffFx / (double) mNumberOfProcessedSamplesPlusOne;
<span class="fc" id="L4044">        mBiasFy = mBiasFy * (double) mNumberOfProcessedSamples</span>
                / (double) mNumberOfProcessedSamplesPlusOne
                + diffFy / (double) mNumberOfProcessedSamplesPlusOne;
<span class="fc" id="L4047">        mBiasFz = mBiasFz * (double) mNumberOfProcessedSamples</span>
                / (double) mNumberOfProcessedSamplesPlusOne
                + diffFz / (double) mNumberOfProcessedSamplesPlusOne;

<span class="fc" id="L4051">        mBiasAngularRateX = mBiasAngularRateX * (double) mNumberOfProcessedSamples</span>
                / (double) mNumberOfProcessedSamplesPlusOne
                + diffAngularRateX / (double) mNumberOfProcessedSamplesPlusOne;
<span class="fc" id="L4054">        mBiasAngularRateY = mBiasAngularRateY * (double) mNumberOfProcessedSamples</span>
                / (double) mNumberOfProcessedSamplesPlusOne
                + diffAngularRateY / (double) mNumberOfProcessedSamplesPlusOne;
<span class="fc" id="L4057">        mBiasAngularRateZ = mBiasAngularRateZ * (double) mNumberOfProcessedSamples</span>
                / (double) mNumberOfProcessedSamplesPlusOne
                + diffAngularRateZ / (double) mNumberOfProcessedSamplesPlusOne;

        // compute variances
<span class="fc" id="L4062">        final double diffBiasFx = diffFx - mBiasFx;</span>
<span class="fc" id="L4063">        final double diffBiasFy = diffFy - mBiasFy;</span>
<span class="fc" id="L4064">        final double diffBiasFz = diffFz - mBiasFz;</span>
<span class="fc" id="L4065">        final double diffBiasAngularRateX = diffAngularRateX - mBiasAngularRateX;</span>
<span class="fc" id="L4066">        final double diffBiasAngularRateY = diffAngularRateY - mBiasAngularRateY;</span>
<span class="fc" id="L4067">        final double diffBiasAngularRateZ = diffAngularRateZ - mBiasAngularRateZ;</span>

<span class="fc" id="L4069">        final double diffBiasFx2 = diffBiasFx * diffBiasFx;</span>
<span class="fc" id="L4070">        final double diffBiasFy2 = diffBiasFy * diffBiasFy;</span>
<span class="fc" id="L4071">        final double diffBiasFz2 = diffBiasFz * diffBiasFz;</span>
<span class="fc" id="L4072">        final double diffBiasAngularRateX2 =</span>
                diffBiasAngularRateX * diffBiasAngularRateX;
<span class="fc" id="L4074">        final double diffBiasAngularRateY2 =</span>
                diffBiasAngularRateY * diffBiasAngularRateY;
<span class="fc" id="L4076">        final double diffBiasAngularRateZ2 =</span>
                diffBiasAngularRateZ * diffBiasAngularRateZ;

<span class="fc" id="L4079">        mVarianceFx = mVarianceFx * (double) mNumberOfProcessedSamples</span>
                / (double) mNumberOfProcessedSamplesPlusOne
                + diffBiasFx2 / (double) mNumberOfProcessedSamplesPlusOne;
<span class="fc" id="L4082">        mVarianceFy = mVarianceFy * (double) mNumberOfProcessedSamples</span>
                / (double) mNumberOfProcessedSamplesPlusOne
                + diffBiasFy2 / (double) mNumberOfProcessedSamplesPlusOne;
<span class="fc" id="L4085">        mVarianceFz = mVarianceFz * (double) mNumberOfProcessedSamples</span>
                / (double) mNumberOfProcessedSamplesPlusOne
                + diffBiasFz2 / (double) mNumberOfProcessedSamplesPlusOne;

<span class="fc" id="L4089">        mVarianceAngularRateX = mVarianceAngularRateX</span>
                * (double) mNumberOfProcessedSamples
                / (double) mNumberOfProcessedSamplesPlusOne
                + diffBiasAngularRateX2 / (double) mNumberOfProcessedSamplesPlusOne;
<span class="fc" id="L4093">        mVarianceAngularRateY = mVarianceAngularRateY</span>
                * (double) mNumberOfProcessedSamples
                / (double) mNumberOfProcessedSamplesPlusOne
                + diffBiasAngularRateY2 / (double) mNumberOfProcessedSamplesPlusOne;
<span class="fc" id="L4097">        mVarianceAngularRateZ = mVarianceAngularRateZ</span>
                * (double) mNumberOfProcessedSamples
                / (double) mNumberOfProcessedSamplesPlusOne
                + diffBiasAngularRateZ2 / (double) mNumberOfProcessedSamplesPlusOne;

<span class="fc" id="L4102">        mLastBodyKinematics = kinematics;</span>

<span class="fc" id="L4104">        mNumberOfProcessedSamples++;</span>
<span class="fc" id="L4105">        mNumberOfProcessedSamplesPlusOne++;</span>

<span class="pc bpc" id="L4107" title="1 of 2 branches missed.">        if (mListener != null) {</span>
<span class="fc" id="L4108">            mListener.onBodyKinematicsAdded(this);</span>
        }

<span class="fc" id="L4111">        mRunning = false;</span>

<span class="pc bpc" id="L4113" title="1 of 4 branches missed.">        if (isFinished() &amp;&amp; mListener != null) {</span>
<span class="fc" id="L4114">            mListener.onFinish(this);</span>
        }

<span class="fc" id="L4117">        return true;</span>
    }

    /**
     * Resets current estimator.
     *
     * @return true if estimator was successfully reset, false if no reset was needed.
     * @throws LockedException if estimator is currently running.
     */
    public boolean reset() throws LockedException {
<span class="fc bfc" id="L4127" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L4128">            throw new LockedException();</span>
        }

<span class="pc bpc" id="L4131" title="1 of 2 branches missed.">        if (mNumberOfProcessedSamples == 0) {</span>
<span class="nc" id="L4132">            return false;</span>
        }

<span class="fc" id="L4135">        mRunning = true;</span>
<span class="fc" id="L4136">        mLastBodyKinematics = null;</span>
<span class="fc" id="L4137">        mBiasFx = 0.0;</span>
<span class="fc" id="L4138">        mBiasFy = 0.0;</span>
<span class="fc" id="L4139">        mBiasFz = 0.0;</span>
<span class="fc" id="L4140">        mBiasAngularRateX = 0.0;</span>
<span class="fc" id="L4141">        mBiasAngularRateY = 0.0;</span>
<span class="fc" id="L4142">        mBiasAngularRateZ = 0.0;</span>
<span class="fc" id="L4143">        mVarianceFx = 0.0;</span>
<span class="fc" id="L4144">        mVarianceFy = 0.0;</span>
<span class="fc" id="L4145">        mVarianceFz = 0.0;</span>
<span class="fc" id="L4146">        mVarianceAngularRateX = 0.0;</span>
<span class="fc" id="L4147">        mVarianceAngularRateY = 0.0;</span>
<span class="fc" id="L4148">        mVarianceAngularRateZ = 0.0;</span>
<span class="fc" id="L4149">        mNumberOfProcessedSamples = 0;</span>
<span class="fc" id="L4150">        mNumberOfProcessedSamplesPlusOne = 1;</span>

<span class="pc bpc" id="L4152" title="1 of 2 branches missed.">        if (mListener != null) {</span>
<span class="fc" id="L4153">            mListener.onReset(this);</span>
        }

<span class="fc" id="L4156">        mRunning = false;</span>

<span class="fc" id="L4158">        return true;</span>
    }

    /**
     * Converts provided time instance to seconds.
     *
     * @param time instance to be converted.
     * @return obtained conversion in seconds.
     */
    private static double convertTime(final Time time) {
<span class="fc" id="L4168">        return TimeConverter.convert(time.getValue().doubleValue(),</span>
<span class="fc" id="L4169">                time.getUnit(), TimeUnit.SECOND);</span>
    }

    /**
     * Rebuilds expected theoretical kinematics for provided body position
     * and orientation and provided time interval, assuming that body
     * remains at the same position (zero velocity).
     * When body remains static, sensed specific force and angular rates will remain
     * constant due to gravity and Earth rotation.
     */
    private void rebuildExpectedKinematics() {
<span class="pc bpc" id="L4180" title="1 of 2 branches missed.">        if (mFrame == null) {</span>
<span class="nc" id="L4181">            return;</span>
        }
<span class="fc bfc" id="L4183" title="All 2 branches covered.">        if (mExpectedKinematics == null) {</span>
<span class="fc" id="L4184">            mExpectedKinematics = new BodyKinematics();</span>
        }

<span class="fc" id="L4187">        final CoordinateTransformation ecefC = getEcefC();</span>
<span class="fc" id="L4188">        final double x = mFrame.getX();</span>
<span class="fc" id="L4189">        final double y = mFrame.getY();</span>
<span class="fc" id="L4190">        final double z = mFrame.getZ();</span>
<span class="fc" id="L4191">        ECEFKinematicsEstimator.estimateKinematics(mTimeInterval, ecefC, ecefC,</span>
                0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
                x, y, z, mExpectedKinematics);
<span class="fc" id="L4194">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>