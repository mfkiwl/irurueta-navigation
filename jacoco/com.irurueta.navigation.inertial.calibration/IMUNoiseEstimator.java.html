<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>IMUNoiseEstimator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.irurueta:irurueta-navigation</a> &gt; <a href="index.source.html" class="el_package">com.irurueta.navigation.inertial.calibration</a> &gt; <span class="el_source">IMUNoiseEstimator.java</span></div><h1>IMUNoiseEstimator.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2020 Alberto Irurueta Carro (alberto@irurueta.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.irurueta.navigation.inertial.calibration;

import com.irurueta.navigation.LockedException;
import com.irurueta.navigation.inertial.BodyKinematics;
import com.irurueta.units.Acceleration;
import com.irurueta.units.AccelerationUnit;
import com.irurueta.units.AngularSpeed;
import com.irurueta.units.AngularSpeedUnit;
import com.irurueta.units.Time;
import com.irurueta.units.TimeConverter;
import com.irurueta.units.TimeUnit;

/**
 * This class estimates IMU accelerometer and gyroscope noise variances and PSD's (Power
 * Spectral Densities) along with their average values.
 * This estimator must be used when the body where the IMU is attached remains static
 * on the same position with zero velocity while capturing data.
 * To compute PSD's, this estimator assumes that IMU samples are obtained at a constant
 * provided rate equal to {@link #getTimeInterval()} seconds.
 * If not available, IMU sampling rate average can be estimated using
 * {@link IMUTimeIntervalEstimator}.
 * This estimator does NOT require the knowledge of current location and body
 * orientation.
 * This estimator is very similar to {@link IMUBiasEstimator} except that location and
 * orientation is not required, hence noise levels can be correctly determined, but
 * average levels do not necessarily math IMU bias values.
 */
public class IMUNoiseEstimator {
    /**
     * Default total samples to be processed.
     */
    public static final int DEFAULT_TOTAL_SAMPLES = 100000;

    /**
     * Default time interval between body kinematics samples expressed in seconds (s).
     */
    public static final double DEFAULT_TIME_INTERVAL_SECONDS = 0.02;

    /**
     * Total samples to be processed to finish estimation.
     */
<span class="fc" id="L57">    private int mTotalSamples = DEFAULT_TOTAL_SAMPLES;</span>

    /**
     * Time interval expressed in seconds (s) between body kinematics samples.
     */
<span class="fc" id="L62">    private double mTimeInterval = DEFAULT_TIME_INTERVAL_SECONDS;</span>

    /**
     * Listener to handle events raised by this estimator.
     */
    private IMUNoiseEstimatorListener mListener;

    /**
     * Last provided body kinematics values.
     */
    private BodyKinematics mLastBodyKinematics;

    /**
     * Contains estimated average of x coordinate of accelerometer sensed specific force
     * expressed in meters per squared second (m/s^2).
     */
    private double mAvgFx;

    /**
     * Contains estimated average of y coordinate of accelerometer sensed specific force
     * expressed in meters per squared second (m/s^2).
     */
    private double mAvgFy;

    /**
     * Contains estimated average of z coordinate of accelerometer sensed specific force
     * expressed in meters per squared second (m/s^2).
     */
    private double mAvgFz;

    /**
     * Contains estimated average of x coordinate of gyroscope sensed angular rate
     * expressed in radians per second (rad/s).
     */
    private double mAvgAngularRateX;

    /**
     * Contains estimated average of y coordinate of gyroscope sensed angular rate
     * expressed in radians per second (rad/s).
     */
    private double mAvgAngularRateY;

    /**
     * Contains estimated average of z coordinate of gyroscope sensed angular rate
     * expressed in radians per second (rad/s).
     */
    private double mAvgAngularRateZ;

    /**
     * Contains estimated variance of x coordinate of accelerometer sensed specific
     * force expressed in (m^2/s^4).
     */
    private double mVarianceFx;

    /**
     * Contains estimated variance of y coordinate of accelerometer sensed specific
     * force expressed in (m^2/s^4).
     */
    private double mVarianceFy;

    /**
     * Contains estimated variance of z coordinate of accelerometer sensed specific
     * force expressed in (m^2/s^4).
     */
    private double mVarianceFz;

    /**
     * Contains estimated variance of x coordinate of gyroscope sensed angular rate
     * expressed in (rad^2/s^2).
     */
    private double mVarianceAngularRateX;

    /**
     * Contains estimated variance of y coordinate of gyroscope sensed angular rate
     * expressed in (rad^2/s^2).
     */
    private double mVarianceAngularRateY;

    /**
     * Contains estimated variance of z coordinate of gyroscope sensed angular rate
     * expressed in (rad^2/s^2).
     */
    private double mVarianceAngularRateZ;

    /**
     * Number of processed body kinematics samples.
     */
    private int mNumberOfProcessedSamples;

    /**
     * Number of processed timestamp samples plus one.
     */
<span class="fc" id="L154">    private int mNumberOfProcessedSamplesPlusOne = 1;</span>

    /**
     * Indicates that estimator is running.
     */
    private boolean mRunning;

    /**
     * Constructor.
     */
<span class="fc" id="L164">    public IMUNoiseEstimator() {</span>
<span class="fc" id="L165">    }</span>

    /**
     * Constructor.
     *
     * @param listener listener to handle events raised by this estimator.
     */
<span class="fc" id="L172">    public IMUNoiseEstimator(final IMUNoiseEstimatorListener listener) {</span>
<span class="fc" id="L173">        mListener = listener;</span>
<span class="fc" id="L174">    }</span>

    /**
     * Constructor.
     *
     * @param totalSamples total samples to be processed to finish estimation.
     * @throws IllegalArgumentException if provided total samples is zero or negative.
     */
<span class="fc" id="L182">    public IMUNoiseEstimator(final int totalSamples) {</span>
<span class="fc bfc" id="L183" title="All 2 branches covered.">        if (totalSamples &lt;= 0) {</span>
<span class="fc" id="L184">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L187">        mTotalSamples = totalSamples;</span>
<span class="fc" id="L188">    }</span>

    /**
     * Constructor.
     *
     * @param totalSamples total samples to be processed to finish estimation.
     * @param listener     listener to handle events raised by this estimator.
     * @throws IllegalArgumentException if provided total samples is zero or negative.
     */
    public IMUNoiseEstimator(final int totalSamples,
                             final IMUNoiseEstimatorListener listener) {
<span class="fc" id="L199">        this(totalSamples);</span>
<span class="fc" id="L200">        mListener = listener;</span>
<span class="fc" id="L201">    }</span>

    /**
     * Constructor.
     *
     * @param timeInterval time interval between body kinematics
     *                     (IMU acceleration + gyroscope) samples
     *                     expressed in seconds (s).
     * @throws IllegalArgumentException if provided time interval is negative.
     */
<span class="fc" id="L211">    public IMUNoiseEstimator(final double timeInterval) {</span>
        try {
<span class="fc" id="L213">            setTimeInterval(timeInterval);</span>
<span class="nc" id="L214">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L216">        }</span>
<span class="fc" id="L217">    }</span>

    /**
     * Constructor.
     *
     * @param timeInterval time interval between body kinematics
     *                     (IMU acceleration + gyroscope) samples.
     * @throws IllegalArgumentException if provided time interval is negative.
     */
<span class="fc" id="L226">    public IMUNoiseEstimator(final Time timeInterval) {</span>
        try {
<span class="fc" id="L228">            setTimeInterval(timeInterval);</span>
<span class="nc" id="L229">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L231">        }</span>
<span class="fc" id="L232">    }</span>

    /**
     * Constructor.
     *
     * @param timeInterval time interval between body kinematics
     *                     (IMU acceleration + gyroscope) samples
     *                     expressed in seconds (s).
     * @param listener     listener to handle events raised by this estimator.
     * @throws IllegalArgumentException if provided time interval is negative.
     */
    public IMUNoiseEstimator(final double timeInterval,
                             final IMUNoiseEstimatorListener listener) {
<span class="fc" id="L245">        this(timeInterval);</span>
<span class="fc" id="L246">        mListener = listener;</span>
<span class="fc" id="L247">    }</span>

    /**
     * Constructor.
     *
     * @param timeInterval time interval between body kinematics
     *                     (IMU acceleration + gyroscope) samples.
     * @param listener     listener to handle events raised by this estimator.
     * @throws IllegalArgumentException if provided time interval is negative.
     */
    public IMUNoiseEstimator(final Time timeInterval,
                             final IMUNoiseEstimatorListener listener) {
<span class="fc" id="L259">        this(timeInterval);</span>
<span class="fc" id="L260">        mListener = listener;</span>
<span class="fc" id="L261">    }</span>

    /**
     * Constructor.
     *
     * @param totalSamples total samples to be processed to finish estimation.
     * @param timeInterval time interval between body kinematics (IMU acceleration +
     *                     gyroscope) samples expressed in seconds (s).
     * @throws IllegalArgumentException if provided total samples is zero or negative
     *                                  or if provided time interval is negative.
     */
    public IMUNoiseEstimator(final int totalSamples, final double timeInterval) {
<span class="fc" id="L273">        this(totalSamples);</span>
        try {
<span class="fc" id="L275">            setTimeInterval(timeInterval);</span>
<span class="nc" id="L276">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L278">        }</span>
<span class="fc" id="L279">    }</span>

    /**
     * Constructor.
     *
     * @param totalSamples total samples to be processed to finish estimation.
     * @param timeInterval time interval between body kinematics (IMU acceleration +
     *                     gyroscope) samples.
     * @throws IllegalArgumentException if provided total samples is zero or negative
     *                                  or if provided time interval is negative.
     */
    public IMUNoiseEstimator(final int totalSamples, final Time timeInterval) {
<span class="fc" id="L291">        this(totalSamples);</span>
        try {
<span class="fc" id="L293">            setTimeInterval(timeInterval);</span>
<span class="nc" id="L294">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L296">        }</span>
<span class="fc" id="L297">    }</span>

    /**
     * Constructor.
     *
     * @param totalSamples total samples to be processed to finish estimation.
     * @param timeInterval time interval between body kinematics (IMU acceleration +
     *                     gyroscope) samples expressed in seconds (s).
     * @param listener     listener to handle events raised by this estimator.
     * @throws IllegalArgumentException if provided total samples is zero or negative
     *                                  or if provided time interval is negative.
     */
    public IMUNoiseEstimator(final int totalSamples, final double timeInterval,
                             final IMUNoiseEstimatorListener listener) {
<span class="fc" id="L311">        this(totalSamples, timeInterval);</span>
<span class="fc" id="L312">        mListener = listener;</span>
<span class="fc" id="L313">    }</span>

    /**
     * Constructor.
     *
     * @param totalSamples total samples to be processed to finish estimation.
     * @param timeInterval time interval between body kinematics (IMU acceleration +
     *                     gyroscope) samples.
     * @param listener     listener to handle events raised by this estimator.
     * @throws IllegalArgumentException if provided total samples is zero or negative
     *                                  or if provided time interval is negative.
     */
    public IMUNoiseEstimator(final int totalSamples, final Time timeInterval,
                             final IMUNoiseEstimatorListener listener) {
<span class="fc" id="L327">        this(totalSamples, timeInterval);</span>
<span class="fc" id="L328">        mListener = listener;</span>
<span class="fc" id="L329">    }</span>

    /**
     * Gets total samples to be processed to finish estimation.
     *
     * @return total samples to be processed to finish estimation.
     */
    public int getTotalSamples() {
<span class="fc" id="L337">        return mTotalSamples;</span>
    }

    /**
     * Sets total samples to be processed to finish estimation.
     *
     * @param totalSamples total samples to be processed to finish estimation.
     * @throws LockedException if estimator is currently running.
     */
    public void setTotalSamples(final int totalSamples) throws LockedException {
<span class="fc bfc" id="L347" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L348">            throw new LockedException();</span>
        }

<span class="fc bfc" id="L351" title="All 2 branches covered.">        if (totalSamples &lt;= 0) {</span>
<span class="fc" id="L352">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L355">        mTotalSamples = totalSamples;</span>
<span class="fc" id="L356">    }</span>

    /**
     * Gets time interval between body kinematics (IMU acceleration + gyroscope)
     * samples expressed in seconds (s).
     *
     * @return time interval between body kinematics samples.
     */
    public double getTimeInterval() {
<span class="fc" id="L365">        return mTimeInterval;</span>
    }

    /**
     * Sets time interval between body kinematics (IMU acceleration + gyroscope)
     * samples expressed in seconds (s).
     *
     * @param timeInterval time interval between body kinematics samples.
     * @throws LockedException if estimator is currently running.
     */
    public void setTimeInterval(final double timeInterval) throws LockedException {
<span class="fc bfc" id="L376" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L377">            throw new LockedException();</span>
        }

<span class="fc bfc" id="L380" title="All 2 branches covered.">        if (timeInterval &lt; 0.0) {</span>
<span class="fc" id="L381">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L384">        mTimeInterval = timeInterval;</span>
<span class="fc" id="L385">    }</span>

    /**
     * Gets time interval between body kinematics (IMU acceleration + gyroscope)
     * samples.
     *
     * @return time interval between body kinematics samples.
     */
    public Time getTimeIntervalAsTime() {
<span class="fc" id="L394">        return new Time(mTimeInterval, TimeUnit.SECOND);</span>
    }

    /**
     * Gets time interval between body kinematics (IMU acceleration + gyroscope)
     * samples.
     *
     * @param result instance where time interval will be stored.
     */
    public void getTimeIntervalAsTime(final Time result) {
<span class="fc" id="L404">        result.setValue(mTimeInterval);</span>
<span class="fc" id="L405">        result.setUnit(TimeUnit.SECOND);</span>
<span class="fc" id="L406">    }</span>

    /**
     * Sets time interval between body kinematics (IMU acceleration + gyroscope)
     * samples.
     *
     * @param timeInterval time interval between body kinematics samples.
     * @throws LockedException if estimator is currently running.
     */
    public void setTimeInterval(final Time timeInterval) throws LockedException {
<span class="fc" id="L416">        setTimeInterval(TimeConverter.convert(timeInterval.getValue().doubleValue(),</span>
<span class="fc" id="L417">                timeInterval.getUnit(), TimeUnit.SECOND));</span>
<span class="fc" id="L418">    }</span>

    /**
     * Gets listener to handle events raised by this estimator.
     *
     * @return listener to handle events raised by this estimator.
     */
    public IMUNoiseEstimatorListener getListener() {
<span class="fc" id="L426">        return mListener;</span>
    }

    /**
     * Sets listener to handle events raised by this estimator.
     *
     * @param listener listener to handle events raised by this estimator.
     * @throws LockedException if this estimator is running.
     */
    public void setListener(final IMUNoiseEstimatorListener listener)
            throws LockedException {
<span class="fc bfc" id="L437" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L438">            throw new LockedException();</span>
        }

<span class="fc" id="L441">        mListener = listener;</span>
<span class="fc" id="L442">    }</span>

    /**
     * Gets last provided body kinematics values or null if not available.
     *
     * @return last provided body kinematics values or null.
     */
    public BodyKinematics getLastBodyKinematics() {
<span class="fc bfc" id="L450" title="All 2 branches covered.">        return mLastBodyKinematics != null ?</span>
<span class="fc" id="L451">                new BodyKinematics(mLastBodyKinematics) : null;</span>
    }

    /**
     * Gets last provided body kinematics values.
     *
     * @param result instance where last provided body kinematics will be stored.
     * @return true if result instance was updated, false otherwise.
     */
    public boolean getLastBodyKinematics(final BodyKinematics result) {
<span class="fc bfc" id="L461" title="All 2 branches covered.">        if (mLastBodyKinematics != null) {</span>
<span class="fc" id="L462">            mLastBodyKinematics.copyTo(result);</span>
<span class="fc" id="L463">            return true;</span>
        } else {
<span class="fc" id="L465">            return false;</span>
        }
    }

    /**
     * Gets estimated average of x coordinate of accelerometer sensed specific force
     * expressed in meters per squared second (m/s^2).
     * This value will depend of body location and orientation, hence it should never
     * be used as a calibration bias.
     *
     * @return average of x coordinate of sensed specific force.
     */
    public double getAvgFx() {
<span class="fc" id="L478">        return mAvgFx;</span>
    }

    /**
     * Gets estimated average of x coordinate of accelerometer sensed specific force.
     * This value will depend of body location and orientation, hence it should never
     * be used as a calibration bias.
     *
     * @return average of x coordinate of sensed specific force.
     */
    public Acceleration getAvgFxAsAcceleration() {
<span class="fc" id="L489">        return new Acceleration(mAvgFx, AccelerationUnit.METERS_PER_SQUARED_SECOND);</span>
    }

    /**
     * Gets estimated average of x coordinate of accelerometer sensed specific force.
     * This value will depend of body location and orientation, hence it should never
     * be used as a calibration bias.
     *
     * @param result instance where average of x coordinate of sensed specific force
     *               will be stored.
     */
    public void getAvgFxAsAcceleration(final Acceleration result) {
<span class="fc" id="L501">        result.setValue(mAvgFx);</span>
<span class="fc" id="L502">        result.setUnit(AccelerationUnit.METERS_PER_SQUARED_SECOND);</span>
<span class="fc" id="L503">    }</span>

    /**
     * Gets estimated average of y coordinate of accelerometer sensed specific force
     * expressed in meters per squared second (m/s^2).
     * This value will depend of body location and orientation, hence it should never
     * be used as a calibration bias.
     *
     * @return average of y coordinate of sensed specific force.
     */
    public double getAvgFy() {
<span class="fc" id="L514">        return mAvgFy;</span>
    }

    /**
     * Gets estimated average of y coordinate of accelerometer sensed specific force.
     * This value will depend of body location and orientation, hence it should never
     * be used as a calibration bias.
     *
     * @return average of y coordinate of sensed specific force.
     */
    public Acceleration getAvgFyAsAcceleration() {
<span class="fc" id="L525">        return new Acceleration(mAvgFy, AccelerationUnit.METERS_PER_SQUARED_SECOND);</span>
    }

    /**
     * Gets estimated average of y coordinate of accelerometer sensed specific force.
     * This value will depend of body location and orientation, hence it should never
     * be used as a calibration bias.
     *
     * @param result instance where average of y coordinate of sensed specific force
     *               will be stored.
     */
    public void getAvgFyAsAcceleration(final Acceleration result) {
<span class="fc" id="L537">        result.setValue(mAvgFy);</span>
<span class="fc" id="L538">        result.setUnit(AccelerationUnit.METERS_PER_SQUARED_SECOND);</span>
<span class="fc" id="L539">    }</span>

    /**
     * Gets estimated average of z coordinate of accelerometer sensed specific force
     * expressed in meters per squared second (m/s^2).
     * This value will depend of body location and orientation, hence it should never
     * be used as a calibration bias.
     *
     * @return average of z coordinate of sensed specific force.
     */
    public double getAvgFz() {
<span class="fc" id="L550">        return mAvgFz;</span>
    }

    /**
     * Gets estimated average of z coordinate of accelerometer sensed specific force.
     * This value will depend of body location and orientation, hence it should never
     * be used as a calibration bias.
     *
     * @return average of z coordinate of sensed specific force.
     */
    public Acceleration getAvgFzAsAcceleration() {
<span class="fc" id="L561">        return new Acceleration(mAvgFz, AccelerationUnit.METERS_PER_SQUARED_SECOND);</span>
    }

    /**
     * Gets estimated average of z coordinate of accelerometer sensed specific force.
     * This value will depend of body location and orientation, hence it should never
     * be used as a calibration bias.
     *
     * @param result instance where average of z coordinate of sensed specific force
     *               will be stored.
     */
    public void getAvgFzAsAcceleration(final Acceleration result) {
<span class="fc" id="L573">        result.setValue(mAvgFz);</span>
<span class="fc" id="L574">        result.setUnit(AccelerationUnit.METERS_PER_SQUARED_SECOND);</span>
<span class="fc" id="L575">    }</span>

    /**
     * Gets estimated average of x coordinate of gyroscope sensed angular rate
     * expressed in radians per second (rad/s).
     * This value will depend of body location and orientation, hence it should never
     * be used as a calibration bias.
     *
     * @return average of x coordinate of sensed angular rate.
     */
    public double getAvgAngularRateX() {
<span class="fc" id="L586">        return mAvgAngularRateX;</span>
    }

    /**
     * Gets estimated average of x coordinate of gyroscope sensed angular rate.
     * This value will depend of body location and orientation, hence it should never
     * be used as a calibration bias.
     *
     * @return average of x coordinate of sensed angular rate.
     */
    public AngularSpeed getAvgAngularRateXAsAngularSpeed() {
<span class="fc" id="L597">        return new AngularSpeed(mAvgAngularRateX, AngularSpeedUnit.RADIANS_PER_SECOND);</span>
    }

    /**
     * Gets estimated average of x coordinate of gyroscope sensed angular rate.
     * This value will depend of body location and orientation, hence it should never
     * be used as a calibration bias.
     *
     * @param result instance where average of x coordinate of sensed angular rate
     *               will be stored.
     */
    public void getAvgAngularRateXAsAngularSpeed(final AngularSpeed result) {
<span class="fc" id="L609">        result.setValue(mAvgAngularRateX);</span>
<span class="fc" id="L610">        result.setUnit(AngularSpeedUnit.RADIANS_PER_SECOND);</span>
<span class="fc" id="L611">    }</span>

    /**
     * Gets estimated average of y coordinate of gyroscope sensed angular rate
     * expressed in radians per second (rad/s).
     * This value will depend of body location and orientation, hence it should never
     * be used as a calibration bias.
     *
     * @return average of y coordinate of sensed angular rate.
     */
    public double getAvgAngularRateY() {
<span class="fc" id="L622">        return mAvgAngularRateY;</span>
    }

    /**
     * Gets estimated average of y coordinate of gyroscope sensed angular rate.
     * This value will depend of body location and orientation, hence it should never
     * be used as a calibration bias.
     *
     * @return average of y coordinate of sensed angular rate.
     */
    public AngularSpeed getAvgAngularRateYAsAngularSpeed() {
<span class="fc" id="L633">        return new AngularSpeed(mAvgAngularRateY, AngularSpeedUnit.RADIANS_PER_SECOND);</span>
    }

    /**
     * Gets estimated average of y coordinate of gyroscope sensed angular rate.
     * This value will depend of body location and orientation, hence it should never
     * be used as a calibration bias.
     *
     * @param result instance where average of y coordinate of sensed angular rate
     *               will be stored.
     */
    public void getAvgAngularRateYAsAngularSpeed(final AngularSpeed result) {
<span class="fc" id="L645">        result.setValue(mAvgAngularRateY);</span>
<span class="fc" id="L646">        result.setUnit(AngularSpeedUnit.RADIANS_PER_SECOND);</span>
<span class="fc" id="L647">    }</span>

    /**
     * Gets estimated average of z coordinate of gyroscope sensed angular rate
     * expressed in radians per second (rad/s).
     * This value will depend of body location and orientation, hence it should never
     * be used as a calibration bias.
     *
     * @return average of z coordinate of sensed angular rate.
     */
    public double getAvgAngularRateZ() {
<span class="fc" id="L658">        return mAvgAngularRateZ;</span>
    }

    /**
     * Gets estimated average of z coordinate of gyroscope sensed angular rate.
     * This value will depend of body location and orientation, hence it should never
     * be used as a calibration bias.
     *
     * @return average of z coordinate of sensed angular rate.
     */
    public AngularSpeed getAvgAngularRateZAsAngularSpeed() {
<span class="fc" id="L669">        return new AngularSpeed(mAvgAngularRateZ, AngularSpeedUnit.RADIANS_PER_SECOND);</span>
    }

    /**
     * Gets estimated average of z coordinate of gyroscope sensed angular rate.
     * This value will depend of body location and orientation, hence it should never
     * be used as a calibration bias.
     *
     * @param result instance where average of z coordinate of sensed angular rate
     *               will be stored.
     */
    public void getAvgAngularRateZAsAngularSpeed(final AngularSpeed result) {
<span class="fc" id="L681">        result.setValue(mAvgAngularRateZ);</span>
<span class="fc" id="L682">        result.setUnit(AngularSpeedUnit.RADIANS_PER_SECOND);</span>
<span class="fc" id="L683">    }</span>

    /**
     * Gets estimated average of body kinematics.
     *
     * @return estimated average of body kinematics.
     */
    public BodyKinematics getAvgBodyKinematics() {
<span class="fc" id="L691">        final BodyKinematics result = new BodyKinematics();</span>
<span class="fc" id="L692">        getAvgBodyKinematics(result);</span>
<span class="fc" id="L693">        return result;</span>
    }

    /**
     * Gets estimated average of body kinematics.
     *
     * @param result instance where estimated average of body kinematics will be stored.
     */
    public void getAvgBodyKinematics(final BodyKinematics result) {
<span class="fc" id="L702">        result.setSpecificForceCoordinates(mAvgFx, mAvgFy, mAvgFz);</span>
<span class="fc" id="L703">        result.setAngularRateCoordinates(</span>
                mAvgAngularRateX, mAvgAngularRateY, mAvgAngularRateZ);
<span class="fc" id="L705">    }</span>

    /**
     * Gets estimated variance of x coordinate of accelerometer sensed specific
     * force expressed in (m^2/s^4).
     *
     * @return estimated variance of x coordinate of sensed specific force.
     */
    public double getVarianceFx() {
<span class="fc" id="L714">        return mVarianceFx;</span>
    }

    /**
     * Gets estimated variance of y coordinate of accelerometer sensed specific
     * force expressed in (m^2/s^4).
     *
     * @return estimated variance of y coordinate of sensed specific force.
     */
    public double getVarianceFy() {
<span class="fc" id="L724">        return mVarianceFy;</span>
    }

    /**
     * Gets estimated variance of z coordinate of accelerometer sensed specific
     * force expressed in (m^2/s^4).
     *
     * @return estimated variance of z coordinate of sensed specific force.
     */
    public double getVarianceFz() {
<span class="fc" id="L734">        return mVarianceFz;</span>
    }

    /**
     * Gets estimated variance of x coordinate of gyroscope sensed angular rate
     * expressed in (rad^2/s^2).
     *
     * @return estimated variance of x coordinate of sensed angular rate.
     */
    public double getVarianceAngularRateX() {
<span class="fc" id="L744">        return mVarianceAngularRateX;</span>
    }

    /**
     * Gets estimated variance of y coordinate of gyroscope sensed angular rate
     * expressed in (rad^2/s^2).
     *
     * @return estimated variance of y coordinate of sensed angular rate.
     */
    public double getVarianceAngularRateY() {
<span class="fc" id="L754">        return mVarianceAngularRateY;</span>
    }

    /**
     * Gets estimated variance of z coordinate of gyroscope sensed angular rate
     * expressed in (rad^2/s^2).
     *
     * @return estimated variance of z coordinate of sensed angular rate.
     */
    public double getVarianceAngularRateZ() {
<span class="fc" id="L764">        return mVarianceAngularRateZ;</span>
    }

    /**
     * Gets estimated standard deviation of x coordinate of accelerometer
     * sensed specific force expressed in (m/s^2).
     *
     * @return estimated standard deviation of x coordinate of sensed specific force.
     */
    public double getStandardDeviationFx() {
<span class="fc" id="L774">        return Math.sqrt(mVarianceFx);</span>
    }

    /**
     * Gets estimated standard deviation of x coordinate of accelerometer
     * sensed specific force.
     *
     * @return estimated standard deviation of x coordinate of sensed specific force.
     */
    public Acceleration getStandardDeviationFxAsAcceleration() {
<span class="fc" id="L784">        return new Acceleration(getStandardDeviationFx(),</span>
                AccelerationUnit.METERS_PER_SQUARED_SECOND);
    }

    /**
     * Gets estimated standard deviation of x coordinate of accelerometer
     * sensed specific force.
     *
     * @param result instance where estimated standard deviation of x coordinate
     *               of sensed specific force will be stored.
     */
    public void getStandardDeviationFxAsAcceleration(final Acceleration result) {
<span class="fc" id="L796">        result.setValue(getStandardDeviationFx());</span>
<span class="fc" id="L797">        result.setUnit(AccelerationUnit.METERS_PER_SQUARED_SECOND);</span>
<span class="fc" id="L798">    }</span>

    /**
     * Gets estimated standard deviation of y coordinate of accelerometer
     * sensed specific force expressed in (m/s^2).
     *
     * @return estimated standard deviation of y coordinate of sensed specific
     * force.
     */
    public double getStandardDeviationFy() {
<span class="fc" id="L808">        return Math.sqrt(mVarianceFy);</span>
    }

    /**
     * Gets estimated standard deviation of y coordinate of accelerometer
     * sensed specific force.
     *
     * @return estimated standard deviation of y coordinate of sensed specific
     * force.
     */
    public Acceleration getStandardDeviationFyAsAcceleration() {
<span class="fc" id="L819">        return new Acceleration(getStandardDeviationFy(),</span>
                AccelerationUnit.METERS_PER_SQUARED_SECOND);
    }

    /**
     * Gets estimated standard deviation of y coordinate of accelerometer
     * sensed specific force.
     *
     * @param result instance where estimated standard deviation of y coordinate
     *               of sensed specific force will be stored.
     */
    public void getStandardDeviationFyAsAcceleration(final Acceleration result) {
<span class="fc" id="L831">        result.setValue(getStandardDeviationFy());</span>
<span class="fc" id="L832">        result.setUnit(AccelerationUnit.METERS_PER_SQUARED_SECOND);</span>
<span class="fc" id="L833">    }</span>

    /**
     * Gets estimated standard deviation of z coordinate of accelerometer
     * sensed specific force expressed in (m/s^2).
     *
     * @return estimated standard deviation of z coordinate of sensed specific
     * force.
     */
    public double getStandardDeviationFz() {
<span class="fc" id="L843">        return Math.sqrt(mVarianceFz);</span>
    }

    /**
     * Gets estimated standard deviation of z coordinate of accelerometer
     * sensed specific force.
     *
     * @return estimated standard deviation of z coordinate of sensed specific
     * force.
     */
    public Acceleration getStandardDeviationFzAsAcceleration() {
<span class="fc" id="L854">        return new Acceleration(getStandardDeviationFz(),</span>
                AccelerationUnit.METERS_PER_SQUARED_SECOND);
    }

    /**
     * Gets estimated standard deviation of z coordinate of accelerometer
     * sensed specific force.
     *
     * @param result instance where estimated standard deviation of z coordinate
     *               of sensed specific force will be stored.
     */
    public void getStandardDeviationFzAsAcceleration(final Acceleration result) {
<span class="fc" id="L866">        result.setValue(getStandardDeviationFz());</span>
<span class="fc" id="L867">        result.setUnit(AccelerationUnit.METERS_PER_SQUARED_SECOND);</span>
<span class="fc" id="L868">    }</span>

    /**
     * Gets estimated standard deviation of x coordinate of gyroscope sensed angular
     * rate expressed in (rad/s).
     *
     * @return estimated standard deviation of x coordinate of sensed angular rate.
     */
    public double getStandardDeviationAngularRateX() {
<span class="fc" id="L877">        return Math.sqrt(mVarianceAngularRateX);</span>
    }

    /**
     * Gets estimated standard deviation of x coordinate of gyroscope sensed angular
     * rate.
     *
     * @return estimated standard deviation of x coordinate of sensed angular rate.
     */
    public AngularSpeed getStandardDeviationAngularRateXAsAngularSpeed() {
<span class="fc" id="L887">        return new AngularSpeed(getStandardDeviationAngularRateX(),</span>
                AngularSpeedUnit.RADIANS_PER_SECOND);
    }

    /**
     * Gets estimated standard deviation of x coordinate of gyroscope sensed angular
     * rate.
     *
     * @param result instance where estimated standard deviation of x coordinate of
     *               sensed angular rate will be stored.
     */
    public void getStandardDeviationAngularRateXAsAngularSpeed(
            final AngularSpeed result) {
<span class="fc" id="L900">        result.setValue(getStandardDeviationAngularRateX());</span>
<span class="fc" id="L901">        result.setUnit(AngularSpeedUnit.RADIANS_PER_SECOND);</span>
<span class="fc" id="L902">    }</span>

    /**
     * Gets estimated standard deviation of y coordinate of gyroscope sensed angular
     * rate expressed in (rad/s).
     *
     * @return estimated standard deviation of y coordinate of sensed angular rate.
     */
    public double getStandardDeviationAngularRateY() {
<span class="fc" id="L911">        return Math.sqrt(mVarianceAngularRateY);</span>
    }

    /**
     * Gets estimated standard deviation of y coordinate of gyroscope sensed angular
     * rate.
     *
     * @return estimated standard deviation of y coordinate of sensed angular rate.
     */
    public AngularSpeed getStandardDeviationAngularRateYAsAngularSpeed() {
<span class="fc" id="L921">        return new AngularSpeed(getStandardDeviationAngularRateY(),</span>
                AngularSpeedUnit.RADIANS_PER_SECOND);
    }

    /**
     * Gets estimated standard deviation of y coordinate of gyroscope sensed angular
     * rate.
     *
     * @param result instance where estimated standard deviation of y coordinate of
     *               sensed angular rate will be stored.
     */
    public void getStandardDeviationAngularRateYAsAngularSpeed(
            final AngularSpeed result) {
<span class="fc" id="L934">        result.setValue(getStandardDeviationAngularRateY());</span>
<span class="fc" id="L935">        result.setUnit(AngularSpeedUnit.RADIANS_PER_SECOND);</span>
<span class="fc" id="L936">    }</span>

    /**
     * Gets estimated standard deviation of z coordinate of gyroscope sensed angular
     * rate expressed in (rad/s).
     *
     * @return estimated standard deviation of z coordinate of sensed angular rate.
     */
    public double getStandardDeviationAngularRateZ() {
<span class="fc" id="L945">        return Math.sqrt(mVarianceAngularRateZ);</span>
    }

    /**
     * Gets estimated standard deviation of z coordinate of gyroscope sensed angular
     * rate.
     *
     * @return estimated standard deviation of z coordinate of sensed angular rate.
     */
    public AngularSpeed getStandardDeviationAngularRateZAsAngularSpeed() {
<span class="fc" id="L955">        return new AngularSpeed(getStandardDeviationAngularRateZ(),</span>
                AngularSpeedUnit.RADIANS_PER_SECOND);
    }

    /**
     * Gets estimated standard deviation of z coordinate of gyroscope sensed angular
     * rate.
     *
     * @param result instance where estimated standard deviation of z coordinate of
     *               sensed angular rate will be stored.
     */
    public void getStandardDeviationAngularRateZAsAngularSpeed(
            final AngularSpeed result) {
<span class="fc" id="L968">        result.setValue(getStandardDeviationAngularRateZ());</span>
<span class="fc" id="L969">        result.setUnit(AngularSpeedUnit.RADIANS_PER_SECOND);</span>
<span class="fc" id="L970">    }</span>

    /**
     * Gets estimated standard deviations of accelerometer and gyroscope components
     * as a body kinematics instance.
     *
     * @return a body kinematics instance containing standard deviation values.
     */
    public BodyKinematics getStandardDeviationsAsBodyKinematics() {
<span class="fc" id="L979">        return new BodyKinematics(getStandardDeviationFx(),</span>
<span class="fc" id="L980">                getStandardDeviationFy(),</span>
<span class="fc" id="L981">                getStandardDeviationFz(),</span>
<span class="fc" id="L982">                getStandardDeviationAngularRateX(),</span>
<span class="fc" id="L983">                getStandardDeviationAngularRateY(),</span>
<span class="fc" id="L984">                getStandardDeviationAngularRateZ());</span>
    }

    /**
     * Gets estimated standard deviations of accelerometer and gyroscope components
     * as a body kinematics instance.
     *
     * @param result instance where data will be stored.
     */
    public void getStandardDeviationsAsBodyKinematics(final BodyKinematics result) {
<span class="fc" id="L994">        result.setSpecificForceCoordinates(getStandardDeviationFx(),</span>
<span class="fc" id="L995">                getStandardDeviationFy(), getStandardDeviationFz());</span>
<span class="fc" id="L996">        result.setAngularRateCoordinates(getStandardDeviationAngularRateX(),</span>
<span class="fc" id="L997">                getStandardDeviationAngularRateY(),</span>
<span class="fc" id="L998">                getStandardDeviationAngularRateZ());</span>
<span class="fc" id="L999">    }</span>

    /**
     * Gets accelerometer noise PSD (Power Spectral Density) on x axis expressed
     * in (m^2 * s^-3).
     *
     * @return accelerometer noise PSD on x axis.
     */
    public double getPSDFx() {
<span class="fc" id="L1008">        return mVarianceFx * mTimeInterval;</span>
    }

    /**
     * Gets accelerometer noise PSD (Power Spectral Density) on y axis expressed
     * in (m^2 * s^-3).
     *
     * @return accelerometer noise PSD on y axis.
     */
    public double getPSDFy() {
<span class="fc" id="L1018">        return mVarianceFy * mTimeInterval;</span>
    }

    /**
     * Gets accelerometer noise PSD (Power Spectral Density) on z axis expressed
     * in (m^2 * s^-3).
     *
     * @return accelerometer noise PSD on z axis.
     */
    public double getPSDFz() {
<span class="fc" id="L1028">        return mVarianceFz * mTimeInterval;</span>
    }

    /**
     * Gets gyroscope noise PSD (Power Spectral Density) on x axis expressed
     * in (rad^2/s).
     *
     * @return gyroscope noise PSD on x axis.
     */
    public double getPSDAngularRateX() {
<span class="fc" id="L1038">        return mVarianceAngularRateX * mTimeInterval;</span>
    }

    /**
     * Gets gyroscope noise PSD (Power Spectral Density) on y axis expressed
     * in (rad^2/s).
     *
     * @return gyroscope noise PSD on y axis.
     */
    public double getPSDAngularRateY() {
<span class="fc" id="L1048">        return mVarianceAngularRateY * mTimeInterval;</span>
    }

    /**
     * Gets gyroscope noise PSD (Power Spectral Density) on z axis expressed
     * in (rad^2/s).
     *
     * @return gyroscope noise PSD on z axis.
     */
    public double getPSDAngularRateZ() {
<span class="fc" id="L1058">        return mVarianceAngularRateZ * mTimeInterval;</span>
    }

    /**
     * Gets accelerometer noise root PSD (Power Spectral Density) on x axis
     * expressed in (m * s^-1.5).
     *
     * @return accelerometer noise root PSD on x axis.
     */
    public double getRootPSDFx() {
<span class="fc" id="L1068">        return Math.sqrt(getPSDFx());</span>
    }

    /**
     * Gets accelerometer noise root PSD (Power Spectral Density) on y axis
     * expressed in (m * s^-1.5).
     *
     * @return accelerometer noise root PSD on y axis.
     */
    public double getRootPSDFy() {
<span class="fc" id="L1078">        return Math.sqrt(getPSDFy());</span>
    }

    /**
     * Gets accelerometer noise root PSD (Power Spectral Density) on z axis
     * expressed in (m * s^-1.5).
     *
     * @return accelerometer noise root PSD on z axis.
     */
    public double getRootPSDFz() {
<span class="fc" id="L1088">        return Math.sqrt(getPSDFz());</span>
    }

    /**
     * Gets gyroscope noise root PSD (Power Spectral Density) on x axis
     * expressed in (rad * s^-0.5).
     *
     * @return gyroscope noise root PSD on x axis.
     */
    public double getRootPSDAngularRateX() {
<span class="fc" id="L1098">        return Math.sqrt(getPSDAngularRateX());</span>
    }

    /**
     * Gets gyroscope noise root PSD (Power Spectral Density) on y axis
     * expressed in (rad * s^-0.5).
     *
     * @return gyroscope noise root PSD on y axis.
     */
    public double getRootPSDAngularRateY() {
<span class="fc" id="L1108">        return Math.sqrt(getPSDAngularRateY());</span>
    }

    /**
     * Gets gyroscope noise root PSD (Power Spectral Density) on z axis
     * expressed in (rad * s^-0.5).
     *
     * @return gyroscope noise root PSD on z axis.
     */
    public double getRootPSDAngularRateZ() {
<span class="fc" id="L1118">        return Math.sqrt(getPSDAngularRateZ());</span>
    }

    /**
     * Gets average accelerometer noise PSD (Power Spectral Density) among
     * x,y,z components expressed as (m^2/s^-3).
     *
     * @return average accelerometer noise PSD.
     */
    public double getAccelerometerNoisePSD() {
<span class="fc" id="L1128">        return (getPSDFx() + getPSDFy() + getPSDFz()) / 3.0;</span>
    }

    /**
     * Gets average accelerometer noise root PSD (Power Spectral Density) among
     * x,y,z components expressed as (m * s^-1.5).
     *
     * @return average accelerometer noise root PSD.
     */
    public double getAccelerometerNoiseRootPSD() {
<span class="fc" id="L1138">        return Math.sqrt(getAccelerometerNoisePSD());</span>
    }

    /**
     * Gets average gyroscope noise PSD (Power Spectral Density) among
     * x,y,z components expressed in (rad^2/s).
     *
     * @return average gyroscope noise PSD.
     */
    public double getGyroNoisePSD() {
<span class="fc" id="L1148">        return (getPSDAngularRateX() + getPSDAngularRateY() + getPSDAngularRateZ())</span>
                / 3.0;
    }

    /**
     * Gets average gyroscope noise root PSD (Power Spectral Density) among
     * x,y,z components expressed in (rad * s^-0.5).
     *
     * @return average gyroscope noise root PSD.
     */
    public double getGyroNoiseRootPSD() {
<span class="fc" id="L1159">        return Math.sqrt(getGyroNoisePSD());</span>
    }

    /**
     * Gets number of samples that have been processed so far.
     *
     * @return number of samples that have been processed so far.
     */
    public int getNumberOfProcessedSamples() {
<span class="fc" id="L1168">        return mNumberOfProcessedSamples;</span>
    }

    /**
     * Indicates whether estimator is currently running or not.
     *
     * @return true if estimator is running, false otherwise.
     */
    public boolean isRunning() {
<span class="fc" id="L1177">        return mRunning;</span>
    }

    /**
     * Indicates whether estimator has finished the estimation.
     *
     * @return true if estimator has finished, false otherwise.
     */
    public boolean isFinished() {
<span class="fc bfc" id="L1186" title="All 2 branches covered.">        return mNumberOfProcessedSamples == mTotalSamples;</span>
    }

    /**
     * Adds a sample of body kinematics (accelerometer + gyroscope readings) obtained
     * from an IMU.
     * If estimator is already finished, provided sample will be ignored.
     *
     * @param kinematics kinematics instance to be added and processed.
     * @return true if provided kinematics instance has been processed, false if it has
     * been ignored.
     * @throws LockedException if estimator is currently running.
     */
    public boolean addBodyKinematics(final BodyKinematics kinematics)
            throws LockedException {

<span class="fc bfc" id="L1202" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L1203">            throw new LockedException();</span>
        }

<span class="pc bpc" id="L1206" title="1 of 2 branches missed.">        if (isFinished()) {</span>
<span class="nc" id="L1207">            return true;</span>
        }

<span class="fc" id="L1210">        mRunning = true;</span>

<span class="pc bpc" id="L1212" title="1 of 4 branches missed.">        if (mLastBodyKinematics == null &amp;&amp; mListener != null) {</span>
<span class="fc" id="L1213">            mListener.onStart(this);</span>
        }

<span class="fc" id="L1216">        final double fx = kinematics.getFx();</span>
<span class="fc" id="L1217">        final double fy = kinematics.getFy();</span>
<span class="fc" id="L1218">        final double fz = kinematics.getFz();</span>
<span class="fc" id="L1219">        final double angularRateX = kinematics.getAngularRateX();</span>
<span class="fc" id="L1220">        final double angularRateY = kinematics.getAngularRateY();</span>
<span class="fc" id="L1221">        final double angularRateZ = kinematics.getAngularRateZ();</span>

        // compute averages
<span class="fc" id="L1224">        mAvgFx = mAvgFx * (double) mNumberOfProcessedSamples</span>
                / (double) mNumberOfProcessedSamplesPlusOne
                + fx / (double) mNumberOfProcessedSamplesPlusOne;
<span class="fc" id="L1227">        mAvgFy = mAvgFy * (double) mNumberOfProcessedSamples</span>
                / (double) mNumberOfProcessedSamplesPlusOne
                + fy / (double) mNumberOfProcessedSamplesPlusOne;
<span class="fc" id="L1230">        mAvgFz = mAvgFz * (double) mNumberOfProcessedSamples</span>
                / (double) mNumberOfProcessedSamplesPlusOne
                + fz / (double) mNumberOfProcessedSamplesPlusOne;

<span class="fc" id="L1234">        mAvgAngularRateX = mAvgAngularRateX * (double) mNumberOfProcessedSamples</span>
                / (double) mNumberOfProcessedSamplesPlusOne
                + angularRateX / (double) mNumberOfProcessedSamplesPlusOne;
<span class="fc" id="L1237">        mAvgAngularRateY = mAvgAngularRateY * (double) mNumberOfProcessedSamples</span>
                / (double) mNumberOfProcessedSamplesPlusOne
                + angularRateY / (double) mNumberOfProcessedSamplesPlusOne;
<span class="fc" id="L1240">        mAvgAngularRateZ = mAvgAngularRateZ * (double) mNumberOfProcessedSamples</span>
                / (double) mNumberOfProcessedSamplesPlusOne
                + angularRateZ / (double) mNumberOfProcessedSamplesPlusOne;

        // compute variances
<span class="fc" id="L1245">        final double diffFx = fx - mAvgFx;</span>
<span class="fc" id="L1246">        final double diffFy = fy - mAvgFy;</span>
<span class="fc" id="L1247">        final double diffFz = fz - mAvgFz;</span>
<span class="fc" id="L1248">        final double diffAngularRateX = angularRateX - mAvgAngularRateX;</span>
<span class="fc" id="L1249">        final double diffAngularRateY = angularRateY - mAvgAngularRateY;</span>
<span class="fc" id="L1250">        final double diffAngularRateZ = angularRateZ - mAvgAngularRateZ;</span>

<span class="fc" id="L1252">        final double diffFx2 = diffFx * diffFx;</span>
<span class="fc" id="L1253">        final double diffFy2 = diffFy * diffFy;</span>
<span class="fc" id="L1254">        final double diffFz2 = diffFz * diffFz;</span>
<span class="fc" id="L1255">        final double diffAngularRateX2 = diffAngularRateX * diffAngularRateX;</span>
<span class="fc" id="L1256">        final double diffAngularRateY2 = diffAngularRateY * diffAngularRateY;</span>
<span class="fc" id="L1257">        final double diffAngularRateZ2 = diffAngularRateZ * diffAngularRateZ;</span>

<span class="fc" id="L1259">        mVarianceFx = mVarianceFx * (double) mNumberOfProcessedSamples</span>
                / (double) mNumberOfProcessedSamplesPlusOne
                + diffFx2 / (double) mNumberOfProcessedSamplesPlusOne;
<span class="fc" id="L1262">        mVarianceFy = mVarianceFy * (double) mNumberOfProcessedSamples</span>
                / (double) mNumberOfProcessedSamplesPlusOne
                + diffFy2 / (double) mNumberOfProcessedSamplesPlusOne;
<span class="fc" id="L1265">        mVarianceFz = mVarianceFz * (double) mNumberOfProcessedSamples</span>
                / (double) mNumberOfProcessedSamplesPlusOne
                + diffFz2 / (double) mNumberOfProcessedSamplesPlusOne;

<span class="fc" id="L1269">        mVarianceAngularRateX = mVarianceAngularRateX</span>
                * (double) mNumberOfProcessedSamples
                / (double) mNumberOfProcessedSamplesPlusOne
                + diffAngularRateX2 / (double) mNumberOfProcessedSamplesPlusOne;
<span class="fc" id="L1273">        mVarianceAngularRateY = mVarianceAngularRateY</span>
                * (double) mNumberOfProcessedSamples
                / (double) mNumberOfProcessedSamplesPlusOne
                + diffAngularRateY2 / (double) mNumberOfProcessedSamplesPlusOne;
<span class="fc" id="L1277">        mVarianceAngularRateZ = mVarianceAngularRateZ</span>
                * (double) mNumberOfProcessedSamples
                / (double) mNumberOfProcessedSamplesPlusOne
                + diffAngularRateZ2 / (double) mNumberOfProcessedSamplesPlusOne;

<span class="fc" id="L1282">        mLastBodyKinematics = kinematics;</span>

<span class="fc" id="L1284">        mNumberOfProcessedSamples++;</span>
<span class="fc" id="L1285">        mNumberOfProcessedSamplesPlusOne++;</span>

<span class="pc bpc" id="L1287" title="1 of 2 branches missed.">        if (mListener != null) {</span>
<span class="fc" id="L1288">            mListener.onBodyKinematicsAdded(this);</span>
        }

<span class="fc" id="L1291">        mRunning = false;</span>

<span class="pc bpc" id="L1293" title="1 of 4 branches missed.">        if (isFinished() &amp;&amp; mListener != null) {</span>
<span class="fc" id="L1294">            mListener.onFinish(this);</span>
        }

<span class="fc" id="L1297">        return true;</span>
    }

    /**
     * Resets current estimator.
     *
     * @return true if estimator was successfully reset, false if no reset was needed.
     * @throws LockedException if estimator is currently running.
     */
    public boolean reset() throws LockedException {
<span class="fc bfc" id="L1307" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L1308">            throw new LockedException();</span>
        }

<span class="pc bpc" id="L1311" title="1 of 2 branches missed.">        if (mNumberOfProcessedSamples == 0) {</span>
<span class="nc" id="L1312">            return false;</span>
        }

<span class="fc" id="L1315">        mRunning = true;</span>
<span class="fc" id="L1316">        mLastBodyKinematics = null;</span>
<span class="fc" id="L1317">        mAvgFx = 0.0;</span>
<span class="fc" id="L1318">        mAvgFy = 0.0;</span>
<span class="fc" id="L1319">        mAvgFz = 0.0;</span>
<span class="fc" id="L1320">        mAvgAngularRateX = 0.0;</span>
<span class="fc" id="L1321">        mAvgAngularRateY = 0.0;</span>
<span class="fc" id="L1322">        mAvgAngularRateZ = 0.0;</span>
<span class="fc" id="L1323">        mVarianceFx = 0.0;</span>
<span class="fc" id="L1324">        mVarianceFy = 0.0;</span>
<span class="fc" id="L1325">        mVarianceFz = 0.0;</span>
<span class="fc" id="L1326">        mVarianceAngularRateX = 0.0;</span>
<span class="fc" id="L1327">        mVarianceAngularRateY = 0.0;</span>
<span class="fc" id="L1328">        mVarianceAngularRateZ = 0.0;</span>
<span class="fc" id="L1329">        mNumberOfProcessedSamples = 0;</span>
<span class="fc" id="L1330">        mNumberOfProcessedSamplesPlusOne = 1;</span>

<span class="pc bpc" id="L1332" title="1 of 2 branches missed.">        if (mListener != null) {</span>
<span class="fc" id="L1333">            mListener.onReset(this);</span>
        }

<span class="fc" id="L1336">        mRunning = false;</span>

<span class="fc" id="L1338">        return true;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>