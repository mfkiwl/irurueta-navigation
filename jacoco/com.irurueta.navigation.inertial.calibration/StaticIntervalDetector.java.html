<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>StaticIntervalDetector.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.irurueta:irurueta-navigation</a> &gt; <a href="index.source.html" class="el_package">com.irurueta.navigation.inertial.calibration</a> &gt; <span class="el_source">StaticIntervalDetector.java</span></div><h1>StaticIntervalDetector.java</h1><pre class="source lang-java linenums">package com.irurueta.navigation.inertial.calibration;

import com.irurueta.navigation.LockedException;
import com.irurueta.navigation.inertial.calibration.noise.AccumulatedAccelerationTriadNoiseEstimator;
import com.irurueta.navigation.inertial.calibration.noise.WindowedAccelerationTriadNoiseEstimator;
import com.irurueta.navigation.inertial.calibration.noise.WindowedTriadNoiseEstimator;
import com.irurueta.units.Acceleration;
import com.irurueta.units.AccelerationConverter;
import com.irurueta.units.AccelerationUnit;

/**
 * This detector is in charge of determining when a static period of
 * IMU measurements starts and finishes.
 * Statis periods, are periods of time where the device is considered
 * to remain static (no movement applied to it).
 */
public class StaticIntervalDetector {

    /**
     * Number of samples to keep within the window by default.
     * For an accelerometer generating 100 samples/second, this is equivalent to
     * 1 second.
     * For an accelerometer generating 50 samples/second, this is equivalent to
     * 2 seconds.
     */
    public static final int DEFAULT_WINDOW_SIZE = WindowedTriadNoiseEstimator.DEFAULT_WINDOW_SIZE;

    /**
     * Number of samples to process during the initial static period to determine the accelerometer
     * noise level.
     * For an accelerometer generating 100 samples/secon, this is equivalent to 50 seconds.
     * For an accelerometer generating 50 samples/second, this is equivalent to 100 seconds.
     */
    public static final int DEFAULT_INITIAL_STATIC_SAMPLES = 5000;

    /**
     * Minimum allowed number of samples to be processed during the initial static period.
     */
    public static final int MINIMUM_INITIAL_STATIC_SAMPLES = 2;

    /**
     * Default factor to be applied to detected base noise level in order to determine
     * threshold for static/dynamic period changes. This factor is unit-less.
     */
    public static final double DEFAULT_THRESHOLD_FACTOR = 2.0;

    /**
     * Default factor to determine that a sudden movement has occurred during initialization
     * if instantaneous noise level exceeds accumulated noise level by this factor amount.
     * This factor is unit-less.
     */
    public static final double DEFAULT_INSTANTANEOUS_NOISE_LEVEL_FACTOR = 2.0;

    /**
     * Default overall absolute threshold to determine whether there has been excessive motion
     * during the whole initialization phase.
     * This threshold is expressed in meters per squared second (m/s^2), and by default it is
     * set to the maximum allowed value, thus effectively disabling this error condition check
     * during initialization.
     */
    public static final double DEFAULT_BASE_NOISE_LEVEL_ABSOLUTE_THRESHOLD = Double.MAX_VALUE;

    /**
     * Number of samples to keep in window to find instantaneous noise level averaged within
     * the window of samples.
     * Window size should contain about 1 or 2 seconds of data to be averaged to obtain
     * a more reliable instantaneous noise level.
     */
<span class="fc" id="L69">    private int mWindowSize = DEFAULT_WINDOW_SIZE;</span>

    /**
     * Number of samples to be processed initially while keeping the accelerometer static in order
     * to find the base noise level when device is static.
     */
<span class="fc" id="L75">    private int mInitialStaticSamples = DEFAULT_INITIAL_STATIC_SAMPLES;</span>

    /**
     * Factor to be applied to detected base noise level in order to determine
     * threshold for static/dynamic period changes. This factor is unit-less.
     */
<span class="fc" id="L81">    private double mThresholdFactor = DEFAULT_THRESHOLD_FACTOR;</span>

    /**
     * Factor to determine that a sudden movement has occurred during initialization if
     * instantaneous noise level exceeds accumulated noise level by this factor amount.
     * This factor is unit-less.
     */
<span class="fc" id="L88">    private double mInstantaneousNoiseLevelFactor = DEFAULT_INSTANTANEOUS_NOISE_LEVEL_FACTOR;</span>

    /**
     * Overall absolute threshold to determine whether there has been excessive motion
     * during the whole initialization phase.
     * Failure will be detected if estimated base noise level exceeds this threshold when
     * initialization completes.
     * This threshold is expressed in meters per squared second (m/s^2).
     */
<span class="fc" id="L97">    private double mBaseNoiseLevelAbsoluteThreshold = DEFAULT_BASE_NOISE_LEVEL_ABSOLUTE_THRESHOLD;</span>

    /**
     * Listener to handle events generated by this detector.
     */
    private StaticIntervalDetectorListener mListener;

    /**
     * Current status of this detector.
     */
<span class="fc" id="L107">    private Status mStatus = Status.IDLE;</span>

    /**
     * Accelerometer base noise level that has been detected during initialization expressed in
     * meters per squared second (m/s^2).
     */
    private double mBaseNoiseLevel;

    /**
     * Threshold to determine static/dynamic period changes expressed in meters per squared
     * second (m/s^2).
     */
    private double mThreshold;

    /**
     * Indicates whether this detector is busy processing last provided sample.
     */
    private boolean mRunning;

    /**
     * Number of samples that have been processed so far.
     */
    private int mProcessedSamples;

    /**
     * Gets average x-coordinate of specific force during last static period
     * expressed in meters per squared second (m/s^2).
     * This value is updated when switching from a static period to a dynamic
     * one or after completing initialization.
     */
    private double mAvgSpecificForceX;

    /**
     * Gets average y-coordinate of specific force during last static period
     * expressed in meters per squared second (m/s^2).
     * This value is updated when switching from a static period to a dynamic
     * one or after completing initialization.
     */
    private double mAvgSpecificForceY;

    /**
     * Gets average z-coordinate of specific force during last static period
     * expressed in meters per squared second (m/s^2).
     * This value is updated when switching from a static period to a dynamic
     * one or after completing initialization.
     */
    private double mAvgSpecificForceZ;

    /**
     * Estimator to find instantaneous accelerometer noise level averaged for a certain window of samples.
     */
<span class="fc" id="L158">    private final WindowedAccelerationTriadNoiseEstimator mWindowedNoiseEstimator</span>
            = new WindowedAccelerationTriadNoiseEstimator();

    /**
     * Estimator to find accumulated accelerometer noise level.
     */
<span class="fc" id="L164">    private final AccumulatedAccelerationTriadNoiseEstimator mAccumulatedNoiseEstimator =</span>
            new AccumulatedAccelerationTriadNoiseEstimator();

    /**
     * Constructor.
     */
<span class="fc" id="L170">    public StaticIntervalDetector() {</span>
<span class="fc" id="L171">    }</span>

    /**
     * Constructor.
     *
     * @param listener listener to handle events generated by this detector.
     */
<span class="fc" id="L178">    public StaticIntervalDetector(final StaticIntervalDetectorListener listener) {</span>
<span class="fc" id="L179">        mListener = listener;</span>
<span class="fc" id="L180">    }</span>

    /**
     * Gets length of number of samples to keep within the window being processed
     * to determine instantaneous accelerometer noise level.
     *
     * @return length of number of samples to keep within the window.
     */
    public int getWindowSize() {
<span class="fc" id="L189">        return mWindowSize;</span>
    }

    /**
     * Sets length of number of samples to keep within the window being processed
     * to determine instantaneous accelerometer noise level.
     * Window size must always be larger than allowed minimum value, which is 2.
     *
     * @param windowSize length of number of samples to keep within the window.
     * @throws LockedException          if detector is busy processing a previous sample.
     * @throws IllegalArgumentException if provided value is not valid.
     */
    public void setWindowSize(final int windowSize) throws LockedException {
<span class="fc bfc" id="L202" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L203">            throw new LockedException();</span>
        }

<span class="fc" id="L206">        mWindowedNoiseEstimator.setWindowSize(windowSize);</span>
<span class="fc" id="L207">        mWindowSize = windowSize;</span>
<span class="fc" id="L208">    }</span>

    /**
     * Gets number of samples to be processed initially while keeping the accelerometer static in order
     * to find the base noise level when device is static.
     *
     * @return number of samples to be processed initially.
     */
    public int getInitialStaticSamples() {
<span class="fc" id="L217">        return mInitialStaticSamples;</span>
    }

    /**
     * Sets number of samples to be processed initially while keeping the accelerometer static in order
     * to find the base noise level when device is static.
     *
     * @param initialStaticSamples number of samples to be processed initially.
     * @throws LockedException          if detector is busy.
     * @throws IllegalArgumentException if provided value is less than {@link #MINIMUM_INITIAL_STATIC_SAMPLES}
     */
    public void setInitialStaticSamples(final int initialStaticSamples)
            throws LockedException {
<span class="fc bfc" id="L230" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L231">            throw new LockedException();</span>
        }

<span class="fc bfc" id="L234" title="All 2 branches covered.">        if (initialStaticSamples &lt; MINIMUM_INITIAL_STATIC_SAMPLES) {</span>
<span class="fc" id="L235">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L238">        mInitialStaticSamples = initialStaticSamples;</span>
<span class="fc" id="L239">    }</span>

    /**
     * Gets factor to be applied to detected base noise level in order to
     * determine threshold for static/dynamic period changes. This factor is
     * unit-less.
     *
     * @return factor to be applied to detected base noise level.
     */
    public double getThresholdFactor() {
<span class="fc" id="L249">        return mThresholdFactor;</span>
    }

    /**
     * Sets factor to be applied to detected base noise level in order to
     * determine threshold for static/dynamic period changes. This factor is
     * unit-less.
     *
     * @param thresholdFactor factor to be applied to detected base noise level.
     * @throws LockedException          if detector is busy.
     * @throws IllegalArgumentException if provided value is zero or negative.
     */
    public void setThresholdFactor(final double thresholdFactor)
            throws LockedException {
<span class="fc bfc" id="L263" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L264">            throw new LockedException();</span>
        }
<span class="fc bfc" id="L266" title="All 2 branches covered.">        if (thresholdFactor &lt;= 0.0) {</span>
<span class="fc" id="L267">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L270">        mThresholdFactor = thresholdFactor;</span>
<span class="fc" id="L271">    }</span>

    /**
     * Gets factor to determine that a sudden movement has occurred during
     * initialization if instantaneous noise level exceeds accumulated noise
     * level by this factor amount.
     * This factor is unit-less.
     *
     * @return factor to determine that a sudden movement has occurred.
     */
    public double getInstantaneousNoiseLevelFactor() {
<span class="fc" id="L282">        return mInstantaneousNoiseLevelFactor;</span>
    }

    /**
     * Sets factor to determine that a sudden movement has occurred during
     * initialization if instantaneous noise level exceeds accumulated noise
     * level by this factor amount.
     * This factor is unit-less.
     *
     * @param instantaneousNoiseLevelFactor factor to determine that a sudden
     *                                      movement has occurred during
     *                                      initialization.
     * @throws LockedException          if detector is busy.
     * @throws IllegalArgumentException if provided value is zero or negative.
     */
    public void setInstantaneousNoiseLevelFactor(
            final double instantaneousNoiseLevelFactor) throws LockedException {
<span class="fc bfc" id="L299" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L300">            throw new LockedException();</span>
        }
<span class="fc bfc" id="L302" title="All 2 branches covered.">        if (instantaneousNoiseLevelFactor &lt;= 0.0) {</span>
<span class="fc" id="L303">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L306">        mInstantaneousNoiseLevelFactor = instantaneousNoiseLevelFactor;</span>
<span class="fc" id="L307">    }</span>

    /**
     * Gets overall absolute threshold to determine whether there has been
     * excessive motion during the whole initialization phase.
     * Failure will be detected if estimated base noise level exceeds this
     * threshold when initialization completes.
     * This threshold is expressed in meters per squared second (m/s^2).
     *
     * @return overall absolute threshold to determine whether there has
     * been excessive motion.
     */
    public double getBaseNoiseLevelAbsoluteThreshold() {
<span class="fc" id="L320">        return mBaseNoiseLevelAbsoluteThreshold;</span>
    }

    /**
     * Sets overall absolute threshold to determine whether there has been
     * excessive motion during the whole initialization phase.
     * Failure will be detected if estimated base noise level exceeds this
     * threshold when initialization completes.
     * This threshold is expressed in meters per squared second (m/s^2).
     *
     * @param baseNoiseLevelAbsoluteThreshold overall absolute threshold to
     *                                        determine whether there has been
     *                                        excessive motion.
     * @throws LockedException          if detector is busy.
     * @throws IllegalArgumentException if provided value is zero or negative.
     */
    public void setBaseNoiseLevelAbsoluteThreshold(
            final double baseNoiseLevelAbsoluteThreshold) throws LockedException {
<span class="fc bfc" id="L338" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L339">            throw new LockedException();</span>
        }
<span class="fc bfc" id="L341" title="All 2 branches covered.">        if (baseNoiseLevelAbsoluteThreshold &lt;= 0.0) {</span>
<span class="fc" id="L342">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L345">        mBaseNoiseLevelAbsoluteThreshold = baseNoiseLevelAbsoluteThreshold;</span>
<span class="fc" id="L346">    }</span>

    /**
     * Gets overall absolute threshold to determine whether there has been
     * excessive motion during the whole initialization phase.
     * Failure will be detected if estimated base noise level exceeds this
     * threshold when initialization completes.
     *
     * @return overall absolute threshold to determine whether there has been
     * excessive motion.
     */
    public Acceleration getBaseNoiseLevelAbsoluteThresholdAsAcceleration() {
<span class="fc" id="L358">        return new Acceleration(mBaseNoiseLevelAbsoluteThreshold,</span>
                AccelerationUnit.METERS_PER_SQUARED_SECOND);
    }

    /**
     * Gets overall absolute threshold to determine whether there has been
     * excessive motion during the whole initialization phase.
     * Failure will be detected if estimated base noise level exceeds this
     * threshold when initialization completes.
     *
     * @param result instance where result will be stored.
     */
    public void getBaseNoiseLevelAbsoluteThresholdAsAcceleration(
            final Acceleration result) {
<span class="fc" id="L372">        result.setValue(mBaseNoiseLevelAbsoluteThreshold);</span>
<span class="fc" id="L373">        result.setUnit(AccelerationUnit.METERS_PER_SQUARED_SECOND);</span>
<span class="fc" id="L374">    }</span>

    /**
     * Sets overall absolute threshold to determine whether there has been
     * excessive motion during the whole initialization phase.
     * Failure will be detected if estimated base noise level exceeds this
     * threshold when initialization completes.
     *
     * @param baseNoiseLevelAbsoluteThreshold overall absolute threshold to
     *                                        determine whether there has been
     *                                        excessive motion.
     * @throws LockedException          if detector is busy.
     * @throws IllegalArgumentException if provided value is zero or negative.
     */
    public void setBaseNoiseLevelAbsoluteThreshold(
            final Acceleration baseNoiseLevelAbsoluteThreshold)
            throws LockedException {
<span class="pc bpc" id="L391" title="1 of 2 branches missed.">        if (mRunning) {</span>
<span class="nc" id="L392">            throw new LockedException();</span>
        }

<span class="fc" id="L395">        setBaseNoiseLevelAbsoluteThreshold(convertAcceleration(</span>
                baseNoiseLevelAbsoluteThreshold));
<span class="fc" id="L397">    }</span>

    /**
     * Gets listener to handle events generated by this detector.
     *
     * @return listener to handle events.
     */
    public StaticIntervalDetectorListener getListener() {
<span class="fc" id="L405">        return mListener;</span>
    }

    /**
     * Sets listener to handle events generated by this detector.
     *
     * @param listener listener to handle events.
     * @throws LockedException if detector is busy.
     */
    public void setListener(final StaticIntervalDetectorListener listener)
            throws LockedException {
<span class="fc bfc" id="L416" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L417">            throw new LockedException();</span>
        }

<span class="fc" id="L420">        mListener = listener;</span>
<span class="fc" id="L421">    }</span>

    /**
     * Gets current status of this detector.
     *
     * @return current status of this detector.
     */
    public Status getStatus() {
<span class="fc" id="L429">        return mStatus;</span>
    }

    /**
     * Gets accelerometer base noise level that has been detected during
     * initialization expressed in meters per squared second (m/s^2).
     *
     * @return accelerometer base noise level.
     */
    public double getBaseNoiseLevel() {
<span class="fc" id="L439">        return mBaseNoiseLevel;</span>
    }

    /**
     * Gets accelerometer base noise level that has been detected during
     * initialization.
     *
     * @return accelerometer base noise level.
     */
    public Acceleration getBaseNoiseLevelAsAcceleration() {
<span class="fc" id="L449">        return new Acceleration(mBaseNoiseLevel,</span>
                AccelerationUnit.METERS_PER_SQUARED_SECOND);
    }

    /**
     * Gets accelerometer base noise level that has been detected during
     * initialization.
     *
     * @param result instance where result will be stored.
     */
    public void getBaseNoiseLevelAsAcceleration(final Acceleration result) {
<span class="fc" id="L460">        result.setValue(mBaseNoiseLevel);</span>
<span class="fc" id="L461">        result.setUnit(AccelerationUnit.METERS_PER_SQUARED_SECOND);</span>
<span class="fc" id="L462">    }</span>

    /**
     * Gets threshold to determine static/dynamic period changes expressed in
     * meters per squared second (m/s^2).
     *
     * @return threshold to determine static/dynamic period changes.
     */
    public double getThreshold() {
<span class="fc" id="L471">        return mThreshold;</span>
    }

    /**
     * Gets threshold to determine static/dynamic period changes.
     *
     * @return threshold to determine static/dynamic period changes.
     */
    public Acceleration getThresholdAsAcceleration() {
<span class="fc" id="L480">        return new Acceleration(mThreshold,</span>
                AccelerationUnit.METERS_PER_SQUARED_SECOND);
    }

    /**
     * Gets threshold to determine static/dynamic period changes.
     *
     * @param result instance where result will be stored.
     */
    public void getThresholdAsAcceleration(final Acceleration result) {
<span class="fc" id="L490">        result.setValue(mThreshold);</span>
<span class="fc" id="L491">        result.setUnit(AccelerationUnit.METERS_PER_SQUARED_SECOND);</span>
<span class="fc" id="L492">    }</span>

    /**
     * Indicates whether this detector is busy processing last provided sample.
     *
     * @return true if this detector is busy, false otherwise.
     */
    public boolean isRunning() {
<span class="fc" id="L500">        return mRunning;</span>
    }

    /**
     * Gets number of samples that have been processed so far.
     *
     * @return number of samples that have been processed so far.
     */
    public int getProcessedSamples() {
<span class="fc" id="L509">        return mProcessedSamples;</span>
    }

    /**
     * Gets average x-coordinate of specific force during last static period
     * expressed in meters per squared second (m/s^2).
     * This value is updated when switching from a static period to a dynamic
     * one or after completing initialization.
     *
     * @return average x-coordinate of specific force during last static period.
     */
    public double getAvgSpecificForceX() {
<span class="fc" id="L521">        return mAvgSpecificForceX;</span>
    }

    /**
     * Gets average x-coordinate of specific force during last static period.
     * This value is updated when switching from a static period to a dynamic
     * one or after completing initialization.
     *
     * @return average x-coordinate of specific force during last static period.
     */
    public Acceleration getAvgSpecificForceXAsAcceleration() {
<span class="fc" id="L532">        return new Acceleration(mAvgSpecificForceX,</span>
                AccelerationUnit.METERS_PER_SQUARED_SECOND);
    }

    /**
     * Gets average x-coordinate of specific force during last static period.
     * This value is updated when switching from a static period to a dynamic
     * one or after completing initialization.
     *
     * @param result instance where result will be stored.
     */
    public void getAvgSpecificForceXAsAcceleration(final Acceleration result) {
<span class="fc" id="L544">        result.setValue(mAvgSpecificForceX);</span>
<span class="fc" id="L545">        result.setUnit(AccelerationUnit.METERS_PER_SQUARED_SECOND);</span>
<span class="fc" id="L546">    }</span>

    /**
     * Gets average y-coordinate of specific force during last static period
     * expressed in meters per squared second (m/s^2).
     * This value is updated when switching from a static period to a dynamic
     * one or after completing initialization.
     *
     * @return average y-coordinate of specific force during last static period.
     */
    public double getAvgSpecificForceY() {
<span class="fc" id="L557">        return mAvgSpecificForceY;</span>
    }

    /**
     * Gets average y-coordinate of specific force during last static period.
     * This value is updated when switching from a static period to a dynamic
     * one or after completing initialization.
     *
     * @return average y-coordinate of specific force during last static period.
     */
    public Acceleration getAvgSpecificForceYAsAcceleration() {
<span class="fc" id="L568">        return new Acceleration(mAvgSpecificForceY,</span>
                AccelerationUnit.METERS_PER_SQUARED_SECOND);
    }

    /**
     * Gets average y-coordinate of specific force during last static period.
     * This value is updated when switching from a static period to a dynamic
     * one or after completing initialization.
     *
     * @param result instance where result will be stored.
     */
    public void getAvgSpecificForceYAsAcceleration(final Acceleration result) {
<span class="fc" id="L580">        result.setValue(mAvgSpecificForceY);</span>
<span class="fc" id="L581">        result.setUnit(AccelerationUnit.METERS_PER_SQUARED_SECOND);</span>
<span class="fc" id="L582">    }</span>

    /**
     * Gets average z-coordinate of specific force during last static period
     * expressed in meters per squared second (m/s^2).
     * This value is updated when switching from a static period to a dynamic
     * one or after completing initialization.
     *
     * @return average z-coordinate of specific force during last static period.
     */
    public double getAvgSpecificForceZ() {
<span class="fc" id="L593">        return mAvgSpecificForceZ;</span>
    }

    /**
     * Gets average z-coordinate of specific force during last static period.
     * This value is updated when switching from a static period to a dynamic
     * one or after completing initialization.
     *
     * @return average z-coordinate of specific force during last static period.
     */
    public Acceleration getAvgSpecificForceZAsAcceleration() {
<span class="fc" id="L604">        return new Acceleration(mAvgSpecificForceZ,</span>
                AccelerationUnit.METERS_PER_SQUARED_SECOND);
    }

    /**
     * Gets average z-coordinate of specific force during last static period.
     * This value is updated when switching from a static period to a dynamic
     * one or after completing initialization.
     *
     * @param result instance where result will be stored.
     */
    public void getAvgSpecificForceZAsAcceleration(final Acceleration result) {
<span class="fc" id="L616">        result.setValue(mAvgSpecificForceZ);</span>
<span class="fc" id="L617">        result.setUnit(AccelerationUnit.METERS_PER_SQUARED_SECOND);</span>
<span class="fc" id="L618">    }</span>

    /**
     * Gets average specific force during last static period.
     * This value is updated when switching from a static period to a dynamic
     * one or after completing initialization.
     *
     * @return average specific force during last static period.
     */
    public AccelerationTriad getAvgSpecificForce() {
<span class="fc" id="L628">        return new AccelerationTriad(AccelerationUnit.METERS_PER_SQUARED_SECOND,</span>
                mAvgSpecificForceX, mAvgSpecificForceY, mAvgSpecificForceZ);
    }

    /**
     * Gets average specific force during last static period.
     * This value is updated when switching from a static period to a dynamic
     * one or after completing initialization.
     *
     * @param result instance where result will be stored.
     */
    public void getAvgSpecificForce(final AccelerationTriad result) {
<span class="fc" id="L640">        result.setValueCoordinatesAndUnit(</span>
                mAvgSpecificForceX, mAvgSpecificForceY, mAvgSpecificForceZ,
                AccelerationUnit.METERS_PER_SQUARED_SECOND);
<span class="fc" id="L643">    }</span>

    /**
     * Processes a new acceleration triad sample.
     *
     * @param triad a new acceleration triad to be processed.
     * @return true if provided triad has been processed, false if provided triad has been skipped because detector
     * previously failed. If detector previously failed, it will need to be reset before processing additional
     * samples.
     * @throws LockedException if detector is busy processing a previous sample.
     */
    public boolean processAccelerationTriad(final AccelerationTriad triad) throws LockedException {
<span class="fc" id="L655">        return processAccelerationTriad(</span>
<span class="fc" id="L656">                convertAcceleration(triad.getValueX(), triad.getUnit()),</span>
<span class="fc" id="L657">                convertAcceleration(triad.getValueY(), triad.getUnit()),</span>
<span class="fc" id="L658">                convertAcceleration(triad.getValueZ(), triad.getUnit()));</span>
    }

    /**
     * Processes a new acceleration triad sample.
     *
     * @param fx x-coordinate of sensed accelerometer specific force.
     * @param fy y-coordinate of sensed accelerometer specific force.
     * @param fz z-coordinate of sensed accelerometer specific force.
     * @return true if provided triad has been processed, false if provided triad has been skipped because detector
     * previously failed. If detector previously failed, it will need to be reset before processing additional
     * samples.
     * @throws LockedException if detector is busy processing a previous sample.
     */
    public boolean processAccelerationTriad(
            final Acceleration fx, final Acceleration fy, final Acceleration fz) throws LockedException {
<span class="fc" id="L674">        return processAccelerationTriad(convertAcceleration(fx), convertAcceleration(fy), convertAcceleration(fz));</span>
    }

    /**
     * Processed a new acceleration triad sample.
     *
     * @param fx x-coordinate of sensed accelerometer specific force expressed in meters per squared second (m/s^2).
     * @param fy y-coordinate of sensed accelerometer specific force expressed in meters per squared second (m/s^2).
     * @param fz z-coordinate of sensed accelerometer specific force expressed in meters per squared second (m/s^2).
     * @return true if provided triad has been processed, false if provided triad has been skipped because detector
     * previously failed. If detector previously failed, it will need to be reset before processing additional
     * samples.
     * @throws LockedException if detector is busy processing a previous sample.
     */
    public boolean processAccelerationTriad(final double fx, final double fy, final double fz)
            throws LockedException {
<span class="fc bfc" id="L690" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L691">            throw new LockedException();</span>
        }

<span class="fc bfc" id="L694" title="All 2 branches covered.">        if (mStatus == Status.FAILED) {</span>
<span class="fc" id="L695">            return false;</span>
        }

<span class="fc" id="L698">        mRunning = true;</span>

<span class="fc bfc" id="L700" title="All 2 branches covered.">        if (mStatus == Status.IDLE) {</span>
            // start initialization
<span class="fc" id="L702">            mStatus = Status.INITIALIZING;</span>

<span class="pc bpc" id="L704" title="1 of 2 branches missed.">            if (mListener != null) {</span>
<span class="fc" id="L705">                mListener.onInitializationStarted(this);</span>
            }
        }

<span class="fc" id="L709">        mProcessedSamples++;</span>

<span class="fc" id="L711">        final boolean windowedProcessed = mWindowedNoiseEstimator</span>
<span class="fc" id="L712">                .addTriadAndProcess(fx, fy, fz);</span>

<span class="fc" id="L714">        final double windowedStdNorm = mWindowedNoiseEstimator</span>
<span class="fc" id="L715">                .getStandardDeviationNorm();</span>

<span class="fc" id="L717">        final boolean filledWindow = mWindowedNoiseEstimator.isWindowFilled();</span>

<span class="fc bfc" id="L719" title="All 2 branches covered.">        if (mStatus == Status.INITIALIZING) {</span>
            // process sample during initialization
<span class="fc" id="L721">            final boolean accumulatedProcessed = mAccumulatedNoiseEstimator</span>
<span class="fc" id="L722">                    .addTriad(fx, fy, fz);</span>
<span class="fc" id="L723">            final double accumulatedStdNorm = mAccumulatedNoiseEstimator</span>
<span class="fc" id="L724">                    .getStandardDeviationNorm();</span>

<span class="fc bfc" id="L726" title="All 2 branches covered.">            if (mProcessedSamples &lt; mInitialStaticSamples) {</span>
<span class="pc bpc" id="L727" title="1 of 4 branches missed.">                if (windowedProcessed &amp;&amp; accumulatedProcessed) {</span>
<span class="fc bfc" id="L728" title="All 4 branches covered.">                    if (filledWindow &amp;&amp; (windowedStdNorm / accumulatedStdNorm &gt; mInstantaneousNoiseLevelFactor)) {</span>
                        // sudden motion detected
<span class="fc" id="L730">                        mStatus = Status.FAILED;</span>

                        // notify error
<span class="pc bpc" id="L733" title="1 of 2 branches missed.">                        if (mListener != null) {</span>
<span class="fc" id="L734">                            mListener.onError(this, accumulatedStdNorm,</span>
                                    windowedStdNorm,
                                    ErrorReason.SUDDEN_EXCESSIVE_MOVEMENT_DETECTED);
                        }
                    }
                }

            } else {
                // initialization completed
                // set base noise level and threshold
<span class="fc" id="L744">                mBaseNoiseLevel = accumulatedStdNorm;</span>
<span class="fc" id="L745">                mThreshold = mBaseNoiseLevel * mThresholdFactor;</span>

                // keep average specific force in case we want to obtain
                // its value since initial period must be static
<span class="fc" id="L749">                mAvgSpecificForceX = mAccumulatedNoiseEstimator.getAvgX();</span>
<span class="fc" id="L750">                mAvgSpecificForceY = mAccumulatedNoiseEstimator.getAvgY();</span>
<span class="fc" id="L751">                mAvgSpecificForceZ = mAccumulatedNoiseEstimator.getAvgZ();</span>

                // reset accumulated estimator so that we can estimate
                // average specific force in static periods
<span class="fc" id="L755">                mAccumulatedNoiseEstimator.reset();</span>

<span class="fc bfc" id="L757" title="All 2 branches covered.">                if (mBaseNoiseLevel &gt; mBaseNoiseLevelAbsoluteThreshold) {</span>
                    // base noise level exceeds allowed value
<span class="fc" id="L759">                    mStatus = Status.FAILED;</span>

                    // notify error
<span class="pc bpc" id="L762" title="1 of 2 branches missed.">                    if (mListener != null) {</span>
<span class="fc" id="L763">                        mListener.onError(this, accumulatedStdNorm,</span>
                                windowedStdNorm,
                                ErrorReason.OVERALL_EXCESSIVE_MOVEMENT_DETECTED);
                    }

                } else {
                    // initialization has been successfully completed
<span class="fc" id="L770">                    mStatus = Status.INITIALIZATION_COMPLETED;</span>

<span class="pc bpc" id="L772" title="1 of 2 branches missed.">                    if (mListener != null) {</span>
<span class="fc" id="L773">                        mListener.onInitializationCompleted(</span>
                                this, mBaseNoiseLevel);
                    }
                }

            }

<span class="fc" id="L780">            mRunning = false;</span>
<span class="fc" id="L781">            return true;</span>
        } else {
            // detect static or dynamic period
<span class="fc" id="L784">            final Status previousStatus = mStatus;</span>

<span class="fc bfc" id="L786" title="All 4 branches covered.">            if (previousStatus == Status.STATIC_INTERVAL ||</span>
                    previousStatus == Status.INITIALIZATION_COMPLETED) {
                // while we are in static interval (or initial static period), keep
                // adding samples to estimate accumulated average specific force
<span class="fc" id="L790">                mAccumulatedNoiseEstimator.addTriad(fx, fy, fz);</span>
            }

<span class="fc bfc" id="L793" title="All 2 branches covered.">            if (windowedStdNorm &lt; mThreshold) {</span>
<span class="fc" id="L794">                mStatus = Status.STATIC_INTERVAL;</span>
            } else {
<span class="fc" id="L796">                mStatus = Status.DYNAMIC_INTERVAL;</span>
            }

<span class="fc bfc" id="L799" title="All 2 branches covered.">            if (previousStatus != mStatus) {</span>
                // static/dynamic period change detected
<span class="pc bpc" id="L801" title="1 of 3 branches missed.">                switch (mStatus) {</span>
                    case STATIC_INTERVAL:
<span class="pc bpc" id="L803" title="1 of 2 branches missed.">                        if (mListener != null) {</span>
<span class="fc" id="L804">                            mListener.onStaticIntervalDetected(this);</span>
                        }
                        break;
                    case DYNAMIC_INTERVAL:
                        // when switching from static to dynamic interval,
                        // pick accumulated average specific force
<span class="fc" id="L810">                        mAvgSpecificForceX = mAccumulatedNoiseEstimator.getAvgX();</span>
<span class="fc" id="L811">                        mAvgSpecificForceY = mAccumulatedNoiseEstimator.getAvgY();</span>
<span class="fc" id="L812">                        mAvgSpecificForceZ = mAccumulatedNoiseEstimator.getAvgZ();</span>

                        // reset accumulated estimator when switching to dynamic period
<span class="fc" id="L815">                        mAccumulatedNoiseEstimator.reset();</span>

<span class="pc bpc" id="L817" title="1 of 2 branches missed.">                        if (mListener != null) {</span>
<span class="fc" id="L818">                            mListener.onDynamicIntervalDetected(this,</span>
                                    mAvgSpecificForceX, mAvgSpecificForceY,
                                    mAvgSpecificForceZ);
                        }
                        break;
                }
            }
        }

<span class="fc" id="L827">        mRunning = false;</span>
<span class="fc" id="L828">        return true;</span>
    }

    /**
     * Resets this detector so that it is initialized again when new samples are added.
     *
     * @throws LockedException if detector is busy.
     */
    public void reset() throws LockedException {
<span class="fc bfc" id="L837" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L838">            throw new LockedException();</span>
        }

<span class="fc" id="L841">        mRunning = true;</span>

<span class="fc" id="L843">        mStatus = Status.IDLE;</span>
<span class="fc" id="L844">        mProcessedSamples = 0;</span>
<span class="fc" id="L845">        mBaseNoiseLevel = 0.0;</span>
<span class="fc" id="L846">        mThreshold = 0.0;</span>

<span class="fc" id="L848">        mWindowedNoiseEstimator.reset();</span>
<span class="fc" id="L849">        mAccumulatedNoiseEstimator.reset();</span>

<span class="pc bpc" id="L851" title="1 of 2 branches missed.">        if (mListener != null) {</span>
<span class="fc" id="L852">            mListener.onReset(this);</span>
        }

<span class="fc" id="L855">        mRunning = false;</span>
<span class="fc" id="L856">    }</span>

    /**
     * Converts provided acceleration instance to meters per squared second (m/s^2).
     *
     * @param value value to be converted.
     * @return converted value.
     */
    private static double convertAcceleration(final Acceleration value) {
<span class="fc" id="L865">        return convertAcceleration(value.getValue().doubleValue(), value.getUnit());</span>
    }

    /**
     * Converts provided value from provided unit to meters per squared second (m/s^2).
     *
     * @param value value to be converted.
     * @param unit  unit of value to be converted.
     * @return converted value.
     */
    private static double convertAcceleration(final double value, final AccelerationUnit unit) {
<span class="fc" id="L876">        return AccelerationConverter.convert(value, unit, AccelerationUnit.METERS_PER_SQUARED_SECOND);</span>
    }

    /**
     * Possible detector status values.
     */
<span class="fc" id="L882">    public enum Status {</span>
        /**
         * Detector is in idle status when it hasn't processed any sample yet.
         */
<span class="fc" id="L886">        IDLE,</span>

        /**
         * Detector is processing samples in the initial static process to determine base noise level.
         */
<span class="fc" id="L891">        INITIALIZING,</span>

        /**
         * Detector has sucessfully completed processing samples on the initial
         * static period.
         */
<span class="fc" id="L897">        INITIALIZATION_COMPLETED,</span>

        /**
         * A static interval has been detected, where accelerometer is considered to be subject to no substantial
         * movement forces.
         */
<span class="fc" id="L903">        STATIC_INTERVAL,</span>

        /**
         * A dynamic interval has been detected, where accelerometer is considered to be subject to substantial
         * movement forces.
         */
<span class="fc" id="L909">        DYNAMIC_INTERVAL,</span>

        /**
         * Detector has failed. This happens if accelerometer is subject to sudden movement forces while detector
         * is initializing during the initial static period.
         * When detector has failed, no new samples will be allowed to be processed until detector is reset.
         */
<span class="fc" id="L916">        FAILED</span>
    }

    /**
     * Reason why this detector has failed during initialization.
     */
<span class="fc" id="L922">    public enum ErrorReason {</span>
<span class="fc" id="L923">        SUDDEN_EXCESSIVE_MOVEMENT_DETECTED,</span>
<span class="fc" id="L924">        OVERALL_EXCESSIVE_MOVEMENT_DETECTED</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>