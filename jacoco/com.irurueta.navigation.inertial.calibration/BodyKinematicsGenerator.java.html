<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>BodyKinematicsGenerator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.irurueta:irurueta-navigation</a> &gt; <a href="index.source.html" class="el_package">com.irurueta.navigation.inertial.calibration</a> &gt; <span class="el_source">BodyKinematicsGenerator.java</span></div><h1>BodyKinematicsGenerator.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2020 Alberto Irurueta Carro (alberto@irurueta.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.irurueta.navigation.inertial.calibration;

import com.irurueta.algebra.Matrix;
import com.irurueta.algebra.WrongSizeException;
import com.irurueta.navigation.inertial.BodyKinematics;
import com.irurueta.units.Time;
import com.irurueta.units.TimeConverter;
import com.irurueta.units.TimeUnit;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.Random;

/**
 * Generates body kinematic instances from true body kinematic values taking into
 * account provided IMU errors for a calibrated IMU.
 * This implementation is based on the equations defined in &quot;Principles of GNSS, Inertial, and Multisensor
 * Integrated Navigation Systems, Second Edition&quot; and on the companion software available at:
 * https://github.com/ymjdz/MATLAB-Codes/blob/master/IMU_model.m
 */
public class BodyKinematicsGenerator {

    /**
     * Prevents instantiation of utility class.
     */
    private BodyKinematicsGenerator() { }

    /**
     * Generates uncalibrated body kinematics instances containing a certain level
     * of noise for provided ground-truth body kinematics and IMU errors.
     * This method ignores IMU quantization levels.
     *
     * @param timeInterval   time interval between epochs.
     * @param trueKinematics collection of ground-truth kinematics.
     * @param errors         IMU errors containing calibration data.
     * @param random         a random number generator to generate noise.
     * @return a new collection containing generated uncalibrated kinematics
     * for each provided ground-truth one.
     */
    public static Collection&lt;BodyKinematics&gt; generate(
            final Time timeInterval, final Collection&lt;BodyKinematics&gt; trueKinematics,
            final IMUErrors errors, final Random random) {
<span class="fc" id="L59">        return generate(convertTime(timeInterval), trueKinematics, errors, random);</span>
    }

    /**
     * Generates uncalibrated body kinematics instances containing a certain level
     * of noise for provided ground-truth body kinematics and IMU errors.
     * This method ignores IMU quantization levels.
     *
     * @param timeInterval   time interval between epochs.
     * @param trueKinematics collection of ground-truth kinematics.
     * @param errors         IMU errors containing calibration data.
     * @param random         a random number generator to generate noise.
     * @param result         collection where generated uncalibrated kinematics
     *                       for each provided ground-truth one will be stored.
     */
    public static void generate(final Time timeInterval,
                                final Collection&lt;BodyKinematics&gt; trueKinematics,
                                final IMUErrors errors, final Random random,
                                final Collection&lt;BodyKinematics&gt; result) {
<span class="fc" id="L78">        generate(convertTime(timeInterval), trueKinematics, errors, random, result);</span>
<span class="fc" id="L79">    }</span>

    /**
     * Generates uncalibrated body kinematics instances containing a certain level
     * of noise for provided ground-truth body kinematics and IMU errors.
     * This method ignores IMU quantization levels.
     *
     * @param timeInterval   time interval between epochs expressed in seconds (s).
     * @param trueKinematics collection of ground-truth kinematics.
     * @param errors         IMU errors containing calibration data.
     * @param random         a random number generator to generate noise.
     * @return a new collection containing generated uncalibrated kinematics
     * for each provided ground-truth one.
     */
    public static Collection&lt;BodyKinematics&gt; generate(
            final double timeInterval, final Collection&lt;BodyKinematics&gt; trueKinematics,
            final IMUErrors errors, final Random random) {
<span class="fc" id="L96">        final List&lt;BodyKinematics&gt; result = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L97">        generate(timeInterval, trueKinematics, errors, random, result);</span>
<span class="fc" id="L98">        return result;</span>
    }

    /**
     * Generates uncalibrated body kinematics instances containing a certain level
     * of noise for provided ground-truth body kinematics and IMU errors.
     * This method ignores IMU quantization levels.
     *
     * @param timeInterval   time interval between epochs expressed in seconds (s).
     * @param trueKinematics collection of ground-truth kinematics.
     * @param errors         IMU errors containing calibration data.
     * @param random         a random number generator to generate noise.
     * @param result         collection where generated uncalibrated kinematics
     *                       for each provided ground-truth one will be stored.
     */
    public static void generate(final double timeInterval,
                                final Collection&lt;BodyKinematics&gt; trueKinematics,
                                final IMUErrors errors, final Random random,
                                final Collection&lt;BodyKinematics&gt; result) {
        try {
<span class="fc" id="L118">            final Matrix trueFibb = new Matrix(BodyKinematics.COMPONENTS, 1);</span>
<span class="fc" id="L119">            final Matrix ma = errors.getAccelerometerScaleFactorAndCrossCouplingErrors();</span>
<span class="fc" id="L120">            final Matrix ba = errors.getAccelerometerBiasesAsMatrix();</span>
<span class="fc" id="L121">            final Matrix trueOmegaIbb = new Matrix(BodyKinematics.COMPONENTS, 1);</span>
<span class="fc" id="L122">            final Matrix mg = errors.getGyroScaleFactorAndCrossCouplingErrors();</span>
<span class="fc" id="L123">            final Matrix bg = errors.getGyroBiasesAsMatrix();</span>
<span class="fc" id="L124">            final Matrix gg = errors.getGyroGDependentBiases();</span>
<span class="fc" id="L125">            final Matrix identity = Matrix.identity(BodyKinematics.COMPONENTS,</span>
                    BodyKinematics.COMPONENTS);
<span class="fc" id="L127">            final Matrix tmp33 = new Matrix(BodyKinematics.COMPONENTS,</span>
                    BodyKinematics.COMPONENTS);
<span class="fc" id="L129">            final Matrix tmp31a = new Matrix(BodyKinematics.COMPONENTS, 1);</span>
<span class="fc" id="L130">            final Matrix tmp31b = new Matrix(BodyKinematics.COMPONENTS, 1);</span>

<span class="fc bfc" id="L132" title="All 2 branches covered.">            for (final BodyKinematics k : trueKinematics) {</span>
<span class="fc" id="L133">                final BodyKinematics r = new BodyKinematics();</span>

<span class="fc" id="L135">                internalGenerate(timeInterval, k, errors, random,</span>
                        null, r, null,
                        trueFibb, ma, ba, trueOmegaIbb, mg, bg, gg, identity,
                        tmp33, tmp31a, tmp31b);

<span class="fc" id="L140">                result.add(r);</span>
<span class="fc" id="L141">            }</span>

<span class="nc" id="L143">        } catch (WrongSizeException ignore) {</span>
            // never happens
<span class="fc" id="L145">        }</span>

<span class="fc" id="L147">    }</span>

    /**
     * Generates an uncalibrated body kinematics instance containing a certain level
     * of noise for provided ground-truth body kinematics and IMU errors.
     *
     * @param timeInterval   time interval between epochs expressed in seconds (s).
     * @param trueKinematics ground-truth kinematics.
     * @param errors         IMU errors containing calibration data.
     * @param random         a random number generator to generate noise.
     * @return uncalibrated body kinematics.
     */
    public static BodyKinematics generate(final Time timeInterval,
                                          final BodyKinematics trueKinematics,
                                          final IMUErrors errors, final Random random) {
<span class="fc" id="L162">        return generate(convertTime(timeInterval), trueKinematics, errors, random);</span>
    }

    /**
     * Generates an uncalibrated body kinematics instance containing a certain level
     * of noise for provided ground-truth body kinematics and IMU errors.
     *
     * @param timeInterval   time interval between epochs.
     * @param trueKinematics ground-truth kinematics.
     * @param errors         IMU errors containing calibration data.
     * @param random         a random number generator to generate noise.
     * @param result         instance where uncalibrated body kinematics will be stored.
     */
    public static void generate(final Time timeInterval,
                                final BodyKinematics trueKinematics,
                                final IMUErrors errors, final Random random,
                                final BodyKinematics result) {
<span class="fc" id="L179">        generate(convertTime(timeInterval), trueKinematics,</span>
                errors, random, result);
<span class="fc" id="L181">    }</span>

    /**
     * Generates an uncalibrated body kinematics instance containing a certain level
     * of noise for provided ground-truth body kinematics and IMU errors.
     *
     * @param timeInterval   time interval between epochs expressed in seconds (s).
     * @param trueKinematics ground-truth kinematics.
     * @param errors         IMU errors containing calibration data.
     * @param random         a random number generator to generate noise.
     * @return uncalibrated body kinematics.
     */
    public static BodyKinematics generate(final double timeInterval,
                                          final BodyKinematics trueKinematics,
                                          final IMUErrors errors,
                                          final Random random) {
<span class="fc" id="L197">        final BodyKinematics result = new BodyKinematics();</span>
<span class="fc" id="L198">        generate(timeInterval, trueKinematics, errors, random, result);</span>
<span class="fc" id="L199">        return result;</span>
    }

    /**
     * Generates an uncalibrated body kinematics instance containing a certain level
     * of noise for provided ground-truth body kinematics and IMU errors.
     *
     * @param timeInterval   time interval between epochs expressed in seconds (s).
     * @param trueKinematics ground-truth kinematics.
     * @param errors         IMU errors containing calibration data.
     * @param random         a random number generator to generate noise.
     * @param result         instance where uncalibrated body kinematics will be stored.
     */
    public static void generate(final double timeInterval,
                                final BodyKinematics trueKinematics,
                                final IMUErrors errors, final Random random,
                                final BodyKinematics result) {
<span class="fc" id="L216">        generate(timeInterval, trueKinematics, errors, random,</span>
                null, result, null);
<span class="fc" id="L218">    }</span>

    /**
     * Generates an uncalibrated body kinematics instance containing a certain level
     * of noise for provided ground-truth body kinematics and IMU errors.
     *
     * @param timeInterval             time interval between epochs.
     * @param trueKinematics           ground-truth kinematics.
     * @param errors                   IMU errors containing calibration data.
     * @param random                   a random number generator to generate noise.
     * @param oldQuantizationResiduals previous quantization residuals from previous
     *                                 executions. Optional. If provided, must have
     *                                 length 6, if not provided quantization levels
     *                                 are ignored.
     * @param quantizationResiduals    generated quantization residuals. Optional.
     *                                 If provided, must have length 6.
     * @return generated uncalibrated body kinematics.
     * @throws IllegalArgumentException if either oldQuantizationResiduals or
     *                                  quantizationResiduals are not length 6.
     */
    public static BodyKinematics generate(final Time timeInterval,
                                          final BodyKinematics trueKinematics,
                                          final IMUErrors errors, final Random random,
                                          final double[] oldQuantizationResiduals,
                                          final double[] quantizationResiduals) {
<span class="fc" id="L243">        return generate(convertTime(timeInterval), trueKinematics, errors, random,</span>
                oldQuantizationResiduals, quantizationResiduals);
    }

    /**
     * Generates an uncalibrated body kinematics instance containing a certain level
     * of noise for provided ground-truth body kinematics and IMU errors.
     *
     * @param timeInterval             time interval between epochs.
     * @param trueKinematics           ground-truth kinematics.
     * @param errors                   IMU errors containing calibration data.
     * @param random                   a random number generator to generate noise.
     * @param oldQuantizationResiduals previous quantization residuals from previous
     *                                 executions. Optional. If provided, must have
     *                                 length 6, if not provided quantization levels
     *                                 are ignored.
     * @param result                   instance where uncalibrated body kinematics will be stored.
     * @param quantizationResiduals    generated quantization residuals. Optional.
     *                                 If provided, must have length 6.
     * @throws IllegalArgumentException if either oldQuantizationResiduals or
     *                                  quantizationResiduals are not length 6.
     */
    public static void generate(final Time timeInterval,
                                final BodyKinematics trueKinematics,
                                final IMUErrors errors, final Random random,
                                final double[] oldQuantizationResiduals,
                                final BodyKinematics result,
                                final double[] quantizationResiduals) {
<span class="fc" id="L271">        generate(convertTime(timeInterval), trueKinematics, errors, random,</span>
                oldQuantizationResiduals, result, quantizationResiduals);
<span class="fc" id="L273">    }</span>

    /**
     * Generates an uncalibrated body kinematics instance containing a certain level
     * of noise for provided ground-truth body kinematics and IMU errors.
     *
     * @param timeInterval             time interval between epochs expressed in seconds (s).
     * @param trueKinematics           ground-truth kinematics.
     * @param errors                   IMU errors containing calibration data.
     * @param random                   a random number generator to generate noise.
     * @param oldQuantizationResiduals previous quantization residuals from previous
     *                                 executions. Optional. If provided, must have
     *                                 length 6, if not provided quantization levels
     *                                 are ignored.
     * @param quantizationResiduals    generated quantization residuals. Optional.
     *                                 If provided, must have length 6.
     * @return generated uncalibrated body kinematics.
     * @throws IllegalArgumentException if either oldQuantizationResiduals or
     *                                  quantizationResiduals are not length 6.
     */
    public static BodyKinematics generate(final double timeInterval,
                                          final BodyKinematics trueKinematics,
                                          final IMUErrors errors, final Random random,
                                          final double[] oldQuantizationResiduals,
                                          final double[] quantizationResiduals) {
<span class="fc" id="L298">        final BodyKinematics result = new BodyKinematics();</span>
<span class="fc" id="L299">        generate(timeInterval, trueKinematics, errors, random,</span>
                oldQuantizationResiduals, result, quantizationResiduals);
<span class="fc" id="L301">        return result;</span>
    }

    /**
     * Generates an uncalibrated body kinematics instance containing a certain level
     * of noise for provided ground-truth body kinematics and IMU errors.
     *
     * @param timeInterval             time interval between epochs expressed in seconds (s).
     * @param trueKinematics           ground-truth kinematics.
     * @param errors                   IMU errors containing calibration data.
     * @param random                   a random number generator to generate noise.
     * @param oldQuantizationResiduals previous quantization residuals from previous
     *                                 executions. Optional. If provided, must have
     *                                 length 6, if not provided quantization levels
     *                                 are ignored.
     * @param result                   instance where uncalibrated body kinematics will be stored.
     * @param quantizationResiduals    generated quantization residuals. Optional.
     *                                 If provided, must have length 6.
     * @throws IllegalArgumentException if either oldQuantizationResiduals or
     *                                  quantizationResiduals are not length 6.
     */
    public static void generate(final double timeInterval,
                                final BodyKinematics trueKinematics,
                                final IMUErrors errors, final Random random,
                                final double[] oldQuantizationResiduals,
                                final BodyKinematics result,
                                final double[] quantizationResiduals) {
        try {
<span class="fc" id="L329">            final Matrix trueFibb = new Matrix(BodyKinematics.COMPONENTS, 1);</span>
<span class="fc" id="L330">            final Matrix ma = errors.getAccelerometerScaleFactorAndCrossCouplingErrors();</span>
<span class="fc" id="L331">            final Matrix ba = errors.getAccelerometerBiasesAsMatrix();</span>
<span class="fc" id="L332">            final Matrix trueOmegaIbb = new Matrix(BodyKinematics.COMPONENTS, 1);</span>
<span class="fc" id="L333">            final Matrix mg = errors.getGyroScaleFactorAndCrossCouplingErrors();</span>
<span class="fc" id="L334">            final Matrix bg = errors.getGyroBiasesAsMatrix();</span>
<span class="fc" id="L335">            final Matrix gg = errors.getGyroGDependentBiases();</span>
<span class="fc" id="L336">            final Matrix identity = Matrix.identity(BodyKinematics.COMPONENTS,</span>
                    BodyKinematics.COMPONENTS);
<span class="fc" id="L338">            final Matrix tmp33 = new Matrix(BodyKinematics.COMPONENTS,</span>
                    BodyKinematics.COMPONENTS);
<span class="fc" id="L340">            final Matrix tmp31a = new Matrix(BodyKinematics.COMPONENTS, 1);</span>
<span class="fc" id="L341">            final Matrix tmp31b = new Matrix(BodyKinematics.COMPONENTS, 1);</span>
<span class="fc" id="L342">            internalGenerate(timeInterval, trueKinematics, errors, random,</span>
                    oldQuantizationResiduals, result, quantizationResiduals,
                    trueFibb, ma, ba, trueOmegaIbb, mg, bg, gg, identity, tmp33, tmp31a,
                    tmp31b);
<span class="nc" id="L346">        } catch (final WrongSizeException ignore) {</span>
            // never happens
<span class="fc" id="L348">        }</span>
<span class="fc" id="L349">    }</span>

    /**
     * Internally generates an uncalibrated body kinematics instance containing a certain
     * level of noise for provided ground-truth body kinematics and IMU errors.
     *
     * @param timeInterval             time interval between epochs expressed in seconds (s).
     * @param trueKinematics           ground-truth kinematics.
     * @param errors                   IMU errors containing calibration data.
     * @param random                   a random number generator to generate noise.
     * @param oldQuantizationResiduals previous quantization residuals from previous
     *                                 executions. Optional. If provided, must have
     *                                 length 6, if not provided quantization levels
     *                                 are ignored.
     * @param result                   instance where uncalibrated body kinematics will be stored.
     * @param quantizationResiduals    generated quantization residuals. Optional.
     *                                 If provided, must have length 6.
     * @param trueFibb                 3x1 matrix to be reused for specific force storage.
     * @param ma                       3x3 matrix to be reused for accelerometer scaling and
     *                                 cross coupling errors.
     * @param ba                       3x1 matrix to be reused for accelerometer biases.
     * @param trueOmegaibb             3x1 matrix to be reused for angular rates storage.
     * @param mg                       3x3 matrix to be reused for gyro scaling and cross
     *                                 coupling errors.
     * @param bg                       3x1 matrix to be reused for gyro biases.
     * @param gg                       3x3 matrix to be reused for gyro dependan cross
     *                                 coupling errors.
     * @param identity                 3x3 identity matrix to be reused.
     * @param tmp33                    3x3 matrix to be reused.
     * @param tmp31a                   3x1 matrix to be reused.
     * @param tmp31b                   3x1 matrix to be reused.
     * @throws WrongSizeException       if any of provided matrices has invalid size.
     * @throws IllegalArgumentException if either oldQuantizationResiduals or
     *                                  quantizationResiduals are not length 6.
     */
    private static void internalGenerate(final double timeInterval,
                                         final BodyKinematics trueKinematics,
                                         final IMUErrors errors, final Random random,
                                         final double[] oldQuantizationResiduals,
                                         final BodyKinematics result,
                                         final double[] quantizationResiduals,
                                         final Matrix trueFibb,
                                         final Matrix ma,
                                         final Matrix ba,
                                         final Matrix trueOmegaibb,
                                         final Matrix mg,
                                         final Matrix bg,
                                         final Matrix gg,
                                         final Matrix identity,
                                         final Matrix tmp33,
                                         final Matrix tmp31a,
                                         final Matrix tmp31b) throws WrongSizeException {

<span class="fc" id="L402">        int comp2 = 2 * BodyKinematics.COMPONENTS;</span>
<span class="fc bfc" id="L403" title="All 4 branches covered.">        if (oldQuantizationResiduals != null &amp;&amp;</span>
                oldQuantizationResiduals.length != comp2) {
<span class="fc" id="L405">            throw new IllegalArgumentException();</span>
        }
<span class="fc bfc" id="L407" title="All 4 branches covered.">        if (quantizationResiduals != null &amp;&amp;</span>
                quantizationResiduals.length != comp2) {
<span class="fc" id="L409">            throw new IllegalArgumentException();</span>
        }

        final double accelNoiseX;
        final double accelNoiseY;
        final double accelNoiseZ;
        final double gyroNoiseX;
        final double gyroNoiseY;
        final double gyroNoiseZ;
<span class="fc bfc" id="L418" title="All 2 branches covered.">        if (timeInterval &gt; 0.0) {</span>
<span class="fc" id="L419">            final double sqrtTimeInterval = Math.sqrt(timeInterval);</span>

<span class="fc" id="L421">            final double accelNoiseRootPSD = errors.getAccelerometerNoiseRootPSD();</span>
<span class="fc" id="L422">            final double accelStd = accelNoiseRootPSD / sqrtTimeInterval;</span>

<span class="fc" id="L424">            accelNoiseX = random.nextGaussian() * accelStd;</span>
<span class="fc" id="L425">            accelNoiseY = random.nextGaussian() * accelStd;</span>
<span class="fc" id="L426">            accelNoiseZ = random.nextGaussian() * accelStd;</span>

<span class="fc" id="L428">            final double gyroNoiseRootPSD = errors.getGyroNoiseRootPSD();</span>
<span class="fc" id="L429">            final double gyroStd = gyroNoiseRootPSD / sqrtTimeInterval;</span>

<span class="fc" id="L431">            gyroNoiseX = random.nextGaussian() * gyroStd;</span>
<span class="fc" id="L432">            gyroNoiseY = random.nextGaussian() * gyroStd;</span>
<span class="fc" id="L433">            gyroNoiseZ = random.nextGaussian() * gyroStd;</span>
<span class="fc" id="L434">        } else {</span>
<span class="fc" id="L435">            accelNoiseX = 0.0;</span>
<span class="fc" id="L436">            accelNoiseY = 0.0;</span>
<span class="fc" id="L437">            accelNoiseZ = 0.0;</span>

<span class="fc" id="L439">            gyroNoiseX = 0.0;</span>
<span class="fc" id="L440">            gyroNoiseY = 0.0;</span>
<span class="fc" id="L441">            gyroNoiseZ = 0.0;</span>
        }

        // Calculate accelerometer and gyro outputs using (4.16) and (4.17)
<span class="fc" id="L445">        trueKinematics.asSpecificForceMatrix(trueFibb);</span>
<span class="fc" id="L446">        trueKinematics.asAngularRateMatrix(trueOmegaibb);</span>

<span class="fc" id="L448">        identity.add(ma, tmp33);</span>
<span class="fc" id="L449">        tmp33.multiply(trueFibb, tmp31a);</span>
<span class="fc" id="L450">        tmp31a.add(ba);</span>

<span class="fc" id="L452">        final double uqFibbX = tmp31a.getElementAtIndex(0) + accelNoiseX;</span>
<span class="fc" id="L453">        final double uqFibbY = tmp31a.getElementAtIndex(1) + accelNoiseY;</span>
<span class="fc" id="L454">        final double uqFibbZ = tmp31a.getElementAtIndex(2) + accelNoiseZ;</span>

<span class="fc" id="L456">        identity.add(mg, tmp33);</span>
<span class="fc" id="L457">        tmp33.multiply(trueOmegaibb, tmp31a);</span>
<span class="fc" id="L458">        tmp31a.add(bg);</span>

<span class="fc" id="L460">        gg.multiply(trueFibb, tmp31b);</span>
<span class="fc" id="L461">        tmp31a.add(tmp31b);</span>

<span class="fc" id="L463">        final double uqOmegaIbbX = tmp31a.getElementAtIndex(0) + gyroNoiseX;</span>
<span class="fc" id="L464">        final double uqOmegaIbbY = tmp31a.getElementAtIndex(1) + gyroNoiseY;</span>
<span class="fc" id="L465">        final double uqOmegaIbbZ = tmp31a.getElementAtIndex(2) + gyroNoiseZ;</span>

        // Quantize accelerometer outputs
<span class="fc bfc" id="L468" title="All 4 branches covered.">        if (errors.getAccelerometerQuantizationLevel() &gt; 0.0</span>
                &amp;&amp; oldQuantizationResiduals != null) {
<span class="fc" id="L470">            final double accelQuantLevel = errors.getAccelerometerQuantizationLevel();</span>
<span class="fc" id="L471">            final double fx = accelQuantLevel</span>
<span class="fc" id="L472">                    * Math.round((uqFibbX + oldQuantizationResiduals[0])</span>
                    / accelQuantLevel);
<span class="fc" id="L474">            final double fy = accelQuantLevel</span>
<span class="fc" id="L475">                    * Math.round((uqFibbY + oldQuantizationResiduals[1])</span>
                    / accelQuantLevel);
<span class="fc" id="L477">            final double fz = accelQuantLevel</span>
<span class="fc" id="L478">                    * Math.round((uqFibbZ + oldQuantizationResiduals[2])</span>
                    / accelQuantLevel);

<span class="fc" id="L481">            result.setSpecificForceCoordinates(fx, fy, fz);</span>

<span class="pc bpc" id="L483" title="1 of 2 branches missed.">            if (quantizationResiduals != null) {</span>
<span class="fc" id="L484">                quantizationResiduals[0] = uqFibbX + oldQuantizationResiduals[0] - fx;</span>
<span class="fc" id="L485">                quantizationResiduals[1] = uqFibbY + oldQuantizationResiduals[1] - fy;</span>
<span class="fc" id="L486">                quantizationResiduals[2] = uqFibbZ + oldQuantizationResiduals[2] - fz;</span>
            }
<span class="fc" id="L488">        } else {</span>
<span class="fc" id="L489">            result.setSpecificForceCoordinates(uqFibbX, uqFibbY, uqFibbZ);</span>

<span class="fc bfc" id="L491" title="All 2 branches covered.">            if (quantizationResiduals != null) {</span>
<span class="fc" id="L492">                quantizationResiduals[0] = 0.0;</span>
<span class="fc" id="L493">                quantizationResiduals[1] = 0.0;</span>
<span class="fc" id="L494">                quantizationResiduals[2] = 0.0;</span>
            }
        }

        // Quantize gyro outputs
<span class="fc bfc" id="L499" title="All 4 branches covered.">        if (errors.getGyroQuantizationLevel() &gt; 0.0</span>
                &amp;&amp; oldQuantizationResiduals != null) {
<span class="fc" id="L501">            final double gyroQuantLevel = errors.getGyroQuantizationLevel();</span>
<span class="fc" id="L502">            final double omegaX = gyroQuantLevel</span>
<span class="fc" id="L503">                    * Math.round((uqOmegaIbbX + oldQuantizationResiduals[3])</span>
                    / gyroQuantLevel);
<span class="fc" id="L505">            final double omegaY = gyroQuantLevel</span>
<span class="fc" id="L506">                    * Math.round((uqOmegaIbbY + oldQuantizationResiduals[4])</span>
                    / gyroQuantLevel);
<span class="fc" id="L508">            final double omegaZ = gyroQuantLevel</span>
<span class="fc" id="L509">                    * Math.round((uqOmegaIbbZ + oldQuantizationResiduals[5])</span>
                    / gyroQuantLevel);

<span class="fc" id="L512">            result.setAngularRateCoordinates(omegaX, omegaY, omegaZ);</span>

<span class="pc bpc" id="L514" title="1 of 2 branches missed.">            if (quantizationResiduals != null) {</span>
<span class="fc" id="L515">                quantizationResiduals[3] = uqOmegaIbbX + oldQuantizationResiduals[3]</span>
                        - omegaX;
<span class="fc" id="L517">                quantizationResiduals[4] = uqOmegaIbbY + oldQuantizationResiduals[4]</span>
                        - omegaY;
<span class="fc" id="L519">                quantizationResiduals[5] = uqOmegaIbbZ + oldQuantizationResiduals[5]</span>
                        - omegaZ;
            }
<span class="fc" id="L522">        } else {</span>
<span class="fc" id="L523">            result.setAngularRateCoordinates(uqOmegaIbbX, uqOmegaIbbY, uqOmegaIbbZ);</span>

<span class="fc bfc" id="L525" title="All 2 branches covered.">            if (quantizationResiduals != null) {</span>
<span class="fc" id="L526">                quantizationResiduals[3] = 0.0;</span>
<span class="fc" id="L527">                quantizationResiduals[4] = 0.0;</span>
<span class="fc" id="L528">                quantizationResiduals[5] = 0.0;</span>
            }
        }
<span class="fc" id="L531">    }</span>

    /**
     * Converts provided time instance to seconds.
     *
     * @param time time instance to be converted.
     * @return converted value.
     */
    private static double convertTime(final Time time) {
<span class="fc" id="L540">        return TimeConverter.convert(time.getValue().doubleValue(),</span>
<span class="fc" id="L541">                time.getUnit(), TimeUnit.SECOND);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>