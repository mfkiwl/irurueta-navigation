<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>IMUErrors.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.irurueta:irurueta-navigation</a> &gt; <a href="index.source.html" class="el_package">com.irurueta.navigation.inertial.calibration</a> &gt; <span class="el_source">IMUErrors.java</span></div><h1>IMUErrors.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2020 Alberto Irurueta Carro (alberto@irurueta.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.irurueta.navigation.inertial.calibration;

import com.irurueta.algebra.Matrix;
import com.irurueta.algebra.WrongSizeException;
import com.irurueta.units.Acceleration;
import com.irurueta.units.AccelerationConverter;
import com.irurueta.units.AccelerationUnit;
import com.irurueta.units.AngularSpeed;
import com.irurueta.units.AngularSpeedConverter;
import com.irurueta.units.AngularSpeedUnit;

import java.io.Serializable;
import java.util.Arrays;
import java.util.Objects;

/**
 * Contains Inertial Measurement Unit (IMU) errors statistics obtained from
 * calibration.
 * This data can also be used to generate synthetic IMU data.
 */
public class IMUErrors implements Serializable, Cloneable {

    /**
     * Number of components of accelerometer measures.
     */
    public static final int ACCELEROMETER_COMPONENTS = 3;

    /**
     * Number of components og gyro measures.
     */
    public static final int GYRO_COMPONENTS = 3;

    /**
     * Number of components minus one.
     */
    private static final int COMPONENTS_MINUS_ONE = 2;

    /**
     * Accelerometer biases for each IMU axis expressed in meters per squared
     * second (m/s^2).
     * By default it is assumed to be all zeros.
     */
<span class="fc" id="L58">    private double[] mAccelerometerBiases = new double[ACCELEROMETER_COMPONENTS];</span>

    /**
     * Gyro biases for each IMU axis expressed in radians per second (rad/s).
     * By default it is assumed to be all zeros.
     */
<span class="fc" id="L64">    private double[] mGyroBiases = new double[GYRO_COMPONENTS];</span>

    /**
     * Contains accelerometer scale factors and cross coupling errors.
     * This is the product of matrix Ta containing cross coupling errors and Ka
     * containing scaling factors.
     * So tat:
     * &lt;pre&gt;
     *     Ma = [sx    mxy  mxz] = Ta*Ka
     *          [myx   sy   myz]
     *          [mzx   mzy  sz ]
     * &lt;/pre&gt;
     * Where:
     * &lt;pre&gt;
     *     Ka = [sx 0   0 ]
     *          [0  sy  0 ]
     *          [0  0   sz]
     * &lt;/pre&gt;
     * and
     * &lt;pre&gt;
     *     Ta = [1          -alphaXy    alphaXz ]
     *          [alphaYx    1           -alphaYz]
     *          [-alphaZx   alphaZy     1       ]
     * &lt;/pre&gt;
     * Hence:
     * &lt;pre&gt;
     *     Ma = [sx    mxy  mxz] = Ta*Ka =  [sx             -sy * alphaXy   sz * alphaXz ]
     *          [myx   sy   myz]            [sx * alphaYx   sy              -sz * alphaYz]
     *          [mzx   mzy  sz ]            [-sx * alphaZx  sy * alphaZy    sz           ]
     * &lt;/pre&gt;
     * This instance allows any 3x3 matrix however, typically alphaYx, alphaZx and alphaZy
     * are considered to be zero if the accelerometer z-axis is assumed to be the same
     * as the body z-axis. When this is assumed, myx = mzx = mzy = 0 and the Ma matrix
     * becomes upper diagonal:
     * &lt;pre&gt;
     *     Ma = [sx    mxy  mxz]
     *          [0     sy   myz]
     *          [0     0    sz ]
     * &lt;/pre&gt;
     * Values of this matrix are unitless.
     * By default it is the 3x3 zero matrix.
     */
    private Matrix mAccelerometerScaleFactorAndCrossCouplingErrors;

    /**
     * Contains gyro scale factors and cross coupling errors.
     * This is the product of matrix Tg containing cross coupling errors and Kg
     * containing scaling factors.
     * So tat:
     * &lt;pre&gt;
     *     Mg = [sx    mxy  mxz] = Tg*Kg
     *          [myx   sy   myz]
     *          [mzx   mzy  sz ]
     * &lt;/pre&gt;
     * Where:
     * &lt;pre&gt;
     *     Kg = [sx 0   0 ]
     *          [0  sy  0 ]
     *          [0  0   sz]
     * &lt;/pre&gt;
     * and
     * &lt;pre&gt;
     *     Tg = [1          -gammaXy    gammaXz ]
     *          [gammaYx    1           -gammaYz]
     *          [-gammaZx   gammaZy     1       ]
     * &lt;/pre&gt;
     * Hence:
     * &lt;pre&gt;
     *     Mg = [sx    mxy  mxz] = Tg*Kg =  [sx             -sy * gammaXy   sz * gammaXz ]
     *          [myx   sy   myz]            [sx * gammaYx   sy              -sz * gammaYz]
     *          [mzx   mzy  sz ]            [-sx * gammaZx  sy * gammaZy    sz           ]
     * &lt;/pre&gt;
     * This instance allows any 3x3 matrix however, typically gammaYx, gammaZx and gammaZy
     * are considered to be zero if the accelerometer z-axis is assumed to be the same
     * as the body z-axis. When this is assumed, myx = mzx = mzy = 0 and the Ma matrix
     * becomes upper diagonal:
     * &lt;pre&gt;
     *     Ma = [sx    mxy  mxz]
     *          [0     sy   myz]
     *          [0     0    sz ]
     * &lt;/pre&gt;
     * Values of this matrix are unitless.
     * By default it is the 3x3 zero matrix.
     */
    private Matrix mGyroScaleFactorAndCrossCouplingErrors;

    /**
     * 3x3 matrix containing cross biases introduced by the specific forces sensed
     * by the accelerometer.
     * Values of this matrix are expressed in (rad-sec/m).
     * By default it is all zeros.
     */
    private Matrix mGyroGDependentBiases;

    /**
     * Accelerometer noise root PSD expressed in (m * s^-1.5).
     * By default it is zero.
     */
    private double mAccelerometerNoiseRootPSD;

    /**
     * Gyro noise root PSD expressed in (rad * s^-0.5).
     * By default it is zero.
     */
    private double mGyroNoiseRootPSD;

    /**
     * Accelerometer quantization level expressed in meters per squared second (m/s^2).
     * By default it is zero when no quantization is assumed.
     */
    private double mAccelerometerQuantizationLevel;

    /**
     * Gyro quantization level expressed in radians per second (rad/s).
     */
    private double mGyroQuantizationLevel;

    /**
     * Constructor.
     */
<span class="fc" id="L184">    public IMUErrors() {</span>
        try {
<span class="fc" id="L186">            mAccelerometerScaleFactorAndCrossCouplingErrors = Matrix.identity(</span>
                    ACCELEROMETER_COMPONENTS, ACCELEROMETER_COMPONENTS);
<span class="fc" id="L188">            mGyroScaleFactorAndCrossCouplingErrors = Matrix.identity(</span>
                    GYRO_COMPONENTS, GYRO_COMPONENTS);
<span class="fc" id="L190">            mGyroGDependentBiases = new Matrix(</span>
                    ACCELEROMETER_COMPONENTS, ACCELEROMETER_COMPONENTS);
<span class="nc" id="L192">        } catch (final WrongSizeException ignore) {</span>
            // never happens
<span class="fc" id="L194">        }</span>
<span class="fc" id="L195">    }</span>

    /**
     * Constructor.
     *
     * @param accelerometerBiases                            accelerometer biases for each IMU axis expressed in meters
     *                                                       per squared second (m/s^2). Must have length 3.
     * @param gyroBiases                                     gyro biases for each IMU axis expressed in radians per
     *                                                       second (rad/s). Must have length 3.
     * @param accelerometerScaleFactorAndCrossCouplingErrors accelerometer scale factors and cross coupling errors.
     *                                                       Must be 3x3.
     * @param gyroScaleFactorAndCrossCouplingErrors          gyro scale factors and cross coupling errors. Must be 3x3.
     * @param accelerometerNoiseRootPSD                      accelerometer noise root PSD expressed in (m * s^-1.5).
     * @param gyroNoiseRootPSD                               gyro noise root PSD expressed in (rad * s^-0.5).
     * @throws IllegalArgumentException if any value is invalid.
     */
    public IMUErrors(final double[] accelerometerBiases,
                     final double[] gyroBiases,
                     final Matrix accelerometerScaleFactorAndCrossCouplingErrors,
                     final Matrix gyroScaleFactorAndCrossCouplingErrors,
                     final double accelerometerNoiseRootPSD,
                     final double gyroNoiseRootPSD) {
<span class="fc" id="L217">        this();</span>
<span class="fc" id="L218">        setAccelerometerBiases(accelerometerBiases);</span>
<span class="fc" id="L219">        setGyroBiases(gyroBiases);</span>
<span class="fc" id="L220">        setAccelerometerScaleFactorAndCrossCouplingErrors(</span>
                accelerometerScaleFactorAndCrossCouplingErrors);
<span class="fc" id="L222">        setGyroScaleFactorAndCrossCouplingErrors(</span>
                gyroScaleFactorAndCrossCouplingErrors);
<span class="fc" id="L224">        setAccelerometerNoiseRootPSD(accelerometerNoiseRootPSD);</span>
<span class="fc" id="L225">        setGyroNoiseRootPSD(gyroNoiseRootPSD);</span>
<span class="fc" id="L226">    }</span>

    /**
     * Constructor.
     *
     * @param accelerometerBiases                            accelerometer biases for each IMU axis expressed in meters
     *                                                       per squared second (m/s^2). Must be 3x1.
     * @param gyroBiases                                     gyro biases for each IMU axis expressed in radians per
     *                                                       second (rad/s). Must be 3x1.
     * @param accelerometerScaleFactorAndCrossCouplingErrors accelerometer scale factors and cross coupling errors.
     *                                                       Must be 3x3.
     * @param gyroScaleFactorAndCrossCouplingErrors          gyro scale factors and cross coupling errors. Must be 3x3.
     * @param accelerometerNoiseRootPSD                      accelerometer noise root PSD expressed in (m * s^-1.5).
     * @param gyroNoiseRootPSD                               gyro noise root PSD expressed in (rad * s^-0.5).
     * @throws IllegalArgumentException if any value is invalid.
     */
    public IMUErrors(final Matrix accelerometerBiases,
                     final Matrix gyroBiases,
                     final Matrix accelerometerScaleFactorAndCrossCouplingErrors,
                     final Matrix gyroScaleFactorAndCrossCouplingErrors,
                     final double accelerometerNoiseRootPSD,
                     final double gyroNoiseRootPSD) {
<span class="fc" id="L248">        this();</span>
<span class="fc" id="L249">        setAccelerometerBiases(accelerometerBiases);</span>
<span class="fc" id="L250">        setGyroBiases(gyroBiases);</span>
<span class="fc" id="L251">        setAccelerometerScaleFactorAndCrossCouplingErrors(</span>
                accelerometerScaleFactorAndCrossCouplingErrors);
<span class="fc" id="L253">        setGyroScaleFactorAndCrossCouplingErrors(</span>
                gyroScaleFactorAndCrossCouplingErrors);
<span class="fc" id="L255">        setAccelerometerNoiseRootPSD(accelerometerNoiseRootPSD);</span>
<span class="fc" id="L256">        setGyroNoiseRootPSD(gyroNoiseRootPSD);</span>
<span class="fc" id="L257">    }</span>

    /**
     * Constructor.
     *
     * @param accelerometerBiases                            accelerometer biases for each IMU axis. Must have length 3.
     * @param gyroBiases                                     gyro biases for each IMU axis. Must have length 3.
     * @param accelerometerScaleFactorAndCrossCouplingErrors accelerometer scale factors and cross coupling errors.
     *                                                       Must be 3x3.
     * @param gyroScaleFactorAndCrossCouplingErrors          gyro scale factors and cross coupling errors. Must be 3x3.
     * @param accelerometerNoiseRootPSD                      accelerometer noise root PSD expressed in (m * s^-1.5).
     * @param gyroNoiseRootPSD                               gyro noise root PSD expressed in (rad * s^-0.5).
     * @throws IllegalArgumentException if any value is invalid.
     */
    public IMUErrors(final Acceleration[] accelerometerBiases,
                     final AngularSpeed[] gyroBiases,
                     final Matrix accelerometerScaleFactorAndCrossCouplingErrors,
                     final Matrix gyroScaleFactorAndCrossCouplingErrors,
                     final double accelerometerNoiseRootPSD,
                     final double gyroNoiseRootPSD) {
<span class="fc" id="L277">        this();</span>
<span class="fc" id="L278">        setAccelerometerBiases(accelerometerBiases);</span>
<span class="fc" id="L279">        setGyroBiases(gyroBiases);</span>
<span class="fc" id="L280">        setAccelerometerScaleFactorAndCrossCouplingErrors(</span>
                accelerometerScaleFactorAndCrossCouplingErrors);
<span class="fc" id="L282">        setGyroScaleFactorAndCrossCouplingErrors(</span>
                gyroScaleFactorAndCrossCouplingErrors);
<span class="fc" id="L284">        setAccelerometerNoiseRootPSD(accelerometerNoiseRootPSD);</span>
<span class="fc" id="L285">        setGyroNoiseRootPSD(gyroNoiseRootPSD);</span>
<span class="fc" id="L286">    }</span>

    /**
     * Constructor.
     *
     * @param accelerometerBiases                            accelerometer biases for each IMU axis expressed in meters
     *                                                       per squared second (m/s^2). Must have length 3.
     * @param gyroBiases                                     gyro biases for each IMU axis expressed in radians per
     *                                                       second (rad/s). Must have length 3.
     * @param accelerometerScaleFactorAndCrossCouplingErrors accelerometer scale factors and cross coupling errors.
     *                                                       Must be 3x3.
     * @param gyroScaleFactorAndCrossCouplingErrors          gyro scale factors and cross coupling errors. Must be 3x3.
     * @param gyroGDependentBiases                           Cross biases introduced by the specific forces sensed by
     *                                                       the accelerometer expressed in (rad-sec/m). Must be 3x3.
     * @param accelerometerNoiseRootPSD                      accelerometer noise root PSD expressed in (m * s^-1.5).
     * @param gyroNoiseRootPSD                               gyro noise root PSD expressed in (rad * s^-0.5).
     * @param accelerometerQuantizationLevel                 accelerometer quantization level expressed in meters per
     *                                                       squared second (m/s^2).
     * @param gyroQuantizationLevel                          gyro quantization level expressed in radians per second
     *                                                       (rad/s).
     * @throws IllegalArgumentException if any value is invalid.
     */
    public IMUErrors(final double[] accelerometerBiases,
                     final double[] gyroBiases,
                     final Matrix accelerometerScaleFactorAndCrossCouplingErrors,
                     final Matrix gyroScaleFactorAndCrossCouplingErrors,
                     final Matrix gyroGDependentBiases,
                     final double accelerometerNoiseRootPSD,
                     final double gyroNoiseRootPSD,
                     final double accelerometerQuantizationLevel,
                     final double gyroQuantizationLevel) {
<span class="fc" id="L317">        this();</span>
<span class="fc" id="L318">        setAccelerometerBiases(accelerometerBiases);</span>
<span class="fc" id="L319">        setGyroBiases(gyroBiases);</span>
<span class="fc" id="L320">        setAccelerometerScaleFactorAndCrossCouplingErrors(</span>
                accelerometerScaleFactorAndCrossCouplingErrors);
<span class="fc" id="L322">        setGyroScaleFactorAndCrossCouplingErrors(</span>
                gyroScaleFactorAndCrossCouplingErrors);
<span class="fc" id="L324">        setGyroGDependentBiases(gyroGDependentBiases);</span>
<span class="fc" id="L325">        setAccelerometerNoiseRootPSD(accelerometerNoiseRootPSD);</span>
<span class="fc" id="L326">        setGyroNoiseRootPSD(gyroNoiseRootPSD);</span>
<span class="fc" id="L327">        setAccelerometerQuantizationLevel(accelerometerQuantizationLevel);</span>
<span class="fc" id="L328">        setGyroQuantizationLevel(gyroQuantizationLevel);</span>
<span class="fc" id="L329">    }</span>

    /**
     * Constructor.
     *
     * @param accelerometerBiases                            accelerometer biases for each IMU axis expressed in meters
     *                                                       per squared second (m/s^2). Must be 3x1.
     * @param gyroBiases                                     gyro biases for each IMU axis expressed in radians per
     *                                                       second (rad/s). Must be 3x1.
     * @param accelerometerScaleFactorAndCrossCouplingErrors accelerometer scale factors and cross coupling errors.
     *                                                       Must be 3x3.
     * @param gyroScaleFactorAndCrossCouplingErrors          gyro scale factors and cross coupling errors. Must be 3x3.
     * @param gyroGDependentBiases                           Cross biases introduced by the specific forces sensed by
     *                                                       the accelerometer expressed in (rad-sec/m). Must be 3x3.
     * @param accelerometerNoiseRootPSD                      accelerometer noise root PSD expressed in (m * s^-1.5).
     * @param gyroNoiseRootPSD                               gyro noise root PSD expressed in (rad * s^-0.5).
     * @param accelerometerQuantizationLevel                 accelerometer quantization level expressed in meters per
     *                                                       squared second (m/s^2).
     * @param gyroQuantizationLevel                          gyro quantization level expressed in radians per second
     *                                                       (rad/s).
     * @throws IllegalArgumentException if any value is invalid.
     */
    public IMUErrors(final Matrix accelerometerBiases,
                     final Matrix gyroBiases,
                     final Matrix accelerometerScaleFactorAndCrossCouplingErrors,
                     final Matrix gyroScaleFactorAndCrossCouplingErrors,
                     final Matrix gyroGDependentBiases,
                     final double accelerometerNoiseRootPSD,
                     final double gyroNoiseRootPSD,
                     final double accelerometerQuantizationLevel,
                     final double gyroQuantizationLevel) {
<span class="fc" id="L360">        this();</span>
<span class="fc" id="L361">        setAccelerometerBiases(accelerometerBiases);</span>
<span class="fc" id="L362">        setGyroBiases(gyroBiases);</span>
<span class="fc" id="L363">        setAccelerometerScaleFactorAndCrossCouplingErrors(</span>
                accelerometerScaleFactorAndCrossCouplingErrors);
<span class="fc" id="L365">        setGyroScaleFactorAndCrossCouplingErrors(</span>
                gyroScaleFactorAndCrossCouplingErrors);
<span class="fc" id="L367">        setGyroGDependentBiases(gyroGDependentBiases);</span>
<span class="fc" id="L368">        setAccelerometerNoiseRootPSD(accelerometerNoiseRootPSD);</span>
<span class="fc" id="L369">        setGyroNoiseRootPSD(gyroNoiseRootPSD);</span>
<span class="fc" id="L370">        setAccelerometerQuantizationLevel(accelerometerQuantizationLevel);</span>
<span class="fc" id="L371">        setGyroQuantizationLevel(gyroQuantizationLevel);</span>
<span class="fc" id="L372">    }</span>

    /**
     * Constructor.
     *
     * @param accelerometerBiases                            accelerometer biases for each IMU axis. Must have length 3.
     * @param gyroBiases                                     gyro biases for each IMU axis. Must have length 3.
     * @param accelerometerScaleFactorAndCrossCouplingErrors accelerometer scale factors and cross coupling errors.
     *                                                       Must be 3x3.
     * @param gyroScaleFactorAndCrossCouplingErrors          gyro scale factors and cross coupling errors. Must be 3x3.
     * @param gyroGDependentBiases                           Cross biases introduced by the specific forces sensed by
     *                                                       the accelerometer expressed in (rad-sec/m). Must be 3x3.
     * @param accelerometerNoiseRootPSD                      accelerometer noise root PSD expressed in (m * s^-1.5).
     * @param gyroNoiseRootPSD                               gyro noise root PSD expressed in (rad * s^-0.5).
     * @param accelerometerQuantizationLevel                 accelerometer quantization level.
     * @param gyroQuantizationLevel                          gyro quantization level.
     * @throws IllegalArgumentException if any value is invalid.
     */
    public IMUErrors(final Acceleration[] accelerometerBiases,
                     final AngularSpeed[] gyroBiases,
                     final Matrix accelerometerScaleFactorAndCrossCouplingErrors,
                     final Matrix gyroScaleFactorAndCrossCouplingErrors,
                     final Matrix gyroGDependentBiases,
                     final double accelerometerNoiseRootPSD,
                     final double gyroNoiseRootPSD,
                     final Acceleration accelerometerQuantizationLevel,
                     final AngularSpeed gyroQuantizationLevel) {
<span class="fc" id="L399">        this();</span>
<span class="fc" id="L400">        setAccelerometerBiases(accelerometerBiases);</span>
<span class="fc" id="L401">        setGyroBiases(gyroBiases);</span>
<span class="fc" id="L402">        setAccelerometerScaleFactorAndCrossCouplingErrors(</span>
                accelerometerScaleFactorAndCrossCouplingErrors);
<span class="fc" id="L404">        setGyroScaleFactorAndCrossCouplingErrors(</span>
                gyroScaleFactorAndCrossCouplingErrors);
<span class="fc" id="L406">        setGyroGDependentBiases(gyroGDependentBiases);</span>
<span class="fc" id="L407">        setAccelerometerNoiseRootPSD(accelerometerNoiseRootPSD);</span>
<span class="fc" id="L408">        setGyroNoiseRootPSD(gyroNoiseRootPSD);</span>
<span class="fc" id="L409">        setAccelerometerQuantizationLevel(accelerometerQuantizationLevel);</span>
<span class="fc" id="L410">        setGyroQuantizationLevel(gyroQuantizationLevel);</span>
<span class="fc" id="L411">    }</span>

    /**
     * Constructor.
     *
     * @param input instance to copy data from.
     */
    @SuppressWarnings(&quot;CopyConstructorMissesField&quot;)
    public IMUErrors(final IMUErrors input) {
<span class="fc" id="L420">        this();</span>
<span class="fc" id="L421">        copyFrom(input);</span>
<span class="fc" id="L422">    }</span>

    /**
     * Gets accelerometer biases for each IMU axis expressed in meters per squared
     * second (m/s^2).
     * By default it is assumed to be all zeros.
     *
     * @return accelerometer biases for each IMU axis.
     */
    public double[] getAccelerometerBiases() {
<span class="fc" id="L432">        final double[] result = new double[ACCELEROMETER_COMPONENTS];</span>
<span class="fc" id="L433">        getAccelerometerBiases(result);</span>
<span class="fc" id="L434">        return result;</span>
    }

    /**
     * Gets accelerometer biases for each IMU axis expressed in meters per squared
     * second (m/s^2).
     * By default it is assumed to be all zeros.
     *
     * @param result instance where data will be stored.
     * @throws IllegalArgumentException if provided array does not have length 3.
     */
    public void getAccelerometerBiases(final double[] result) {
<span class="fc bfc" id="L446" title="All 2 branches covered.">        if (result.length != ACCELEROMETER_COMPONENTS) {</span>
<span class="fc" id="L447">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L450">        System.arraycopy(mAccelerometerBiases, 0, result, 0,</span>
                ACCELEROMETER_COMPONENTS);
<span class="fc" id="L452">    }</span>

    /**
     * Sets accelerometer biases for each IMU axis expressed in meters per squared
     * second (m/s^2).
     *
     * @param accelerometerBiases accelerometer biases for each IMU axis.
     * @throws IllegalArgumentException if provided array does not have length 3.
     */
    public void setAccelerometerBiases(final double[] accelerometerBiases) {
<span class="fc bfc" id="L462" title="All 2 branches covered.">        if (accelerometerBiases.length != ACCELEROMETER_COMPONENTS) {</span>
<span class="fc" id="L463">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L466">        mAccelerometerBiases = accelerometerBiases;</span>
<span class="fc" id="L467">    }</span>

    /**
     * Gets accelerometer biases for each IMU axis expressed in meters per squared
     * second (m/s^2) as a column matrix.
     * By default it is assumed to be all zeros.
     *
     * @return 3x1 column matrix containing accelerometer biases for each IMU axis.
     */
    public Matrix getAccelerometerBiasesAsMatrix() {
<span class="fc" id="L477">        return Matrix.newFromArray(mAccelerometerBiases);</span>
    }

    /**
     * Gets accelerometer biases for each IMU axis expressed in meters per squared
     * second (m/s^2) as a column matrix.
     * By default it is assumed to be all zeros.
     *
     * @param result instance where data will be stored.
     * @throws IllegalArgumentException if provided result matrix is not 3x1.
     */
    public void getAccelerometerBiasesAsMatrix(final Matrix result) {
<span class="fc" id="L489">        result.setSubmatrix(0, 0,</span>
                COMPONENTS_MINUS_ONE, 0,
                mAccelerometerBiases);
<span class="fc" id="L492">    }</span>

    /**
     * Sets accelerometer biases for each IMU axis expressed in meters per squared
     * second (m/s^2) from a 3x1 column matrix.
     *
     * @param accelerometerBiases 3x1 column matrix containing values to be set.
     * @throws IllegalArgumentException if provided matrix is not 3x1.
     */
    public void setAccelerometerBiases(final Matrix accelerometerBiases) {
<span class="fc bfc" id="L502" title="All 2 branches covered.">        if (accelerometerBiases.getRows() != ACCELEROMETER_COMPONENTS ||</span>
<span class="fc bfc" id="L503" title="All 2 branches covered.">                accelerometerBiases.getColumns() != 1) {</span>
<span class="fc" id="L504">            throw new IllegalArgumentException();</span>
        }

        try {
<span class="fc" id="L508">            accelerometerBiases.getSubmatrixAsArray(0, 0,</span>
                    COMPONENTS_MINUS_ONE, 0, mAccelerometerBiases);
<span class="nc" id="L510">        } catch (final WrongSizeException ignore) {</span>
            // never happens
<span class="fc" id="L512">        }</span>
<span class="fc" id="L513">    }</span>

    /**
     * Gets accelerometer biases for each IMU axis.
     * By default it is assumed to be all zeros.
     *
     * @return accelerometer biases for each IMU axis.
     */
    public Acceleration[] getAccelerometerBiasesAsAcceleration() {
<span class="fc" id="L522">        final Acceleration[] result = new Acceleration[ACCELEROMETER_COMPONENTS];</span>
<span class="fc" id="L523">        getAccelerometerBiasesAsAcceleration(result);</span>
<span class="fc" id="L524">        return result;</span>
    }

    /**
     * Gets accelerometer biases for each IMU axis.
     * By default it is assumed to be all zeros.
     *
     * @param result instance where data will be copied to.
     * @throws IllegalArgumentException if provided array does not have length 3.
     */
    public void getAccelerometerBiasesAsAcceleration(final Acceleration[] result) {
<span class="fc bfc" id="L535" title="All 2 branches covered.">        if (result.length != ACCELEROMETER_COMPONENTS) {</span>
<span class="fc" id="L536">            throw new IllegalArgumentException();</span>
        }

<span class="fc bfc" id="L539" title="All 2 branches covered.">        for (int i = 0; i &lt; ACCELEROMETER_COMPONENTS; i++) {</span>
<span class="fc" id="L540">            Acceleration a = result[i];</span>
<span class="fc bfc" id="L541" title="All 2 branches covered.">            if (a == null) {</span>
<span class="fc" id="L542">                result[i] = new Acceleration(mAccelerometerBiases[i],</span>
                        AccelerationUnit.METERS_PER_SQUARED_SECOND);
            } else {
<span class="fc" id="L545">                a.setValue(mAccelerometerBiases[i]);</span>
<span class="fc" id="L546">                a.setUnit(AccelerationUnit.METERS_PER_SQUARED_SECOND);</span>
            }
        }
<span class="fc" id="L549">    }</span>

    /**
     * Sets accelerometer biases for each IMU axis.
     *
     * @param accelerometerBiases accelerometer biases to be set.
     * @throws IllegalArgumentException if provided array does not have length 3.
     */
    public void setAccelerometerBiases(final Acceleration[] accelerometerBiases) {
<span class="fc bfc" id="L558" title="All 2 branches covered.">        if (accelerometerBiases.length != ACCELEROMETER_COMPONENTS) {</span>
<span class="fc" id="L559">            throw new IllegalArgumentException();</span>
        }

<span class="fc bfc" id="L562" title="All 2 branches covered.">        for (int i = 0; i &lt; ACCELEROMETER_COMPONENTS; i++) {</span>
<span class="fc" id="L563">            mAccelerometerBiases[i] = convertAcceleration(accelerometerBiases[i]);</span>
        }
<span class="fc" id="L565">    }</span>

    /**
     * Gets gyro biases for each IMU axis expressed in radians per second (rad/s).
     * By default it is assumed to be all zeros.
     *
     * @return gyro biases for each IMU axis.
     */
    public double[] getGyroBiases() {
<span class="fc" id="L574">        final double[] result = new double[GYRO_COMPONENTS];</span>
<span class="fc" id="L575">        getGyroBiases(result);</span>
<span class="fc" id="L576">        return result;</span>
    }

    /**
     * Gets gyro biases for each IMU axis expressed in radians per second (rad/s).
     * By default it is assumed to be all zeros.
     *
     * @param result instance where data will be stored.
     * @throws IllegalArgumentException if provided array does not have length 3.
     */
    public void getGyroBiases(final double[] result) {
<span class="fc bfc" id="L587" title="All 2 branches covered.">        if (result.length != GYRO_COMPONENTS) {</span>
<span class="fc" id="L588">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L591">        System.arraycopy(mGyroBiases, 0, result, 0, GYRO_COMPONENTS);</span>
<span class="fc" id="L592">    }</span>

    /**
     * Sets gyro biases for each IMU axis expressed in radians per second (rad/s).
     *
     * @param gyroBiases gyro biases for each IMU axis.
     * @throws IllegalArgumentException if provided array does not have length 3.
     */
    public void setGyroBiases(final double[] gyroBiases) {
<span class="fc bfc" id="L601" title="All 2 branches covered.">        if (gyroBiases.length != GYRO_COMPONENTS) {</span>
<span class="fc" id="L602">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L605">        mGyroBiases = gyroBiases;</span>
<span class="fc" id="L606">    }</span>

    /**
     * Gets gyro biases for each IMU axis expressed in radians per second (rad/s)
     * as a column matrix.
     * By default it is assumed to be all zeros.
     *
     * @return 3x1 column matrix containing gyro biases for each IMU axis.
     */
    public Matrix getGyroBiasesAsMatrix() {
<span class="fc" id="L616">        return Matrix.newFromArray(mGyroBiases);</span>
    }

    /**
     * Gets gyro biases for each IMU axis expressed in radians per second (rad/s)
     * as a column matrix.
     * By default it is assumed to be all zeros.
     *
     * @param result instance where data will be stored.
     * @throws IllegalArgumentException if provided result matrix is not 3x1.
     */
    public void getGyroBiasesAsMatrix(final Matrix result) {
<span class="fc" id="L628">        result.setSubmatrix(0, 0,</span>
                COMPONENTS_MINUS_ONE, 0, mGyroBiases);
<span class="fc" id="L630">    }</span>

    /**
     * Sets gyro biases for each IMU axis expressed in radians per second (rad/s)
     * from a 3x1 column matrix.
     *
     * @param gyroBiases 3x1 column matrix containing values to be set.
     * @throws IllegalArgumentException if provided matrix is not 3x1.
     */
    public void setGyroBiases(final Matrix gyroBiases) {
<span class="fc bfc" id="L640" title="All 2 branches covered.">        if (gyroBiases.getRows() != GYRO_COMPONENTS ||</span>
<span class="fc bfc" id="L641" title="All 2 branches covered.">                gyroBiases.getColumns() != 1) {</span>
<span class="fc" id="L642">            throw new IllegalArgumentException();</span>
        }

        try {
<span class="fc" id="L646">            gyroBiases.getSubmatrixAsArray(0, 0,</span>
                    COMPONENTS_MINUS_ONE, 0, mGyroBiases);
<span class="nc" id="L648">        } catch (final WrongSizeException ignore) {</span>
            // never happens
<span class="fc" id="L650">        }</span>
<span class="fc" id="L651">    }</span>

    /**
     * Gets gyro biases for each IMU axis.
     * By default it is assumed to be all zeros.
     *
     * @return gyro biases for each IMU axis.
     */
    public AngularSpeed[] getGyroBiasesAsAngularSpeed() {
<span class="fc" id="L660">        final AngularSpeed[] result = new AngularSpeed[GYRO_COMPONENTS];</span>
<span class="fc" id="L661">        getGyroBiasesAsAngularspeed(result);</span>
<span class="fc" id="L662">        return result;</span>
    }

    /**
     * Gets gyro biases for each IMU axis.
     * By default it is assumed to be all zeros.
     *
     * @param result instance where data will be copied to.
     * @throws IllegalArgumentException if provided array does not have length 3.
     */
    public void getGyroBiasesAsAngularspeed(final AngularSpeed[] result) {
<span class="fc bfc" id="L673" title="All 2 branches covered.">        if (result.length != GYRO_COMPONENTS) {</span>
<span class="fc" id="L674">            throw new IllegalArgumentException();</span>
        }

<span class="fc bfc" id="L677" title="All 2 branches covered.">        for (int i = 0; i &lt; GYRO_COMPONENTS; i++) {</span>
<span class="fc" id="L678">            AngularSpeed as = result[i];</span>
<span class="fc bfc" id="L679" title="All 2 branches covered.">            if (as == null) {</span>
<span class="fc" id="L680">                result[i] = new AngularSpeed(mGyroBiases[i],</span>
                        AngularSpeedUnit.RADIANS_PER_SECOND);
            } else {
<span class="fc" id="L683">                as.setValue(mGyroBiases[i]);</span>
<span class="fc" id="L684">                as.setUnit(AngularSpeedUnit.RADIANS_PER_SECOND);</span>
            }
        }
<span class="fc" id="L687">    }</span>

    /**
     * Sets gyro biases for each IMU axis.
     *
     * @param gyroBiases gyro biases to be set.
     * @throws IllegalArgumentException if provided array does not have length 3.
     */
    public void setGyroBiases(final AngularSpeed[] gyroBiases) {
<span class="fc bfc" id="L696" title="All 2 branches covered.">        if (gyroBiases.length != GYRO_COMPONENTS) {</span>
<span class="fc" id="L697">            throw new IllegalArgumentException();</span>
        }

<span class="fc bfc" id="L700" title="All 2 branches covered.">        for (int i = 0; i &lt; GYRO_COMPONENTS; i++) {</span>
<span class="fc" id="L701">            mGyroBiases[i] = convertAngularSpeed(gyroBiases[i]);</span>
        }
<span class="fc" id="L703">    }</span>

    /**
     * Gets accelerometer scale factors and cross coupling errors.
     * This is the product of matrix Ta containing cross coupling errors and Ka
     * containing scaling factors.
     * So tat:
     * &lt;pre&gt;
     *     Ma = [sx    mxy  mxz] = Ta*Ka
     *          [myx   sy   myz]
     *          [mzx   mzy  sz ]
     * &lt;/pre&gt;
     * Where:
     * &lt;pre&gt;
     *     Ka = [sx 0   0 ]
     *          [0  sy  0 ]
     *          [0  0   sz]
     * &lt;/pre&gt;
     * and
     * &lt;pre&gt;
     *     Ta = [1          -alphaXy    alphaXz ]
     *          [alphaYx    1           -alphaYz]
     *          [-alphaZx   alphaZy     1       ]
     * &lt;/pre&gt;
     * Hence:
     * &lt;pre&gt;
     *     Ma = [sx    mxy  mxz] = Ta*Ka =  [sx             -sy * alphaXy   sz * alphaXz ]
     *          [myx   sy   myz]            [sx * alphaYx   sy              -sz * alphaYz]
     *          [mzx   mzy  sz ]            [-sx * alphaZx  sy * alphaZy    sz           ]
     * &lt;/pre&gt;
     * This instance allows any 3x3 matrix however, typically alphaYx, alphaZx and alphaZy
     * are considered to be zero if the accelerometer z-axis is assumed to be the same
     * as the body z-axis. When this is assumed, myx = mzx = mzy = 0 and the Ma matrix
     * becomes upper diagonal:
     * &lt;pre&gt;
     *     Ma = [sx    mxy  mxz]
     *          [0     sy   myz]
     *          [0     0    sz ]
     * &lt;/pre&gt;
     * Values of this matrix are unitless.
     * By default it is the 3x3 identity matrix.
     *
     * @return accelerometer scale factors and cross coupling errors.
     */
    public Matrix getAccelerometerScaleFactorAndCrossCouplingErrors() {
<span class="fc" id="L748">        return new Matrix(mAccelerometerScaleFactorAndCrossCouplingErrors);</span>
    }

    /**
     * Gets accelerometer scale factors and cross coupling errors.
     * This is the product of matrix Ta containing cross coupling errors and Ka
     * containing scaling factors.
     * So tat:
     * &lt;pre&gt;
     *     Ma = [sx    mxy  mxz] = Ta*Ka
     *          [myx   sy   myz]
     *          [mzx   mzy  sz ]
     * &lt;/pre&gt;
     * Where:
     * &lt;pre&gt;
     *     Ka = [sx 0   0 ]
     *          [0  sy  0 ]
     *          [0  0   sz]
     * &lt;/pre&gt;
     * and
     * &lt;pre&gt;
     *     Ta = [1          -alphaXy    alphaXz ]
     *          [alphaYx    1           -alphaYz]
     *          [-alphaZx   alphaZy     1       ]
     * &lt;/pre&gt;
     * Hence:
     * &lt;pre&gt;
     *     Ma = [sx    mxy  mxz] = Ta*Ka =  [sx             -sy * alphaXy   sz * alphaXz ]
     *          [myx   sy   myz]            [sx * alphaYx   sy              -sz * alphaYz]
     *          [mzx   mzy  sz ]            [-sx * alphaZx  sy * alphaZy    sz           ]
     * &lt;/pre&gt;
     * This instance allows any 3x3 matrix however, typically alphaYx, alphaZx and alphaZy
     * are considered to be zero if the accelerometer z-axis is assumed to be the same
     * as the body z-axis. When this is assumed, myx = mzx = mzy = 0 and the Ma matrix
     * becomes upper diagonal:
     * &lt;pre&gt;
     *     Ma = [sx    mxy  mxz]
     *          [0     sy   myz]
     *          [0     0    sz ]
     * &lt;/pre&gt;
     * Values of this matrix are unitless.
     * By default it is the 3x3 identity matrix.
     *
     * @param result instance where data of scale factor and cross coupling matrix will
     *               be copied to. If needed, result instance will be resized.
     */
    public void getAccelerometerScaleFactorAndCrossCouplingErrors(final Matrix result) {
<span class="fc" id="L795">        result.copyFrom(mAccelerometerScaleFactorAndCrossCouplingErrors);</span>
<span class="fc" id="L796">    }</span>

    /**
     * Sets accelerometer scale factors and cross coupling errors.
     * This is the product of matrix Ta containing cross coupling errors and Ka
     * containing scaling factors.
     * So tat:
     * &lt;pre&gt;
     *     Ma = [sx    mxy  mxz] = Ta*Ka
     *          [myx   sy   myz]
     *          [mzx   mzy  sz ]
     * &lt;/pre&gt;
     * Where:
     * &lt;pre&gt;
     *     Ka = [sx 0   0 ]
     *          [0  sy  0 ]
     *          [0  0   sz]
     * &lt;/pre&gt;
     * and
     * &lt;pre&gt;
     *     Ta = [1          -alphaXy    alphaXz ]
     *          [alphaYx    1           -alphaYz]
     *          [-alphaZx   alphaZy     1       ]
     * &lt;/pre&gt;
     * Hence:
     * &lt;pre&gt;
     *     Ma = [sx    mxy  mxz] = Ta*Ka =  [sx             -sy * alphaXy   sz * alphaXz ]
     *          [myx   sy   myz]            [sx * alphaYx   sy              -sz * alphaYz]
     *          [mzx   mzy  sz ]            [-sx * alphaZx  sy * alphaZy    sz           ]
     * &lt;/pre&gt;
     * This instance allows any 3x3 matrix however, typically alphaYx, alphaZx and alphaZy
     * are considered to be zero if the accelerometer z-axis is assumed to be the same
     * as the body z-axis. When this is assumed, myx = mzx = mzy = 0 and the Ma matrix
     * becomes upper diagonal:
     * &lt;pre&gt;
     *     Ma = [sx    mxy  mxz]
     *          [0     sy   myz]
     *          [0     0    sz ]
     * &lt;/pre&gt;
     * Values of this matrix are unitless.
     *
     * @param accelerometerScaleFactorAndCrossCouplingErrors scale factors and cross coupling
     *                                                       matrix to be set.
     * @throws IllegalArgumentException if provided matrix is not 3x3.
     */
    public void setAccelerometerScaleFactorAndCrossCouplingErrors(
            final Matrix accelerometerScaleFactorAndCrossCouplingErrors) {
<span class="fc bfc" id="L843" title="All 2 branches covered.">        if (accelerometerScaleFactorAndCrossCouplingErrors.getRows() != ACCELEROMETER_COMPONENTS</span>
<span class="fc bfc" id="L844" title="All 2 branches covered.">                || accelerometerScaleFactorAndCrossCouplingErrors.getColumns() != ACCELEROMETER_COMPONENTS) {</span>
<span class="fc" id="L845">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L848">        mAccelerometerScaleFactorAndCrossCouplingErrors</span>
<span class="fc" id="L849">                .copyFrom(accelerometerScaleFactorAndCrossCouplingErrors);</span>
<span class="fc" id="L850">    }</span>

    /**
     * Gets gyro scale factors and cross coupling errors.
     * This is the product of matrix Tg containing cross coupling errors and Kg
     * containing scaling factors.
     * So tat:
     * &lt;pre&gt;
     *     Mg = [sx    mxy  mxz] = Tg*Kg
     *          [myx   sy   myz]
     *          [mzx   mzy  sz ]
     * &lt;/pre&gt;
     * Where:
     * &lt;pre&gt;
     *     Kg = [sx 0   0 ]
     *          [0  sy  0 ]
     *          [0  0   sz]
     * &lt;/pre&gt;
     * and
     * &lt;pre&gt;
     *     Tg = [1          -gammaXy    gammaXz ]
     *          [gammaYx    1           -gammaYz]
     *          [-gammaZx   gammaZy     1       ]
     * &lt;/pre&gt;
     * Hence:
     * &lt;pre&gt;
     *     Mg = [sx    mxy  mxz] = Tg*Kg =  [sx             -sy * gammaXy   sz * gammaXz ]
     *          [myx   sy   myz]            [sx * gammaYx   sy              -sz * gammaYz]
     *          [mzx   mzy  sz ]            [-sx * gammaZx  sy * gammaZy    sz           ]
     * &lt;/pre&gt;
     * This instance allows any 3x3 matrix however, typically gammaYx, gammaZx and gammaZy
     * are considered to be zero if the accelerometer z-axis is assumed to be the same
     * as the body z-axis. When this is assumed, myx = mzx = mzy = 0 and the Ma matrix
     * becomes upper diagonal:
     * &lt;pre&gt;
     *     Ma = [sx    mxy  mxz]
     *          [0     sy   myz]
     *          [0     0    sz ]
     * &lt;/pre&gt;
     * Values of this matrix are unitless.
     * By default it is the 3x3 identity matrix.
     *
     * @return gyro scale factors and cross coupling errors.
     */
    public Matrix getGyroScaleFactorAndCrossCouplingErrors() {
<span class="fc" id="L895">        return new Matrix(mGyroScaleFactorAndCrossCouplingErrors);</span>
    }

    /**
     * Gets gyro scale factors and cross coupling errors.
     * This is the product of matrix Tg containing cross coupling errors and Kg
     * containing scaling factors.
     * So tat:
     * &lt;pre&gt;
     *     Mg = [sx    mxy  mxz] = Tg*Kg
     *          [myx   sy   myz]
     *          [mzx   mzy  sz ]
     * &lt;/pre&gt;
     * Where:
     * &lt;pre&gt;
     *     Kg = [sx 0   0 ]
     *          [0  sy  0 ]
     *          [0  0   sz]
     * &lt;/pre&gt;
     * and
     * &lt;pre&gt;
     *     Tg = [1          -gammaXy    gammaXz ]
     *          [gammaYx    1           -gammaYz]
     *          [-gammaZx   gammaZy     1       ]
     * &lt;/pre&gt;
     * Hence:
     * &lt;pre&gt;
     *     Mg = [sx    mxy  mxz] = Tg*Kg =  [sx             -sy * gammaXy   sz * gammaXz ]
     *          [myx   sy   myz]            [sx * gammaYx   sy              -sz * gammaYz]
     *          [mzx   mzy  sz ]            [-sx * gammaZx  sy * gammaZy    sz           ]
     * &lt;/pre&gt;
     * This instance allows any 3x3 matrix however, typically gammaYx, gammaZx and gammaZy
     * are considered to be zero if the accelerometer z-axis is assumed to be the same
     * as the body z-axis. When this is assumed, myx = mzx = mzy = 0 and the Ma matrix
     * becomes upper diagonal:
     * &lt;pre&gt;
     *     Ma = [sx    mxy  mxz]
     *          [0     sy   myz]
     *          [0     0    sz ]
     * &lt;/pre&gt;
     * Values of this matrix are unitless.
     * By default it is the 3x3 identity matrix.
     *
     * @param result instance where data of scale factor and cross coupling matrix will
     *               be copied to. If needed, result instance will be resized.
     */
    public void getGyroScaleFactorAndCrossCouplingErrors(final Matrix result) {
<span class="fc" id="L942">        result.copyFrom(mGyroScaleFactorAndCrossCouplingErrors);</span>
<span class="fc" id="L943">    }</span>

    /**
     * Sets gyro scale factors and cross coupling errors.
     * This is the product of matrix Tg containing cross coupling errors and Kg
     * containing scaling factors.
     * So tat:
     * &lt;pre&gt;
     *     Mg = [sx    mxy  mxz] = Tg*Kg
     *          [myx   sy   myz]
     *          [mzx   mzy  sz ]
     * &lt;/pre&gt;
     * Where:
     * &lt;pre&gt;
     *     Kg = [sx 0   0 ]
     *          [0  sy  0 ]
     *          [0  0   sz]
     * &lt;/pre&gt;
     * and
     * &lt;pre&gt;
     *     Tg = [1          -gammaXy    gammaXz ]
     *          [gammaYx    1           -gammaYz]
     *          [-gammaZx   gammaZy     1       ]
     * &lt;/pre&gt;
     * Hence:
     * &lt;pre&gt;
     *     Mg = [sx    mxy  mxz] = Tg*Kg =  [sx             -sy * gammaXy   sz * gammaXz ]
     *          [myx   sy   myz]            [sx * gammaYx   sy              -sz * gammaYz]
     *          [mzx   mzy  sz ]            [-sx * gammaZx  sy * gammaZy    sz           ]
     * &lt;/pre&gt;
     * This instance allows any 3x3 matrix however, typically gammaYx, gammaZx and gammaZy
     * are considered to be zero if the accelerometer z-axis is assumed to be the same
     * as the body z-axis. When this is assumed, myx = mzx = mzy = 0 and the Ma matrix
     * becomes upper diagonal:
     * &lt;pre&gt;
     *     Ma = [sx    mxy  mxz]
     *          [0     sy   myz]
     *          [0     0    sz ]
     * &lt;/pre&gt;
     * Values of this matrix are unitless.
     *
     * @param gyroScaleFactorAndCrossCouplingErrors scale factors and cross coupling
     *                                              matrix to be set.
     * @throws IllegalArgumentException if provided matrix is not 3x3.
     */
    public void setGyroScaleFactorAndCrossCouplingErrors(
            final Matrix gyroScaleFactorAndCrossCouplingErrors) {
<span class="fc bfc" id="L990" title="All 2 branches covered.">        if (gyroScaleFactorAndCrossCouplingErrors.getRows() != GYRO_COMPONENTS</span>
<span class="fc bfc" id="L991" title="All 2 branches covered.">                || gyroScaleFactorAndCrossCouplingErrors.getColumns() != GYRO_COMPONENTS) {</span>
<span class="fc" id="L992">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L995">        mGyroScaleFactorAndCrossCouplingErrors</span>
<span class="fc" id="L996">                .copyFrom(gyroScaleFactorAndCrossCouplingErrors);</span>
<span class="fc" id="L997">    }</span>

    /**
     * Gets 3x3 matrix containing cross biases introduced by the specific forces
     * sensed by the accelerometer.
     * Values of this matrix are expressed in (rad-sec/m).
     * By default it is all zeros.
     *
     * @return cross biases introduced by the specific forces sensed by the
     * accelerometer.
     */
    public Matrix getGyroGDependentBiases() {
<span class="fc" id="L1009">        return new Matrix(mGyroGDependentBiases);</span>
    }

    /**
     * Gets 3x3 matrix containing cross biases introduced by the specific forces
     * sensed by the accelerometer.
     * Values of this matrix are expressed in (rad-sec/m).
     * By default it is all zeros.
     *
     * @param result instance where data will be stored. If needed, result instance
     *               will be resized.
     */
    public void getGyroGDependentBiases(final Matrix result) {
<span class="fc" id="L1022">        result.copyFrom(mGyroGDependentBiases);</span>
<span class="fc" id="L1023">    }</span>

    /**
     * Sets 3x3 matrix containing cross biases introduced by the specific forces
     * sensed by the accelerometer.
     * Values of this matrix are expressed in (rad-sec/m).
     *
     * @param gyroGDependentBiases cross biases introduced by the specific forces
     *                             sensed by the accelerometer to be set.
     * @throws IllegalArgumentException if provided matrix is not 3x3.
     */
    public void setGyroGDependentBiases(final Matrix gyroGDependentBiases) {
<span class="fc bfc" id="L1035" title="All 2 branches covered.">        if (gyroGDependentBiases.getRows() != ACCELEROMETER_COMPONENTS</span>
<span class="fc bfc" id="L1036" title="All 2 branches covered.">                || gyroGDependentBiases.getColumns() != ACCELEROMETER_COMPONENTS) {</span>
<span class="fc" id="L1037">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L1040">        mGyroGDependentBiases.copyFrom(gyroGDependentBiases);</span>
<span class="fc" id="L1041">    }</span>

    /**
     * Gets accelerometer noise root PSD expressed in (m * s^-1.5).
     * By default it is zero.
     *
     * @return accelerometer noise root PSD.
     */
    public double getAccelerometerNoiseRootPSD() {
<span class="fc" id="L1050">        return mAccelerometerNoiseRootPSD;</span>
    }

    /**
     * Sets accelerometer noise root PSD expressed in (m * s^-1.5)
     *
     * @param accelerometerNoiseRootPSD accelerometer noise root PSD to be set.
     */
    public void setAccelerometerNoiseRootPSD(final double accelerometerNoiseRootPSD) {
<span class="fc" id="L1059">        mAccelerometerNoiseRootPSD = accelerometerNoiseRootPSD;</span>
<span class="fc" id="L1060">    }</span>

    /**
     * Gets accelerometer noise PSD expressed in (m^2 * s^-3).
     * By default it is zero.
     *
     * @return accelerometer noise PSD.
     */
    public double getAccelerometerNoisePSD() {
<span class="fc" id="L1069">        return mAccelerometerNoiseRootPSD * mAccelerometerNoiseRootPSD;</span>
    }

    /**
     * Sets accelerometer noise PSD expressed in (m^2 * s^-3).
     *
     * @param accelerometerNoisePSD accelerometer noise PSD to be set.
     * @throws IllegalArgumentException if provided value is negative.
     */
    public void setAccelerometerNoisePSD(final double accelerometerNoisePSD) {
<span class="fc bfc" id="L1079" title="All 2 branches covered.">        if (accelerometerNoisePSD &lt; 0.0) {</span>
<span class="fc" id="L1080">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L1083">        mAccelerometerNoiseRootPSD = Math.sqrt(accelerometerNoisePSD);</span>
<span class="fc" id="L1084">    }</span>

    /**
     * Gets gyro noise root PSD expressed in (rad * s^-0.5).
     * By default it is zero.
     *
     * @return gyro noise root PSD.
     */
    public double getGyroNoiseRootPSD() {
<span class="fc" id="L1093">        return mGyroNoiseRootPSD;</span>
    }

    /**
     * Sets gyro noise root PSD expressed in (rad * s^-0.5).
     *
     * @param gyroNoiseRootPSD gyro noise root PSD to be set.
     */
    public void setGyroNoiseRootPSD(final double gyroNoiseRootPSD) {
<span class="fc" id="L1102">        mGyroNoiseRootPSD = gyroNoiseRootPSD;</span>
<span class="fc" id="L1103">    }</span>

    /**
     * Gets gyro noise PSD expressed in (rad^2/s).
     * By default it is zero.
     *
     * @return gyro noise PSD.
     */
    public double getGyroNoisePSD() {
<span class="fc" id="L1112">        return mGyroNoiseRootPSD * mGyroNoiseRootPSD;</span>
    }

    /**
     * Sets gyro noise PSD expressed in (rad^2/s).
     *
     * @param gyroNoisePSD gyro noise PSD.
     * @throws IllegalArgumentException if provided value is negative.
     */
    public void setGyroNoisePSD(final double gyroNoisePSD) {
<span class="fc bfc" id="L1122" title="All 2 branches covered.">        if (gyroNoisePSD &lt; 0.0) {</span>
<span class="fc" id="L1123">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L1126">        mGyroNoiseRootPSD = Math.sqrt(gyroNoisePSD);</span>
<span class="fc" id="L1127">    }</span>

    /**
     * Gets accelerometer quantization level expressed in meters per squared second
     * (m/s^2).
     * By default it is zero when no quantization is assumed.
     *
     * @return accelerometer quantization level.
     */
    public double getAccelerometerQuantizationLevel() {
<span class="fc" id="L1137">        return mAccelerometerQuantizationLevel;</span>
    }

    /**
     * Sets accelerometer quantization level expressed in meters per squared second
     * (m/s^2).
     *
     * @param accelerometerQuantizationLevel accelerometer quantization level to be
     *                                       set.
     */
    public void setAccelerometerQuantizationLevel(
            final double accelerometerQuantizationLevel) {
<span class="fc" id="L1149">        mAccelerometerQuantizationLevel = accelerometerQuantizationLevel;</span>
<span class="fc" id="L1150">    }</span>

    /**
     * Gets accelerometer quantization level.
     * By default it is zero when no quantization is assumed.
     *
     * @return accelerometer quantization level.
     */
    public Acceleration getAccelerometerQuantizationLevelAsAcceleration() {
<span class="fc" id="L1159">        return new Acceleration(mAccelerometerQuantizationLevel,</span>
                AccelerationUnit.METERS_PER_SQUARED_SECOND);
    }

    /**
     * Gets accelerometer quantization level.
     * By default it is zero when no quantization is assumed.
     *
     * @param result instance where value will be stored.
     */
    public void getAccelerometerQuantizationLevelAsAcceleration(final Acceleration result) {
<span class="fc" id="L1170">        result.setValue(mAccelerometerQuantizationLevel);</span>
<span class="fc" id="L1171">        result.setUnit(AccelerationUnit.METERS_PER_SQUARED_SECOND);</span>
<span class="fc" id="L1172">    }</span>

    /**
     * Sets accelerometer quantization level.
     *
     * @param accelerometerQuantizationLevel accelerometer quantization level to be set.
     */
    public void setAccelerometerQuantizationLevel(
            final Acceleration accelerometerQuantizationLevel) {
<span class="fc" id="L1181">        mAccelerometerQuantizationLevel = convertAcceleration(</span>
                accelerometerQuantizationLevel);
<span class="fc" id="L1183">    }</span>

    /**
     * Gets gyro quantization level expressed in radians per second (rad/s).
     * By default it is zero when no quantization is assumed.
     *
     * @return gyro quantization level expressed in radians per seocnd.
     */
    public double getGyroQuantizationLevel() {
<span class="fc" id="L1192">        return mGyroQuantizationLevel;</span>
    }

    /**
     * Sets gyro quantization level expressed in radians per second (rad/s).
     *
     * @param gyroQuantizationLevel gyro quantization level to be set.
     */
    public void setGyroQuantizationLevel(final double gyroQuantizationLevel) {
<span class="fc" id="L1201">        mGyroQuantizationLevel = gyroQuantizationLevel;</span>
<span class="fc" id="L1202">    }</span>

    /**
     * Gets gyro quantization level.
     * By default it is zero when no quantization is assumed.
     *
     * @return gyro quantization level.
     */
    public AngularSpeed getGyroQuantizationLevelAsAngularSpeed() {
<span class="fc" id="L1211">        return new AngularSpeed(mGyroQuantizationLevel,</span>
                AngularSpeedUnit.RADIANS_PER_SECOND);
    }

    /**
     * Gets gyro quantization level.
     * By default it is zero when no quantization is assumed.
     *
     * @param result instance where value will be stored.
     */
    public void getGyroQuantizationLevelAsAngularSpeed(final AngularSpeed result) {
<span class="fc" id="L1222">        result.setValue(mGyroQuantizationLevel);</span>
<span class="fc" id="L1223">        result.setUnit(AngularSpeedUnit.RADIANS_PER_SECOND);</span>
<span class="fc" id="L1224">    }</span>

    /**
     * Sets gyro quantization level.
     *
     * @param gyroQuantizationLevel gyro quantization level.
     */
    public void setGyroQuantizationLevel(final AngularSpeed gyroQuantizationLevel) {
<span class="fc" id="L1232">        mGyroQuantizationLevel = convertAngularSpeed(gyroQuantizationLevel);</span>
<span class="fc" id="L1233">    }</span>

    /**
     * Copies this instance data into provided instance.
     *
     * @param output destination instance where data will be copied to.
     */
    public void copyTo(final IMUErrors output) {
<span class="fc" id="L1241">        output.copyFrom(this);</span>
<span class="fc" id="L1242">    }</span>

    /**
     * Copies data of provided instance into this instance.
     *
     * @param input instance to copy data from.
     */
    public void copyFrom(final IMUErrors input) {
<span class="fc" id="L1250">        input.getAccelerometerBiases(mAccelerometerBiases);</span>
<span class="fc" id="L1251">        input.getGyroBiases(mGyroBiases);</span>
<span class="fc" id="L1252">        mAccelerometerScaleFactorAndCrossCouplingErrors.copyFrom(</span>
                input.mAccelerometerScaleFactorAndCrossCouplingErrors);
<span class="fc" id="L1254">        mGyroScaleFactorAndCrossCouplingErrors.copyFrom(</span>
                input.mGyroScaleFactorAndCrossCouplingErrors);
<span class="fc" id="L1256">        mGyroGDependentBiases.copyFrom(input.mGyroGDependentBiases);</span>
<span class="fc" id="L1257">        mAccelerometerNoiseRootPSD = input.mAccelerometerNoiseRootPSD;</span>
<span class="fc" id="L1258">        mGyroNoiseRootPSD = input.mGyroNoiseRootPSD;</span>
<span class="fc" id="L1259">        mAccelerometerQuantizationLevel = input.mAccelerometerQuantizationLevel;</span>
<span class="fc" id="L1260">        mGyroQuantizationLevel = input.mGyroQuantizationLevel;</span>
<span class="fc" id="L1261">    }</span>

    /**
     * Computes and returns hash code for this instance. Hash codes are almost unique
     * values that are useful for fast classification and storage of objects in
     * collections.
     *
     * @return Hash code.
     */
    @Override
    public int hashCode() {
<span class="fc" id="L1272">        int result = Objects.hash(mAccelerometerScaleFactorAndCrossCouplingErrors,</span>
                mGyroScaleFactorAndCrossCouplingErrors, mGyroGDependentBiases,
<span class="fc" id="L1274">                mAccelerometerNoiseRootPSD, mGyroNoiseRootPSD,</span>
<span class="fc" id="L1275">                mAccelerometerQuantizationLevel, mGyroQuantizationLevel);</span>
<span class="fc" id="L1276">        result = 31 * result + Arrays.hashCode(mAccelerometerBiases);</span>
<span class="fc" id="L1277">        result = 31 * result + Arrays.hashCode(mGyroBiases);</span>
<span class="fc" id="L1278">        return result;</span>
    }

    /**
     * Checks if provided object is an IMUErrors instance having exactly the same
     * contents as this instance.
     *
     * @param o Object to be compared.
     * @return true if both objects are considered to be equal, false otherwise.
     */
    @Override
    public boolean equals(Object o) {
<span class="fc bfc" id="L1290" title="All 2 branches covered.">        if (this == o) return true;</span>
<span class="fc bfc" id="L1291" title="All 4 branches covered.">        if (o == null || getClass() != o.getClass()) return false;</span>
<span class="fc" id="L1292">        final IMUErrors imuErrors = (IMUErrors) o;</span>
<span class="fc bfc" id="L1293" title="All 2 branches covered.">        return Double.compare(imuErrors.mAccelerometerNoiseRootPSD, mAccelerometerNoiseRootPSD) == 0 &amp;&amp;</span>
<span class="pc bpc" id="L1294" title="1 of 2 branches missed.">                Double.compare(imuErrors.mGyroNoiseRootPSD, mGyroNoiseRootPSD) == 0 &amp;&amp;</span>
<span class="pc bpc" id="L1295" title="1 of 2 branches missed.">                Double.compare(imuErrors.mAccelerometerQuantizationLevel, mAccelerometerQuantizationLevel) == 0 &amp;&amp;</span>
<span class="pc bpc" id="L1296" title="1 of 2 branches missed.">                Double.compare(imuErrors.mGyroQuantizationLevel, mGyroQuantizationLevel) == 0 &amp;&amp;</span>
<span class="pc bpc" id="L1297" title="1 of 2 branches missed.">                Arrays.equals(mAccelerometerBiases, imuErrors.mAccelerometerBiases) &amp;&amp;</span>
<span class="pc bpc" id="L1298" title="1 of 2 branches missed.">                Arrays.equals(mGyroBiases, imuErrors.mGyroBiases) &amp;&amp;</span>
<span class="pc bpc" id="L1299" title="1 of 2 branches missed.">                mAccelerometerScaleFactorAndCrossCouplingErrors.equals(</span>
                        imuErrors.mAccelerometerScaleFactorAndCrossCouplingErrors) &amp;&amp;
<span class="pc bpc" id="L1301" title="1 of 2 branches missed.">                mGyroScaleFactorAndCrossCouplingErrors.equals(imuErrors.mGyroScaleFactorAndCrossCouplingErrors) &amp;&amp;</span>
<span class="pc bpc" id="L1302" title="1 of 2 branches missed.">                mGyroGDependentBiases.equals(imuErrors.mGyroGDependentBiases);</span>
    }

    /**
     * Makes a copy of this instance.
     *
     * @return a copy of this instance.
     * @throws CloneNotSupportedException if clone fails for some reason.
     */
    @Override
    protected Object clone() throws CloneNotSupportedException {
<span class="fc" id="L1313">        final IMUErrors result = (IMUErrors) super.clone();</span>
<span class="fc" id="L1314">        copyTo(result);</span>
<span class="fc" id="L1315">        return result;</span>
    }

    /**
     * Converts acceleration instance to meters per squared second (m/s^2).
     *
     * @param acceleration instance to be converted.
     * @return converted value.
     */
    private double convertAcceleration(final Acceleration acceleration) {
<span class="fc" id="L1325">        return AccelerationConverter.convert(acceleration.getValue().doubleValue(),</span>
<span class="fc" id="L1326">                acceleration.getUnit(), AccelerationUnit.METERS_PER_SQUARED_SECOND);</span>
    }

    /**
     * Converts angular speed instance to radians per second (rad/s).
     *
     * @param angularSpeed instance ot be converted.
     * @return converted value.
     */
    private double convertAngularSpeed(final AngularSpeed angularSpeed) {
<span class="fc" id="L1336">        return AngularSpeedConverter.convert(angularSpeed.getValue().doubleValue(),</span>
<span class="fc" id="L1337">                angularSpeed.getUnit(), AngularSpeedUnit.RADIANS_PER_SECOND);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>