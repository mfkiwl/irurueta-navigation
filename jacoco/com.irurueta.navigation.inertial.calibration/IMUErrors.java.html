<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>IMUErrors.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.irurueta:irurueta-navigation</a> &gt; <a href="index.source.html" class="el_package">com.irurueta.navigation.inertial.calibration</a> &gt; <span class="el_source">IMUErrors.java</span></div><h1>IMUErrors.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2020 Alberto Irurueta Carro (alberto@irurueta.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.irurueta.navigation.inertial.calibration;

import com.irurueta.algebra.Matrix;
import com.irurueta.algebra.WrongSizeException;
import com.irurueta.units.Acceleration;
import com.irurueta.units.AccelerationConverter;
import com.irurueta.units.AccelerationUnit;
import com.irurueta.units.AngularSpeed;
import com.irurueta.units.AngularSpeedConverter;
import com.irurueta.units.AngularSpeedUnit;

import java.io.Serializable;
import java.util.Arrays;
import java.util.Objects;

/**
 * Contains Inertial Measurement Unit (IMU) errors statistics obtained from
 * calibration.
 * This data can also be used to generate synthetic IMU data.
 * IMU errors are related to accelerometer and gyroscope calibration parameters.
 */
public class IMUErrors implements Serializable, Cloneable {

    /**
     * Number of components of accelerometer measures.
     */
    public static final int ACCELEROMETER_COMPONENTS = 3;

    /**
     * Number of components og gyro measures.
     */
    public static final int GYRO_COMPONENTS = 3;

    /**
     * Number of components minus one.
     */
    private static final int COMPONENTS_MINUS_ONE = 2;

    /**
     * Accelerometer biases for each IMU axis expressed in meters per squared
     * second (m/s^2).
     * By default it is assumed to be all zeros.
     */
<span class="fc" id="L59">    private double[] mAccelerometerBiases = new double[ACCELEROMETER_COMPONENTS];</span>

    /**
     * Gyro biases for each IMU axis expressed in radians per second (rad/s).
     * By default it is assumed to be all zeros.
     */
<span class="fc" id="L65">    private double[] mGyroBiases = new double[GYRO_COMPONENTS];</span>

    /**
     * Contains accelerometer scale factors and cross coupling errors.
     * This is the product of matrix Ta containing cross coupling errors and Ka
     * containing scaling factors.
     * So tat:
     * &lt;pre&gt;
     *     Ma = [sx    mxy  mxz] = Ta*Ka
     *          [myx   sy   myz]
     *          [mzx   mzy  sz ]
     * &lt;/pre&gt;
     * Where:
     * &lt;pre&gt;
     *     Ka = [sx 0   0 ]
     *          [0  sy  0 ]
     *          [0  0   sz]
     * &lt;/pre&gt;
     * and
     * &lt;pre&gt;
     *     Ta = [1          -alphaXy    alphaXz ]
     *          [alphaYx    1           -alphaYz]
     *          [-alphaZx   alphaZy     1       ]
     * &lt;/pre&gt;
     * Hence:
     * &lt;pre&gt;
     *     Ma = [sx    mxy  mxz] = Ta*Ka =  [sx             -sy * alphaXy   sz * alphaXz ]
     *          [myx   sy   myz]            [sx * alphaYx   sy              -sz * alphaYz]
     *          [mzx   mzy  sz ]            [-sx * alphaZx  sy * alphaZy    sz           ]
     * &lt;/pre&gt;
     * This instance allows any 3x3 matrix however, typically alphaYx, alphaZx and alphaZy
     * are considered to be zero if the accelerometer z-axis is assumed to be the same
     * as the body z-axis. When this is assumed, myx = mzx = mzy = 0 and the Ma matrix
     * becomes upper diagonal:
     * &lt;pre&gt;
     *     Ma = [sx    mxy  mxz]
     *          [0     sy   myz]
     *          [0     0    sz ]
     * &lt;/pre&gt;
     * Values of this matrix are unitless.
     * By default it is the 3x3 zero matrix.
     */
    private Matrix mAccelerometerScaleFactorAndCrossCouplingErrors;

    /**
     * Contains gyro scale factors and cross coupling errors.
     * This is the product of matrix Tg containing cross coupling errors and Kg
     * containing scaling factors.
     * So tat:
     * &lt;pre&gt;
     *     Mg = [sx    mxy  mxz] = Tg*Kg
     *          [myx   sy   myz]
     *          [mzx   mzy  sz ]
     * &lt;/pre&gt;
     * Where:
     * &lt;pre&gt;
     *     Kg = [sx 0   0 ]
     *          [0  sy  0 ]
     *          [0  0   sz]
     * &lt;/pre&gt;
     * and
     * &lt;pre&gt;
     *     Tg = [1          -gammaXy    gammaXz ]
     *          [gammaYx    1           -gammaYz]
     *          [-gammaZx   gammaZy     1       ]
     * &lt;/pre&gt;
     * Hence:
     * &lt;pre&gt;
     *     Mg = [sx    mxy  mxz] = Tg*Kg =  [sx             -sy * gammaXy   sz * gammaXz ]
     *          [myx   sy   myz]            [sx * gammaYx   sy              -sz * gammaYz]
     *          [mzx   mzy  sz ]            [-sx * gammaZx  sy * gammaZy    sz           ]
     * &lt;/pre&gt;
     * This instance allows any 3x3 matrix however, typically gammaYx, gammaZx and gammaZy
     * are considered to be zero if the accelerometer z-axis is assumed to be the same
     * as the body z-axis. When this is assumed, myx = mzx = mzy = 0 and the Ma matrix
     * becomes upper diagonal:
     * &lt;pre&gt;
     *     Ma = [sx    mxy  mxz]
     *          [0     sy   myz]
     *          [0     0    sz ]
     * &lt;/pre&gt;
     * Values of this matrix are unitless.
     * By default it is the 3x3 zero matrix.
     */
    private Matrix mGyroScaleFactorAndCrossCouplingErrors;

    /**
     * 3x3 matrix containing cross biases introduced by the specific forces sensed
     * by the accelerometer.
     * Values of this matrix are expressed in (rad-sec/m).
     * By default it is all zeros.
     */
    private Matrix mGyroGDependentBiases;

    /**
     * Accelerometer noise root PSD expressed in (m * s^-1.5).
     * By default it is zero.
     */
    private double mAccelerometerNoiseRootPSD;

    /**
     * Gyro noise root PSD expressed in (rad * s^-0.5).
     * By default it is zero.
     */
    private double mGyroNoiseRootPSD;

    /**
     * Accelerometer quantization level expressed in meters per squared second (m/s^2).
     * By default it is zero when no quantization is assumed.
     */
    private double mAccelerometerQuantizationLevel;

    /**
     * Gyro quantization level expressed in radians per second (rad/s).
     */
    private double mGyroQuantizationLevel;

    /**
     * Constructor.
     */
<span class="fc" id="L185">    public IMUErrors() {</span>
        try {
<span class="fc" id="L187">            mAccelerometerScaleFactorAndCrossCouplingErrors = Matrix.identity(</span>
                    ACCELEROMETER_COMPONENTS, ACCELEROMETER_COMPONENTS);
<span class="fc" id="L189">            mGyroScaleFactorAndCrossCouplingErrors = Matrix.identity(</span>
                    GYRO_COMPONENTS, GYRO_COMPONENTS);
<span class="fc" id="L191">            mGyroGDependentBiases = new Matrix(</span>
                    ACCELEROMETER_COMPONENTS, ACCELEROMETER_COMPONENTS);
<span class="nc" id="L193">        } catch (final WrongSizeException ignore) {</span>
            // never happens
<span class="fc" id="L195">        }</span>
<span class="fc" id="L196">    }</span>

    /**
     * Constructor.
     *
     * @param accelerometerBiases                            accelerometer biases for each IMU axis expressed in meters
     *                                                       per squared second (m/s^2). Must have length 3.
     * @param gyroBiases                                     gyro biases for each IMU axis expressed in radians per
     *                                                       second (rad/s). Must have length 3.
     * @param accelerometerScaleFactorAndCrossCouplingErrors accelerometer scale factors and cross coupling errors.
     *                                                       Must be 3x3.
     * @param gyroScaleFactorAndCrossCouplingErrors          gyro scale factors and cross coupling errors. Must be 3x3.
     * @param accelerometerNoiseRootPSD                      accelerometer noise root PSD expressed in (m * s^-1.5).
     * @param gyroNoiseRootPSD                               gyro noise root PSD expressed in (rad * s^-0.5).
     * @throws IllegalArgumentException if any value is invalid.
     */
    public IMUErrors(final double[] accelerometerBiases,
                     final double[] gyroBiases,
                     final Matrix accelerometerScaleFactorAndCrossCouplingErrors,
                     final Matrix gyroScaleFactorAndCrossCouplingErrors,
                     final double accelerometerNoiseRootPSD,
                     final double gyroNoiseRootPSD) {
<span class="fc" id="L218">        this();</span>
<span class="fc" id="L219">        setAccelerometerBiases(accelerometerBiases);</span>
<span class="fc" id="L220">        setGyroBiases(gyroBiases);</span>
<span class="fc" id="L221">        setAccelerometerScaleFactorAndCrossCouplingErrors(</span>
                accelerometerScaleFactorAndCrossCouplingErrors);
<span class="fc" id="L223">        setGyroScaleFactorAndCrossCouplingErrors(</span>
                gyroScaleFactorAndCrossCouplingErrors);
<span class="fc" id="L225">        setAccelerometerNoiseRootPSD(accelerometerNoiseRootPSD);</span>
<span class="fc" id="L226">        setGyroNoiseRootPSD(gyroNoiseRootPSD);</span>
<span class="fc" id="L227">    }</span>

    /**
     * Constructor.
     *
     * @param accelerometerBiases                            accelerometer biases for each IMU axis expressed in meters
     *                                                       per squared second (m/s^2). Must be 3x1.
     * @param gyroBiases                                     gyro biases for each IMU axis expressed in radians per
     *                                                       second (rad/s). Must be 3x1.
     * @param accelerometerScaleFactorAndCrossCouplingErrors accelerometer scale factors and cross coupling errors.
     *                                                       Must be 3x3.
     * @param gyroScaleFactorAndCrossCouplingErrors          gyro scale factors and cross coupling errors. Must be 3x3.
     * @param accelerometerNoiseRootPSD                      accelerometer noise root PSD expressed in (m * s^-1.5).
     * @param gyroNoiseRootPSD                               gyro noise root PSD expressed in (rad * s^-0.5).
     * @throws IllegalArgumentException if any value is invalid.
     */
    public IMUErrors(final Matrix accelerometerBiases,
                     final Matrix gyroBiases,
                     final Matrix accelerometerScaleFactorAndCrossCouplingErrors,
                     final Matrix gyroScaleFactorAndCrossCouplingErrors,
                     final double accelerometerNoiseRootPSD,
                     final double gyroNoiseRootPSD) {
<span class="fc" id="L249">        this();</span>
<span class="fc" id="L250">        setAccelerometerBiases(accelerometerBiases);</span>
<span class="fc" id="L251">        setGyroBiases(gyroBiases);</span>
<span class="fc" id="L252">        setAccelerometerScaleFactorAndCrossCouplingErrors(</span>
                accelerometerScaleFactorAndCrossCouplingErrors);
<span class="fc" id="L254">        setGyroScaleFactorAndCrossCouplingErrors(</span>
                gyroScaleFactorAndCrossCouplingErrors);
<span class="fc" id="L256">        setAccelerometerNoiseRootPSD(accelerometerNoiseRootPSD);</span>
<span class="fc" id="L257">        setGyroNoiseRootPSD(gyroNoiseRootPSD);</span>
<span class="fc" id="L258">    }</span>

    /**
     * Constructor.
     *
     * @param accelerometerBiases                            accelerometer biases for each IMU axis. Must have length 3.
     * @param gyroBiases                                     gyro biases for each IMU axis. Must have length 3.
     * @param accelerometerScaleFactorAndCrossCouplingErrors accelerometer scale factors and cross coupling errors.
     *                                                       Must be 3x3.
     * @param gyroScaleFactorAndCrossCouplingErrors          gyro scale factors and cross coupling errors. Must be 3x3.
     * @param accelerometerNoiseRootPSD                      accelerometer noise root PSD expressed in (m * s^-1.5).
     * @param gyroNoiseRootPSD                               gyro noise root PSD expressed in (rad * s^-0.5).
     * @throws IllegalArgumentException if any value is invalid.
     */
    public IMUErrors(final Acceleration[] accelerometerBiases,
                     final AngularSpeed[] gyroBiases,
                     final Matrix accelerometerScaleFactorAndCrossCouplingErrors,
                     final Matrix gyroScaleFactorAndCrossCouplingErrors,
                     final double accelerometerNoiseRootPSD,
                     final double gyroNoiseRootPSD) {
<span class="fc" id="L278">        this();</span>
<span class="fc" id="L279">        setAccelerometerBiases(accelerometerBiases);</span>
<span class="fc" id="L280">        setGyroBiases(gyroBiases);</span>
<span class="fc" id="L281">        setAccelerometerScaleFactorAndCrossCouplingErrors(</span>
                accelerometerScaleFactorAndCrossCouplingErrors);
<span class="fc" id="L283">        setGyroScaleFactorAndCrossCouplingErrors(</span>
                gyroScaleFactorAndCrossCouplingErrors);
<span class="fc" id="L285">        setAccelerometerNoiseRootPSD(accelerometerNoiseRootPSD);</span>
<span class="fc" id="L286">        setGyroNoiseRootPSD(gyroNoiseRootPSD);</span>
<span class="fc" id="L287">    }</span>

    /**
     * Constructor.
     *
     * @param accelerometerBiases                            accelerometer biases for each IMU axis expressed in meters
     *                                                       per squared second (m/s^2). Must have length 3.
     * @param gyroBiases                                     gyro biases for each IMU axis expressed in radians per
     *                                                       second (rad/s). Must have length 3.
     * @param accelerometerScaleFactorAndCrossCouplingErrors accelerometer scale factors and cross coupling errors.
     *                                                       Must be 3x3.
     * @param gyroScaleFactorAndCrossCouplingErrors          gyro scale factors and cross coupling errors. Must be 3x3.
     * @param gyroGDependentBiases                           Cross biases introduced by the specific forces sensed by
     *                                                       the accelerometer expressed in (rad-sec/m). Must be 3x3.
     * @param accelerometerNoiseRootPSD                      accelerometer noise root PSD expressed in (m * s^-1.5).
     * @param gyroNoiseRootPSD                               gyro noise root PSD expressed in (rad * s^-0.5).
     * @param accelerometerQuantizationLevel                 accelerometer quantization level expressed in meters per
     *                                                       squared second (m/s^2).
     * @param gyroQuantizationLevel                          gyro quantization level expressed in radians per second
     *                                                       (rad/s).
     * @throws IllegalArgumentException if any value is invalid.
     */
    public IMUErrors(final double[] accelerometerBiases,
                     final double[] gyroBiases,
                     final Matrix accelerometerScaleFactorAndCrossCouplingErrors,
                     final Matrix gyroScaleFactorAndCrossCouplingErrors,
                     final Matrix gyroGDependentBiases,
                     final double accelerometerNoiseRootPSD,
                     final double gyroNoiseRootPSD,
                     final double accelerometerQuantizationLevel,
                     final double gyroQuantizationLevel) {
<span class="fc" id="L318">        this();</span>
<span class="fc" id="L319">        setAccelerometerBiases(accelerometerBiases);</span>
<span class="fc" id="L320">        setGyroBiases(gyroBiases);</span>
<span class="fc" id="L321">        setAccelerometerScaleFactorAndCrossCouplingErrors(</span>
                accelerometerScaleFactorAndCrossCouplingErrors);
<span class="fc" id="L323">        setGyroScaleFactorAndCrossCouplingErrors(</span>
                gyroScaleFactorAndCrossCouplingErrors);
<span class="fc" id="L325">        setGyroGDependentBiases(gyroGDependentBiases);</span>
<span class="fc" id="L326">        setAccelerometerNoiseRootPSD(accelerometerNoiseRootPSD);</span>
<span class="fc" id="L327">        setGyroNoiseRootPSD(gyroNoiseRootPSD);</span>
<span class="fc" id="L328">        setAccelerometerQuantizationLevel(accelerometerQuantizationLevel);</span>
<span class="fc" id="L329">        setGyroQuantizationLevel(gyroQuantizationLevel);</span>
<span class="fc" id="L330">    }</span>

    /**
     * Constructor.
     *
     * @param accelerometerBiases                            accelerometer biases for each IMU axis expressed in meters
     *                                                       per squared second (m/s^2). Must be 3x1.
     * @param gyroBiases                                     gyro biases for each IMU axis expressed in radians per
     *                                                       second (rad/s). Must be 3x1.
     * @param accelerometerScaleFactorAndCrossCouplingErrors accelerometer scale factors and cross coupling errors.
     *                                                       Must be 3x3.
     * @param gyroScaleFactorAndCrossCouplingErrors          gyro scale factors and cross coupling errors. Must be 3x3.
     * @param gyroGDependentBiases                           Cross biases introduced by the specific forces sensed by
     *                                                       the accelerometer expressed in (rad-sec/m). Must be 3x3.
     * @param accelerometerNoiseRootPSD                      accelerometer noise root PSD expressed in (m * s^-1.5).
     * @param gyroNoiseRootPSD                               gyro noise root PSD expressed in (rad * s^-0.5).
     * @param accelerometerQuantizationLevel                 accelerometer quantization level expressed in meters per
     *                                                       squared second (m/s^2).
     * @param gyroQuantizationLevel                          gyro quantization level expressed in radians per second
     *                                                       (rad/s).
     * @throws IllegalArgumentException if any value is invalid.
     */
    public IMUErrors(final Matrix accelerometerBiases,
                     final Matrix gyroBiases,
                     final Matrix accelerometerScaleFactorAndCrossCouplingErrors,
                     final Matrix gyroScaleFactorAndCrossCouplingErrors,
                     final Matrix gyroGDependentBiases,
                     final double accelerometerNoiseRootPSD,
                     final double gyroNoiseRootPSD,
                     final double accelerometerQuantizationLevel,
                     final double gyroQuantizationLevel) {
<span class="fc" id="L361">        this();</span>
<span class="fc" id="L362">        setAccelerometerBiases(accelerometerBiases);</span>
<span class="fc" id="L363">        setGyroBiases(gyroBiases);</span>
<span class="fc" id="L364">        setAccelerometerScaleFactorAndCrossCouplingErrors(</span>
                accelerometerScaleFactorAndCrossCouplingErrors);
<span class="fc" id="L366">        setGyroScaleFactorAndCrossCouplingErrors(</span>
                gyroScaleFactorAndCrossCouplingErrors);
<span class="fc" id="L368">        setGyroGDependentBiases(gyroGDependentBiases);</span>
<span class="fc" id="L369">        setAccelerometerNoiseRootPSD(accelerometerNoiseRootPSD);</span>
<span class="fc" id="L370">        setGyroNoiseRootPSD(gyroNoiseRootPSD);</span>
<span class="fc" id="L371">        setAccelerometerQuantizationLevel(accelerometerQuantizationLevel);</span>
<span class="fc" id="L372">        setGyroQuantizationLevel(gyroQuantizationLevel);</span>
<span class="fc" id="L373">    }</span>

    /**
     * Constructor.
     *
     * @param accelerometerBiases                            accelerometer biases for each IMU axis. Must have length 3.
     * @param gyroBiases                                     gyro biases for each IMU axis. Must have length 3.
     * @param accelerometerScaleFactorAndCrossCouplingErrors accelerometer scale factors and cross coupling errors.
     *                                                       Must be 3x3.
     * @param gyroScaleFactorAndCrossCouplingErrors          gyro scale factors and cross coupling errors. Must be 3x3.
     * @param gyroGDependentBiases                           Cross biases introduced by the specific forces sensed by
     *                                                       the accelerometer expressed in (rad-sec/m). Must be 3x3.
     * @param accelerometerNoiseRootPSD                      accelerometer noise root PSD expressed in (m * s^-1.5).
     * @param gyroNoiseRootPSD                               gyro noise root PSD expressed in (rad * s^-0.5).
     * @param accelerometerQuantizationLevel                 accelerometer quantization level.
     * @param gyroQuantizationLevel                          gyro quantization level.
     * @throws IllegalArgumentException if any value is invalid.
     */
    public IMUErrors(final Acceleration[] accelerometerBiases,
                     final AngularSpeed[] gyroBiases,
                     final Matrix accelerometerScaleFactorAndCrossCouplingErrors,
                     final Matrix gyroScaleFactorAndCrossCouplingErrors,
                     final Matrix gyroGDependentBiases,
                     final double accelerometerNoiseRootPSD,
                     final double gyroNoiseRootPSD,
                     final Acceleration accelerometerQuantizationLevel,
                     final AngularSpeed gyroQuantizationLevel) {
<span class="fc" id="L400">        this();</span>
<span class="fc" id="L401">        setAccelerometerBiases(accelerometerBiases);</span>
<span class="fc" id="L402">        setGyroBiases(gyroBiases);</span>
<span class="fc" id="L403">        setAccelerometerScaleFactorAndCrossCouplingErrors(</span>
                accelerometerScaleFactorAndCrossCouplingErrors);
<span class="fc" id="L405">        setGyroScaleFactorAndCrossCouplingErrors(</span>
                gyroScaleFactorAndCrossCouplingErrors);
<span class="fc" id="L407">        setGyroGDependentBiases(gyroGDependentBiases);</span>
<span class="fc" id="L408">        setAccelerometerNoiseRootPSD(accelerometerNoiseRootPSD);</span>
<span class="fc" id="L409">        setGyroNoiseRootPSD(gyroNoiseRootPSD);</span>
<span class="fc" id="L410">        setAccelerometerQuantizationLevel(accelerometerQuantizationLevel);</span>
<span class="fc" id="L411">        setGyroQuantizationLevel(gyroQuantizationLevel);</span>
<span class="fc" id="L412">    }</span>

    /**
     * Constructor.
     *
     * @param input instance to copy data from.
     */
    @SuppressWarnings(&quot;CopyConstructorMissesField&quot;)
    public IMUErrors(final IMUErrors input) {
<span class="fc" id="L421">        this();</span>
<span class="fc" id="L422">        copyFrom(input);</span>
<span class="fc" id="L423">    }</span>

    /**
     * Gets accelerometer biases for each IMU axis expressed in meters per squared
     * second (m/s^2).
     * By default it is assumed to be all zeros.
     *
     * @return accelerometer biases for each IMU axis.
     */
    public double[] getAccelerometerBiases() {
<span class="fc" id="L433">        final double[] result = new double[ACCELEROMETER_COMPONENTS];</span>
<span class="fc" id="L434">        getAccelerometerBiases(result);</span>
<span class="fc" id="L435">        return result;</span>
    }

    /**
     * Gets accelerometer biases for each IMU axis expressed in meters per squared
     * second (m/s^2).
     * By default it is assumed to be all zeros.
     *
     * @param result instance where data will be stored.
     * @throws IllegalArgumentException if provided array does not have length 3.
     */
    public void getAccelerometerBiases(final double[] result) {
<span class="fc bfc" id="L447" title="All 2 branches covered.">        if (result.length != ACCELEROMETER_COMPONENTS) {</span>
<span class="fc" id="L448">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L451">        System.arraycopy(mAccelerometerBiases, 0, result, 0,</span>
                ACCELEROMETER_COMPONENTS);
<span class="fc" id="L453">    }</span>

    /**
     * Sets accelerometer biases for each IMU axis expressed in meters per squared
     * second (m/s^2).
     *
     * @param accelerometerBiases accelerometer biases for each IMU axis.
     * @throws IllegalArgumentException if provided array does not have length 3.
     */
    public void setAccelerometerBiases(final double[] accelerometerBiases) {
<span class="fc bfc" id="L463" title="All 2 branches covered.">        if (accelerometerBiases.length != ACCELEROMETER_COMPONENTS) {</span>
<span class="fc" id="L464">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L467">        mAccelerometerBiases = accelerometerBiases;</span>
<span class="fc" id="L468">    }</span>

    /**
     * Gets accelerometer biases for each IMU axis expressed in meters per squared
     * second (m/s^2) as a column matrix.
     * By default it is assumed to be all zeros.
     *
     * @return 3x1 column matrix containing accelerometer biases for each IMU axis.
     */
    public Matrix getAccelerometerBiasesAsMatrix() {
<span class="fc" id="L478">        return Matrix.newFromArray(mAccelerometerBiases);</span>
    }

    /**
     * Gets accelerometer biases for each IMU axis expressed in meters per squared
     * second (m/s^2) as a column matrix.
     * By default it is assumed to be all zeros.
     *
     * @param result instance where data will be stored.
     * @throws IllegalArgumentException if provided result matrix is not 3x1.
     */
    public void getAccelerometerBiasesAsMatrix(final Matrix result) {
<span class="fc" id="L490">        result.setSubmatrix(0, 0,</span>
                COMPONENTS_MINUS_ONE, 0,
                mAccelerometerBiases);
<span class="fc" id="L493">    }</span>

    /**
     * Sets accelerometer biases for each IMU axis expressed in meters per squared
     * second (m/s^2) from a 3x1 column matrix.
     *
     * @param accelerometerBiases 3x1 column matrix containing values to be set.
     * @throws IllegalArgumentException if provided matrix is not 3x1.
     */
    public void setAccelerometerBiases(final Matrix accelerometerBiases) {
<span class="fc bfc" id="L503" title="All 2 branches covered.">        if (accelerometerBiases.getRows() != ACCELEROMETER_COMPONENTS ||</span>
<span class="fc bfc" id="L504" title="All 2 branches covered.">                accelerometerBiases.getColumns() != 1) {</span>
<span class="fc" id="L505">            throw new IllegalArgumentException();</span>
        }

        try {
<span class="fc" id="L509">            accelerometerBiases.getSubmatrixAsArray(0, 0,</span>
                    COMPONENTS_MINUS_ONE, 0, mAccelerometerBiases);
<span class="nc" id="L511">        } catch (final WrongSizeException ignore) {</span>
            // never happens
<span class="fc" id="L513">        }</span>
<span class="fc" id="L514">    }</span>

    /**
     * Gets accelerometer biases for each IMU axis.
     * By default it is assumed to be all zeros.
     *
     * @return accelerometer biases for each IMU axis.
     */
    public Acceleration[] getAccelerometerBiasesAsAcceleration() {
<span class="fc" id="L523">        final Acceleration[] result = new Acceleration[ACCELEROMETER_COMPONENTS];</span>
<span class="fc" id="L524">        getAccelerometerBiasesAsAcceleration(result);</span>
<span class="fc" id="L525">        return result;</span>
    }

    /**
     * Gets accelerometer biases for each IMU axis.
     * By default it is assumed to be all zeros.
     *
     * @param result instance where data will be copied to.
     * @throws IllegalArgumentException if provided array does not have length 3.
     */
    public void getAccelerometerBiasesAsAcceleration(final Acceleration[] result) {
<span class="fc bfc" id="L536" title="All 2 branches covered.">        if (result.length != ACCELEROMETER_COMPONENTS) {</span>
<span class="fc" id="L537">            throw new IllegalArgumentException();</span>
        }

<span class="fc bfc" id="L540" title="All 2 branches covered.">        for (int i = 0; i &lt; ACCELEROMETER_COMPONENTS; i++) {</span>
<span class="fc" id="L541">            Acceleration a = result[i];</span>
<span class="fc bfc" id="L542" title="All 2 branches covered.">            if (a == null) {</span>
<span class="fc" id="L543">                result[i] = new Acceleration(mAccelerometerBiases[i],</span>
                        AccelerationUnit.METERS_PER_SQUARED_SECOND);
            } else {
<span class="fc" id="L546">                a.setValue(mAccelerometerBiases[i]);</span>
<span class="fc" id="L547">                a.setUnit(AccelerationUnit.METERS_PER_SQUARED_SECOND);</span>
            }
        }
<span class="fc" id="L550">    }</span>

    /**
     * Sets accelerometer biases for each IMU axis.
     *
     * @param accelerometerBiases accelerometer biases to be set.
     * @throws IllegalArgumentException if provided array does not have length 3.
     */
    public void setAccelerometerBiases(final Acceleration[] accelerometerBiases) {
<span class="fc bfc" id="L559" title="All 2 branches covered.">        if (accelerometerBiases.length != ACCELEROMETER_COMPONENTS) {</span>
<span class="fc" id="L560">            throw new IllegalArgumentException();</span>
        }

<span class="fc bfc" id="L563" title="All 2 branches covered.">        for (int i = 0; i &lt; ACCELEROMETER_COMPONENTS; i++) {</span>
<span class="fc" id="L564">            mAccelerometerBiases[i] = convertAcceleration(accelerometerBiases[i]);</span>
        }
<span class="fc" id="L566">    }</span>

    /**
     * Gets gyro biases for each IMU axis expressed in radians per second (rad/s).
     * By default it is assumed to be all zeros.
     *
     * @return gyro biases for each IMU axis.
     */
    public double[] getGyroBiases() {
<span class="fc" id="L575">        final double[] result = new double[GYRO_COMPONENTS];</span>
<span class="fc" id="L576">        getGyroBiases(result);</span>
<span class="fc" id="L577">        return result;</span>
    }

    /**
     * Gets gyro biases for each IMU axis expressed in radians per second (rad/s).
     * By default it is assumed to be all zeros.
     *
     * @param result instance where data will be stored.
     * @throws IllegalArgumentException if provided array does not have length 3.
     */
    public void getGyroBiases(final double[] result) {
<span class="fc bfc" id="L588" title="All 2 branches covered.">        if (result.length != GYRO_COMPONENTS) {</span>
<span class="fc" id="L589">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L592">        System.arraycopy(mGyroBiases, 0, result, 0, GYRO_COMPONENTS);</span>
<span class="fc" id="L593">    }</span>

    /**
     * Sets gyro biases for each IMU axis expressed in radians per second (rad/s).
     *
     * @param gyroBiases gyro biases for each IMU axis.
     * @throws IllegalArgumentException if provided array does not have length 3.
     */
    public void setGyroBiases(final double[] gyroBiases) {
<span class="fc bfc" id="L602" title="All 2 branches covered.">        if (gyroBiases.length != GYRO_COMPONENTS) {</span>
<span class="fc" id="L603">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L606">        mGyroBiases = gyroBiases;</span>
<span class="fc" id="L607">    }</span>

    /**
     * Gets gyro biases for each IMU axis expressed in radians per second (rad/s)
     * as a column matrix.
     * By default it is assumed to be all zeros.
     *
     * @return 3x1 column matrix containing gyro biases for each IMU axis.
     */
    public Matrix getGyroBiasesAsMatrix() {
<span class="fc" id="L617">        return Matrix.newFromArray(mGyroBiases);</span>
    }

    /**
     * Gets gyro biases for each IMU axis expressed in radians per second (rad/s)
     * as a column matrix.
     * By default it is assumed to be all zeros.
     *
     * @param result instance where data will be stored.
     * @throws IllegalArgumentException if provided result matrix is not 3x1.
     */
    public void getGyroBiasesAsMatrix(final Matrix result) {
<span class="fc" id="L629">        result.setSubmatrix(0, 0,</span>
                COMPONENTS_MINUS_ONE, 0, mGyroBiases);
<span class="fc" id="L631">    }</span>

    /**
     * Sets gyro biases for each IMU axis expressed in radians per second (rad/s)
     * from a 3x1 column matrix.
     *
     * @param gyroBiases 3x1 column matrix containing values to be set.
     * @throws IllegalArgumentException if provided matrix is not 3x1.
     */
    public void setGyroBiases(final Matrix gyroBiases) {
<span class="fc bfc" id="L641" title="All 2 branches covered.">        if (gyroBiases.getRows() != GYRO_COMPONENTS ||</span>
<span class="fc bfc" id="L642" title="All 2 branches covered.">                gyroBiases.getColumns() != 1) {</span>
<span class="fc" id="L643">            throw new IllegalArgumentException();</span>
        }

        try {
<span class="fc" id="L647">            gyroBiases.getSubmatrixAsArray(0, 0,</span>
                    COMPONENTS_MINUS_ONE, 0, mGyroBiases);
<span class="nc" id="L649">        } catch (final WrongSizeException ignore) {</span>
            // never happens
<span class="fc" id="L651">        }</span>
<span class="fc" id="L652">    }</span>

    /**
     * Gets gyro biases for each IMU axis.
     * By default it is assumed to be all zeros.
     *
     * @return gyro biases for each IMU axis.
     */
    public AngularSpeed[] getGyroBiasesAsAngularSpeed() {
<span class="fc" id="L661">        final AngularSpeed[] result = new AngularSpeed[GYRO_COMPONENTS];</span>
<span class="fc" id="L662">        getGyroBiasesAsAngularspeed(result);</span>
<span class="fc" id="L663">        return result;</span>
    }

    /**
     * Gets gyro biases for each IMU axis.
     * By default it is assumed to be all zeros.
     *
     * @param result instance where data will be copied to.
     * @throws IllegalArgumentException if provided array does not have length 3.
     */
    public void getGyroBiasesAsAngularspeed(final AngularSpeed[] result) {
<span class="fc bfc" id="L674" title="All 2 branches covered.">        if (result.length != GYRO_COMPONENTS) {</span>
<span class="fc" id="L675">            throw new IllegalArgumentException();</span>
        }

<span class="fc bfc" id="L678" title="All 2 branches covered.">        for (int i = 0; i &lt; GYRO_COMPONENTS; i++) {</span>
<span class="fc" id="L679">            AngularSpeed as = result[i];</span>
<span class="fc bfc" id="L680" title="All 2 branches covered.">            if (as == null) {</span>
<span class="fc" id="L681">                result[i] = new AngularSpeed(mGyroBiases[i],</span>
                        AngularSpeedUnit.RADIANS_PER_SECOND);
            } else {
<span class="fc" id="L684">                as.setValue(mGyroBiases[i]);</span>
<span class="fc" id="L685">                as.setUnit(AngularSpeedUnit.RADIANS_PER_SECOND);</span>
            }
        }
<span class="fc" id="L688">    }</span>

    /**
     * Sets gyro biases for each IMU axis.
     *
     * @param gyroBiases gyro biases to be set.
     * @throws IllegalArgumentException if provided array does not have length 3.
     */
    public void setGyroBiases(final AngularSpeed[] gyroBiases) {
<span class="fc bfc" id="L697" title="All 2 branches covered.">        if (gyroBiases.length != GYRO_COMPONENTS) {</span>
<span class="fc" id="L698">            throw new IllegalArgumentException();</span>
        }

<span class="fc bfc" id="L701" title="All 2 branches covered.">        for (int i = 0; i &lt; GYRO_COMPONENTS; i++) {</span>
<span class="fc" id="L702">            mGyroBiases[i] = convertAngularSpeed(gyroBiases[i]);</span>
        }
<span class="fc" id="L704">    }</span>

    /**
     * Gets accelerometer scale factors and cross coupling errors.
     * This is the product of matrix Ta containing cross coupling errors and Ka
     * containing scaling factors.
     * So tat:
     * &lt;pre&gt;
     *     Ma = [sx    mxy  mxz] = Ta*Ka
     *          [myx   sy   myz]
     *          [mzx   mzy  sz ]
     * &lt;/pre&gt;
     * Where:
     * &lt;pre&gt;
     *     Ka = [sx 0   0 ]
     *          [0  sy  0 ]
     *          [0  0   sz]
     * &lt;/pre&gt;
     * and
     * &lt;pre&gt;
     *     Ta = [1          -alphaXy    alphaXz ]
     *          [alphaYx    1           -alphaYz]
     *          [-alphaZx   alphaZy     1       ]
     * &lt;/pre&gt;
     * Hence:
     * &lt;pre&gt;
     *     Ma = [sx    mxy  mxz] = Ta*Ka =  [sx             -sy * alphaXy   sz * alphaXz ]
     *          [myx   sy   myz]            [sx * alphaYx   sy              -sz * alphaYz]
     *          [mzx   mzy  sz ]            [-sx * alphaZx  sy * alphaZy    sz           ]
     * &lt;/pre&gt;
     * This instance allows any 3x3 matrix however, typically alphaYx, alphaZx and alphaZy
     * are considered to be zero if the accelerometer z-axis is assumed to be the same
     * as the body z-axis. When this is assumed, myx = mzx = mzy = 0 and the Ma matrix
     * becomes upper diagonal:
     * &lt;pre&gt;
     *     Ma = [sx    mxy  mxz]
     *          [0     sy   myz]
     *          [0     0    sz ]
     * &lt;/pre&gt;
     * Values of this matrix are unitless.
     * By default it is the 3x3 identity matrix.
     *
     * @return accelerometer scale factors and cross coupling errors.
     */
    public Matrix getAccelerometerScaleFactorAndCrossCouplingErrors() {
<span class="fc" id="L749">        return new Matrix(mAccelerometerScaleFactorAndCrossCouplingErrors);</span>
    }

    /**
     * Gets accelerometer scale factors and cross coupling errors.
     * This is the product of matrix Ta containing cross coupling errors and Ka
     * containing scaling factors.
     * So tat:
     * &lt;pre&gt;
     *     Ma = [sx    mxy  mxz] = Ta*Ka
     *          [myx   sy   myz]
     *          [mzx   mzy  sz ]
     * &lt;/pre&gt;
     * Where:
     * &lt;pre&gt;
     *     Ka = [sx 0   0 ]
     *          [0  sy  0 ]
     *          [0  0   sz]
     * &lt;/pre&gt;
     * and
     * &lt;pre&gt;
     *     Ta = [1          -alphaXy    alphaXz ]
     *          [alphaYx    1           -alphaYz]
     *          [-alphaZx   alphaZy     1       ]
     * &lt;/pre&gt;
     * Hence:
     * &lt;pre&gt;
     *     Ma = [sx    mxy  mxz] = Ta*Ka =  [sx             -sy * alphaXy   sz * alphaXz ]
     *          [myx   sy   myz]            [sx * alphaYx   sy              -sz * alphaYz]
     *          [mzx   mzy  sz ]            [-sx * alphaZx  sy * alphaZy    sz           ]
     * &lt;/pre&gt;
     * This instance allows any 3x3 matrix however, typically alphaYx, alphaZx and alphaZy
     * are considered to be zero if the accelerometer z-axis is assumed to be the same
     * as the body z-axis. When this is assumed, myx = mzx = mzy = 0 and the Ma matrix
     * becomes upper diagonal:
     * &lt;pre&gt;
     *     Ma = [sx    mxy  mxz]
     *          [0     sy   myz]
     *          [0     0    sz ]
     * &lt;/pre&gt;
     * Values of this matrix are unitless.
     * By default it is the 3x3 identity matrix.
     *
     * @param result instance where data of scale factor and cross coupling matrix will
     *               be copied to. If needed, result instance will be resized.
     */
    public void getAccelerometerScaleFactorAndCrossCouplingErrors(final Matrix result) {
<span class="fc" id="L796">        result.copyFrom(mAccelerometerScaleFactorAndCrossCouplingErrors);</span>
<span class="fc" id="L797">    }</span>

    /**
     * Sets accelerometer scale factors and cross coupling errors.
     * This is the product of matrix Ta containing cross coupling errors and Ka
     * containing scaling factors.
     * So tat:
     * &lt;pre&gt;
     *     Ma = [sx    mxy  mxz] = Ta*Ka
     *          [myx   sy   myz]
     *          [mzx   mzy  sz ]
     * &lt;/pre&gt;
     * Where:
     * &lt;pre&gt;
     *     Ka = [sx 0   0 ]
     *          [0  sy  0 ]
     *          [0  0   sz]
     * &lt;/pre&gt;
     * and
     * &lt;pre&gt;
     *     Ta = [1          -alphaXy    alphaXz ]
     *          [alphaYx    1           -alphaYz]
     *          [-alphaZx   alphaZy     1       ]
     * &lt;/pre&gt;
     * Hence:
     * &lt;pre&gt;
     *     Ma = [sx    mxy  mxz] = Ta*Ka =  [sx             -sy * alphaXy   sz * alphaXz ]
     *          [myx   sy   myz]            [sx * alphaYx   sy              -sz * alphaYz]
     *          [mzx   mzy  sz ]            [-sx * alphaZx  sy * alphaZy    sz           ]
     * &lt;/pre&gt;
     * This instance allows any 3x3 matrix however, typically alphaYx, alphaZx and alphaZy
     * are considered to be zero if the accelerometer z-axis is assumed to be the same
     * as the body z-axis. When this is assumed, myx = mzx = mzy = 0 and the Ma matrix
     * becomes upper diagonal:
     * &lt;pre&gt;
     *     Ma = [sx    mxy  mxz]
     *          [0     sy   myz]
     *          [0     0    sz ]
     * &lt;/pre&gt;
     * Values of this matrix are unitless.
     *
     * @param accelerometerScaleFactorAndCrossCouplingErrors scale factors and cross coupling
     *                                                       matrix to be set.
     * @throws IllegalArgumentException if provided matrix is not 3x3.
     */
    public void setAccelerometerScaleFactorAndCrossCouplingErrors(
            final Matrix accelerometerScaleFactorAndCrossCouplingErrors) {
<span class="fc bfc" id="L844" title="All 2 branches covered.">        if (accelerometerScaleFactorAndCrossCouplingErrors.getRows() != ACCELEROMETER_COMPONENTS</span>
<span class="fc bfc" id="L845" title="All 2 branches covered.">                || accelerometerScaleFactorAndCrossCouplingErrors.getColumns() != ACCELEROMETER_COMPONENTS) {</span>
<span class="fc" id="L846">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L849">        mAccelerometerScaleFactorAndCrossCouplingErrors</span>
<span class="fc" id="L850">                .copyFrom(accelerometerScaleFactorAndCrossCouplingErrors);</span>
<span class="fc" id="L851">    }</span>

    /**
     * Gets gyro scale factors and cross coupling errors.
     * This is the product of matrix Tg containing cross coupling errors and Kg
     * containing scaling factors.
     * So tat:
     * &lt;pre&gt;
     *     Mg = [sx    mxy  mxz] = Tg*Kg
     *          [myx   sy   myz]
     *          [mzx   mzy  sz ]
     * &lt;/pre&gt;
     * Where:
     * &lt;pre&gt;
     *     Kg = [sx 0   0 ]
     *          [0  sy  0 ]
     *          [0  0   sz]
     * &lt;/pre&gt;
     * and
     * &lt;pre&gt;
     *     Tg = [1          -gammaXy    gammaXz ]
     *          [gammaYx    1           -gammaYz]
     *          [-gammaZx   gammaZy     1       ]
     * &lt;/pre&gt;
     * Hence:
     * &lt;pre&gt;
     *     Mg = [sx    mxy  mxz] = Tg*Kg =  [sx             -sy * gammaXy   sz * gammaXz ]
     *          [myx   sy   myz]            [sx * gammaYx   sy              -sz * gammaYz]
     *          [mzx   mzy  sz ]            [-sx * gammaZx  sy * gammaZy    sz           ]
     * &lt;/pre&gt;
     * This instance allows any 3x3 matrix however, typically gammaYx, gammaZx and gammaZy
     * are considered to be zero if the accelerometer z-axis is assumed to be the same
     * as the body z-axis. When this is assumed, myx = mzx = mzy = 0 and the Ma matrix
     * becomes upper diagonal:
     * &lt;pre&gt;
     *     Ma = [sx    mxy  mxz]
     *          [0     sy   myz]
     *          [0     0    sz ]
     * &lt;/pre&gt;
     * Values of this matrix are unitless.
     * By default it is the 3x3 identity matrix.
     *
     * @return gyro scale factors and cross coupling errors.
     */
    public Matrix getGyroScaleFactorAndCrossCouplingErrors() {
<span class="fc" id="L896">        return new Matrix(mGyroScaleFactorAndCrossCouplingErrors);</span>
    }

    /**
     * Gets gyro scale factors and cross coupling errors.
     * This is the product of matrix Tg containing cross coupling errors and Kg
     * containing scaling factors.
     * So tat:
     * &lt;pre&gt;
     *     Mg = [sx    mxy  mxz] = Tg*Kg
     *          [myx   sy   myz]
     *          [mzx   mzy  sz ]
     * &lt;/pre&gt;
     * Where:
     * &lt;pre&gt;
     *     Kg = [sx 0   0 ]
     *          [0  sy  0 ]
     *          [0  0   sz]
     * &lt;/pre&gt;
     * and
     * &lt;pre&gt;
     *     Tg = [1          -gammaXy    gammaXz ]
     *          [gammaYx    1           -gammaYz]
     *          [-gammaZx   gammaZy     1       ]
     * &lt;/pre&gt;
     * Hence:
     * &lt;pre&gt;
     *     Mg = [sx    mxy  mxz] = Tg*Kg =  [sx             -sy * gammaXy   sz * gammaXz ]
     *          [myx   sy   myz]            [sx * gammaYx   sy              -sz * gammaYz]
     *          [mzx   mzy  sz ]            [-sx * gammaZx  sy * gammaZy    sz           ]
     * &lt;/pre&gt;
     * This instance allows any 3x3 matrix however, typically gammaYx, gammaZx and gammaZy
     * are considered to be zero if the accelerometer z-axis is assumed to be the same
     * as the body z-axis. When this is assumed, myx = mzx = mzy = 0 and the Ma matrix
     * becomes upper diagonal:
     * &lt;pre&gt;
     *     Ma = [sx    mxy  mxz]
     *          [0     sy   myz]
     *          [0     0    sz ]
     * &lt;/pre&gt;
     * Values of this matrix are unitless.
     * By default it is the 3x3 identity matrix.
     *
     * @param result instance where data of scale factor and cross coupling matrix will
     *               be copied to. If needed, result instance will be resized.
     */
    public void getGyroScaleFactorAndCrossCouplingErrors(final Matrix result) {
<span class="fc" id="L943">        result.copyFrom(mGyroScaleFactorAndCrossCouplingErrors);</span>
<span class="fc" id="L944">    }</span>

    /**
     * Sets gyro scale factors and cross coupling errors.
     * This is the product of matrix Tg containing cross coupling errors and Kg
     * containing scaling factors.
     * So tat:
     * &lt;pre&gt;
     *     Mg = [sx    mxy  mxz] = Tg*Kg
     *          [myx   sy   myz]
     *          [mzx   mzy  sz ]
     * &lt;/pre&gt;
     * Where:
     * &lt;pre&gt;
     *     Kg = [sx 0   0 ]
     *          [0  sy  0 ]
     *          [0  0   sz]
     * &lt;/pre&gt;
     * and
     * &lt;pre&gt;
     *     Tg = [1          -gammaXy    gammaXz ]
     *          [gammaYx    1           -gammaYz]
     *          [-gammaZx   gammaZy     1       ]
     * &lt;/pre&gt;
     * Hence:
     * &lt;pre&gt;
     *     Mg = [sx    mxy  mxz] = Tg*Kg =  [sx             -sy * gammaXy   sz * gammaXz ]
     *          [myx   sy   myz]            [sx * gammaYx   sy              -sz * gammaYz]
     *          [mzx   mzy  sz ]            [-sx * gammaZx  sy * gammaZy    sz           ]
     * &lt;/pre&gt;
     * This instance allows any 3x3 matrix however, typically gammaYx, gammaZx and gammaZy
     * are considered to be zero if the accelerometer z-axis is assumed to be the same
     * as the body z-axis. When this is assumed, myx = mzx = mzy = 0 and the Ma matrix
     * becomes upper diagonal:
     * &lt;pre&gt;
     *     Ma = [sx    mxy  mxz]
     *          [0     sy   myz]
     *          [0     0    sz ]
     * &lt;/pre&gt;
     * Values of this matrix are unitless.
     *
     * @param gyroScaleFactorAndCrossCouplingErrors scale factors and cross coupling
     *                                              matrix to be set.
     * @throws IllegalArgumentException if provided matrix is not 3x3.
     */
    public void setGyroScaleFactorAndCrossCouplingErrors(
            final Matrix gyroScaleFactorAndCrossCouplingErrors) {
<span class="fc bfc" id="L991" title="All 2 branches covered.">        if (gyroScaleFactorAndCrossCouplingErrors.getRows() != GYRO_COMPONENTS</span>
<span class="fc bfc" id="L992" title="All 2 branches covered.">                || gyroScaleFactorAndCrossCouplingErrors.getColumns() != GYRO_COMPONENTS) {</span>
<span class="fc" id="L993">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L996">        mGyroScaleFactorAndCrossCouplingErrors</span>
<span class="fc" id="L997">                .copyFrom(gyroScaleFactorAndCrossCouplingErrors);</span>
<span class="fc" id="L998">    }</span>

    /**
     * Gets 3x3 matrix containing cross biases introduced by the specific forces
     * sensed by the accelerometer.
     * Values of this matrix are expressed in (rad-sec/m).
     * By default it is all zeros.
     *
     * @return cross biases introduced by the specific forces sensed by the
     * accelerometer.
     */
    public Matrix getGyroGDependentBiases() {
<span class="fc" id="L1010">        return new Matrix(mGyroGDependentBiases);</span>
    }

    /**
     * Gets 3x3 matrix containing cross biases introduced by the specific forces
     * sensed by the accelerometer.
     * Values of this matrix are expressed in (rad-sec/m).
     * By default it is all zeros.
     *
     * @param result instance where data will be stored. If needed, result instance
     *               will be resized.
     */
    public void getGyroGDependentBiases(final Matrix result) {
<span class="fc" id="L1023">        result.copyFrom(mGyroGDependentBiases);</span>
<span class="fc" id="L1024">    }</span>

    /**
     * Sets 3x3 matrix containing cross biases introduced by the specific forces
     * sensed by the accelerometer.
     * Values of this matrix are expressed in (rad-sec/m).
     *
     * @param gyroGDependentBiases cross biases introduced by the specific forces
     *                             sensed by the accelerometer to be set.
     * @throws IllegalArgumentException if provided matrix is not 3x3.
     */
    public void setGyroGDependentBiases(final Matrix gyroGDependentBiases) {
<span class="fc bfc" id="L1036" title="All 2 branches covered.">        if (gyroGDependentBiases.getRows() != ACCELEROMETER_COMPONENTS</span>
<span class="fc bfc" id="L1037" title="All 2 branches covered.">                || gyroGDependentBiases.getColumns() != ACCELEROMETER_COMPONENTS) {</span>
<span class="fc" id="L1038">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L1041">        mGyroGDependentBiases.copyFrom(gyroGDependentBiases);</span>
<span class="fc" id="L1042">    }</span>

    /**
     * Gets accelerometer noise root PSD expressed in (m * s^-1.5).
     * By default it is zero.
     *
     * @return accelerometer noise root PSD.
     */
    public double getAccelerometerNoiseRootPSD() {
<span class="fc" id="L1051">        return mAccelerometerNoiseRootPSD;</span>
    }

    /**
     * Sets accelerometer noise root PSD expressed in (m * s^-1.5)
     *
     * @param accelerometerNoiseRootPSD accelerometer noise root PSD to be set.
     */
    public void setAccelerometerNoiseRootPSD(final double accelerometerNoiseRootPSD) {
<span class="fc" id="L1060">        mAccelerometerNoiseRootPSD = accelerometerNoiseRootPSD;</span>
<span class="fc" id="L1061">    }</span>

    /**
     * Gets accelerometer noise PSD expressed in (m^2 * s^-3).
     * By default it is zero.
     *
     * @return accelerometer noise PSD.
     */
    public double getAccelerometerNoisePSD() {
<span class="fc" id="L1070">        return mAccelerometerNoiseRootPSD * mAccelerometerNoiseRootPSD;</span>
    }

    /**
     * Sets accelerometer noise PSD expressed in (m^2 * s^-3).
     *
     * @param accelerometerNoisePSD accelerometer noise PSD to be set.
     * @throws IllegalArgumentException if provided value is negative.
     */
    public void setAccelerometerNoisePSD(final double accelerometerNoisePSD) {
<span class="fc bfc" id="L1080" title="All 2 branches covered.">        if (accelerometerNoisePSD &lt; 0.0) {</span>
<span class="fc" id="L1081">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L1084">        mAccelerometerNoiseRootPSD = Math.sqrt(accelerometerNoisePSD);</span>
<span class="fc" id="L1085">    }</span>

    /**
     * Gets gyro noise root PSD expressed in (rad * s^-0.5).
     * By default it is zero.
     *
     * @return gyro noise root PSD.
     */
    public double getGyroNoiseRootPSD() {
<span class="fc" id="L1094">        return mGyroNoiseRootPSD;</span>
    }

    /**
     * Sets gyro noise root PSD expressed in (rad * s^-0.5).
     *
     * @param gyroNoiseRootPSD gyro noise root PSD to be set.
     */
    public void setGyroNoiseRootPSD(final double gyroNoiseRootPSD) {
<span class="fc" id="L1103">        mGyroNoiseRootPSD = gyroNoiseRootPSD;</span>
<span class="fc" id="L1104">    }</span>

    /**
     * Gets gyro noise PSD expressed in (rad^2/s).
     * By default it is zero.
     *
     * @return gyro noise PSD.
     */
    public double getGyroNoisePSD() {
<span class="fc" id="L1113">        return mGyroNoiseRootPSD * mGyroNoiseRootPSD;</span>
    }

    /**
     * Sets gyro noise PSD expressed in (rad^2/s).
     *
     * @param gyroNoisePSD gyro noise PSD.
     * @throws IllegalArgumentException if provided value is negative.
     */
    public void setGyroNoisePSD(final double gyroNoisePSD) {
<span class="fc bfc" id="L1123" title="All 2 branches covered.">        if (gyroNoisePSD &lt; 0.0) {</span>
<span class="fc" id="L1124">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L1127">        mGyroNoiseRootPSD = Math.sqrt(gyroNoisePSD);</span>
<span class="fc" id="L1128">    }</span>

    /**
     * Gets accelerometer quantization level expressed in meters per squared second
     * (m/s^2).
     * By default it is zero when no quantization is assumed.
     *
     * @return accelerometer quantization level.
     */
    public double getAccelerometerQuantizationLevel() {
<span class="fc" id="L1138">        return mAccelerometerQuantizationLevel;</span>
    }

    /**
     * Sets accelerometer quantization level expressed in meters per squared second
     * (m/s^2).
     *
     * @param accelerometerQuantizationLevel accelerometer quantization level to be
     *                                       set.
     */
    public void setAccelerometerQuantizationLevel(
            final double accelerometerQuantizationLevel) {
<span class="fc" id="L1150">        mAccelerometerQuantizationLevel = accelerometerQuantizationLevel;</span>
<span class="fc" id="L1151">    }</span>

    /**
     * Gets accelerometer quantization level.
     * By default it is zero when no quantization is assumed.
     *
     * @return accelerometer quantization level.
     */
    public Acceleration getAccelerometerQuantizationLevelAsAcceleration() {
<span class="fc" id="L1160">        return new Acceleration(mAccelerometerQuantizationLevel,</span>
                AccelerationUnit.METERS_PER_SQUARED_SECOND);
    }

    /**
     * Gets accelerometer quantization level.
     * By default it is zero when no quantization is assumed.
     *
     * @param result instance where value will be stored.
     */
    public void getAccelerometerQuantizationLevelAsAcceleration(final Acceleration result) {
<span class="fc" id="L1171">        result.setValue(mAccelerometerQuantizationLevel);</span>
<span class="fc" id="L1172">        result.setUnit(AccelerationUnit.METERS_PER_SQUARED_SECOND);</span>
<span class="fc" id="L1173">    }</span>

    /**
     * Sets accelerometer quantization level.
     *
     * @param accelerometerQuantizationLevel accelerometer quantization level to be set.
     */
    public void setAccelerometerQuantizationLevel(
            final Acceleration accelerometerQuantizationLevel) {
<span class="fc" id="L1182">        mAccelerometerQuantizationLevel = convertAcceleration(</span>
                accelerometerQuantizationLevel);
<span class="fc" id="L1184">    }</span>

    /**
     * Gets gyro quantization level expressed in radians per second (rad/s).
     * By default it is zero when no quantization is assumed.
     *
     * @return gyro quantization level expressed in radians per seocnd.
     */
    public double getGyroQuantizationLevel() {
<span class="fc" id="L1193">        return mGyroQuantizationLevel;</span>
    }

    /**
     * Sets gyro quantization level expressed in radians per second (rad/s).
     *
     * @param gyroQuantizationLevel gyro quantization level to be set.
     */
    public void setGyroQuantizationLevel(final double gyroQuantizationLevel) {
<span class="fc" id="L1202">        mGyroQuantizationLevel = gyroQuantizationLevel;</span>
<span class="fc" id="L1203">    }</span>

    /**
     * Gets gyro quantization level.
     * By default it is zero when no quantization is assumed.
     *
     * @return gyro quantization level.
     */
    public AngularSpeed getGyroQuantizationLevelAsAngularSpeed() {
<span class="fc" id="L1212">        return new AngularSpeed(mGyroQuantizationLevel,</span>
                AngularSpeedUnit.RADIANS_PER_SECOND);
    }

    /**
     * Gets gyro quantization level.
     * By default it is zero when no quantization is assumed.
     *
     * @param result instance where value will be stored.
     */
    public void getGyroQuantizationLevelAsAngularSpeed(final AngularSpeed result) {
<span class="fc" id="L1223">        result.setValue(mGyroQuantizationLevel);</span>
<span class="fc" id="L1224">        result.setUnit(AngularSpeedUnit.RADIANS_PER_SECOND);</span>
<span class="fc" id="L1225">    }</span>

    /**
     * Sets gyro quantization level.
     *
     * @param gyroQuantizationLevel gyro quantization level.
     */
    public void setGyroQuantizationLevel(final AngularSpeed gyroQuantizationLevel) {
<span class="fc" id="L1233">        mGyroQuantizationLevel = convertAngularSpeed(gyroQuantizationLevel);</span>
<span class="fc" id="L1234">    }</span>

    /**
     * Copies this instance data into provided instance.
     *
     * @param output destination instance where data will be copied to.
     */
    public void copyTo(final IMUErrors output) {
<span class="fc" id="L1242">        output.copyFrom(this);</span>
<span class="fc" id="L1243">    }</span>

    /**
     * Copies data of provided instance into this instance.
     *
     * @param input instance to copy data from.
     */
    public void copyFrom(final IMUErrors input) {
<span class="fc" id="L1251">        input.getAccelerometerBiases(mAccelerometerBiases);</span>
<span class="fc" id="L1252">        input.getGyroBiases(mGyroBiases);</span>
<span class="fc" id="L1253">        mAccelerometerScaleFactorAndCrossCouplingErrors.copyFrom(</span>
                input.mAccelerometerScaleFactorAndCrossCouplingErrors);
<span class="fc" id="L1255">        mGyroScaleFactorAndCrossCouplingErrors.copyFrom(</span>
                input.mGyroScaleFactorAndCrossCouplingErrors);
<span class="fc" id="L1257">        mGyroGDependentBiases.copyFrom(input.mGyroGDependentBiases);</span>
<span class="fc" id="L1258">        mAccelerometerNoiseRootPSD = input.mAccelerometerNoiseRootPSD;</span>
<span class="fc" id="L1259">        mGyroNoiseRootPSD = input.mGyroNoiseRootPSD;</span>
<span class="fc" id="L1260">        mAccelerometerQuantizationLevel = input.mAccelerometerQuantizationLevel;</span>
<span class="fc" id="L1261">        mGyroQuantizationLevel = input.mGyroQuantizationLevel;</span>
<span class="fc" id="L1262">    }</span>

    /**
     * Computes and returns hash code for this instance. Hash codes are almost unique
     * values that are useful for fast classification and storage of objects in
     * collections.
     *
     * @return Hash code.
     */
    @Override
    public int hashCode() {
<span class="fc" id="L1273">        int result = Objects.hash(mAccelerometerScaleFactorAndCrossCouplingErrors,</span>
                mGyroScaleFactorAndCrossCouplingErrors, mGyroGDependentBiases,
<span class="fc" id="L1275">                mAccelerometerNoiseRootPSD, mGyroNoiseRootPSD,</span>
<span class="fc" id="L1276">                mAccelerometerQuantizationLevel, mGyroQuantizationLevel);</span>
<span class="fc" id="L1277">        result = 31 * result + Arrays.hashCode(mAccelerometerBiases);</span>
<span class="fc" id="L1278">        result = 31 * result + Arrays.hashCode(mGyroBiases);</span>
<span class="fc" id="L1279">        return result;</span>
    }

    /**
     * Checks if provided object is an IMUErrors instance having exactly the same
     * contents as this instance.
     *
     * @param o Object to be compared.
     * @return true if both objects are considered to be equal, false otherwise.
     */
    @Override
    public boolean equals(Object o) {
<span class="fc bfc" id="L1291" title="All 2 branches covered.">        if (this == o) return true;</span>
<span class="fc bfc" id="L1292" title="All 4 branches covered.">        if (o == null || getClass() != o.getClass()) return false;</span>
<span class="fc" id="L1293">        final IMUErrors imuErrors = (IMUErrors) o;</span>
<span class="fc bfc" id="L1294" title="All 2 branches covered.">        return Double.compare(imuErrors.mAccelerometerNoiseRootPSD, mAccelerometerNoiseRootPSD) == 0 &amp;&amp;</span>
<span class="pc bpc" id="L1295" title="1 of 2 branches missed.">                Double.compare(imuErrors.mGyroNoiseRootPSD, mGyroNoiseRootPSD) == 0 &amp;&amp;</span>
<span class="pc bpc" id="L1296" title="1 of 2 branches missed.">                Double.compare(imuErrors.mAccelerometerQuantizationLevel, mAccelerometerQuantizationLevel) == 0 &amp;&amp;</span>
<span class="pc bpc" id="L1297" title="1 of 2 branches missed.">                Double.compare(imuErrors.mGyroQuantizationLevel, mGyroQuantizationLevel) == 0 &amp;&amp;</span>
<span class="pc bpc" id="L1298" title="1 of 2 branches missed.">                Arrays.equals(mAccelerometerBiases, imuErrors.mAccelerometerBiases) &amp;&amp;</span>
<span class="pc bpc" id="L1299" title="1 of 2 branches missed.">                Arrays.equals(mGyroBiases, imuErrors.mGyroBiases) &amp;&amp;</span>
<span class="pc bpc" id="L1300" title="1 of 2 branches missed.">                mAccelerometerScaleFactorAndCrossCouplingErrors.equals(</span>
                        imuErrors.mAccelerometerScaleFactorAndCrossCouplingErrors) &amp;&amp;
<span class="pc bpc" id="L1302" title="1 of 2 branches missed.">                mGyroScaleFactorAndCrossCouplingErrors.equals(imuErrors.mGyroScaleFactorAndCrossCouplingErrors) &amp;&amp;</span>
<span class="pc bpc" id="L1303" title="1 of 2 branches missed.">                mGyroGDependentBiases.equals(imuErrors.mGyroGDependentBiases);</span>
    }

    /**
     * Makes a copy of this instance.
     *
     * @return a copy of this instance.
     * @throws CloneNotSupportedException if clone fails for some reason.
     */
    @Override
    protected Object clone() throws CloneNotSupportedException {
<span class="fc" id="L1314">        final IMUErrors result = (IMUErrors) super.clone();</span>
<span class="fc" id="L1315">        copyTo(result);</span>
<span class="fc" id="L1316">        return result;</span>
    }

    /**
     * Converts acceleration instance to meters per squared second (m/s^2).
     *
     * @param acceleration instance to be converted.
     * @return converted value.
     */
    private double convertAcceleration(final Acceleration acceleration) {
<span class="fc" id="L1326">        return AccelerationConverter.convert(acceleration.getValue().doubleValue(),</span>
<span class="fc" id="L1327">                acceleration.getUnit(), AccelerationUnit.METERS_PER_SQUARED_SECOND);</span>
    }

    /**
     * Converts angular speed instance to radians per second (rad/s).
     *
     * @param angularSpeed instance ot be converted.
     * @return converted value.
     */
    private double convertAngularSpeed(final AngularSpeed angularSpeed) {
<span class="fc" id="L1337">        return AngularSpeedConverter.convert(angularSpeed.getValue().doubleValue(),</span>
<span class="fc" id="L1338">                angularSpeed.getUnit(), AngularSpeedUnit.RADIANS_PER_SECOND);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>