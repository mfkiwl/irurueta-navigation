<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>QuaternionIntegrator2.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.irurueta:irurueta-navigation</a> &gt; <a href="index.source.html" class="el_package">com.irurueta.navigation.inertial.calibration.gyroscope</a> &gt; <span class="el_source">QuaternionIntegrator2.java</span></div><h1>QuaternionIntegrator2.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2020 Alberto Irurueta Carro (alberto@irurueta.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.irurueta.navigation.inertial.calibration.gyroscope;

import com.irurueta.algebra.Matrix;
import com.irurueta.algebra.Utils;
import com.irurueta.algebra.WrongSizeException;
import com.irurueta.geometry.Quaternion;
import com.irurueta.navigation.inertial.BodyKinematics;
import com.irurueta.navigation.inertial.calibration.BodyKinematicsSequence2;
import com.irurueta.navigation.inertial.calibration.StandardDeviationTimedBodyKinematics;

import java.util.List;

/**
 * Class in charge of performing integration steps of rotations.
 * This implementation uses a Runge-Kutta integration algorithm to obtain
 * accurate results on {@link EasyGyroscopeCalibrator}
 */
<span class="nc" id="L33">public class QuaternionIntegrator2 {</span>

    /**
     * Integrates a sequence of gyroscope measurements contained within timed body kinematics,
     * starting at an initial attitude to obtain a final attitude.
     *
     * @param sequence        sequence of gyroscope measurements to be integrated.
     * @param initialAttitude (optional) initial attitude to be used. If null, then the
     *                        identity attitude will be used.
     * @param result          resulting rotation after integration.
     */
    public static void integrateGyroSequence(
            final BodyKinematicsSequence2&lt;StandardDeviationTimedBodyKinematics&gt; sequence,
            final Quaternion initialAttitude,
            final Quaternion result) {

<span class="fc bfc" id="L49" title="All 2 branches covered.">        if (initialAttitude != null) {</span>
            // if provided initial attitude
<span class="fc" id="L51">            result.fromRotation(initialAttitude);</span>
        } else {
            // if no initial attitude is provided, we use the identity
<span class="fc" id="L54">            result.setA(1.0);</span>
<span class="fc" id="L55">            result.setB(0.0);</span>
<span class="fc" id="L56">            result.setC(0.0);</span>
<span class="fc" id="L57">            result.setD(0.0);</span>
        }


<span class="fc" id="L61">        final List&lt;StandardDeviationTimedBodyKinematics&gt; sortedMeasurements =</span>
<span class="fc" id="L62">                sequence.getSortedItems();</span>

<span class="fc" id="L64">        boolean first = true;</span>
<span class="fc" id="L65">        double previousTimestamp = 0.0;</span>
<span class="fc" id="L66">        final double[] previousGyroData = new double[BodyKinematics.COMPONENTS];</span>
<span class="fc" id="L67">        final double[] gyroData = new double[BodyKinematics.COMPONENTS];</span>
<span class="fc bfc" id="L68" title="All 2 branches covered.">        for (final StandardDeviationTimedBodyKinematics measurement : sortedMeasurements) {</span>
<span class="fc" id="L69">            final BodyKinematics kinematics = measurement.getKinematics();</span>

<span class="fc" id="L71">            gyroData[0] = kinematics.getAngularRateX();</span>
<span class="fc" id="L72">            gyroData[1] = kinematics.getAngularRateY();</span>
<span class="fc" id="L73">            gyroData[2] = kinematics.getAngularRateZ();</span>

<span class="fc bfc" id="L75" title="All 2 branches covered.">            if (first) {</span>
<span class="fc" id="L76">                previousTimestamp = measurement.getTimestampSeconds();</span>

                // copy gyroData to previousGyroData
<span class="fc" id="L79">                System.arraycopy(gyroData, 0, previousGyroData, 0, gyroData.length);</span>

<span class="fc" id="L81">                first = false;</span>
<span class="fc" id="L82">                continue;</span>
            }

<span class="fc" id="L85">            final double timestamp = measurement.getTimestampSeconds();</span>


<span class="fc" id="L88">            final double dt = timestamp - previousTimestamp;</span>

<span class="fc" id="L90">            quatIntegrationStepRK4(result, previousGyroData, gyroData, dt, result);</span>


            // prepare data for next iteration

            // copy gyroData to previousGyroData
<span class="fc" id="L96">            System.arraycopy(gyroData, 0, previousGyroData, 0, gyroData.length);</span>
            // copy timestamp to previous timestamp
<span class="fc" id="L98">            previousTimestamp = timestamp;</span>
<span class="fc" id="L99">        }</span>
<span class="fc" id="L100">    }</span>

    /**
     * Integrates a sequence of gyroscope measurements contained within timed body kinematics,
     * starting at the identity attitude to obtain a final attitude.
     *
     * @param sequence sequence of gyroscope measurements to be integrated.
     * @param result   resulting rotation after integration.
     */
    public static void integrateGyroSequence(
            final BodyKinematicsSequence2&lt;StandardDeviationTimedBodyKinematics&gt; sequence,
            final Quaternion result) {
<span class="fc" id="L112">        integrateGyroSequence(sequence, null, result);</span>
<span class="fc" id="L113">    }</span>

    /**
     * Integrates a sequence of gyroscope measurements contained within timed body kinematics,
     * starting at an initial attitude to obtain a final attitude.
     *
     * @param sequence        sequence of gyroscope measurements to be integrated.
     * @param initialAttitude (optional) initial attitude to be used. If null, then the
     *                        identity attitude will be used.
     * @return resulting rotation after integration.
     */
    public static Quaternion integrateGyroSequenceAndReturnNew(
            final BodyKinematicsSequence2&lt;StandardDeviationTimedBodyKinematics&gt; sequence,
            final Quaternion initialAttitude) {
<span class="nc" id="L127">        final Quaternion result = new Quaternion();</span>
<span class="nc" id="L128">        integrateGyroSequence(sequence, initialAttitude, result);</span>
<span class="nc" id="L129">        return result;</span>
    }

    /**
     * Integrates a sequence of gyroscope measurements contained within timed body kinematics,
     * starting at the identity attitude to obtain a final attitude.
     *
     * @param sequence sequence of gyroscope measurements to be integrated.
     * @return resulting rotation after integration.
     */
    public static Quaternion integrateGyroSequenceAndReturnNew(
            final BodyKinematicsSequence2&lt;StandardDeviationTimedBodyKinematics&gt; sequence) {
<span class="nc" id="L141">        final Quaternion result = new Quaternion();</span>
<span class="nc" id="L142">        integrateGyroSequence(sequence, result);</span>
<span class="nc" id="L143">        return result;</span>
    }

    /**
     * Normalize an input matrix corresponding to a quaterniont into a unit
     * vector.
     *
     * @param quaternion matrix containing quaternion values to be normalized.
     */
    private static void normalizeQuaternion(final Matrix quaternion) {
<span class="fc" id="L153">        final double norm = Utils.normF(quaternion);</span>
<span class="fc" id="L154">        quaternion.multiplyByScalar(1.0 / norm);</span>
<span class="fc" id="L155">    }</span>

    /**
     * Gets skew symmetric matrix representation of angular speed.
     *
     * @param omega  matrix containing angular speed components. Must be 3x1.
     * @param result computed skew symmetricmatrix representation. Must be 4x4.
     */
    private static void computeOmegaSkew(final Matrix omega, final Matrix result) {
<span class="fc" id="L164">        final double omega0 = omega.getElementAtIndex(0);</span>
<span class="fc" id="L165">        final double omega1 = omega.getElementAtIndex(1);</span>
<span class="fc" id="L166">        final double omega2 = omega.getElementAtIndex(2);</span>

<span class="fc" id="L168">        result.setElementAtIndex(0, 0.0);</span>
<span class="fc" id="L169">        result.setElementAtIndex(1, omega0);</span>
<span class="fc" id="L170">        result.setElementAtIndex(2, omega1);</span>
<span class="fc" id="L171">        result.setElementAtIndex(3, omega2);</span>

<span class="fc" id="L173">        result.setElementAtIndex(4, -omega0);</span>
<span class="fc" id="L174">        result.setElementAtIndex(5, 0.0);</span>
<span class="fc" id="L175">        result.setElementAtIndex(6, -omega2);</span>
<span class="fc" id="L176">        result.setElementAtIndex(7, omega1);</span>

<span class="fc" id="L178">        result.setElementAtIndex(8, -omega1);</span>
<span class="fc" id="L179">        result.setElementAtIndex(9, omega2);</span>
<span class="fc" id="L180">        result.setElementAtIndex(10, 0.0);</span>
<span class="fc" id="L181">        result.setElementAtIndex(11, -omega0);</span>

<span class="fc" id="L183">        result.setElementAtIndex(12, -omega2);</span>
<span class="fc" id="L184">        result.setElementAtIndex(13, -omega1);</span>
<span class="fc" id="L185">        result.setElementAtIndex(14, omega0);</span>
<span class="fc" id="L186">        result.setElementAtIndex(15, 0.0);</span>
<span class="fc" id="L187">    }</span>

    /**
     * Performs a RK4 Runge-Kutta integration step.
     *
     * @param quat   the input 4D vector representing the initial rotation as
     *               quaternion values. Must be 4x1.
     * @param omega0 initial rotational velocity at time t0 expressed in radians
     *               per second (rad/s). Must be 3x1.
     * @param omega1 final rotational velocity at time t1 expressed in radians
     *               per second (rad/s). Must be 3x1.
     * @param dt     time step expressed in seconds (t1 - t0).
     * @param result resulting final rotation. Must be 4x1.
     */
    private static void quatIntegrationStepRK4(
            final Matrix quat,
            final Matrix omega0,
            final Matrix omega1,
            final double dt,
            final Matrix result) {
        try {
<span class="fc" id="L208">            final Matrix omega01 = omega0.addAndReturnNew(omega1);</span>
<span class="fc" id="L209">            omega01.multiplyByScalar(0.5);</span>

<span class="fc" id="L211">            final Matrix k1 = new Matrix(Quaternion.N_PARAMS, 1);</span>
<span class="fc" id="L212">            final Matrix k2 = new Matrix(Quaternion.N_PARAMS, 1);</span>
<span class="fc" id="L213">            final Matrix k3 = new Matrix(Quaternion.N_PARAMS, 1);</span>
<span class="fc" id="L214">            final Matrix k4 = new Matrix(Quaternion.N_PARAMS, 1);</span>
<span class="fc" id="L215">            final Matrix tmpQ = new Matrix(Quaternion.N_PARAMS, 1);</span>

<span class="fc" id="L217">            final Matrix omegaSkew = new Matrix(</span>
                    Quaternion.N_PARAMS, Quaternion.N_PARAMS);

            // First Runge-Kutta coefficient
<span class="fc" id="L221">            computeOmegaSkew(omega0, omegaSkew);</span>
<span class="fc" id="L222">            omegaSkew.multiply(quat, k1);</span>
<span class="fc" id="L223">            k1.multiplyByScalar(0.5);</span>

            // Second Runge-Kutta coefficient
<span class="fc" id="L226">            tmpQ.copyFrom(k1);</span>
<span class="fc" id="L227">            tmpQ.multiplyByScalar(0.5 * dt);</span>
<span class="fc" id="L228">            tmpQ.add(quat);</span>
<span class="fc" id="L229">            computeOmegaSkew(omega01, omegaSkew);</span>
<span class="fc" id="L230">            omegaSkew.multiply(tmpQ, k2);</span>
<span class="fc" id="L231">            k2.multiplyByScalar(0.5);</span>

            // Third Runge-Kutta coefficient (same omega skew as second coeff.)
<span class="fc" id="L234">            tmpQ.copyFrom(k2);</span>
<span class="fc" id="L235">            tmpQ.multiplyByScalar(0.5 * dt);</span>
<span class="fc" id="L236">            tmpQ.add(quat);</span>
<span class="fc" id="L237">            omegaSkew.multiply(tmpQ, k3);</span>
<span class="fc" id="L238">            k3.multiplyByScalar(0.5);</span>

            // Forth Runge-Kutta coefficient
<span class="fc" id="L241">            tmpQ.copyFrom(k3);</span>
<span class="fc" id="L242">            tmpQ.multiplyByScalar(dt);</span>
<span class="fc" id="L243">            tmpQ.add(quat);</span>
<span class="fc" id="L244">            computeOmegaSkew(omega1, omegaSkew);</span>
<span class="fc" id="L245">            omegaSkew.multiply(tmpQ, k4);</span>
<span class="fc" id="L246">            k4.multiplyByScalar(0.5);</span>

<span class="fc" id="L248">            final double mult1 = 1.0 / 6.0;</span>
<span class="fc" id="L249">            final double mult2 = 1.0 / 3.0;</span>

            // result = quat + dt * (mult1 * k1 + mult2 * k2 + mult2 * k3 + mult1 * k4)
<span class="fc" id="L252">            k1.multiplyByScalar(mult1);</span>
<span class="fc" id="L253">            k2.multiplyByScalar(mult2);</span>
<span class="fc" id="L254">            k3.multiplyByScalar(mult2);</span>
<span class="fc" id="L255">            k4.multiplyByScalar(mult1);</span>

<span class="fc" id="L257">            result.copyFrom(k1);</span>
<span class="fc" id="L258">            result.add(k2);</span>
<span class="fc" id="L259">            result.add(k3);</span>
<span class="fc" id="L260">            result.add(k4);</span>
<span class="fc" id="L261">            result.multiplyByScalar(dt);</span>
<span class="fc" id="L262">            result.add(quat);</span>
<span class="nc" id="L263">        } catch (final WrongSizeException ignore) {</span>
            // never happens
<span class="fc" id="L265">        }</span>

<span class="fc" id="L267">        normalizeQuaternion(result);</span>
<span class="fc" id="L268">    }</span>

    /**
     * Performs a RK4 Runge-Kutta integration step.
     *
     * @param quaternion the initial rotation.
     * @param omega0     initial rotation velocity at time t0 expressed in radians
     *                   per second (rad/s). Must have length 3.
     * @param omega1     final rotation velocity at time t1 expressed in radians
     *                   per second (rad/s). Must have length 3.
     * @param dt         time step expressed in seconds (t1 - t0).
     * @param result     resulting final rotation.
     */
    private static void quatIntegrationStepRK4(
            final Quaternion quaternion,
            final double[] omega0,
            final double[] omega1,
            final double dt,
            final Quaternion result) {
        try {
<span class="fc" id="L288">            final Matrix quat = new Matrix(</span>
                    Quaternion.N_PARAMS, 1);
<span class="fc" id="L290">            quaternion.values(quat.getBuffer());</span>

<span class="fc" id="L292">            final Matrix omega0b = Matrix.newFromArray(omega0);</span>
<span class="fc" id="L293">            final Matrix omega1b = Matrix.newFromArray(omega1);</span>

<span class="fc" id="L295">            final Matrix quatResult = new Matrix(</span>
                    Quaternion.N_PARAMS, 1);

<span class="fc" id="L298">            quatIntegrationStepRK4(quat, omega0b, omega1b, dt, quatResult);</span>
<span class="fc" id="L299">            result.setValues(quatResult.getBuffer());</span>

<span class="nc" id="L301">        } catch (WrongSizeException ignore) {</span>
            // never happens
<span class="fc" id="L303">        }</span>
<span class="fc" id="L304">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>