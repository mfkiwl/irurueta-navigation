<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>QuaternionIntegrator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.irurueta:irurueta-navigation</a> &gt; <a href="index.source.html" class="el_package">com.irurueta.navigation.inertial.calibration.gyroscope</a> &gt; <span class="el_source">QuaternionIntegrator.java</span></div><h1>QuaternionIntegrator.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2020 Alberto Irurueta Carro (alberto@irurueta.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.irurueta.navigation.inertial.calibration.gyroscope;

import com.irurueta.algebra.Matrix;
import com.irurueta.algebra.Utils;
import com.irurueta.algebra.WrongSizeException;
import com.irurueta.geometry.InvalidRotationMatrixException;
import com.irurueta.geometry.Quaternion;
import com.irurueta.navigation.frames.CoordinateTransformation;
import com.irurueta.navigation.frames.FrameType;
import com.irurueta.navigation.inertial.BodyKinematics;
import com.irurueta.navigation.inertial.calibration.BodyKinematicsSequence;
import com.irurueta.navigation.inertial.calibration.StandardDeviationTimedBodyKinematics;

import java.util.List;

/**
 * Class in charge of performing integration steps of rotations.
 * This implementation uses a Runge-Kutta integration algorithm to obtain
 * accurate results on {@link KnownPositionGyroscopeCalibrator}
 */
<span class="nc" id="L36">public class QuaternionIntegrator {</span>

    /**
     * Integrates a sequence of gyroscope measurements contained within timed body kinematics,
     * starting at an initial attitude to obtain a final attitude.
     *
     * @param sequence        sequence of gyroscope measurements to be integrated.
     * @param initialAttitude (optional) initial attitude to be used. If null, the initial attitude available
     *                        on provided sequence will be used. If that one is neither available, then the
     *                        identity attitude will be used.
     * @param result          resulting rotation after integration.
     * @throws InvalidRotationMatrixException if an invalid rotation is generated. This will happen if numerical
     *                                        instabilities occur.
     */
    public static void integrateGyroSequence(
            final BodyKinematicsSequence&lt;StandardDeviationTimedBodyKinematics&gt; sequence,
            final Quaternion initialAttitude,
            final Quaternion result) throws InvalidRotationMatrixException {

<span class="fc bfc" id="L55" title="All 2 branches covered.">        if (initialAttitude != null) {</span>
            // us provided initial attitude
<span class="fc" id="L57">            result.fromRotation(initialAttitude);</span>
        } else {
            // if no initial attitude is provided, the one contained in sequence is used
            // instead
<span class="fc bfc" id="L61" title="All 2 branches covered.">            if (sequence.getStartBodyAttitude() != null) {</span>
                // use initial attitude in sequence
<span class="fc" id="L63">                sequence.getStartBodyAttitude().asRotation(result);</span>
            } else {
                // if no initial attitude is available in sequence, we use the identity
<span class="fc" id="L66">                result.setA(1.0);</span>
<span class="fc" id="L67">                result.setB(0.0);</span>
<span class="fc" id="L68">                result.setC(0.0);</span>
<span class="fc" id="L69">                result.setD(0.0);</span>
            }
        }


<span class="fc" id="L74">        final List&lt;StandardDeviationTimedBodyKinematics&gt; sortedMeasurements =</span>
<span class="fc" id="L75">                sequence.getSortedItems();</span>

<span class="fc" id="L77">        boolean first = true;</span>
<span class="fc" id="L78">        double previousTimestamp = 0.0;</span>
<span class="fc" id="L79">        final double[] previousGyroData = new double[BodyKinematics.COMPONENTS];</span>
<span class="fc" id="L80">        final double[] gyroData = new double[BodyKinematics.COMPONENTS];</span>
<span class="fc bfc" id="L81" title="All 2 branches covered.">        for (final StandardDeviationTimedBodyKinematics measurement : sortedMeasurements) {</span>
<span class="fc" id="L82">            final BodyKinematics kinematics = measurement.getKinematics();</span>

<span class="fc" id="L84">            gyroData[0] = kinematics.getAngularRateX();</span>
<span class="fc" id="L85">            gyroData[1] = kinematics.getAngularRateY();</span>
<span class="fc" id="L86">            gyroData[2] = kinematics.getAngularRateZ();</span>

<span class="fc bfc" id="L88" title="All 2 branches covered.">            if (first) {</span>
<span class="fc" id="L89">                previousTimestamp = measurement.getTimestampSeconds();</span>

                // copy gyroData to previousGyroData
<span class="fc" id="L92">                System.arraycopy(gyroData, 0, previousGyroData, 0, gyroData.length);</span>

<span class="fc" id="L94">                first = false;</span>
<span class="fc" id="L95">                continue;</span>
            }

<span class="fc" id="L98">            final double timestamp = measurement.getTimestampSeconds();</span>


<span class="fc" id="L101">            final double dt = timestamp - previousTimestamp;</span>

<span class="fc" id="L103">            quatIntegrationStepRK4(result, previousGyroData, gyroData, dt, result);</span>


            // prepare data for next iteration

            // copy gyroData to previousGyroData
<span class="fc" id="L109">            System.arraycopy(gyroData, 0, previousGyroData, 0, gyroData.length);</span>
            // copy timestamp to previous timestamp
<span class="fc" id="L111">            previousTimestamp = timestamp;</span>
<span class="fc" id="L112">        }</span>
<span class="fc" id="L113">    }</span>

    /**
     * Integrates a sequence of gyroscope measurements contained within timed body kinematics,
     * starting at the initial attitude of the sequence (if available) to obtain a final attitude.
     * Notice that if provided sequence does not contain an initial attitude, the identity rotation will be
     * used as the starting attitude.
     *
     * @param sequence sequence of gyroscope measurements to be integrated.
     * @param result   resulting rotation after integration.
     * @throws InvalidRotationMatrixException if an invalid rotation is generated. This will happen if numerical
     *                                        instabilities occur.
     */
    public static void integrateGyroSequence(
            final BodyKinematicsSequence&lt;StandardDeviationTimedBodyKinematics&gt; sequence,
            final Quaternion result) throws InvalidRotationMatrixException {
<span class="fc" id="L129">        integrateGyroSequence(sequence, null, result);</span>
<span class="fc" id="L130">    }</span>

    /**
     * Integrates a sequence of gyroscope measurements contained within timed body kinematics,
     * starting at an initial attitude to obtain a final attitude.
     *
     * @param sequence        sequence of gyroscope measurements to be integrated.
     * @param initialAttitude (optional) initial attitude to be used. If null, the initial attitude available
     *                        on provided sequence will be used. If that one is neither available, then the
     *                        identity attitude will be used.
     * @param result          resulting rotation after integration. Source and destination types will match those
     *                        provided on initial attitude, or if not available, those provided on sequence start body
     *                        attitude. If no initial attitude is available, the identity will be used and start and
     *                        destination types will be left unchanged.
     * @throws InvalidRotationMatrixException if an invalid rotation is generated. This will happen if numerical
     *                                        instabilities occur.
     */
    public static void integrateGyroSequence(
            final BodyKinematicsSequence&lt;StandardDeviationTimedBodyKinematics&gt; sequence,
            final CoordinateTransformation initialAttitude,
            final CoordinateTransformation result) throws InvalidRotationMatrixException {
        final Quaternion initialQ;
<span class="fc bfc" id="L152" title="All 2 branches covered.">        if (initialAttitude != null) {</span>
<span class="fc" id="L153">            initialQ = new Quaternion();</span>
<span class="fc" id="L154">            initialAttitude.asRotation(initialQ);</span>

<span class="fc" id="L156">            result.setSourceType(initialAttitude.getSourceType());</span>
<span class="fc" id="L157">            result.setDestinationType(initialAttitude.getDestinationType());</span>
        } else {
<span class="fc" id="L159">            initialQ = null;</span>
        }

<span class="fc" id="L162">        final Quaternion resultQ = new Quaternion();</span>

<span class="fc" id="L164">        integrateGyroSequence(sequence, initialQ, resultQ);</span>

<span class="fc bfc" id="L166" title="All 2 branches covered.">        if (sequence.getStartBodyAttitude() != null) {</span>
<span class="fc" id="L167">            final CoordinateTransformation startBodyAttitude = sequence.getStartBodyAttitude();</span>
<span class="fc" id="L168">            result.setSourceType(startBodyAttitude.getSourceType());</span>
<span class="fc" id="L169">            result.setDestinationType(startBodyAttitude.getDestinationType());</span>
        }
<span class="fc" id="L171">        result.setMatrix(resultQ.asInhomogeneousMatrix());</span>
<span class="fc" id="L172">    }</span>

    /**
     * Integrates a sequence of gyroscope measurements contained within timed body kinematics,
     * starting at the initial attitude of the sequence (if available) to obtain a final attitude.
     * Notice that if provided sequence does not contain an initial attitude, the identity rotation will be
     * used as the starting attitude and start and destination frame types will be left unchanged on provided
     * result instance.
     *
     * @param sequence sequence of gyroscope measurements to be integrated.
     * @param result   resulting rotation after integration. Source and destination types will match those
     *                 provided on  sequence start body attitude, otherwise source and destination types will
     *                 be left unchanged.
     * @throws InvalidRotationMatrixException if an invalid rotation is generated. This will happen if numerical
     *                                        instabilities occur.
     */
    public static void integrateGyroSequence(
            final BodyKinematicsSequence&lt;StandardDeviationTimedBodyKinematics&gt; sequence,
            final CoordinateTransformation result) throws InvalidRotationMatrixException {
<span class="fc" id="L191">        integrateGyroSequence(sequence, null, result);</span>
<span class="fc" id="L192">    }</span>

    /**
     * Integrates a sequence of gyroscope measurements contained within timed body kinematics,
     * starting at an initial attitude to obtain a final attitude.
     *
     * @param sequence        sequence of gyroscope measurements to be integrated.
     * @param initialAttitude (optional) initial attitude to be used. If null, the initial attitude available
     *                        on provided sequence will be used. If that one is neither available, then the
     *                        identity attitude will be used.
     * @return resulting rotation after integration.
     * @throws InvalidRotationMatrixException if an invalid rotation is generated. This will happen if numerical
     *                                        instabilities occur.
     */
    public static Quaternion integrateGyroSequenceAndReturnNewQuaternion(
            final BodyKinematicsSequence&lt;StandardDeviationTimedBodyKinematics&gt; sequence,
            final Quaternion initialAttitude) throws InvalidRotationMatrixException {
<span class="fc" id="L209">        final Quaternion result = new Quaternion();</span>
<span class="fc" id="L210">        integrateGyroSequence(sequence, initialAttitude, result);</span>
<span class="fc" id="L211">        return result;</span>
    }

    /**
     * Integrates a sequence of gyroscope measurements contained within timed body kinematics,
     * starting at the initial attitude of the sequence (if available) to obtain a final attitude.
     * Notice that if provided sequence does not contain an initial attitude, the identity rotation will be
     * used as the starting attitude.
     *
     * @param sequence sequence of gyroscope measurements to be integrated.
     * @return resulting rotation after integration.
     * @throws InvalidRotationMatrixException if an invalid rotation is generated. This will happen if numerical
     *                                        instabilities occur.
     */
    public static Quaternion integrateGyroSequenceAndReturnNewQuaternion(
            final BodyKinematicsSequence&lt;StandardDeviationTimedBodyKinematics&gt; sequence)
            throws InvalidRotationMatrixException {
<span class="fc" id="L228">        final Quaternion result = new Quaternion();</span>
<span class="fc" id="L229">        integrateGyroSequence(sequence, result);</span>
<span class="fc" id="L230">        return result;</span>
    }

    /**
     * Integrates a sequence of gyroscope measurements contained within timed body kinematics,
     * starting at an initial attitude to obtain a final attitude.
     *
     * @param sequence        sequence of gyroscope measurements to be integrated.
     * @param initialAttitude (optional) initial attitude to be used. If null, the initial attitude available
     *                        on provided sequence will be used. If that one is neither available, then the
     *                        identity attitude will be used.
     * @return resulting rotation after integration.
     * @throws InvalidRotationMatrixException if an invalid rotation is generated. This will happen if numerical
     *                                        instabilities occur.
     */
    public static CoordinateTransformation integrateGyroSequenceAndReturnNewCoordinateTransformation(
            final BodyKinematicsSequence&lt;StandardDeviationTimedBodyKinematics&gt; sequence,
            final CoordinateTransformation initialAttitude)
            throws InvalidRotationMatrixException {

        // start body attitude is required to determine start and destination frame types of result
<span class="fc bfc" id="L251" title="All 2 branches covered.">        if (sequence.getStartBodyAttitude() == null) {</span>
<span class="fc" id="L252">            throw new IllegalArgumentException();</span>
        }
<span class="fc" id="L254">        final CoordinateTransformation result = new CoordinateTransformation(</span>
                FrameType.BODY_FRAME, FrameType.EARTH_CENTERED_EARTH_FIXED_FRAME);
<span class="fc" id="L256">        integrateGyroSequence(sequence, initialAttitude, result);</span>
<span class="fc" id="L257">        return result;</span>
    }

    /**
     * Integrates a sequence of gyroscope measurements contained within timed body kinematics,
     * starting at the initial attitude of the sequence (if available) to obtain a final attitude.
     * Notice that if provided sequence does not contain an initial attitude, the identity rotation will be
     * used as the starting attitude and start and destination frame types will be left unchanged on provided
     * result instance.
     *
     * @param sequence sequence of gyroscope measurements to be integrated.
     * @return resulting rotation after integration. Source and destination types will match those
     * provided on  sequence start body attitude, otherwise source and destination types will
     * be left unchanged.
     * @throws InvalidRotationMatrixException if an invalid rotation is generated. This will happen if numerical
     *                                        instabilities occur.
     */
    public static CoordinateTransformation integrateGyroSequenceAndReturnNewCoordinateTransformation(
            final BodyKinematicsSequence&lt;StandardDeviationTimedBodyKinematics&gt; sequence)
            throws InvalidRotationMatrixException {

        // start body attitude is required to determine start and destination frame types of result
<span class="pc bpc" id="L279" title="1 of 2 branches missed.">        if (sequence.getStartBodyAttitude() == null) {</span>
<span class="nc" id="L280">            throw new IllegalArgumentException();</span>
        }
<span class="fc" id="L282">        final CoordinateTransformation result = new CoordinateTransformation(</span>
                FrameType.BODY_FRAME, FrameType.EARTH_CENTERED_EARTH_FIXED_FRAME);
<span class="fc" id="L284">        integrateGyroSequence(sequence, result);</span>
<span class="fc" id="L285">        return result;</span>
    }

    /**
     * Normalize an input matrix corresponding to a quaterniont into a unit
     * vector.
     *
     * @param quaternion matrix containing quaternion values to be normalized.
     */
    private static void normalizeQuaternion(final Matrix quaternion) {
<span class="fc" id="L295">        final double norm = Utils.normF(quaternion);</span>
<span class="fc" id="L296">        quaternion.multiplyByScalar(1.0 / norm);</span>
<span class="fc" id="L297">    }</span>

    /**
     * Gets skew symmetric matrix representation of angular speed.
     *
     * @param omega  matrix containing angular speed components. Must be 3x1.
     * @param result computed skew symmetricmatrix representation. Must be 4x4.
     */
    private static void computeOmegaSkew(final Matrix omega, final Matrix result) {
<span class="fc" id="L306">        final double omega0 = omega.getElementAtIndex(0);</span>
<span class="fc" id="L307">        final double omega1 = omega.getElementAtIndex(1);</span>
<span class="fc" id="L308">        final double omega2 = omega.getElementAtIndex(2);</span>

<span class="fc" id="L310">        result.setElementAtIndex(0, 0.0);</span>
<span class="fc" id="L311">        result.setElementAtIndex(1, omega0);</span>
<span class="fc" id="L312">        result.setElementAtIndex(2, omega1);</span>
<span class="fc" id="L313">        result.setElementAtIndex(3, omega2);</span>

<span class="fc" id="L315">        result.setElementAtIndex(4, -omega0);</span>
<span class="fc" id="L316">        result.setElementAtIndex(5, 0.0);</span>
<span class="fc" id="L317">        result.setElementAtIndex(6, -omega2);</span>
<span class="fc" id="L318">        result.setElementAtIndex(7, omega1);</span>

<span class="fc" id="L320">        result.setElementAtIndex(8, -omega1);</span>
<span class="fc" id="L321">        result.setElementAtIndex(9, omega2);</span>
<span class="fc" id="L322">        result.setElementAtIndex(10, 0.0);</span>
<span class="fc" id="L323">        result.setElementAtIndex(11, -omega0);</span>

<span class="fc" id="L325">        result.setElementAtIndex(12, -omega2);</span>
<span class="fc" id="L326">        result.setElementAtIndex(13, -omega1);</span>
<span class="fc" id="L327">        result.setElementAtIndex(14, omega0);</span>
<span class="fc" id="L328">        result.setElementAtIndex(15, 0.0);</span>
<span class="fc" id="L329">    }</span>

    /**
     * Performs a RK4 Runge-Kutta integration step.
     *
     * @param quat   the input 4D vector representing the initial rotation as
     *               quaternion values. Must be 4x1.
     * @param omega0 initial rotational velocity at time t0 expressed in radians
     *               per second (rad/s). Must be 3x1.
     * @param omega1 final rotational velocity at time t1 expressed in radians
     *               per second (rad/s). Must be 3x1.
     * @param dt     time step expressed in seconds (t1 - t0).
     * @param result resulting final rotation. Must be 4x1.
     */
    private static void quatIntegrationStepRK4(
            final Matrix quat,
            final Matrix omega0,
            final Matrix omega1,
            final double dt,
            final Matrix result) {
        try {
<span class="fc" id="L350">            final Matrix omega01 = omega0.addAndReturnNew(omega1);</span>
<span class="fc" id="L351">            omega01.multiplyByScalar(0.5);</span>

<span class="fc" id="L353">            final Matrix k1 = new Matrix(Quaternion.N_PARAMS, 1);</span>
<span class="fc" id="L354">            final Matrix k2 = new Matrix(Quaternion.N_PARAMS, 1);</span>
<span class="fc" id="L355">            final Matrix k3 = new Matrix(Quaternion.N_PARAMS, 1);</span>
<span class="fc" id="L356">            final Matrix k4 = new Matrix(Quaternion.N_PARAMS, 1);</span>
<span class="fc" id="L357">            final Matrix tmpQ = new Matrix(Quaternion.N_PARAMS, 1);</span>

<span class="fc" id="L359">            final Matrix omegaSkew = new Matrix(</span>
                    Quaternion.N_PARAMS, Quaternion.N_PARAMS);

            // First Runge-Kutta coefficient
<span class="fc" id="L363">            computeOmegaSkew(omega0, omegaSkew);</span>
<span class="fc" id="L364">            omegaSkew.multiply(quat, k1);</span>
<span class="fc" id="L365">            k1.multiplyByScalar(0.5);</span>

            // Second Runge-Kutta coefficient
<span class="fc" id="L368">            tmpQ.copyFrom(k1);</span>
<span class="fc" id="L369">            tmpQ.multiplyByScalar(0.5 * dt);</span>
<span class="fc" id="L370">            tmpQ.add(quat);</span>
<span class="fc" id="L371">            computeOmegaSkew(omega01, omegaSkew);</span>
<span class="fc" id="L372">            omegaSkew.multiply(tmpQ, k2);</span>
<span class="fc" id="L373">            k2.multiplyByScalar(0.5);</span>

            // Third Runge-Kutta coefficient (same omega skew as second coeff.)
<span class="fc" id="L376">            tmpQ.copyFrom(k2);</span>
<span class="fc" id="L377">            tmpQ.multiplyByScalar(0.5 * dt);</span>
<span class="fc" id="L378">            tmpQ.add(quat);</span>
<span class="fc" id="L379">            omegaSkew.multiply(tmpQ, k3);</span>
<span class="fc" id="L380">            k3.multiplyByScalar(0.5);</span>

            // Forth Runge-Kutta coefficient
<span class="fc" id="L383">            tmpQ.copyFrom(k3);</span>
<span class="fc" id="L384">            tmpQ.multiplyByScalar(dt);</span>
<span class="fc" id="L385">            tmpQ.add(quat);</span>
<span class="fc" id="L386">            computeOmegaSkew(omega1, omegaSkew);</span>
<span class="fc" id="L387">            omegaSkew.multiply(tmpQ, k4);</span>
<span class="fc" id="L388">            k4.multiplyByScalar(0.5);</span>

<span class="fc" id="L390">            final double mult1 = 1.0 / 6.0;</span>
<span class="fc" id="L391">            final double mult2 = 1.0 / 3.0;</span>

            // result = quat + dt * (mult1 * k1 + mult2 * k2 + mult2 * k3 + mult1 * k4)
<span class="fc" id="L394">            k1.multiplyByScalar(mult1);</span>
<span class="fc" id="L395">            k2.multiplyByScalar(mult2);</span>
<span class="fc" id="L396">            k3.multiplyByScalar(mult2);</span>
<span class="fc" id="L397">            k4.multiplyByScalar(mult1);</span>

<span class="fc" id="L399">            result.copyFrom(k1);</span>
<span class="fc" id="L400">            result.add(k2);</span>
<span class="fc" id="L401">            result.add(k3);</span>
<span class="fc" id="L402">            result.add(k4);</span>
<span class="fc" id="L403">            result.multiplyByScalar(dt);</span>
<span class="fc" id="L404">            result.add(quat);</span>
<span class="nc" id="L405">        } catch (final WrongSizeException ignore) {</span>
            // never happens
<span class="fc" id="L407">        }</span>

<span class="fc" id="L409">        normalizeQuaternion(result);</span>
<span class="fc" id="L410">    }</span>

    /**
     * Performs a RK4 Runge-Kutta integration step.
     *
     * @param quaternion the initial rotation.
     * @param omega0     initial rotation velocity at time t0 expressed in radians
     *                   per second (rad/s). Must have length 3.
     * @param omega1     final rotation velocity at time t1 expressed in radians
     *                   per second (rad/s). Must have length 3.
     * @param dt         time step expressed in seconds (t1 - t0).
     * @param result     resulting final rotation.
     */
    private static void quatIntegrationStepRK4(
            final Quaternion quaternion,
            final double[] omega0,
            final double[] omega1,
            final double dt,
            final Quaternion result) {
        try {
<span class="fc" id="L430">            final Matrix quat = new Matrix(</span>
                    Quaternion.N_PARAMS, 1);
<span class="fc" id="L432">            quaternion.values(quat.getBuffer());</span>

<span class="fc" id="L434">            final Matrix omega0b = Matrix.newFromArray(omega0);</span>
<span class="fc" id="L435">            final Matrix omega1b = Matrix.newFromArray(omega1);</span>

<span class="fc" id="L437">            final Matrix quatResult = new Matrix(</span>
                    Quaternion.N_PARAMS, 1);

<span class="fc" id="L440">            quatIntegrationStepRK4(quat, omega0b, omega1b, dt, quatResult);</span>
<span class="fc" id="L441">            result.setValues(quatResult.getBuffer());</span>

<span class="nc" id="L443">        } catch (WrongSizeException ignore) {</span>
            // never happens
<span class="fc" id="L445">        }</span>
<span class="fc" id="L446">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>