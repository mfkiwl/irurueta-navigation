<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TriadStaticIntervalDetector.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.irurueta:irurueta-navigation</a> &gt; <a href="index.source.html" class="el_package">com.irurueta.navigation.inertial.calibration.intervals</a> &gt; <span class="el_source">TriadStaticIntervalDetector.java</span></div><h1>TriadStaticIntervalDetector.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2020 Alberto Irurueta Carro (alberto@irurueta.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.irurueta.navigation.inertial.calibration.intervals;

import com.irurueta.navigation.LockedException;
import com.irurueta.navigation.inertial.calibration.Triad;
import com.irurueta.navigation.inertial.calibration.noise.AccumulatedTriadNoiseEstimator;
import com.irurueta.navigation.inertial.calibration.noise.WindowedTriadNoiseEstimator;
import com.irurueta.units.Measurement;

/**
 * Abstract base class for detectors in charge of determining when a static period of
 * measurements starts and finishes.
 * Static periods are periods of time where the device is considered to
 * remain static (no movement applied to it).
 *
 * @param &lt;U&gt; type of unit.
 * @param &lt;M&gt; a type of measurement.
 * @param &lt;T&gt; a triad type.
 * @param &lt;D&gt; a detector type.
 * @param &lt;L&gt; a listener type.
 */
public abstract class TriadStaticIntervalDetector&lt;U extends Enum&lt;?&gt;, M extends Measurement&lt;U&gt;,
        T extends Triad&lt;U, M&gt;, D extends TriadStaticIntervalDetector&lt;U, M, T, D, L&gt;,
        L extends TriadStaticIntervalDetectorListener&lt;U, M, T, D&gt;&gt; {

    /**
     * Number of samples to keep within the window by default.
     * For a sensor generating 100 samples/second, this is equivalent to 1 second.
     * For a sensor generating 50 samples/second, this is equivalent to 2 seconds.
     */
    public static final int DEFAULT_WINDOW_SIZE = WindowedTriadNoiseEstimator.DEFAULT_WINDOW_SIZE;

    /**
     * Number of samples to process during the initial static period to determine the sensor
     * (accelerometer, gyroscope or magnetometer) noise level.
     * For a sensor generating 100 samples/second, this is equivalent to 50 seconds.
     * For a sensor generating 50 samples/second, this is equivalent to 100 seconds.
     */
    public static final int DEFAULT_INITIAL_STATIC_SAMPLES = 5000;

    /**
     * Minimum allowed number of samples to be processed during the initial static period.
     */
    public static final int MINIMUM_INITIAL_STATIC_SAMPLES = 2;

    /**
     * Default factor to be applied to detected base noise level in order to determine
     * threshold for static/dynamic period changes. This factor is unit-less.
     */
    public static final double DEFAULT_THRESHOLD_FACTOR = 2.0;

    /**
     * Default factor to determine that a sudden movement has occurred during initialization
     * if instantaneous noise level exceeds accumulated noise level by this factor amount.
     * This factor is unit-less.
     */
    public static final double DEFAULT_INSTANTANEOUS_NOISE_LEVEL_FACTOR = 2.0;

    /**
     * Default overall absolute threshold to determine whether there has been excessive motion
     * during the whole initialization phase.
     * This threshold is expressed in meters per squared second (m/s^2) for acceleration, radians
     * per second (rad/s) for angular speed or Teslas (T) for magnetic flux density, and by
     * default it is set to the maximum allowed value, thus effectively disabling this error
     * condition check during initialization.
     */
    public static final double DEFAULT_BASE_NOISE_LEVEL_ABSOLUTE_THRESHOLD = Double.MAX_VALUE;

    /**
     * Number of samples to keep in window to find instantaneous noise level averaged within
     * the window of samples.
     * Window size should contain about 1 or 2 seconds of data to be averaged to obtain
     * a more reliable instantaneous noise level.
     */
<span class="fc" id="L89">    private int mWindowSize = DEFAULT_WINDOW_SIZE;</span>

    /**
     * Number of samples to be processed initially while keeping the sensor static in order
     * to find the base noise level when device is static.
     */
<span class="fc" id="L95">    private int mInitialStaticSamples = DEFAULT_INITIAL_STATIC_SAMPLES;</span>

    /**
     * Factor to be applied to detected base noise level in order to determine
     * threshold for static/dynamic period changes. This factor is unit-less.
     */
<span class="fc" id="L101">    private double mThresholdFactor = DEFAULT_THRESHOLD_FACTOR;</span>

    /**
     * Factor to determine that a sudden movement has occurred during initialization if
     * instantaneous noise level exceeds accumulated noise level by this factor amount.
     * This factor is unit-less.
     */
<span class="fc" id="L108">    private double mInstantaneousNoiseLevelFactor = DEFAULT_INSTANTANEOUS_NOISE_LEVEL_FACTOR;</span>

    /**
     * Overall absolute threshold to determine whether there has been excessive motion
     * during the whole initialization phase.
     * Failure will be detected if estimated base noise level exceeds this threshold when
     * initialization completes.
     * This threshold is expressed in meters per squared second (m/s^2) for acceleration,
     * radians per second (rad/s) for angular speed or Teslas (T) for magnetic flux density.
     */
<span class="fc" id="L118">    private double mBaseNoiseLevelAbsoluteThreshold = DEFAULT_BASE_NOISE_LEVEL_ABSOLUTE_THRESHOLD;</span>

    /**
     * Listener to handle events generated by this detector.
     */
    private L mListener;

    /**
     * Current status of this detector.
     */
<span class="fc" id="L128">    private Status mStatus = Status.IDLE;</span>

    /**
     * Measurement base noise level that has been detected during initialization expressed in
     * meters per squared second (m/s^2) for acceleration, radians per second (rad/s) for
     * angular speed or Teslas (T) for magnetic flux density.
     */
    private double mBaseNoiseLevel;

    /**
     * Threshold to determine static/dynamic period changes expressed in meters per squared
     * second (m/s^2) for acceleration, radians per second (rad/s) for angular speed or
     * Teslas (T) for magnetic flux density.
     */
    private double mThreshold;

    /**
     * Indicates whether this detector is busy processing last provided sample.
     */
    private boolean mRunning;

    /**
     * Number of samples that have been processed so far.
     */
    private int mProcessedSamples;

    /**
     * Average x-coordinate of measurements accumulated during last static
     * period expressed in meters per squared second (m/s^2) for acceleration,
     * radians per second (rad/s) for angular speed or Teslas (T) for
     * magnetic flux density.
     * This value is updated when switching from a static period to a dynamic
     * one or after completing initialization.
     */
    private double mAccumulatedAvgX;

    /**
     * Average y-coordinate of measurements accumulated during last static
     * period expressed in meters per squared second (m/s^2) for acceleration,
     * radians per second (rad/s) for angular speed or Teslas (T) for
     * magnetic flux density.
     * This value is updated when switching from a static period to a dynamic
     * one or after completing initialization.
     */
    private double mAccumulatedAvgY;

    /**
     * Average z-coordinate of measurements accumulated during last static
     * period expressed in meters per squared second (m/s^2) for acceleration,
     * radians per second (rad/s) for angular speed or Teslas (T) for
     * magnetic flux density.
     * This value is updated when switching from a static period to a dynamic
     * one or after completing initialization.
     */
    private double mAccumulatedAvgZ;

    /**
     * Standard deviation of x-coordinate of measurements accumulated during
     * last static period expressed in meters per squared second (m/s^2) for
     * acceleration, radians per second (rad/s) for angular speed or Teslas
     * (T) for magnetic flux density.
     * This value is updated when switching from a static period to a dynamic
     * one or after completing initialization.
     */
    private double mAccumulatedStdX;

    /**
     * Standard deviation of y-coordinate of measurements accumulated during
     * last static period expressed in meters per squared second (m/s^2) for
     * acceleration, radians per second (rad/s) for angular speed or Teslas
     * (T) for magnetic flux density.
     * This value is updated when switching from a static period to a dynamic
     * one or after completing initialization.
     */
    private double mAccumulatedStdY;

    /**
     * Standard deviation of z-coordinate of measurements accumulated during
     * last static period expressed in meters per squared second (m/s^2) for
     * acceleration, radians per second (rad/s) for angular speed or Teslas
     * (T) for magnetic flux density.
     * This value is updated when switching from a static period to a dynamic
     * one or after completing initialization.
     */
    private double mAccumulatedStdZ;

    /**
     * Windowed average x-coordinate of measurements for each processed triad
     * expressed in meters per squared second (m/s^2) for acceleration,
     * radians per second (rad/s) for angular speed or Teslas (T) for
     * magnetic flux density.
     * This value is updated for each processed sample containing an average
     * value for the samples within the window.
     */
    private double mInstantaneousAvgX;

    /**
     * Windowed average y-coordinate of measurements for each processed triad
     * expressed in meters per squared second (m/s^2) for acceleration,
     * radians per second (rad/s) for angular speed or Teslas (T) for
     * magnetic flux density.
     * This value is updated for each processed sample containing an average
     * value for the samples within the window.
     */
    private double mInstantaneousAvgY;

    /**
     * Windowed average z-coordinate of measurements for each processed triad
     * expressed in meters per squared second (m/s^2) for acceleration,
     * radians per second (rad/s) for angular speed or Teslas (T) for
     * magnetic flux density.
     * This value is updated for each processed sample containing an average
     * value for the samples within the window.
     */
    private double mInstantaneousAvgZ;

    /**
     * Windowed standard deviation of x-coordinate of measurements for each
     * processed triad expressed in meters per squared second (m/s^2) for
     * acceleration, radians per second (rad/s) for angular speed or Teslas (T)
     * for magnetic flux density.
     * This value is updated for each processed sample containing measured standard
     * deviation for the samples within the window.
     */
    private double mInstantaneousStdX;

    /**
     * Windowed standard deviation of y-coordinate of measurements for each
     * processed triad expressed in meters per squared second (m/s^2) for
     * acceleration, radians per second (rad/s) for angular speed or Teslas (T)
     * for magnetic flux density.
     * This value is updated for each processed sample containing measured standard
     * deviation for the samples within the window.
     */
    private double mInstantaneousStdY;

    /**
     * Windowed standard deviation of z-coordinate of measurements for each
     * processed triad expressed in meters per squared second (m/s^2) for
     * acceleration, radians per second (rad/s) for angular speed or Teslas (T)
     * for magnetic flux density.
     * This value is updated for each processed sample containing measured standard
     * deviation for the samples within the window.
     */
    private double mInstantaneousStdZ;

    /**
     * Estimator to find instantaneous measurement noise level averaged for a certain window of samples.
     */
    private final WindowedTriadNoiseEstimator&lt;U, M, T, ?, ?&gt; mWindowedNoiseEstimator;

    /**
     * Estimator to find accumulated accelerometer noise level.
     */
    private final AccumulatedTriadNoiseEstimator&lt;U, M, T, ?, ?&gt; mAccumulatedNoiseEstimator;

    /**
     * Constructor.
     *
     * @param windowedNoiseEstimator    windowed noise estimator to estimate noise within a window of measures.
     * @param accumulatedNoiseEstimator accumulated noise estimator to estimate accumulated noise and average.
     */
    protected TriadStaticIntervalDetector(
            final WindowedTriadNoiseEstimator&lt;U, M, T, ?, ?&gt; windowedNoiseEstimator,
<span class="fc" id="L292">            final AccumulatedTriadNoiseEstimator&lt;U, M, T, ?, ?&gt; accumulatedNoiseEstimator) {</span>
<span class="fc" id="L293">        mWindowedNoiseEstimator = windowedNoiseEstimator;</span>
<span class="fc" id="L294">        mAccumulatedNoiseEstimator = accumulatedNoiseEstimator;</span>
<span class="fc" id="L295">    }</span>

    /**
     * Constructor.
     *
     * @param windowedNoiseEstimator    windowed noise estimator to estimate noise within a window of measures.
     * @param accumulatedNoiseEstimator accumulated noise estimator to estimate accumulated noise and average.
     * @param listener                  listener to handle events generated by this detector.
     */
    protected TriadStaticIntervalDetector(
            final WindowedTriadNoiseEstimator&lt;U, M, T, ?, ?&gt; windowedNoiseEstimator,
            final AccumulatedTriadNoiseEstimator&lt;U, M, T, ?, ?&gt; accumulatedNoiseEstimator,
            final L listener) {
<span class="fc" id="L308">        this(windowedNoiseEstimator, accumulatedNoiseEstimator);</span>
<span class="fc" id="L309">        mListener = listener;</span>
<span class="fc" id="L310">    }</span>

    /**
     * Gets length of number of samples to keep within the window being processed
     * to determine instantaneous accelerometer noise level.
     *
     * @return length of number of samples to keep within the window.
     */
    public int getWindowSize() {
<span class="fc" id="L319">        return mWindowSize;</span>
    }

    /**
     * Sets length of number of samples to keep within the window being processed
     * to determine instantaneous accelerometer noise level.
     * Window size must always be larger than allowed minimum value, which is 2 and
     * must have and odd value.
     *
     * @param windowSize length of number of samples to keep within the window.
     * @throws LockedException          if detector is busy processing a previous sample.
     * @throws IllegalArgumentException if provided value is not valid.
     */
    public void setWindowSize(final int windowSize) throws LockedException {
<span class="fc bfc" id="L333" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L334">            throw new LockedException();</span>
        }

<span class="fc" id="L337">        mWindowedNoiseEstimator.setWindowSize(windowSize);</span>
<span class="fc" id="L338">        mWindowSize = windowSize;</span>
<span class="fc" id="L339">    }</span>

    /**
     * Gets number of samples to be processed initially while keeping the sensor static in order
     * to find the base noise level when device is static.
     *
     * @return number of samples to be processed initially.
     */
    public int getInitialStaticSamples() {
<span class="fc" id="L348">        return mInitialStaticSamples;</span>
    }

    /**
     * Sets number of samples to be processed initially while keeping the sensor static in order
     * to find the base noise level when device is static.
     *
     * @param initialStaticSamples number of samples to be processed initially.
     * @throws LockedException          if detector is busy.
     * @throws IllegalArgumentException if provided value is less than {@link #MINIMUM_INITIAL_STATIC_SAMPLES}
     */
    public void setInitialStaticSamples(final int initialStaticSamples)
            throws LockedException {
<span class="fc bfc" id="L361" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L362">            throw new LockedException();</span>
        }

<span class="fc bfc" id="L365" title="All 2 branches covered.">        if (initialStaticSamples &lt; MINIMUM_INITIAL_STATIC_SAMPLES) {</span>
<span class="fc" id="L366">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L369">        mInitialStaticSamples = initialStaticSamples;</span>
<span class="fc" id="L370">    }</span>

    /**
     * Gets factor to be applied to detected base noise level in order to
     * determine threshold for static/dynamic period changes. This factor is
     * unit-less.
     *
     * @return factor to be applied to detected base noise level.
     */
    public double getThresholdFactor() {
<span class="fc" id="L380">        return mThresholdFactor;</span>
    }

    /**
     * Sets factor to be applied to detected base noise level in order to
     * determine threshold for static/dynamic period changes. This factor is
     * unit-less.
     *
     * @param thresholdFactor factor to be applied to detected base noise level.
     * @throws LockedException          if detector is busy.
     * @throws IllegalArgumentException if provided value is zero or negative.
     */
    public void setThresholdFactor(final double thresholdFactor)
            throws LockedException {
<span class="fc bfc" id="L394" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L395">            throw new LockedException();</span>
        }
<span class="fc bfc" id="L397" title="All 2 branches covered.">        if (thresholdFactor &lt;= 0.0) {</span>
<span class="fc" id="L398">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L401">        mThresholdFactor = thresholdFactor;</span>
<span class="fc" id="L402">    }</span>

    /**
     * Gets factor to determine that a sudden movement has occurred during
     * initialization if instantaneous noise level exceeds accumulated noise
     * level by this factor amount.
     * This factor is unit-less.
     *
     * @return factor to determine that a sudden movement has occurred.
     */
    public double getInstantaneousNoiseLevelFactor() {
<span class="fc" id="L413">        return mInstantaneousNoiseLevelFactor;</span>
    }

    /**
     * Sets factor to determine that a sudden movement has occurred during
     * initialization if instantaneous noise level exceeds accumulated noise
     * level by this factor amount.
     * This factor is unit-less.
     *
     * @param instantaneousNoiseLevelFactor factor to determine that a sudden
     *                                      movement has occurred during
     *                                      initialization.
     * @throws LockedException          if detector is busy.
     * @throws IllegalArgumentException if provided value is zero or negative.
     */
    public void setInstantaneousNoiseLevelFactor(
            final double instantaneousNoiseLevelFactor) throws LockedException {
<span class="fc bfc" id="L430" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L431">            throw new LockedException();</span>
        }
<span class="fc bfc" id="L433" title="All 2 branches covered.">        if (instantaneousNoiseLevelFactor &lt;= 0.0) {</span>
<span class="fc" id="L434">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L437">        mInstantaneousNoiseLevelFactor = instantaneousNoiseLevelFactor;</span>
<span class="fc" id="L438">    }</span>

    /**
     * Gets overall absolute threshold to determine whether there has been
     * excessive motion during the whole initialization phase.
     * Failure will be detected if estimated base noise level exceeds this
     * threshold when initialization completes.
     * This threshold is expressed in meters per squared second (m/s^2) for
     * acceleration, radians per second (rad/s) for angular speed or Teslas
     * (T) for magnetic flux density.
     *
     * @return overall absolute threshold to determine whether there has
     * been excessive motion.
     */
    public double getBaseNoiseLevelAbsoluteThreshold() {
<span class="fc" id="L453">        return mBaseNoiseLevelAbsoluteThreshold;</span>
    }

    /**
     * Sets overall absolute threshold to determine whether there has been
     * excessive motion during the whole initialization phase.
     * Failure will be detected if estimated base noise level exceeds this
     * threshold when initialization completes.
     * This threshold is expressed in meters per squared second (m/s^2) for
     * acceleration, radians per second (rad/s) for angular speed or Teslas
     * (T) for magnetic flux density.
     *
     * @param baseNoiseLevelAbsoluteThreshold overall absolute threshold to
     *                                        determine whether there has been
     *                                        excessive motion.
     * @throws LockedException          if detector is busy.
     * @throws IllegalArgumentException if provided value is zero or negative.
     */
    public void setBaseNoiseLevelAbsoluteThreshold(
            final double baseNoiseLevelAbsoluteThreshold) throws LockedException {
<span class="fc bfc" id="L473" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L474">            throw new LockedException();</span>
        }
<span class="fc bfc" id="L476" title="All 2 branches covered.">        if (baseNoiseLevelAbsoluteThreshold &lt;= 0.0) {</span>
<span class="fc" id="L477">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L480">        mBaseNoiseLevelAbsoluteThreshold = baseNoiseLevelAbsoluteThreshold;</span>
<span class="fc" id="L481">    }</span>

    /**
     * Gets overall absolute threshold to determine whether there has been
     * excessive motion during the whole initialization phase.
     * Failure will be detected if estimated base noise level exceeds this
     * threshold when initialization completes.
     *
     * @return overall absolute threshold to determine whether there has been
     * excessive motion.
     */
    public M getBaseNoiseLevelAbsoluteThresholdAsMeasurement() {
<span class="fc" id="L493">        return createMeasurement(mBaseNoiseLevelAbsoluteThreshold, getDefaultUnit());</span>
    }

    /**
     * Gets overall absolute threshold to determine whether there has been
     * excessive motion during the whole initialization phase.
     * Failure will be detected if estimated base noise level exceeds this
     * threshold when initialization completes.
     *
     * @param result instance where result will be stored.
     */
    public void getBaseNoiseLevelAbsoluteThresholdAsMeasurement(final M result) {
<span class="fc" id="L505">        result.setValue(mBaseNoiseLevelAbsoluteThreshold);</span>
<span class="fc" id="L506">        result.setUnit(getDefaultUnit());</span>
<span class="fc" id="L507">    }</span>

    /**
     * Sets overall absolute threshold to determine whether there has been
     * excessive motion during the whole initialization phase.
     * Failure will be detected if estimated base noise level exceeds this
     * threshold when initialization completes.
     *
     * @param baseNoiseLevelAbsoluteThreshold overall absolute threshold to
     *                                        determine whether there has been
     *                                        excessive motion.
     * @throws LockedException          if detector is busy.
     * @throws IllegalArgumentException if provided value is zero or negative.
     */
    public void setBaseNoiseLevelAbsoluteThreshold(
            final M baseNoiseLevelAbsoluteThreshold) throws LockedException {
<span class="pc bpc" id="L523" title="1 of 2 branches missed.">        if (mRunning) {</span>
<span class="nc" id="L524">            throw new LockedException();</span>
        }

<span class="fc" id="L527">        setBaseNoiseLevelAbsoluteThreshold(</span>
<span class="fc" id="L528">                convertMeasurement(baseNoiseLevelAbsoluteThreshold));</span>
<span class="fc" id="L529">    }</span>

    /**
     * Gets listener to handle events generated by this detector.
     *
     * @return listener to handle events.
     */
    public L getListener() {
<span class="fc" id="L537">        return mListener;</span>
    }

    /**
     * Sets listener to handle events generated by this detector.
     *
     * @param listener listener to handle events.
     * @throws LockedException if detector is busy.
     */
    public void setListener(final L listener) throws LockedException {
<span class="fc bfc" id="L547" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L548">            throw new LockedException();</span>
        }

<span class="fc" id="L551">        mListener = listener;</span>
<span class="fc" id="L552">    }</span>

    /**
     * Gets current status of this detector.
     *
     * @return current status of this detector.
     */
    public Status getStatus() {
<span class="fc" id="L560">        return mStatus;</span>
    }

    /**
     * Gets measurement base noise level that has been detected during
     * initialization expressed in meters per squared second (m/s^2) for
     * acceleration, radians per second (rad/s) for angular speed or
     * Teslas (T) for magnetic flux density.
     *
     * @return base noise level.
     */
    public double getBaseNoiseLevel() {
<span class="fc" id="L572">        return mBaseNoiseLevel;</span>
    }

    /**
     * Gets measurement base noise level that has been detected during
     * initialization.
     *
     * @return measurement base noise level.
     */
    public M getBaseNoiseLevelAsMeasurement() {
<span class="fc" id="L582">        return createMeasurement(mBaseNoiseLevel, getDefaultUnit());</span>
    }

    /**
     * Gets measurement base noise level that has been detected during
     * initialization.
     *
     * @param result instance where result will be stored.
     */
    public void getBaseNoiseLevelAsMeasurement(final M result) {
<span class="fc" id="L592">        result.setValue(mBaseNoiseLevel);</span>
<span class="fc" id="L593">        result.setUnit(getDefaultUnit());</span>
<span class="fc" id="L594">    }</span>

    /**
     * Gets threshold to determine static/dynamic period changes expressed in
     * meters per squared second (m/s^2) for acceleration, radians per second
     * (rad/s) for angular speed or Teslas (T) for magnetic flux density.
     *
     * @return threshold to determine static/dynamic period changes.
     */
    public double getThreshold() {
<span class="fc" id="L604">        return mThreshold;</span>
    }

    /**
     * Gets threshold to determine static/dynamic period changes.
     *
     * @return threshold to determine static/dynamic period changes.
     */
    public M getThresholdAsMeasurement() {
<span class="fc" id="L613">        return createMeasurement(mThreshold, getDefaultUnit());</span>
    }

    /**
     * Gets threshold to determine static/dynamic period changes.
     *
     * @param result instance where result will be stored.
     */
    public void getThresholdAsMeasurement(final M result) {
<span class="fc" id="L622">        result.setValue(mThreshold);</span>
<span class="fc" id="L623">        result.setUnit(getDefaultUnit());</span>
<span class="fc" id="L624">    }</span>

    /**
     * Indicates whether this detector is busy processing last provided sample.
     *
     * @return true if this detector is busy, false otherwise.
     */
    public boolean isRunning() {
<span class="fc" id="L632">        return mRunning;</span>
    }

    /**
     * Gets number of samples that have been processed so far.
     *
     * @return number of samples that have been processed so far.
     */
    public int getProcessedSamples() {
<span class="fc" id="L641">        return mProcessedSamples;</span>
    }

    /**
     * Gets average x-coordinate of measurements accumulated during last static
     * period expressed in meters per squared second (m/s^2) for acceleration,
     * radians per second (rad/s) for angular speed or Teslas (T) for
     * magnetic flux density.
     * This value is updated when switching from a static period to a dynamic
     * one or after completing initialization.
     *
     * @return accumulated average x-coordinate of measurement during last static
     * period.
     */
    public double getAccumulatedAvgX() {
<span class="fc" id="L656">        return mAccumulatedAvgX;</span>
    }

    /**
     * Gets average x-coordinate of measurements accumulated during last static
     * period.
     * This value is updated when switching from a static period to a dynamic
     * one or after completing initialization.
     *
     * @return accumulated average x-coordinate of measurement during last static
     * period.
     */
    public M getAccumulatedAvgXAsMeasurement() {
<span class="fc" id="L669">        return createMeasurement(mAccumulatedAvgX, getDefaultUnit());</span>
    }

    /**
     * Gets average x-coordinate of measurements accumulated during last static
     * period.
     * This value is updated when switching from a static period to a dynamic
     * one or after completing initialization.
     *
     * @param result instance where result will be stored.
     */
    public void getAccumulatedAvgXAsMeasurement(final M result) {
<span class="fc" id="L681">        result.setValue(mAccumulatedAvgX);</span>
<span class="fc" id="L682">        result.setUnit(getDefaultUnit());</span>
<span class="fc" id="L683">    }</span>

    /**
     * Gets average y-coordinate of measurements accumulated during last static
     * period expressed in meters per squared second (m/s^2) for acceleration,
     * radians per second (rad/s) for angular speed or Teslas (T) for
     * magnetic flux density.
     * This value is updated when switching from a static period to a dynamic
     * one or after completing initialization.
     *
     * @return accumulated average y-coordinate of measurement during last static
     * period.
     */
    public double getAccumulatedAvgY() {
<span class="fc" id="L697">        return mAccumulatedAvgY;</span>
    }

    /**
     * Gets average y-coordinate of measurements accumulated during last static
     * period.
     * This value is updated when switching from a static period to a dynamic
     * one or after completing initialization.
     *
     * @return accumulated average y-coordinate of measurement during last static
     * period.
     */
    public M getAccumulatedAvgYAsMeasurement() {
<span class="fc" id="L710">        return createMeasurement(mAccumulatedAvgY, getDefaultUnit());</span>
    }

    /**
     * Gets average y-coordinate of measurements accumulated during last static
     * period.
     * This value is updated when switching from a static period to a dynamic
     * one or after completing initialization.
     *
     * @param result instance where result will be stored.
     */
    public void getAccumulatedAvgYAsMeasurement(final M result) {
<span class="fc" id="L722">        result.setValue(mAccumulatedAvgY);</span>
<span class="fc" id="L723">        result.setUnit(getDefaultUnit());</span>
<span class="fc" id="L724">    }</span>

    /**
     * Gets average z-coordinate of measurements accumulated during last static
     * period expressed in meters per squared second (m/s^2) for acceleration,
     * radians per second (rad/s) for angular speed or Teslas (T) for
     * magnetic flux density.
     * This value is updated when switching from a static period to a dynamic
     * one or after completing initialization.
     *
     * @return accumulated average y-coordinate of measurement during last static
     * period.
     */
    public double getAccumulatedAvgZ() {
<span class="fc" id="L738">        return mAccumulatedAvgZ;</span>
    }

    /**
     * Gets average z-coordinate of measurements accumulated during last static
     * period.
     * This value is updated when switching from a static period to a dynamic
     * one or after completing initialization.
     *
     * @return accumulated average z-coordinate of measurement during last static
     * period.
     */
    public M getAccumulatedAvgZAsMeasurement() {
<span class="fc" id="L751">        return createMeasurement(mAccumulatedAvgZ, getDefaultUnit());</span>
    }

    /**
     * Gets average z-coordinate of measurements accumulated during last static
     * period.
     * This value is updated when switching from a static period to a dynamic
     * one or after completing initialization.
     *
     * @param result instance where result will be stored.
     */
    public void getAccumulatedAvgZAsMeasurement(final M result) {
<span class="fc" id="L763">        result.setValue(mAccumulatedAvgZ);</span>
<span class="fc" id="L764">        result.setUnit(getDefaultUnit());</span>
<span class="fc" id="L765">    }</span>

    /**
     * Gets average measurements triad accumulated during last static period.
     * This value is updated when switching from a static period to a dynamic
     * one or after completing initialization.
     *
     * @return accumulated average measurements triad during last static period.
     */
    public T getAccumulatedAvgTriad() {
<span class="fc" id="L775">        return createTriad(mAccumulatedAvgX, mAccumulatedAvgY, mAccumulatedAvgZ, getDefaultUnit());</span>
    }

    /**
     * Gets average measurements triad accumulated during last static period.
     * This value is updated when switching from a static period to a dynamic
     * one or after completing initialization.
     *
     * @param result instance where result will be stored.
     */
    public void getAccumulatedAvgTriad(final T result) {
<span class="fc" id="L786">        result.setValueCoordinatesAndUnit(mAccumulatedAvgX, mAccumulatedAvgY, mAccumulatedAvgZ,</span>
<span class="fc" id="L787">                getDefaultUnit());</span>
<span class="fc" id="L788">    }</span>

    /**
     * Gets standard deviation of x-coordinate of measurements accumulated during
     * last static period expressed in meters per squared second (m/s^2) for
     * acceleration, radians per second (rad/s) for angular speed or Teslas
     * (T) for magnetic flux density.
     * This value is updated when switching from a static period to a dynamic
     * one or after completing initialization.
     *
     * @return standard deviation of x-coordinate of measurements accumulated
     * during last static period.
     */
    public double getAccumulatedStdX() {
<span class="fc" id="L802">        return mAccumulatedStdX;</span>
    }

    /**
     * Gets standard deviation of x-coordinate of measurements accumulated during
     * last static period.
     * This value is updated when switching from a static period to a dynamic
     * one or after completing initialization.
     *
     * @return standard deviation of x-coordinate of measurements accumulated
     * during last static period.
     */
    public M getAccumulatedStdXAsMeasurement() {
<span class="fc" id="L815">        return createMeasurement(mAccumulatedStdX, getDefaultUnit());</span>
    }

    /**
     * Gets standard deviation of x-coordinate of measurements accumulated during
     * last static period.
     * This value is updated when switching from a static period to a dynamic
     * one or after completing initialization.
     *
     * @param result instance where result will be stored.
     */
    public void getAccumulatedStdXAsMeasurement(final M result) {
<span class="fc" id="L827">        result.setValue(mAccumulatedStdX);</span>
<span class="fc" id="L828">        result.setUnit(getDefaultUnit());</span>
<span class="fc" id="L829">    }</span>

    /**
     * Gets standard deviation of y-coordinate of measurements accumulated during
     * last static period expressed in meters per squared second (m/s^2) for
     * acceleration, radians per second (rad/s) for angular speed or Teslas
     * (T) for magnetic flux density.
     * This value is updated when switching from a static period to a dynamic
     * one or after completing initialization.
     *
     * @return standard deviation of y-coordinate of measurements accumulated
     * during last static period.
     */
    public double getAccumulatedStdY() {
<span class="fc" id="L843">        return mAccumulatedStdY;</span>
    }

    /**
     * Gets standard deviation of y-coordinate of measurements accumulated during
     * last static period.
     * This value is updated when switching from a static period to a dynamic
     * one or after completing initialization.
     *
     * @return standard deviation of y-coordinate of measurements accumulated
     * during last static period.
     */
    public M getAccumulatedStdYAsMeasurement() {
<span class="fc" id="L856">        return createMeasurement(mAccumulatedStdY, getDefaultUnit());</span>
    }

    /**
     * Gets standard deviation of y-coordinate of measurements accumulated during
     * last static period.
     * This value is updated when switching from a static period to a dynamic
     * one or after completing initialization.
     *
     * @param result instance where result will be stored.
     */
    public void getAccumulatedStdYAsMeasurement(final M result) {
<span class="fc" id="L868">        result.setValue(mAccumulatedStdY);</span>
<span class="fc" id="L869">        result.setUnit(getDefaultUnit());</span>
<span class="fc" id="L870">    }</span>

    /**
     * Gets standard deviation of z-coordinate of measurements accumulated during
     * last static period expressed in meters per squared second (m/s^2) for
     * acceleration, radians per second (rad/s) for angular speed or Teslas
     * (T) for magnetic flux density.
     * This value is updated when switching from a static period to a dynamic
     * one or after completing initialization.
     *
     * @return standard deviation of z-coordinate of measurements accumulated
     * during last static period.
     */
    public double getAccumulatedStdZ() {
<span class="fc" id="L884">        return mAccumulatedStdZ;</span>
    }

    /**
     * Gets standard deviation of z-coordinate of measurements accumulated during
     * last static period.
     * This value is updated when switching from a static period to a dynamic
     * one or after completing initialization.
     *
     * @return standard deviation of z-coordinate of measurements accumulated
     * during last static period.
     */
    public M getAccumulatedStdZAsMeasurement() {
<span class="fc" id="L897">        return createMeasurement(mAccumulatedStdZ, getDefaultUnit());</span>
    }

    /**
     * Gets standard deviation of z-coordinate of measurements accumulated during
     * last static period.
     * This value is updated when switching from a static period to a dynamic
     * one or after completing initialization.
     *
     * @param result instance where result will be stored.
     */
    public void getAccumulatedStdZAsMeasurement(final M result) {
<span class="fc" id="L909">        result.setValue(mAccumulatedStdZ);</span>
<span class="fc" id="L910">        result.setUnit(getDefaultUnit());</span>
<span class="fc" id="L911">    }</span>

    /**
     * Gets standard deviation of measurements accumulated during last static
     * period.
     * This value is updated when switching from a static period to a dynamic
     * one or after completing initialization.
     *
     * @return standard deviation of measurements accumulated during last static
     * period.
     */
    public T getAccumulatedStdTriad() {
<span class="fc" id="L923">        return createTriad(mAccumulatedStdX, mAccumulatedStdY, mAccumulatedStdZ,</span>
<span class="fc" id="L924">                getDefaultUnit());</span>
    }

    /**
     * Gets standard deviation of measurements accumulated during last static
     * period.
     * This value is updated when switching from a static period to a dynamic
     * one or after completing initialization.
     *
     * @param result instance where result will be stored.
     */
    public void getAccumulatedStdTriad(final T result) {
<span class="fc" id="L936">        result.setValueCoordinatesAndUnit(</span>
                mAccumulatedStdX, mAccumulatedStdY, mAccumulatedStdZ,
<span class="fc" id="L938">                getDefaultUnit());</span>
<span class="fc" id="L939">    }</span>

    /**
     * Gets windowed average x-coordinate of measurements for each processed triad
     * expressed in meters per squared second (m/s^2) for acceleration,
     * radians per second (rad/s) for angular speed or Teslas (T) for
     * magnetic flux density.
     * This value is updated for each processed sample containing an average
     * value for the samples within the window.
     *
     * @return windowed average x-coordinate of measurements for each processed
     * triad.
     */
    public double getInstantaneousAvgX() {
<span class="fc" id="L953">        return mInstantaneousAvgX;</span>
    }

    /**
     * Gets windowed average x-coordinate of measurements for each processed triad.
     * This value is updated for each processed sample containing an average
     * value for the samples within the window.
     *
     * @return windowed average x-coordinate of measurements for each processed
     * triad.
     */
    public M getInstantaneousAvgXAsMeasurement() {
<span class="fc" id="L965">        return createMeasurement(mInstantaneousAvgX, getDefaultUnit());</span>
    }

    /**
     * Gets windowed average x-coordinate of measurements for each processed triad.
     * This value is updated for each processed sample containing an average
     * value for the samples within the window.
     *
     * @param result instance where result will be stored.
     */
    public void getInstantaneousAvgXAsMeasurement(final M result) {
<span class="fc" id="L976">        result.setValue(mInstantaneousAvgX);</span>
<span class="fc" id="L977">        result.setUnit(getDefaultUnit());</span>
<span class="fc" id="L978">    }</span>

    /**
     * Gets windowed average y-coordinate of measurements for each processed triad
     * expressed in meters per squared second (m/s^2) for acceleration,
     * radians per second (rad/s) for angular speed or Teslas (T) for
     * magnetic flux density.
     * This value is updated for each processed sample containing an average
     * value for the samples within the window.
     *
     * @return windowed average y-coordinate of measurements for each processed
     * triad.
     */
    public double getInstantaneousAvgY() {
<span class="fc" id="L992">        return mInstantaneousAvgY;</span>
    }

    /**
     * Gets windowed average y-coordinate of measurements for each processed triad.
     * This value is updated for each processed sample containing an average
     * value for the samples within the window.
     *
     * @return windowed average y-coordinate of measurements for each processed
     * triad.
     */
    public M getInstantaneousAvgYAsMeasurement() {
<span class="fc" id="L1004">        return createMeasurement(mInstantaneousAvgY, getDefaultUnit());</span>
    }

    /**
     * Gets windowed average y-coordinate of measurements for each processed triad.
     * This value is updated for each processed sample containing an average
     * value for the samples within the window.
     *
     * @param result instance where result will be stored.
     */
    public void getInstantaneousAvgYAsMeasurement(final M result) {
<span class="fc" id="L1015">        result.setValue(mInstantaneousAvgY);</span>
<span class="fc" id="L1016">        result.setUnit(getDefaultUnit());</span>
<span class="fc" id="L1017">    }</span>

    /**
     * Gets windowed average z-coordinate of measurements for each processed triad
     * expressed in meters per squared second (m/s^2) for acceleration,
     * radians per second (rad/s) for angular speed or Teslas (T) for
     * magnetic flux density.
     * This value is updated for each processed sample containing an average
     * value for the samples within the window.
     *
     * @return windowed average z-coordinate of measurements for each processed
     * triad.
     */
    public double getInstantaneousAvgZ() {
<span class="fc" id="L1031">        return mInstantaneousAvgZ;</span>
    }

    /**
     * Gets windowed average z-coordinate of measurements for each processed triad.
     * This value is updated for each processed sample containing an average
     * value for the samples within the window.
     *
     * @return windowed average z-coordinate of measurements for each processed
     * triad.
     */
    public M getInstantaneousAvgZAsMeasurement() {
<span class="fc" id="L1043">        return createMeasurement(mInstantaneousAvgZ, getDefaultUnit());</span>
    }

    /**
     * Gets windowed average z-coordinate of measurements for each processed triad.
     * This value is updated for each processed sample containing an average
     * value for the samples within the window.
     *
     * @param result instance where result will be stored.
     */
    public void getInstantaneousAvgZAsMeasurement(final M result) {
<span class="fc" id="L1054">        result.setValue(mInstantaneousAvgZ);</span>
<span class="fc" id="L1055">        result.setUnit(getDefaultUnit());</span>
<span class="fc" id="L1056">    }</span>

    /**
     * Gets windowed average of measurements for each processed triad.
     * This value is updated for each processed sample containing an average
     * value for the samples within the window.
     *
     * @return windowed average of measurements for each processed triad.
     */
    public T getInstantaneousAvgTriad() {
<span class="fc" id="L1066">        return createTriad(</span>
                mInstantaneousAvgX, mInstantaneousAvgY, mInstantaneousAvgZ,
<span class="fc" id="L1068">                getDefaultUnit());</span>
    }

    /**
     * Gets windowed average of measurements for each processed triad.
     * This value is updated for each processed sample containing an average
     * value for the samples within the window.
     *
     * @param result instance where result will be stored.
     */
    public void getInstantaneousAvgTriad(final T result) {
<span class="fc" id="L1079">        result.setValueCoordinatesAndUnit(</span>
                mInstantaneousAvgX, mInstantaneousAvgY, mInstantaneousAvgZ,
<span class="fc" id="L1081">                getDefaultUnit());</span>
<span class="fc" id="L1082">    }</span>

    /**
     * Gets windowed standard deviation of x-coordinate of measurements for each
     * processed triad expressed in meters per squared second (m/s^2) for
     * acceleration, radians per second (rad/s) for angular speed or Teslas
     * (T) for magnetic flux density.
     * This value is updated for each processed sample containing measured standard
     * deviation for the samples within the window.
     *
     * @return windowed standard deviation of x-coordinate of measurements for
     * each processed triad.
     */
    public double getInstantaneousStdX() {
<span class="fc" id="L1096">        return mInstantaneousStdX;</span>
    }

    /**
     * Gets windowed standard deviation of x-coordinate of measurements for each
     * processed triad.
     * This value is updated for each processed sample containing measured standard
     * deviation for the samples within the window.
     *
     * @return windowed standard deviation of x-coordinate of measurements for
     * each processed triad.
     */
    public M getInstantaneousStdXAsMeasurement() {
<span class="fc" id="L1109">        return createMeasurement(mInstantaneousStdX, getDefaultUnit());</span>
    }

    /**
     * Gets windowed standard deviation of x-coordinate of measurements for each
     * processed triad.
     * This value is updated for each processed sample containing measured standard
     * deviation for the samples within the window.
     *
     * @param result instance where result will be stored.
     */
    public void getInstantaneousStdXAsMeasurement(final M result) {
<span class="fc" id="L1121">        result.setValue(mInstantaneousStdX);</span>
<span class="fc" id="L1122">        result.setUnit(getDefaultUnit());</span>
<span class="fc" id="L1123">    }</span>

    /**
     * Gets windowed standard deviation of y-coordinate of measurements for each
     * processed triad expressed in meters per squared second (m/s^2) for
     * acceleration, radians per second (rad/s) for angular speed or Teslas
     * (T) for magnetic flux density.
     * This value is updated for each processed sample containing measured standard
     * deviation for the samples within the window.
     *
     * @return windowed standard deviation of y-coordinate of measurements for
     * each processed triad.
     */
    public double getInstantaneousStdY() {
<span class="fc" id="L1137">        return mInstantaneousStdY;</span>
    }

    /**
     * Gets windowed standard deviation of y-coordinate of measurements for each
     * processed triad.
     * This value is updated for each processed sample containing measured standard
     * deviation of the samples within the window.
     *
     * @return windowed standard deviation of y-coordinate of measurements for
     * each processed triad.
     */
    public M getInstantaneousStdYAsMeasurement() {
<span class="fc" id="L1150">        return createMeasurement(mInstantaneousStdY, getDefaultUnit());</span>
    }

    /**
     * Gets windowed standard deviation of y-coordinate of measurements for each
     * processed triad.
     * This value is updated for each processed sample containing measured standard
     * deviation of the samples within the window.
     *
     * @param result instance where result will be stored.
     */
    public void getInstantaneousStdYAsMeasurement(final M result) {
<span class="fc" id="L1162">        result.setValue(mInstantaneousStdY);</span>
<span class="fc" id="L1163">        result.setUnit(getDefaultUnit());</span>
<span class="fc" id="L1164">    }</span>

    /**
     * Gets windowed standard deviation of z-coordinate of measurements for each
     * processed triad expressed in meters per squared second (m/s^2) for
     * acceleration, radians per second (rad/s) for angular speed or Teslas (T)
     * for magnetic flux density.
     * This value is updated for each processed sample containing measured standard
     * deviation for the samples within the window.
     *
     * @return windowed standard deviation of z-coordinate of measurements for
     * each processed triad.
     */
    public double getInstantaneousStdZ() {
<span class="fc" id="L1178">        return mInstantaneousStdZ;</span>
    }

    /**
     * Gets windowed standard deviation of z-coordinate of measurements for each
     * processed triad.
     * This value is updated for each processed sample containing measured standard
     * deviation for the samples within the window.
     *
     * @return windowed standard deviation of z-coordinate of measurements for
     * each processed triad.
     */
    public M getInstantaneousStdZAsMeasurement() {
<span class="fc" id="L1191">        return createMeasurement(mInstantaneousStdZ, getDefaultUnit());</span>
    }

    /**
     * Gets windowed standard deviation of z-coordinate of measurements for each
     * processed triad.
     * This value is updated for each processed sample containing measured standard
     * deviation for the samples within the window.
     *
     * @param result instance where result will be stored.
     */
    public void getInstantaneousStdZAsMeasurement(final M result) {
<span class="fc" id="L1203">        result.setValue(mInstantaneousStdZ);</span>
<span class="fc" id="L1204">        result.setUnit(getDefaultUnit());</span>
<span class="fc" id="L1205">    }</span>

    /**
     * Gets windowed standard deviation of measurements for each processed triad.
     * This value is updated for each processed sample containing measured standard
     * deviation for the samples within the window.
     *
     * @return windowed standard deviation of measurements for each processed
     * triad.
     */
    public T getInstantaneousStdTriad() {
<span class="fc" id="L1216">        return createTriad(</span>
                mInstantaneousStdX, mInstantaneousStdY, mInstantaneousStdZ,
<span class="fc" id="L1218">                getDefaultUnit());</span>
    }

    /**
     * Gets windowed standard deviation of measurements for each processed triad.
     * This value is updated for each processed sample containing measured standard
     * deviation for the samples within the window.
     *
     * @param result instance where result will be stored.
     */
    public void getInstantaneousStdTriad(final T result) {
<span class="fc" id="L1229">        result.setValueCoordinatesAndUnit(</span>
                mInstantaneousStdX, mInstantaneousStdY, mInstantaneousStdZ,
<span class="fc" id="L1231">                getDefaultUnit());</span>
<span class="fc" id="L1232">    }</span>

    /**
     * Processes a new measurement triad sample.
     *
     * @param triad a new measurement triad to be processed.
     * @return true if provided triad has been processed, false if provided triad has been skipped because detector
     * previously failed. If detector previously failed, it will need to be reset before processing additional
     * samples.
     * @throws LockedException if detector is busy processing a previous sample.
     */
    public boolean process(final T triad) throws LockedException {
<span class="fc" id="L1244">        return process(convertMeasurement(triad.getValueX(), triad.getUnit()),</span>
<span class="fc" id="L1245">                convertMeasurement(triad.getValueY(), triad.getUnit()),</span>
<span class="fc" id="L1246">                convertMeasurement(triad.getValueZ(), triad.getUnit()));</span>
    }

    /**
     * Processes a new measurement triad sample.
     *
     * @param valueX x-coordinate of sensed measurement.
     * @param valueY y-coordinate of sensed measurement.
     * @param valueZ z-coordinate of sensed measurement.
     * @return true if provided triad has been processed, false if provided triad has been skipped because detector
     * previously failed. If detector previously failed, it will need to be reset before processing additional
     * samples.
     * @throws LockedException if detector is busy processing a previous sample.
     */
    public boolean process(final M valueX, final M valueY, final M valueZ)
            throws LockedException {
<span class="fc" id="L1262">        return process(convertMeasurement(valueX),</span>
<span class="fc" id="L1263">                convertMeasurement(valueY),</span>
<span class="fc" id="L1264">                convertMeasurement(valueZ));</span>
    }

    /**
     * Processes a new measurement triad sample.
     * Provided measurement coordinates are expressed in meters per squared second (m/s^2) for acceleration,
     * radians per second (rad/s) for angular speed or Teslas (T) for magnetic flux density.
     *
     * @param valueX x-coordinate of sensed measurement.
     * @param valueY y-coordinate of sensed measurement.
     * @param valueZ z-coordinate of sensed measurement.
     * @return true if provided triad has been processed, false if provided triad has been skipped because detector
     * previously failed. If detector previously failed, it will need to be reset before processing additional
     * samples.
     * @throws LockedException if detector is busy processing a previous sample.
     */
    public boolean process(final double valueX,
                           final double valueY,
                           final double valueZ) throws LockedException {
<span class="fc bfc" id="L1283" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L1284">            throw new LockedException();</span>
        }

<span class="fc bfc" id="L1287" title="All 2 branches covered.">        if (mStatus == Status.FAILED) {</span>
<span class="fc" id="L1288">            return false;</span>
        }

<span class="fc" id="L1291">        mRunning = true;</span>

<span class="fc bfc" id="L1293" title="All 2 branches covered.">        if (mStatus == Status.IDLE) {</span>
            // start initialization
<span class="fc" id="L1295">            mStatus = Status.INITIALIZING;</span>

<span class="pc bpc" id="L1297" title="1 of 2 branches missed.">            if (mListener != null) {</span>
                //noinspection unchecked
<span class="fc" id="L1299">                mListener.onInitializationStarted((D) this);</span>
            }
        }

<span class="fc" id="L1303">        mProcessedSamples++;</span>

<span class="fc" id="L1305">        mWindowedNoiseEstimator.addTriadAndProcess(valueX, valueY, valueZ);</span>

<span class="fc" id="L1307">        mInstantaneousAvgX = mWindowedNoiseEstimator.getAvgX();</span>
<span class="fc" id="L1308">        mInstantaneousAvgY = mWindowedNoiseEstimator.getAvgY();</span>
<span class="fc" id="L1309">        mInstantaneousAvgZ = mWindowedNoiseEstimator.getAvgZ();</span>

<span class="fc" id="L1311">        mInstantaneousStdX = mWindowedNoiseEstimator.getStandardDeviationX();</span>
<span class="fc" id="L1312">        mInstantaneousStdY = mWindowedNoiseEstimator.getStandardDeviationY();</span>
<span class="fc" id="L1313">        mInstantaneousStdZ = mWindowedNoiseEstimator.getStandardDeviationZ();</span>

<span class="fc" id="L1315">        final double windowedStdNorm = mWindowedNoiseEstimator</span>
<span class="fc" id="L1316">                .getStandardDeviationNorm();</span>

<span class="fc" id="L1318">        final boolean filledWindow = mWindowedNoiseEstimator.isWindowFilled();</span>

<span class="fc bfc" id="L1320" title="All 2 branches covered.">        if (mStatus == Status.INITIALIZING) {</span>
            // process sample during initialization
<span class="fc" id="L1322">            mAccumulatedNoiseEstimator.addTriad(valueX, valueY, valueZ);</span>
<span class="fc" id="L1323">            final double accumulatedStdNorm = mAccumulatedNoiseEstimator</span>
<span class="fc" id="L1324">                    .getStandardDeviationNorm();</span>

<span class="fc bfc" id="L1326" title="All 2 branches covered.">            if (mProcessedSamples &lt; mInitialStaticSamples) {</span>
<span class="fc bfc" id="L1327" title="All 4 branches covered.">                if (filledWindow &amp;&amp; (windowedStdNorm / accumulatedStdNorm &gt; mInstantaneousNoiseLevelFactor)) {</span>
                    // sudden motion detected
<span class="fc" id="L1329">                    mStatus = Status.FAILED;</span>

                    // notify error
<span class="pc bpc" id="L1332" title="1 of 2 branches missed.">                    if (mListener != null) {</span>
                        //noinspection unchecked
<span class="fc" id="L1334">                        mListener.onError((D) this, accumulatedStdNorm,</span>
                                windowedStdNorm,
                                ErrorReason.SUDDEN_EXCESSIVE_MOVEMENT_DETECTED);
                    }
                }

<span class="pc bpc" id="L1340" title="1 of 2 branches missed.">            } else if (filledWindow) {</span>
                // initialization completed
                // set base noise level and threshold
<span class="fc" id="L1343">                mBaseNoiseLevel = accumulatedStdNorm;</span>
<span class="fc" id="L1344">                mThreshold = mBaseNoiseLevel * mThresholdFactor;</span>

                // keep average/std measurements triad in case we want to obtain
                // its value since initial period must be static
<span class="fc" id="L1348">                mAccumulatedAvgX = mAccumulatedNoiseEstimator.getAvgX();</span>
<span class="fc" id="L1349">                mAccumulatedAvgY = mAccumulatedNoiseEstimator.getAvgY();</span>
<span class="fc" id="L1350">                mAccumulatedAvgZ = mAccumulatedNoiseEstimator.getAvgZ();</span>

<span class="fc" id="L1352">                mAccumulatedStdX = mAccumulatedNoiseEstimator.getStandardDeviationX();</span>
<span class="fc" id="L1353">                mAccumulatedStdY = mAccumulatedNoiseEstimator.getStandardDeviationY();</span>
<span class="fc" id="L1354">                mAccumulatedStdZ = mAccumulatedNoiseEstimator.getStandardDeviationZ();</span>

                // reset accumulated estimator so that we can estimate
                // average specific force in static periods
<span class="fc" id="L1358">                mAccumulatedNoiseEstimator.reset();</span>

<span class="fc bfc" id="L1360" title="All 2 branches covered.">                if (mBaseNoiseLevel &gt; mBaseNoiseLevelAbsoluteThreshold) {</span>
                    // base noise level exceeds allowed value
<span class="fc" id="L1362">                    mStatus = Status.FAILED;</span>

                    // notify error
<span class="pc bpc" id="L1365" title="1 of 2 branches missed.">                    if (mListener != null) {</span>
                        //noinspection unchecked
<span class="fc" id="L1367">                        mListener.onError((D) this, accumulatedStdNorm,</span>
                                windowedStdNorm,
                                ErrorReason.OVERALL_EXCESSIVE_MOVEMENT_DETECTED);
                    }

                } else {
                    // initialization has been successfully completed
<span class="fc" id="L1374">                    mStatus = Status.INITIALIZATION_COMPLETED;</span>

<span class="pc bpc" id="L1376" title="1 of 2 branches missed.">                    if (mListener != null) {</span>
                        //noinspection unchecked
<span class="fc" id="L1378">                        mListener.onInitializationCompleted(</span>
                                (D) this, mBaseNoiseLevel);
                    }
                }

            }

<span class="fc" id="L1385">            mRunning = false;</span>
<span class="fc" id="L1386">            return true;</span>
        } else {
            // detect static or dynamic period
<span class="fc" id="L1389">            final Status previousStatus = mStatus;</span>

<span class="fc bfc" id="L1391" title="All 2 branches covered.">            if (windowedStdNorm &lt; mThreshold) {</span>
<span class="fc" id="L1392">                mStatus = Status.STATIC_INTERVAL;</span>
            } else {
<span class="fc" id="L1394">                mStatus = Status.DYNAMIC_INTERVAL;</span>
            }

<span class="fc bfc" id="L1397" title="All 2 branches covered.">            if (mStatus == Status.STATIC_INTERVAL) {</span>
                // while we are in static interval, keep adding samples to estimate
                // accumulated average measurement triad
<span class="fc" id="L1400">                mAccumulatedNoiseEstimator.addTriad(valueX, valueY, valueZ);</span>
            }

<span class="fc bfc" id="L1403" title="All 2 branches covered.">            if (previousStatus != mStatus) {</span>
                // static/dynamic period change detected
<span class="pc bpc" id="L1405" title="1 of 3 branches missed.">                switch (mStatus) {</span>
                    case STATIC_INTERVAL:
<span class="pc bpc" id="L1407" title="1 of 2 branches missed.">                        if (mListener != null) {</span>
                            //noinspection unchecked
<span class="fc" id="L1409">                            mListener.onStaticIntervalDetected((D) this,</span>
                                    mInstantaneousAvgX, mInstantaneousAvgY, mInstantaneousAvgZ,
                                    mInstantaneousStdX, mInstantaneousStdY, mInstantaneousStdZ);
                        }
                        break;
                    case DYNAMIC_INTERVAL:
                        // when switching from static to dynamic interval,
                        // pick accumulated average and standard deviation measurement triads
<span class="fc" id="L1417">                        mAccumulatedAvgX = mAccumulatedNoiseEstimator.getAvgX();</span>
<span class="fc" id="L1418">                        mAccumulatedAvgY = mAccumulatedNoiseEstimator.getAvgY();</span>
<span class="fc" id="L1419">                        mAccumulatedAvgZ = mAccumulatedNoiseEstimator.getAvgZ();</span>

<span class="fc" id="L1421">                        mAccumulatedStdX = mAccumulatedNoiseEstimator.getStandardDeviationX();</span>
<span class="fc" id="L1422">                        mAccumulatedStdY = mAccumulatedNoiseEstimator.getStandardDeviationY();</span>
<span class="fc" id="L1423">                        mAccumulatedStdZ = mAccumulatedNoiseEstimator.getStandardDeviationZ();</span>

                        // reset accumulated estimator when switching to dynamic period
<span class="fc" id="L1426">                        mAccumulatedNoiseEstimator.reset();</span>

<span class="pc bpc" id="L1428" title="1 of 2 branches missed.">                        if (mListener != null) {</span>
                            //noinspection unchecked
<span class="fc" id="L1430">                            mListener.onDynamicIntervalDetected((D) this,</span>
                                    mInstantaneousAvgX, mInstantaneousAvgY, mInstantaneousAvgZ,
                                    mInstantaneousStdX, mInstantaneousStdY, mInstantaneousStdZ,
                                    mAccumulatedAvgX, mAccumulatedAvgY, mAccumulatedAvgZ,
                                    mAccumulatedStdX, mAccumulatedStdY, mAccumulatedStdZ);
                        }
                        break;
                }
            }
        }

<span class="fc" id="L1441">        mRunning = false;</span>
<span class="fc" id="L1442">        return true;</span>
    }

    /**
     * Resets this detector so that it is initialized again when new samples are added.
     *
     * @throws LockedException if detector is busy.
     */
    public void reset() throws LockedException {
<span class="fc bfc" id="L1451" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L1452">            throw new LockedException();</span>
        }

<span class="fc" id="L1455">        mRunning = true;</span>

<span class="fc" id="L1457">        mStatus = Status.IDLE;</span>
<span class="fc" id="L1458">        mProcessedSamples = 0;</span>
<span class="fc" id="L1459">        mBaseNoiseLevel = 0.0;</span>
<span class="fc" id="L1460">        mThreshold = 0.0;</span>

<span class="fc" id="L1462">        mWindowedNoiseEstimator.reset();</span>
<span class="fc" id="L1463">        mAccumulatedNoiseEstimator.reset();</span>
        
<span class="pc bpc" id="L1465" title="1 of 2 branches missed.">        if (mListener != null) {</span>
            //noinspection unchecked
<span class="fc" id="L1467">            mListener.onReset((D) this);</span>
        }

<span class="fc" id="L1470">        mRunning = false;</span>
<span class="fc" id="L1471">    }</span>

    /**
     * Converts provided measurement instance to its default unit, which is
     * meters per squared second (m/s^2) for acceleration, radians per second (rad/s) for
     * angular speed or Teslas (T) for magnetic flux density.
     *
     * @param measurement measurement to be converted.
     * @return converted value.
     */
    protected double convertMeasurement(M measurement) {
<span class="fc" id="L1482">        return convertMeasurement(measurement.getValue().doubleValue(),</span>
<span class="fc" id="L1483">                measurement.getUnit());</span>
    }

    /**
     * Converts provided measurement value expressed in provided unit to the
     * default measurement value, which is meters per squared second (m/s^2) for acceleration,
     * radians per second (rad/s) for angular speed or Teslas (t) for magnetic flux density.
     *
     * @param value value to be converted.
     * @param unit  unit of value to be converted.
     * @return converted value.
     */
    protected abstract double convertMeasurement(final double value, final U unit);

    /**
     * Creates a measurement instance using provided value and unit.
     *
     * @param value value of measurement.
     * @param unit  unit of value.
     * @return created measurement
     */
    protected abstract M createMeasurement(final double value, final U unit);

    /**
     * Gets default unit for measurements this implementation works with.
     *
     * @return default measurement unit.
     */
    protected abstract U getDefaultUnit();

    /**
     * Creates a triad.
     *
     * @param valueX x-coordinate value.
     * @param valueY y-coordinate value.
     * @param valueZ z-coordinate value.
     * @param unit   unit of values.
     * @return created triad.
     */
    protected abstract T createTriad(
            final double valueX, final double valueY, final double valueZ, final U unit);

    /**
     * Possible detector status values.
     */
<span class="fc" id="L1528">    public enum Status {</span>
        /**
         * Detector is in idle status when it hasn't processed any sample yet.
         */
<span class="fc" id="L1532">        IDLE,</span>

        /**
         * Detector is processing samples in the initial static process to determine base noise level.
         */
<span class="fc" id="L1537">        INITIALIZING,</span>

        /**
         * Detector has sucessfully completed processing samples on the initial
         * static period.
         */
<span class="fc" id="L1543">        INITIALIZATION_COMPLETED,</span>

        /**
         * A static interval has been detected, where accelerometer is considered to be subject to no substantial
         * movement forces.
         */
<span class="fc" id="L1549">        STATIC_INTERVAL,</span>

        /**
         * A dynamic interval has been detected, where accelerometer is considered to be subject to substantial
         * movement forces.
         */
<span class="fc" id="L1555">        DYNAMIC_INTERVAL,</span>

        /**
         * Detector has failed. This happens if accelerometer is subject to sudden movement forces while detector
         * is initializing during the initial static period.
         * When detector has failed, no new samples will be allowed to be processed until detector is reset.
         */
<span class="fc" id="L1562">        FAILED</span>
    }

    /**
     * Reason why this detector has failed during initialization.
     */
<span class="fc" id="L1568">    public enum ErrorReason {</span>
        /**
         * If a sudden movement is detected during initialization.
         */
<span class="fc" id="L1572">        SUDDEN_EXCESSIVE_MOVEMENT_DETECTED,</span>

        /**
         * If overall noise level is excessive during initialization.
         */
<span class="fc" id="L1577">        OVERALL_EXCESSIVE_MOVEMENT_DETECTED</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>