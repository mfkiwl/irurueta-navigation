<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GyroscopeMeasurementsGenerator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.irurueta:irurueta-navigation</a> &gt; <a href="index.source.html" class="el_package">com.irurueta.navigation.inertial.calibration.generators</a> &gt; <span class="el_source">GyroscopeMeasurementsGenerator.java</span></div><h1>GyroscopeMeasurementsGenerator.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2020 Alberto Irurueta Carro (alberto@irurueta.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.irurueta.navigation.inertial.calibration.generators;

import com.irurueta.navigation.LockedException;
import com.irurueta.navigation.inertial.BodyKinematics;
import com.irurueta.navigation.inertial.calibration.AngularSpeedTriad;
import com.irurueta.navigation.inertial.calibration.BodyKinematicsSequence;
import com.irurueta.navigation.inertial.calibration.StandardDeviationTimedBodyKinematics;
import com.irurueta.navigation.inertial.calibration.TimedBodyKinematics;
import com.irurueta.navigation.inertial.calibration.intervals.TriadStaticIntervalDetector;
import com.irurueta.navigation.inertial.calibration.noise.AccumulatedAngularSpeedTriadNoiseEstimator;
import com.irurueta.units.AngularSpeed;
import com.irurueta.units.AngularSpeedUnit;

import java.util.ArrayList;
import java.util.List;

/**
 * Generates measurements for the calibration of gyroscopes by alternating
 * static and dynamic intervals where device is kept static or moved.
 * Generated measurements must be used with easy gyroscope calibrators.
 * Notice that accuracy of the gyroscope calibration is very sensitive to the
 * accuracy of detected dynamic intervals respect the average specific forces
 * during static intervals.
 * In order to increase the accuracy, calibration should be repeated trying different
 * threshold factors {@link #getThresholdFactor()}.
 * Such calibrators are the following ones:
 * - {@link com.irurueta.navigation.inertial.calibration.gyroscope.EasyGyroscopeCalibrator}
 * - {@link com.irurueta.navigation.inertial.calibration.gyroscope.KnownBiasEasyGyroscopeCalibrator}
 * - {@link com.irurueta.navigation.inertial.calibration.gyroscope.RobustEasyGyroscopeCalibrator} and all its
 * implementations.
 * - {@link com.irurueta.navigation.inertial.calibration.gyroscope.RobustKnownBiasEasyGyroscopeCalibrator} and all its
 * implementations.
 */
public class GyroscopeMeasurementsGenerator extends
        MeasurementsGenerator&lt;
                BodyKinematicsSequence&lt;StandardDeviationTimedBodyKinematics&gt;,
                GyroscopeMeasurementsGenerator,
                GyroscopeMeasurementGeneratorListener, TimedBodyKinematics&gt; {

    /**
     * An angular speed triad.
     * This is reused for memory efficiency.
     */
<span class="fc" id="L60">    protected final AngularSpeedTriad mAngularSpeedTriad =</span>
            new AngularSpeedTriad();

    /**
     * Items to be added to a generated sequence when next static period occurs.
     */
    private List&lt;StandardDeviationTimedBodyKinematics&gt; mCurrentSequenceItems;

    /**
     * Accumulated noise estimator for angular speed measurements.
     */
<span class="fc" id="L71">    private final AccumulatedAngularSpeedTriadNoiseEstimator mAccumulatedEstimator =</span>
            new AccumulatedAngularSpeedTriadNoiseEstimator();

    /**
     * Estimated acceleration standard deviation during initialization expressed
     * in meters per squared second (m/s^2).
     */
    private double mAccelerationStandardDeviation;

    /**
     * Estimated angular speed standard deviation during initialization expressed
     * in radians per second (rad/s).
     */
    private double mAngularSpeedStandardDeviation;

    /**
     * Previous average x-coordinate of measurements expressed in meters
     * per squared second (m/s^2).
     */
    private Double mPreviousAvgX;

    /**
     * Previous average y-coordinate of measurements expressed in meters
     * per squared second (m/s^2).
     */
    private Double mPreviousAvgY;

    /**
     * Previous average z-coordinate of measurements expressed in meters
     * per squared second (m/s^2).
     */
    private Double mPreviousAvgZ;

    /**
     * Current average x-coordinate of measurements expressed in meters
     * per squared second (m/s^2).
     */
    private Double mCurrentAvgX;

    /**
     * Current average y-coordinate of measurements expressed in meters
     * per squared second (m/s^2).
     */
    private Double mCurrentAvgY;

    /**
     * Current average z-coordinate of measurements expressed in meters
     * per squared second (m/s^2).
     */
    private Double mCurrentAvgZ;

    /**
     * Contains previous status while processing samples.
     */
    private TriadStaticIntervalDetector.Status mPreviousStatus;

    /**
     * Constructor.
     */
    public GyroscopeMeasurementsGenerator() {
<span class="fc" id="L131">        super();</span>
<span class="fc" id="L132">    }</span>

    /**
     * Constructor.
     *
     * @param listener listener to handle events raised by this generator.
     */
    public GyroscopeMeasurementsGenerator(
            final GyroscopeMeasurementGeneratorListener listener) {
<span class="fc" id="L141">        super(listener);</span>
<span class="fc" id="L142">    }</span>

    /**
     * Resets this generator.
     *
     * @throws LockedException if generator is busy.
     */
    @Override
    public void reset() throws LockedException {
<span class="fc" id="L151">        super.reset();</span>

<span class="fc" id="L153">        mCurrentSequenceItems = null;</span>

<span class="fc" id="L155">        mAccelerationStandardDeviation = 0.0;</span>
<span class="fc" id="L156">        mAngularSpeedStandardDeviation = 0.0;</span>

<span class="fc" id="L158">        mPreviousAvgX = null;</span>
<span class="fc" id="L159">        mPreviousAvgY = null;</span>
<span class="fc" id="L160">        mPreviousAvgZ = null;</span>

<span class="fc" id="L162">        mCurrentAvgX = null;</span>
<span class="fc" id="L163">        mCurrentAvgY = null;</span>
<span class="fc" id="L164">        mCurrentAvgZ = null;</span>

<span class="fc" id="L166">        mAccumulatedEstimator.reset();</span>

<span class="fc" id="L168">        mPreviousStatus = null;</span>
<span class="fc" id="L169">    }</span>

    /**
     * Gets estimated average angular rate during initialization phase.
     *
     * @return estimated average angular rate during initialization phase.
     */
    public AngularSpeedTriad getInitialAvgAngularSpeedTriad() {
<span class="fc" id="L177">        return mAccumulatedEstimator.getAvgTriad();</span>
    }

    /**
     * Gets estimated average angular rate during initialization phase.
     *
     * @param result instance where result will be stored.
     */
    public void getInitialAvgAngularSpeedTriad(final AngularSpeedTriad result) {
<span class="fc" id="L186">        mAccumulatedEstimator.getAvgTriad(result);</span>
<span class="fc" id="L187">    }</span>

    /**
     * Gets estimated standard deviation of angular rate during initialization phase.
     *
     * @return estimated standard deviation of angular rate during initialization phase.
     */
    public AngularSpeedTriad getInitialAngularSpeedTriadStandardDeviation() {
<span class="fc" id="L195">        return mAccumulatedEstimator.getStandardDeviationTriad();</span>
    }

    /**
     * Gets estimated standard deviation of angular rate during initialization phase.
     *
     * @param result instance where result will be stored.
     */
    public void getInitialAngularSpeedTriadStandardDeviation(final AngularSpeedTriad result) {
<span class="fc" id="L204">        mAccumulatedEstimator.getStandardDeviationTriad(result);</span>
<span class="fc" id="L205">    }</span>

    /**
     * Gets norm of estimated standard deviation of angular rate during initialization phase
     * expressed in radians per second (rad/s).
     *
     * @return norm of estimated standard deviation of angular rate during initialization phase.
     */
    public double getInitialAngularSpeedTriadStandardDeviationNorm() {
<span class="fc" id="L214">        return mAngularSpeedStandardDeviation;</span>
    }

    /**
     * Gets norm of estimated standard deviation of angular rate during initialization phase.
     *
     * @return norm of estimated standard deviation of angular rate during initialization phase.
     */
    public AngularSpeed getInitialAngularSpeedTriadStandardDeviationNormAsMeasurement() {
<span class="fc" id="L223">        return new AngularSpeed(mAngularSpeedStandardDeviation,</span>
                AngularSpeedUnit.RADIANS_PER_SECOND);
    }

    /**
     * Gets norm of estimated standard deviation of angular rate during initialization phase.
     *
     * @param result instance where result will be stored.
     */
    public void getInitialAngularSpeedTriadStandardDeviationNormAsMeasurement(
            final AngularSpeed result) {
<span class="fc" id="L234">        result.setValue(mAngularSpeedStandardDeviation);</span>
<span class="fc" id="L235">        result.setUnit(AngularSpeedUnit.RADIANS_PER_SECOND);</span>
<span class="fc" id="L236">    }</span>

    /**
     * Post process provided input sample.
     *
     * @param sample an input sample.
     * @throws LockedException if generator is busy.
     */
    @Override
    protected void postProcess(final TimedBodyKinematics sample)
            throws LockedException {
<span class="fc" id="L247">        final TriadStaticIntervalDetector.Status status =</span>
<span class="fc" id="L248">                mStaticIntervalDetector.getStatus();</span>

<span class="fc bfc" id="L250" title="All 2 branches covered.">        if (status == TriadStaticIntervalDetector.Status.INITIALIZING) {</span>
<span class="fc" id="L251">            sample.getKinematics().getAngularRateTriad(mAngularSpeedTriad);</span>
<span class="fc" id="L252">            mAccumulatedEstimator.addTriad(mAngularSpeedTriad);</span>
        }

        // while we are in a dynamic interval, we must record all timed kinematics
        // along with accelerometer and gyroscope standard deviations
<span class="fc bfc" id="L257" title="All 2 branches covered.">        if (status == TriadStaticIntervalDetector.Status.DYNAMIC_INTERVAL) {</span>
<span class="fc bfc" id="L258" title="All 2 branches covered.">            if (isDynamicIntervalSkipped()) {</span>
                // dynamic interval has been skipped because there were too many
                // items in the sequence.
<span class="fc" id="L261">                mCurrentSequenceItems = null;</span>
            } else {
<span class="pc bpc" id="L263" title="1 of 2 branches missed.">                if (mPreviousStatus == TriadStaticIntervalDetector.Status.STATIC_INTERVAL) {</span>
<span class="fc" id="L264">                    mPreviousAvgX = mStaticIntervalDetector.getAccumulatedAvgX();</span>
<span class="fc" id="L265">                    mPreviousAvgY = mStaticIntervalDetector.getAccumulatedAvgY();</span>
<span class="fc" id="L266">                    mPreviousAvgZ = mStaticIntervalDetector.getAccumulatedAvgZ();</span>
                }

<span class="fc" id="L269">                addSequenceItem(sample);</span>
            }
<span class="fc bfc" id="L271" title="All 2 branches covered.">        } else if (status == TriadStaticIntervalDetector.Status.STATIC_INTERVAL) {</span>
<span class="pc bpc" id="L272" title="1 of 4 branches missed.">            if (mPreviousStatus == TriadStaticIntervalDetector.Status.DYNAMIC_INTERVAL</span>
<span class="pc bpc" id="L273" title="1 of 2 branches missed.">                &amp;&amp; mCurrentSequenceItems != null &amp;&amp; !mCurrentSequenceItems.isEmpty()) {</span>

<span class="fc" id="L275">                mCurrentAvgX = mStaticIntervalDetector.getInstantaneousAvgX();</span>
<span class="fc" id="L276">                mCurrentAvgY = mStaticIntervalDetector.getInstantaneousAvgY();</span>
<span class="fc" id="L277">                mCurrentAvgZ = mStaticIntervalDetector.getInstantaneousAvgZ();</span>

                // we have all required data to generate a sequence
<span class="fc" id="L280">                final BodyKinematicsSequence&lt;StandardDeviationTimedBodyKinematics&gt; sequence =</span>
                        new BodyKinematicsSequence&lt;&gt;();
<span class="fc" id="L282">                sequence.setBeforeMeanSpecificForceCoordinates(</span>
<span class="fc" id="L283">                        mPreviousAvgX, mPreviousAvgY, mPreviousAvgZ);</span>
<span class="fc" id="L284">                sequence.setItems(mCurrentSequenceItems);</span>
<span class="fc" id="L285">                sequence.setAfterMeanSpecificForceCoordinates(</span>
<span class="fc" id="L286">                        mCurrentAvgX, mCurrentAvgY, mCurrentAvgZ);</span>

<span class="fc" id="L288">                mCurrentSequenceItems = null;</span>

<span class="pc bpc" id="L290" title="1 of 2 branches missed.">                if (mListener != null) {</span>
<span class="fc" id="L291">                    mListener.onGeneratedMeasurement(this, sequence);</span>
                }
            }
        }
<span class="fc" id="L295">    }</span>

    /**
     * Gets corresponding acceleration triad from provided input sample.
     * This method must store the result into {@link #mTriad}.
     *
     * @param sample input sample.
     */
    @Override
    protected void getAccelerationTriadFromInputSample(
            final TimedBodyKinematics sample) {
<span class="fc" id="L306">        sample.getKinematics().getSpecificForceTriad(mTriad);</span>
<span class="fc" id="L307">    }</span>

    /**
     * Handles a static-to-dynamic interval change.
     *
     * @param accumulatedAvgX   average x-coordinate of measurements during last
     *                          static period expressed in meters per squared
     *                          second (m/s^2).
     * @param accumulatedAvgY   average y-coordinate of specific force during last
     *                          static period expressed in meters per squared
     *                          second (m/s^2).
     * @param accumulatedAvgZ   average z-coordinate of specific force during last
     *                          static period expressed in meters per squared
     *                          second (m/s^2).
     * @param accumulatedStdX   standard deviation of x-coordinate of measurements
     *                          during last static period expressed in meters per
     *                          squared second (m/s^2).
     * @param accumulatedStdY   standard deviation of y-coordinate of measurements
     *                          during last static period expressed in meters per
     *                          squared second (m/s^2).
     * @param accumulatedStdZ   standard deviation of z-coordinate of measurements
     *                          during last static period expressed in meters per
     *                          squared second (m/s^2).
     */
    @Override
    protected void handleStaticToDynamicChange(
            final double accumulatedAvgX,
            final double accumulatedAvgY,
            final double accumulatedAvgZ,
            final double accumulatedStdX,
            final double accumulatedStdY,
            final double accumulatedStdZ) {
<span class="fc" id="L339">        mPreviousStatus = TriadStaticIntervalDetector.Status.STATIC_INTERVAL;</span>
<span class="fc" id="L340">    }</span>

    /**
     * Handles a dynamic-to-static interval change.
     */
    @Override
    protected void handleDynamicToStaticChange() {
<span class="fc" id="L347">        mPreviousStatus = TriadStaticIntervalDetector.Status.DYNAMIC_INTERVAL;</span>
<span class="fc" id="L348">    }</span>

    /**
     * Handles an initialization completion.
     */
    @Override
    protected void handleInitializationCompleted() {
<span class="fc" id="L355">        mAccelerationStandardDeviation = mStaticIntervalDetector.getBaseNoiseLevel();</span>
<span class="fc" id="L356">        mAngularSpeedStandardDeviation = mAccumulatedEstimator.getStandardDeviationNorm();</span>

<span class="fc" id="L358">        mPreviousStatus = mStaticIntervalDetector.getStatus();</span>
<span class="fc" id="L359">    }</span>

    /**
     * Handles an error during initialization.
     */
    @Override
    protected void handleInitializationFailed() {
<span class="fc" id="L366">        mPreviousStatus = null;</span>

        try {
<span class="fc" id="L369">            mAccumulatedEstimator.reset();</span>
<span class="nc" id="L370">        } catch (final LockedException ignore) {</span>
<span class="fc" id="L371">        }</span>
<span class="fc" id="L372">    }</span>

    /**
     * Adds an item to current sequence items.
     *
     * @param sample sample to generate a sequence item from.
     */
    private void addSequenceItem(final TimedBodyKinematics sample) {
<span class="fc bfc" id="L380" title="All 2 branches covered.">        if (mCurrentSequenceItems == null) {</span>
<span class="fc" id="L381">            mCurrentSequenceItems = new ArrayList&lt;&gt;();</span>
        }

<span class="fc" id="L384">        final BodyKinematics kinematics = new BodyKinematics(</span>
<span class="fc" id="L385">                sample.getKinematics());</span>
<span class="fc" id="L386">        final double timestampSeconds = sample.getTimestampSeconds();</span>
<span class="fc" id="L387">        final StandardDeviationTimedBodyKinematics stdTimedKinematics =</span>
                new StandardDeviationTimedBodyKinematics(kinematics,
                        timestampSeconds, mAccelerationStandardDeviation,
                        mAngularSpeedStandardDeviation);
<span class="fc" id="L391">        mCurrentSequenceItems.add(stdTimedKinematics);</span>
<span class="fc" id="L392">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>