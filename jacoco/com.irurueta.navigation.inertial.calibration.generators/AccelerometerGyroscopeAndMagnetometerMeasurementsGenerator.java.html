<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AccelerometerGyroscopeAndMagnetometerMeasurementsGenerator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.irurueta:irurueta-navigation</a> &gt; <a href="index.source.html" class="el_package">com.irurueta.navigation.inertial.calibration.generators</a> &gt; <span class="el_source">AccelerometerGyroscopeAndMagnetometerMeasurementsGenerator.java</span></div><h1>AccelerometerGyroscopeAndMagnetometerMeasurementsGenerator.java</h1><pre class="source lang-java linenums">package com.irurueta.navigation.inertial.calibration.generators;

import com.irurueta.navigation.LockedException;
import com.irurueta.navigation.inertial.calibration.AngularSpeedTriad;
import com.irurueta.navigation.inertial.calibration.BodyKinematicsSequence;
import com.irurueta.navigation.inertial.calibration.StandardDeviationBodyKinematics;
import com.irurueta.navigation.inertial.calibration.StandardDeviationBodyMagneticFluxDensity;
import com.irurueta.navigation.inertial.calibration.StandardDeviationTimedBodyKinematics;
import com.irurueta.navigation.inertial.calibration.TimedBodyKinematics;
import com.irurueta.navigation.inertial.calibration.TimedBodyKinematicsAndMagneticFluxDensity;
import com.irurueta.navigation.inertial.calibration.intervals.TriadStaticIntervalDetector;
import com.irurueta.units.Acceleration;
import com.irurueta.units.AngularSpeed;

/**
 * Generates measurements for the calibration of accelerometers and gyroscopes by alternating
 * static and dynamic intervals where device is kept static or moved.
 * Generated measurements must be used with accelerometer calibrators based
 * on the knowledge of gravity norm (or Earth position) when the device orientation
 * is unknown, with easy gyroscope calibrators and with magnetometer calibrators based
 * on the knowledge of position on Earth and time instant.
 * Notice that accuracy of the gyroscope calibration is very sensitive to the
 * accuracy of detected dynamic intervals respect the average specific forces
 * during static intervals.
 * In order to increase the accuracy, calibration should be repeated trying different
 * threshold factors {@link #getThresholdFactor()}.
 *
 * @see AccelerometerMeasurementsGenerator
 * @see GyroscopeMeasurementsGenerator
 * @see MagnetometerMeasurementsGenerator
 */
public class AccelerometerGyroscopeAndMagnetometerMeasurementsGenerator {

    /**
     * Listener to handle generated events.
     */
    private AccelerometerGyroscopeAndMagnetometerMeasurementsGeneratorListener mListener;

    /**
     * Listener for internal accelerometer measurements generator.
     */
<span class="fc" id="L42">    private final AccelerometerMeasurementsGeneratorListener mAccelerometerListener =</span>
<span class="fc" id="L43">            new AccelerometerMeasurementsGeneratorListener() {</span>
                @Override
                public void onInitializationStarted(
                        final AccelerometerMeasurementsGenerator generator) {
                    // no action required
<span class="fc" id="L48">                }</span>

                @Override
                public void onInitializationCompleted(
                        final AccelerometerMeasurementsGenerator generator,
                        final double baseNoiseLevel) {
                    // no action required
<span class="fc" id="L55">                }</span>

                @Override
                public void onError(
                        final AccelerometerMeasurementsGenerator generator,
                        final TriadStaticIntervalDetector.ErrorReason reason) {
<span class="pc bpc" id="L61" title="1 of 2 branches missed.">                    if (mListener != null) {</span>
<span class="fc" id="L62">                        mListener.onError(</span>
                                AccelerometerGyroscopeAndMagnetometerMeasurementsGenerator.this,
                                reason);
                    }
<span class="fc" id="L66">                }</span>

                @Override
                public void onStaticIntervalDetected(
                        final AccelerometerMeasurementsGenerator generator) {
                    // no action required
<span class="fc" id="L72">                }</span>

                @Override
                public void onDynamicIntervalDetected(
                        final AccelerometerMeasurementsGenerator generator) {
                    // no action required
<span class="fc" id="L78">                }</span>

                @Override
                public void onStaticIntervalSkipped(
                        final AccelerometerMeasurementsGenerator generator) {
                    // no action required
<span class="fc" id="L84">                }</span>

                @Override
                public void onDynamicIntervalSkipped(
                        final AccelerometerMeasurementsGenerator generator) {
                    // no action required
<span class="fc" id="L90">                }</span>

                @Override
                public void onGeneratedMeasurement(
                        final AccelerometerMeasurementsGenerator generator,
                        final StandardDeviationBodyKinematics measurement) {
<span class="pc bpc" id="L96" title="1 of 2 branches missed.">                    if (mListener != null) {</span>
<span class="fc" id="L97">                        mListener.onGeneratedAccelerometerMeasurement(</span>
                                AccelerometerGyroscopeAndMagnetometerMeasurementsGenerator.this,
                                measurement);
                    }
<span class="fc" id="L101">                }</span>

                @Override
                public void onReset(
                        final AccelerometerMeasurementsGenerator generator) {
                    // no action required
<span class="fc" id="L107">                }</span>
            };

    /**
     * Listener for internal gyroscope measurements generator.
     */
<span class="fc" id="L113">    private final GyroscopeMeasurementGeneratorListener mGyroscopeListener =</span>
<span class="fc" id="L114">            new GyroscopeMeasurementGeneratorListener() {</span>
                @Override
                public void onInitializationStarted(
                        final GyroscopeMeasurementsGenerator generator) {
                    // no action required
<span class="fc" id="L119">                }</span>

                @Override
                public void onInitializationCompleted(
                        final GyroscopeMeasurementsGenerator generator,
                        final double baseNoiseLevel) {
                    // no action required
<span class="fc" id="L126">                }</span>

                @Override
                public void onError(
                        final GyroscopeMeasurementsGenerator generator,
                        final TriadStaticIntervalDetector.ErrorReason reason) {
                    // no action required
<span class="fc" id="L133">                }</span>

                @Override
                public void onStaticIntervalDetected(
                        final GyroscopeMeasurementsGenerator generator) {
                    // no action required
<span class="fc" id="L139">                }</span>

                @Override
                public void onDynamicIntervalDetected(
                        final GyroscopeMeasurementsGenerator generator) {
                    // no action required
<span class="fc" id="L145">                }</span>

                @Override
                public void onStaticIntervalSkipped(
                        final GyroscopeMeasurementsGenerator generator) {
                    // no action required
<span class="fc" id="L151">                }</span>

                @Override
                public void onDynamicIntervalSkipped(
                        final GyroscopeMeasurementsGenerator generator) {
                    // no action required
<span class="fc" id="L157">                }</span>

                @Override
                public void onGeneratedMeasurement(
                        final GyroscopeMeasurementsGenerator generator,
                        final BodyKinematicsSequence&lt;StandardDeviationTimedBodyKinematics&gt; measurement) {
<span class="pc bpc" id="L163" title="1 of 2 branches missed.">                    if (mListener != null) {</span>
<span class="fc" id="L164">                        mListener.onGeneratedGyroscopeMeasurement(</span>
                                AccelerometerGyroscopeAndMagnetometerMeasurementsGenerator.this,
                                measurement);
                    }
<span class="fc" id="L168">                }</span>

                @Override
                public void onReset(
                        final GyroscopeMeasurementsGenerator generator) {
                    // no action required
<span class="fc" id="L174">                }</span>
            };

    /**
     * Listener for internal magnetometer measurements generator.
     */
<span class="fc" id="L180">    private final MagnetometerMeasurementsGeneratorListener mMagnetometerListener =</span>
<span class="fc" id="L181">            new MagnetometerMeasurementsGeneratorListener() {</span>
        @Override
        public void onInitializationStarted(
                final MagnetometerMeasurementsGenerator generator) {
<span class="pc bpc" id="L185" title="1 of 2 branches missed.">            if (mListener != null) {</span>
<span class="fc" id="L186">                mListener.onInitializationStarted(</span>
                        AccelerometerGyroscopeAndMagnetometerMeasurementsGenerator.this);
            }
<span class="fc" id="L189">        }</span>

        @Override
        public void onInitializationCompleted(
                final MagnetometerMeasurementsGenerator generator,
                final double baseNoiseLevel) {
<span class="pc bpc" id="L195" title="1 of 2 branches missed.">            if (mListener != null) {</span>
<span class="fc" id="L196">                mListener.onInitializationCompleted(</span>
                        AccelerometerGyroscopeAndMagnetometerMeasurementsGenerator.this,
                        baseNoiseLevel);
            }
<span class="fc" id="L200">        }</span>

        @Override
        public void onError(
                final MagnetometerMeasurementsGenerator generator,
                final TriadStaticIntervalDetector.ErrorReason reason) {
            // no action required
<span class="fc" id="L207">        }</span>

        @Override
        public void onStaticIntervalDetected(
                final MagnetometerMeasurementsGenerator generator) {
<span class="pc bpc" id="L212" title="1 of 2 branches missed.">            if (mListener != null) {</span>
<span class="fc" id="L213">                mListener.onStaticIntervalDetected(</span>
                        AccelerometerGyroscopeAndMagnetometerMeasurementsGenerator.this);
            }
<span class="fc" id="L216">        }</span>

        @Override
        public void onDynamicIntervalDetected(
                final MagnetometerMeasurementsGenerator generator) {
<span class="pc bpc" id="L221" title="1 of 2 branches missed.">            if (mListener != null) {</span>
<span class="fc" id="L222">                mListener.onDynamicIntervalDetected(</span>
                        AccelerometerGyroscopeAndMagnetometerMeasurementsGenerator.this);
            }
<span class="fc" id="L225">        }</span>

        @Override
        public void onStaticIntervalSkipped(
                final MagnetometerMeasurementsGenerator generator) {
<span class="pc bpc" id="L230" title="1 of 2 branches missed.">            if (mListener != null) {</span>
<span class="fc" id="L231">                mListener.onStaticIntervalSkipped(</span>
                        AccelerometerGyroscopeAndMagnetometerMeasurementsGenerator.this);
            }
<span class="fc" id="L234">        }</span>

        @Override
        public void onDynamicIntervalSkipped(
                final MagnetometerMeasurementsGenerator generator) {
<span class="pc bpc" id="L239" title="1 of 2 branches missed.">            if (mListener != null) {</span>
<span class="fc" id="L240">                mListener.onDynamicIntervalSkipped(</span>
                        AccelerometerGyroscopeAndMagnetometerMeasurementsGenerator.this);
            }
<span class="fc" id="L243">        }</span>

        @Override
        public void onGeneratedMeasurement(
                final MagnetometerMeasurementsGenerator generator,
                final StandardDeviationBodyMagneticFluxDensity measurement) {
<span class="pc bpc" id="L249" title="1 of 2 branches missed.">            if (mListener != null) {</span>
<span class="fc" id="L250">                mListener.onGeneratedMagnetometerMeasurement(</span>
                        AccelerometerGyroscopeAndMagnetometerMeasurementsGenerator.this,
                        measurement);
            }
<span class="fc" id="L254">        }</span>

        @Override
        public void onReset(
                final MagnetometerMeasurementsGenerator generator) {
            // no action required
<span class="fc" id="L260">        }</span>
    };

    /**
     * Internal accelerometer measurements generator.
     */
<span class="fc" id="L266">    private final AccelerometerMeasurementsGenerator mAccelerometerMeasurementsGenerator =</span>
            new AccelerometerMeasurementsGenerator(mAccelerometerListener);

    /**
     * Internal gyroscope measurements generator.
     */
<span class="fc" id="L272">    private final GyroscopeMeasurementsGenerator mGyroscopeMeasurementsGenerator =</span>
            new GyroscopeMeasurementsGenerator(mGyroscopeListener);

    /**
     * Internal magnetometer measurements generator.
     */
<span class="fc" id="L278">    private final MagnetometerMeasurementsGenerator mMagnetometerMeasurementsGenerator =</span>
            new MagnetometerMeasurementsGenerator(mMagnetometerListener);

    /**
     * Indicates whether generator is running or not.
     */
    private boolean mRunning;

    /**
     * Timed body kinematics instance to be reused.
     */
<span class="fc" id="L289">    private final TimedBodyKinematics mTimedKinematics = new TimedBodyKinematics();</span>

    /**
     * Constructor.
     */
<span class="fc" id="L294">    public AccelerometerGyroscopeAndMagnetometerMeasurementsGenerator() {</span>
<span class="fc" id="L295">    }</span>

    /**
     * Constructor.
     *
     * @param listener listener to handle events raised by this generator.
     */
    public AccelerometerGyroscopeAndMagnetometerMeasurementsGenerator(
            final AccelerometerGyroscopeAndMagnetometerMeasurementsGeneratorListener listener) {
<span class="fc" id="L304">        this();</span>
<span class="fc" id="L305">        mListener = listener;</span>
<span class="fc" id="L306">    }</span>

    /**
     * Gets minimum number of samples required in a static interval to be taken into account.
     * Smaller static intervals will be discarded.
     *
     * @return minimum number of samples required in a static interval to be taken into account.
     */
    public int getMinStaticSamples() {
<span class="fc" id="L315">        return mAccelerometerMeasurementsGenerator.getMinStaticSamples();</span>
    }

    /**
     * Sets minimum number of samples required in a static interval to be taken into account.
     * Smaller static intervals will be discarded.
     *
     * @param minStaticSamples minimum number of samples required in a static interval to be
     *                         taken into account.
     * @throws LockedException          if generator is busy.
     * @throws IllegalArgumentException if provided value is less than 2.
     */
    public void setMinStaticSamples(final int minStaticSamples) throws LockedException {
<span class="fc bfc" id="L328" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L329">            throw new LockedException();</span>
        }

<span class="fc" id="L332">        mAccelerometerMeasurementsGenerator.setMinStaticSamples(minStaticSamples);</span>
<span class="fc" id="L333">        mGyroscopeMeasurementsGenerator.setMinStaticSamples(minStaticSamples);</span>
<span class="fc" id="L334">        mMagnetometerMeasurementsGenerator.setMinStaticSamples(minStaticSamples);</span>
<span class="fc" id="L335">    }</span>

    /**
     * Gets maximum number of samples allowed in dynamic intervals.
     *
     * @return maximum number of samples allowed in dynamic intervals.
     */
    public int getMaxDynamicSamples() {
<span class="fc" id="L343">        return mAccelerometerMeasurementsGenerator.getMaxDynamicSamples();</span>
    }

    /**
     * Sets maximum number of samples allowed in dynamic intervals.
     *
     * @param maxDynamicSamples maximum number of samples allowed in dynamic intervals.
     * @throws LockedException          if generator is busy.
     * @throws IllegalArgumentException if provided value is less than 2.
     */
    public void setMaxDynamicSamples(final int maxDynamicSamples) throws LockedException {
<span class="fc bfc" id="L354" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L355">            throw new LockedException();</span>
        }

<span class="fc" id="L358">        mAccelerometerMeasurementsGenerator.setMaxDynamicSamples(maxDynamicSamples);</span>
<span class="fc" id="L359">        mGyroscopeMeasurementsGenerator.setMaxDynamicSamples(maxDynamicSamples);</span>
<span class="fc" id="L360">        mMagnetometerMeasurementsGenerator.setMaxDynamicSamples(maxDynamicSamples);</span>
<span class="fc" id="L361">    }</span>

    /**
     * Gets listener to handle generated events.
     *
     * @return listener to handle generated events.
     */
    public AccelerometerGyroscopeAndMagnetometerMeasurementsGeneratorListener getListener() {
<span class="fc" id="L369">        return mListener;</span>
    }

    /**
     * Sets listener to handle generated events.
     *
     * @param listener listener to handle generated evets.
     * @throws LockedException if generator is busy.
     */
    public void setListener(final AccelerometerGyroscopeAndMagnetometerMeasurementsGeneratorListener listener)
            throws LockedException {
<span class="fc bfc" id="L380" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L381">            throw new LockedException();</span>
        }

<span class="fc" id="L384">        mListener = listener;</span>
<span class="fc" id="L385">    }</span>

    /**
     * Gets length of number of samples to keep within the window being processed
     * to determine instantaneous accelerometer noise level.
     *
     * @return length of number of samples to keep within the window.
     */
    public int getWindowSize() {
<span class="fc" id="L394">        return mAccelerometerMeasurementsGenerator.getWindowSize();</span>
    }

    /**
     * Sets length of number of samples to keep within the window being processed
     * to determine instantaneous accelerometer noise level.
     * Window size must always be larger than allowed minimum value, which is 2 and
     * must have an odd value.
     *
     * @param windowSize length of number of samples to keep within the window.
     * @throws LockedException          if detector is busy processing a previous sample.
     * @throws IllegalArgumentException if provided value is not valid.
     */
    public void setWindowSize(final int windowSize) throws LockedException {
<span class="fc bfc" id="L408" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L409">            throw new LockedException();</span>
        }

<span class="fc" id="L412">        mAccelerometerMeasurementsGenerator.setWindowSize(windowSize);</span>
<span class="fc" id="L413">        mGyroscopeMeasurementsGenerator.setWindowSize(windowSize);</span>
<span class="fc" id="L414">        mMagnetometerMeasurementsGenerator.setWindowSize(windowSize);</span>
<span class="fc" id="L415">    }</span>

    /**
     * Gets number of samples to be processed initially while keeping the sensor static in order
     * to find the base noise level when device is static.
     *
     * @return number of samples to be processed initially.
     */
    public int getInitialStaticSamples() {
<span class="fc" id="L424">        return mAccelerometerMeasurementsGenerator.getInitialStaticSamples();</span>
    }

    /**
     * Sets number of samples to be processed initially while keeping the sensor static in order
     * to find the base noise level when device is static.
     *
     * @param initialStaticSamples number of samples to be processed initially.
     * @throws LockedException          if detector is busy.
     * @throws IllegalArgumentException if provided value is less than
     *                                  {@link TriadStaticIntervalDetector#MINIMUM_INITIAL_STATIC_SAMPLES}
     */
    public void setInitialStaticSamples(final int initialStaticSamples)
            throws LockedException {
<span class="fc bfc" id="L438" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L439">            throw new LockedException();</span>
        }

<span class="fc" id="L442">        mAccelerometerMeasurementsGenerator.setInitialStaticSamples(initialStaticSamples);</span>
<span class="fc" id="L443">        mGyroscopeMeasurementsGenerator.setInitialStaticSamples(initialStaticSamples);</span>
<span class="fc" id="L444">        mMagnetometerMeasurementsGenerator.setInitialStaticSamples(initialStaticSamples);</span>
<span class="fc" id="L445">    }</span>

    /**
     * Gets factor to be applied to detected base noise level in order to
     * determine threshold for static/dynamic period changes. This factor is
     * unit-less.
     *
     * @return factor to be applied to detected base noise level.
     */
    public double getThresholdFactor() {
<span class="fc" id="L455">        return mAccelerometerMeasurementsGenerator.getThresholdFactor();</span>
    }

    /**
     * Sets factor to be applied to detected base noise level in order to
     * determine threshold for static/dynamic period changes. This factor is
     * unit-less.
     *
     * @param thresholdFactor factor to be applied to detected base noise level.
     * @throws LockedException          if detector is busy.
     * @throws IllegalArgumentException if provided value is zero or negative.
     */
    public void setThresholdFactor(final double thresholdFactor)
            throws LockedException {
<span class="fc bfc" id="L469" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L470">            throw new LockedException();</span>
        }

<span class="fc" id="L473">        mAccelerometerMeasurementsGenerator.setThresholdFactor(thresholdFactor);</span>
<span class="fc" id="L474">        mGyroscopeMeasurementsGenerator.setThresholdFactor(thresholdFactor);</span>
<span class="fc" id="L475">        mMagnetometerMeasurementsGenerator.setThresholdFactor(thresholdFactor);</span>
<span class="fc" id="L476">    }</span>

    /**
     * Gets factor to determine that a sudden movement has occurred during
     * initialization if instantaneous noise level exceeds accumulated noise
     * level by this factor amount.
     * This factor is unit-less.
     *
     * @return factor to determine that a sudden movement has occurred.
     */
    public double getInstantaneousNoiseLevelFactor() {
<span class="fc" id="L487">        return mAccelerometerMeasurementsGenerator.getInstantaneousNoiseLevelFactor();</span>
    }

    /**
     * Sets factor to determine that a sudden movement has occurred during
     * initialization if instantaneous noise level exceeds accumulated noise
     * level by this factor amount.
     * This factor is unit-less.
     *
     * @param instantaneousNoiseLevelFactor factor to determine that a sudden
     *                                      movement has occurred during
     *                                      initialization.
     * @throws LockedException          if detector is busy.
     * @throws IllegalArgumentException if provided value is zero or negative.
     */
    public void setInstantaneousNoiseLevelFactor(
            final double instantaneousNoiseLevelFactor) throws LockedException {
<span class="fc bfc" id="L504" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L505">            throw new LockedException();</span>
        }

<span class="fc" id="L508">        mAccelerometerMeasurementsGenerator.setInstantaneousNoiseLevelFactor(</span>
                instantaneousNoiseLevelFactor);
<span class="fc" id="L510">        mGyroscopeMeasurementsGenerator.setInstantaneousNoiseLevelFactor(</span>
                instantaneousNoiseLevelFactor);
<span class="fc" id="L512">        mMagnetometerMeasurementsGenerator.setInstantaneousNoiseLevelFactor(</span>
                instantaneousNoiseLevelFactor);
<span class="fc" id="L514">    }</span>

    /**
     * Gets overall absolute threshold to determine whether there has been
     * excessive motion during the whole initialization phase.
     * Failure will be detected if estimated base noise level exceeds this
     * threshold when initialization completes.
     * This threshold is expressed in meters per squared second (m/s^2).
     *
     * @return overall absolute threshold to determine whether there has
     * been excessive motion.
     */
    public double getBaseNoiseLevelAbsoluteThreshold() {
<span class="fc" id="L527">        return mAccelerometerMeasurementsGenerator.getBaseNoiseLevelAbsoluteThreshold();</span>
    }

    /**
     * Sets overall absolute threshold to determine whether there has been
     * excessive motion during the whole initialization phase.
     * Failure will be detected if estimated base noise level exceeds this
     * threshold when initialization completes.
     * This threshold is expressed in meters per squared second (m/s^2).
     *
     * @param baseNoiseLevelAbsoluteThreshold overall absolute threshold to
     *                                        determine whether there has been
     *                                        excessive motion.
     * @throws LockedException          if detector is busy.
     * @throws IllegalArgumentException if provided value is zero or negative.
     */
    public void setBaseNoiseLevelAbsoluteThreshold(
            final double baseNoiseLevelAbsoluteThreshold) throws LockedException {
<span class="fc bfc" id="L545" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L546">            throw new LockedException();</span>
        }

<span class="fc" id="L549">        mAccelerometerMeasurementsGenerator.setBaseNoiseLevelAbsoluteThreshold(</span>
                baseNoiseLevelAbsoluteThreshold);
<span class="fc" id="L551">        mGyroscopeMeasurementsGenerator.setBaseNoiseLevelAbsoluteThreshold(</span>
                baseNoiseLevelAbsoluteThreshold);
<span class="fc" id="L553">        mMagnetometerMeasurementsGenerator.setBaseNoiseLevelAbsoluteThreshold(</span>
                baseNoiseLevelAbsoluteThreshold);
<span class="fc" id="L555">    }</span>

    /**
     * Gets overall absolute threshold to determine whether there has been
     * excessive motion during the whole initialization phase.
     * Failure will be detected if estimated base noise level exceeds this
     * threshold when initialization completes.
     *
     * @return overall absolute threshold to determine whether there has been
     * excessive motion.
     */
    public Acceleration getBaseNoiseLevelAbsoluteThresholdAsMeasurement() {
<span class="fc" id="L567">        return mAccelerometerMeasurementsGenerator.getBaseNoiseLevelAbsoluteThresholdAsMeasurement();</span>
    }

    /**
     * Gets overall absolute threshold to determine whether there has been
     * excessive motion during the whole initialization phase.
     * Failure will be detected if estimated base noise level exceeds this
     * threshold when initialization completes.
     *
     * @param result instance where result will be stored.
     */
    public void getBaseNoiseLevelAbsoluteThresholdAsMeasurement(
            final Acceleration result) {
<span class="fc" id="L580">        mAccelerometerMeasurementsGenerator.getBaseNoiseLevelAbsoluteThresholdAsMeasurement(</span>
                result);
<span class="fc" id="L582">    }</span>

    /**
     * Sets overall absolute threshold to determine whether there has been
     * excessive motion during the whole initialization phase.
     * Failure will be detected if estimated base noise level exceeds this
     * threshold when initialization completes.
     *
     * @param baseNoiseLevelAbsoluteThreshold overall absolute threshold to
     *                                        determine whether there has been
     *                                        excessive motion.
     * @throws LockedException          if detector is busy.
     * @throws IllegalArgumentException if provided value is zero or negative.
     */
    public void setBaseNoiseLevelAbsoluteThreshold(
            final Acceleration baseNoiseLevelAbsoluteThreshold) throws LockedException {
<span class="fc bfc" id="L598" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L599">            throw new LockedException();</span>
        }

<span class="fc" id="L602">        mAccelerometerMeasurementsGenerator.setBaseNoiseLevelAbsoluteThreshold(</span>
                baseNoiseLevelAbsoluteThreshold);
<span class="fc" id="L604">        mGyroscopeMeasurementsGenerator.setBaseNoiseLevelAbsoluteThreshold(</span>
                baseNoiseLevelAbsoluteThreshold);
<span class="fc" id="L606">        mMagnetometerMeasurementsGenerator.setBaseNoiseLevelAbsoluteThreshold(</span>
                baseNoiseLevelAbsoluteThreshold);
<span class="fc" id="L608">    }</span>

    /**
     * Gets internal status of this generator.
     *
     * @return internal status of this generator.
     */
    public TriadStaticIntervalDetector.Status getStatus() {
<span class="fc" id="L616">        return mAccelerometerMeasurementsGenerator.getStatus();</span>
    }

    /**
     * Gets accelerometer base noise level that has been detected during
     * initialization expressed in meters per squared second (m/s^2).
     * This is equal to the standard deviation of the accelerometer measurements
     * during initialization phase.
     *
     * @return accelerometer base noise level.
     */
    public double getAccelerometerBaseNoiseLevel() {
<span class="fc" id="L628">        return mAccelerometerMeasurementsGenerator.getBaseNoiseLevel();</span>
    }

    /**
     * Gets accelerometer base noise level that has been detected during
     * initialization.
     * This is equal to the standard deviation of the accelerometer measurements
     * during initialization phase.
     *
     * @return measurement base noise level.
     */
    public Acceleration getAccelerometerBaseNoiseLevelAsMeasurement() {
<span class="fc" id="L640">        return mAccelerometerMeasurementsGenerator.getBaseNoiseLevelAsMeasurement();</span>
    }

    /**
     * Gets accelerometer base noise level that has been detected during
     * initialization.
     *
     * @param result instance where result will be stored.
     */
    public void getAccelerometerBaseNoiseLevelAsMeasurement(final Acceleration result) {
<span class="fc" id="L650">        mAccelerometerMeasurementsGenerator.getBaseNoiseLevelAsMeasurement(result);</span>
<span class="fc" id="L651">    }</span>

    /**
     * Gets threshold to determine static/dynamic period changes expressed in
     * meters per squared second (m/s^2).
     *
     * @return threshold to determine static/dynamic period changes.
     */
    public double getThreshold() {
<span class="fc" id="L660">        return mAccelerometerMeasurementsGenerator.getThreshold();</span>
    }

    /**
     * Gets threshold to determine static/dynamic period changes.
     *
     * @return threshold to determine static/dynamic period changes.
     */
    public Acceleration getThresholdAsMeasurement() {
<span class="fc" id="L669">        return mAccelerometerMeasurementsGenerator.getThresholdAsMeasurement();</span>
    }

    /**
     * Gets threshold to determine static/dynamic period changes.
     *
     * @param result instance where result will be stored.
     */
    public void getThresholdAsMeasurement(final Acceleration result) {
<span class="fc" id="L678">        mAccelerometerMeasurementsGenerator.getThresholdAsMeasurement(result);</span>
<span class="fc" id="L679">    }</span>

    /**
     * Gets number of samples that have been processed in a static period so far.
     *
     * @return number of samples that have been processed in a static period so far.
     */
    public int getProcessedStaticSamples() {
<span class="fc" id="L687">        return mAccelerometerMeasurementsGenerator.getProcessedStaticSamples();</span>
    }

    /**
     * Gets number of samples that have been processed in a dynamic period so far.
     *
     * @return number of samples that have been processed in a dynamic period so far.
     */
    public int getProcessedDynamicSamples() {
<span class="fc" id="L696">        return mAccelerometerMeasurementsGenerator.getProcessedDynamicSamples();</span>
    }

    /**
     * Indicates whether last static interval must be skipped.
     *
     * @return true if last static interval must be skipped.
     */
    public boolean isStaticIntervalSkipped() {
<span class="fc" id="L705">        return mAccelerometerMeasurementsGenerator.isStaticIntervalSkipped();</span>
    }

    /**
     * Indicates whether last dynamic interval must be skipped.
     *
     * @return true if last dynamic interval must be skipped.
     */
    public boolean isDynamicIntervalSkipped() {
<span class="fc" id="L714">        return mAccelerometerMeasurementsGenerator.isDynamicIntervalSkipped();</span>
    }

    /**
     * Indicates whether generator is running or not.
     *
     * @return true if generator is running, false otherwise.
     */
    public boolean isRunning() {
<span class="fc" id="L723">        return mRunning;</span>
    }

    /**
     * Processes a sample of data.
     *
     * @param sample sample of data to be processed.
     * @return true if provided samples has been processed, false if provided triad has been skipped because
     * generator previously failed. If generator previously failed, it will need to be reset before
     * processing additional samples.
     * @throws LockedException if generator is busy processing a previous sample.
     */
    public boolean process(final TimedBodyKinematicsAndMagneticFluxDensity sample) throws LockedException {
<span class="fc bfc" id="L736" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L737">            throw new LockedException();</span>
        }

        try {
<span class="fc" id="L741">            mRunning = true;</span>

<span class="fc" id="L743">            sample.getTimedKinematics(mTimedKinematics);</span>

<span class="fc bfc" id="L745" title="All 2 branches covered.">            return mAccelerometerMeasurementsGenerator.process(sample.getKinematics())</span>
<span class="pc bpc" id="L746" title="1 of 2 branches missed.">                    &amp;&amp; mGyroscopeMeasurementsGenerator.process(mTimedKinematics)</span>
<span class="pc bpc" id="L747" title="1 of 2 branches missed.">                    &amp;&amp; mMagnetometerMeasurementsGenerator.process(sample);</span>
        } finally {
<span class="fc" id="L749">            mRunning = false;</span>
        }
    }

    /**
     * Resets this generator.
     *
     * @throws LockedException if generator is busy.
     */
    public void reset() throws LockedException {
<span class="fc bfc" id="L759" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L760">            throw new LockedException();</span>
        }

<span class="fc" id="L763">        mAccelerometerMeasurementsGenerator.reset();</span>
<span class="fc" id="L764">        mGyroscopeMeasurementsGenerator.reset();</span>
<span class="fc" id="L765">        mMagnetometerMeasurementsGenerator.reset();</span>

<span class="pc bpc" id="L767" title="1 of 2 branches missed.">        if (mListener != null) {</span>
<span class="fc" id="L768">            mListener.onReset(this);</span>
        }
<span class="fc" id="L770">    }</span>

    /**
     * Gets estimated average angular rate during initialization phase.
     *
     * @return estimated average angular rate during initialization phase.
     */
    public AngularSpeedTriad getInitialAvgAngularSpeedTriad() {
<span class="fc" id="L778">        return mGyroscopeMeasurementsGenerator.getInitialAvgAngularSpeedTriad();</span>
    }

    /**
     * Gets estimated average angular rate during initialization phase.
     *
     * @param result instance where result will be stored.
     */
    public void getInitialAvgAngularSpeedTriad(final AngularSpeedTriad result) {
<span class="fc" id="L787">        mGyroscopeMeasurementsGenerator.getInitialAvgAngularSpeedTriad(result);</span>
<span class="fc" id="L788">    }</span>

    /**
     * Gets estimated standard deviation of angular rate during initialization phase.
     *
     * @return estimated standard deviation of angular rate during initialization phase.
     */
    public AngularSpeedTriad getInitialAngularSpeedTriadStandardDeviation() {
<span class="fc" id="L796">        return mGyroscopeMeasurementsGenerator.getInitialAngularSpeedTriadStandardDeviation();</span>
    }

    /**
     * Gets estimated standard deviation of angular rate during initialization phase.
     *
     * @param result instance where result will be stored.
     */
    public void getInitialAngularSpeedTriadStandardDeviation(final AngularSpeedTriad result) {
<span class="fc" id="L805">        mGyroscopeMeasurementsGenerator.getInitialAngularSpeedTriadStandardDeviation(result);</span>
<span class="fc" id="L806">    }</span>

    /**
     * Gets norm of estimated standard deviation of angular rate during initialization phase
     * expressed in radians per second (rad/s).
     *
     * @return norm of estimated standard deviation of angular rate during initialization phase.
     */
    public double getInitialAngularSpeedTriadStandardDeviationNorm() {
<span class="fc" id="L815">        return mGyroscopeMeasurementsGenerator.getInitialAngularSpeedTriadStandardDeviationNorm();</span>
    }

    /**
     * Gets norm of estimated standard deviation of angular rate during initialization phase.
     *
     * @return norm of estimated standard deviation of angular rate during initialization phase.
     */
    public AngularSpeed getInitialAngularSpeedTriadStandardDeviationNormAsMeasurement() {
<span class="fc" id="L824">        return mGyroscopeMeasurementsGenerator.getInitialAngularSpeedTriadStandardDeviationNormAsMeasurement();</span>
    }

    /**
     * Gets norm of estimated standard deviation of angular rate during initialization phase.
     *
     * @param result instance where result will be stored.
     */
    public void getInitialAngularSpeedTriadStandardDeviationNormAsMeasurement(
            final AngularSpeed result) {
<span class="fc" id="L834">        mGyroscopeMeasurementsGenerator.getInitialAngularSpeedTriadStandardDeviationNormAsMeasurement(</span>
                result);
<span class="fc" id="L836">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>