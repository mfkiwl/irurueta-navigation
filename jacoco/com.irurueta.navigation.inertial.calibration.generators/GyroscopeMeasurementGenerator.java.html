<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GyroscopeMeasurementGenerator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.irurueta:irurueta-navigation</a> &gt; <a href="index.source.html" class="el_package">com.irurueta.navigation.inertial.calibration.generators</a> &gt; <span class="el_source">GyroscopeMeasurementGenerator.java</span></div><h1>GyroscopeMeasurementGenerator.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2020 Alberto Irurueta Carro (alberto@irurueta.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.irurueta.navigation.inertial.calibration.generators;

import com.irurueta.navigation.LockedException;
import com.irurueta.navigation.inertial.BodyKinematics;
import com.irurueta.navigation.inertial.calibration.AngularSpeedTriad;
import com.irurueta.navigation.inertial.calibration.BodyKinematicsSequence;
import com.irurueta.navigation.inertial.calibration.StandardDeviationTimedBodyKinematics;
import com.irurueta.navigation.inertial.calibration.TimedBodyKinematics;
import com.irurueta.navigation.inertial.calibration.intervals.AccelerationTriadStaticIntervalDetector;
import com.irurueta.navigation.inertial.calibration.intervals.TriadStaticIntervalDetector;
import com.irurueta.navigation.inertial.calibration.noise.AccumulatedAngularSpeedTriadNoiseEstimator;

import java.util.ArrayList;
import java.util.List;

/**
 * Generates measurements for the calibration of gyroscopes by alternating
 * static and dynamic intervals where device is kept static or moved.
 * Generated measurements must be used with easy gyroscope calibrators.
 * Notice that accuracy of the gyroscope calibration is very sensitive to the
 * accuracy of detected dynamic intervals respect the average specific forces
 * during static intervals.
 * In order to increase the accuracy, calibration should be repeated trying different
 * threshold factors {@link #getThresholdFactor()}.
 * Such calibrators are the following ones:
 * - {@link com.irurueta.navigation.inertial.calibration.gyroscope.EasyGyroscopeCalibrator}
 * - {@link com.irurueta.navigation.inertial.calibration.gyroscope.KnownBiasEasyGyroscopeCalibrator}
 * - {@link com.irurueta.navigation.inertial.calibration.gyroscope.RobustEasyGyroscopeCalibrator} and all its
 * implementations.
 * - {@link com.irurueta.navigation.inertial.calibration.gyroscope.RobustKnownBiasEasyGyroscopeCalibrator} and all its
 * implementations.
 */
public class GyroscopeMeasurementGenerator extends
        MeasurementsGenerator&lt;
                BodyKinematicsSequence&lt;StandardDeviationTimedBodyKinematics&gt;,
                GyroscopeMeasurementGenerator,
                GyroscopeMeasurementGeneratorListener, TimedBodyKinematics&gt; {

    /**
     * An angular speed triad.
     * This is reused for memory efficiency.
     */
<span class="fc" id="L59">    protected final AngularSpeedTriad mAngularSpeedTriad =</span>
            new AngularSpeedTriad();

    /**
     * Items to be added to a generated sequence when next static period occurs.
     */
    private List&lt;StandardDeviationTimedBodyKinematics&gt; mCurrentSequenceItems;

    /**
     * Accumulated noise estimator for angular speed measurements.
     */
<span class="fc" id="L70">    private final AccumulatedAngularSpeedTriadNoiseEstimator mAccumulatedEstimator =</span>
            new AccumulatedAngularSpeedTriadNoiseEstimator();

    /**
     * Estimated acceleration standard deviation during initialization expressed
     * in meters per squared second (m/s^2).
     */
    private double mAccelerationStandardDeviation;

    /**
     * Estimated angular speed standard deviation during initialization expressed
     * in radians per second (rad/s).
     */
    private double mAngularSpeedStandardDeviation;

    /**
     * Previous average x-coordinate of measurements expressed in meters
     * per squared second (m/s^2).
     */
    private Double mPreviousAvgX;

    /**
     * Previous average y-coordinate of measurements expressed in meters
     * per squared second (m/s^2).
     */
    private Double mPreviousAvgY;

    /**
     * Previous average z-coordinate of measurements expressed in meters
     * per squared second (m/s^2).
     */
    private Double mPreviousAvgZ;

    /**
     * Current average x-coordinate of measurements expressed in meters
     * per squared second (m/s^2).
     */
    private Double mCurrentAvgX;

    /**
     * Current average y-coordinate of measurements expressed in meters
     * per squared second (m/s^2).
     */
    private Double mCurrentAvgY;

    /**
     * Current average z-coordinate of measurements expressed in meters
     * per squared second (m/s^2).
     */
    private Double mCurrentAvgZ;

    /**
     * Contains previous status while processing samples.
     */
    private TriadStaticIntervalDetector.Status mPreviousStatus;

    /**
     * Constructor.
     */
    public GyroscopeMeasurementGenerator() {
<span class="fc" id="L130">        super();</span>
<span class="fc" id="L131">    }</span>

    /**
     * Constructor.
     *
     * @param listener listener to handle events raised by this generator.
     */
    public GyroscopeMeasurementGenerator(
            final GyroscopeMeasurementGeneratorListener listener) {
<span class="fc" id="L140">        super(listener);</span>
<span class="fc" id="L141">    }</span>

    /**
     * Constructor.
     *
     * @param staticIntervalDetector a static interval detector for accelerometer samples.
     * @throws LockedException if provided detector is busy.
     */
    protected GyroscopeMeasurementGenerator(
            final AccelerationTriadStaticIntervalDetector staticIntervalDetector)
            throws LockedException {
<span class="fc" id="L152">        super(staticIntervalDetector);</span>
<span class="fc" id="L153">    }</span>

    /**
     * Constructor.
     *
     * @param staticIntervalDetector a static interval detector for accelerometer samples.
     * @param listener               listener to handle events raised by this generator.
     * @throws LockedException if provided detector is busy.
     */
    protected GyroscopeMeasurementGenerator(
            final AccelerationTriadStaticIntervalDetector staticIntervalDetector,
            final GyroscopeMeasurementGeneratorListener listener)
            throws LockedException {
<span class="fc" id="L166">        super(staticIntervalDetector, listener);</span>
<span class="fc" id="L167">    }</span>

    /**
     * Resets this generator.
     *
     * @throws LockedException if generator is busy.
     */
    @Override
    public void reset() throws LockedException {
<span class="fc" id="L176">        super.reset();</span>

<span class="fc" id="L178">        mCurrentSequenceItems = null;</span>

<span class="fc" id="L180">        mAccelerationStandardDeviation = 0.0;</span>
<span class="fc" id="L181">        mAngularSpeedStandardDeviation = 0.0;</span>

<span class="fc" id="L183">        mPreviousAvgX = null;</span>
<span class="fc" id="L184">        mPreviousAvgY = null;</span>
<span class="fc" id="L185">        mPreviousAvgZ = null;</span>

<span class="fc" id="L187">        mCurrentAvgX = null;</span>
<span class="fc" id="L188">        mCurrentAvgY = null;</span>
<span class="fc" id="L189">        mCurrentAvgZ = null;</span>

<span class="fc" id="L191">        mAccumulatedEstimator.reset();</span>

<span class="fc" id="L193">        mPreviousStatus = null;</span>
<span class="fc" id="L194">    }</span>

    /**
     * Gets estimated average angular rate during initialization phase.
     *
     * @return estimated average angular rate during initialization phase.
     */
    public AngularSpeedTriad getInitialAvgAngularSpeedTriad() {
<span class="fc" id="L202">        return mAccumulatedEstimator.getAvgTriad();</span>
    }

    /**
     * Gets estimated average angular rate during initialization phase.
     *
     * @param result instance where result will be stored.
     */
    public void getInitialAvgAngularSpeedTriad(final AngularSpeedTriad result) {
<span class="fc" id="L211">        mAccumulatedEstimator.getAvgTriad(result);</span>
<span class="fc" id="L212">    }</span>

    /**
     * Post process provided input sample.
     *
     * @param sample an input sample.
     * @throws LockedException if generator is busy.
     */
    @Override
    protected void postProcess(final TimedBodyKinematics sample)
            throws LockedException {
<span class="fc" id="L223">        final TriadStaticIntervalDetector.Status status =</span>
<span class="fc" id="L224">                mStaticIntervalDetector.getStatus();</span>

<span class="fc bfc" id="L226" title="All 2 branches covered.">        if (status == TriadStaticIntervalDetector.Status.INITIALIZING) {</span>
<span class="fc" id="L227">            sample.getKinematics().getAngularRateTriad(mAngularSpeedTriad);</span>
<span class="fc" id="L228">            mAccumulatedEstimator.addTriad(mAngularSpeedTriad);</span>
        }

        // while we are in a dynamic interval, we must record all timed kinematics
        // along with accelerometer and gyroscope standard deviations
<span class="fc bfc" id="L233" title="All 2 branches covered.">        if (status == TriadStaticIntervalDetector.Status.DYNAMIC_INTERVAL) {</span>
<span class="fc bfc" id="L234" title="All 2 branches covered.">            if (isDynamicIntervalSkipped()) {</span>
                // dynamic interval has been skipped because there were too many
                // items in the sequence.
<span class="fc" id="L237">                mCurrentSequenceItems = null;</span>
            } else {
<span class="pc bpc" id="L239" title="1 of 2 branches missed.">                if (mPreviousStatus == TriadStaticIntervalDetector.Status.STATIC_INTERVAL) {</span>
<span class="fc" id="L240">                    mPreviousAvgX = mStaticIntervalDetector.getAccumulatedAvgX();</span>
<span class="fc" id="L241">                    mPreviousAvgY = mStaticIntervalDetector.getAccumulatedAvgY();</span>
<span class="fc" id="L242">                    mPreviousAvgZ = mStaticIntervalDetector.getAccumulatedAvgZ();</span>
                }

<span class="fc" id="L245">                addSequenceItem(sample);</span>
            }
<span class="fc bfc" id="L247" title="All 2 branches covered.">        } else if (status == TriadStaticIntervalDetector.Status.STATIC_INTERVAL) {</span>
<span class="pc bpc" id="L248" title="1 of 4 branches missed.">            if (mPreviousStatus == TriadStaticIntervalDetector.Status.DYNAMIC_INTERVAL</span>
<span class="pc bpc" id="L249" title="1 of 2 branches missed.">                &amp;&amp; mCurrentSequenceItems != null &amp;&amp; !mCurrentSequenceItems.isEmpty()) {</span>

<span class="fc" id="L251">                mCurrentAvgX = mStaticIntervalDetector.getInstantaneousAvgX();</span>
<span class="fc" id="L252">                mCurrentAvgY = mStaticIntervalDetector.getInstantaneousAvgY();</span>
<span class="fc" id="L253">                mCurrentAvgZ = mStaticIntervalDetector.getInstantaneousAvgZ();</span>

                // we have all required data to generate a sequence
<span class="fc" id="L256">                final BodyKinematicsSequence&lt;StandardDeviationTimedBodyKinematics&gt; sequence =</span>
                        new BodyKinematicsSequence&lt;&gt;();
<span class="fc" id="L258">                sequence.setBeforeMeanSpecificForceCoordinates(</span>
<span class="fc" id="L259">                        mPreviousAvgX, mPreviousAvgY, mPreviousAvgZ);</span>
<span class="fc" id="L260">                sequence.setItems(mCurrentSequenceItems);</span>
<span class="fc" id="L261">                sequence.setAfterMeanSpecificForceCoordinates(</span>
<span class="fc" id="L262">                        mCurrentAvgX, mCurrentAvgY, mCurrentAvgZ);</span>

<span class="fc" id="L264">                mCurrentSequenceItems = null;</span>

<span class="pc bpc" id="L266" title="1 of 2 branches missed.">                if (mListener != null) {</span>
<span class="fc" id="L267">                    mListener.onGeneratedMeasurement(this, sequence);</span>
                }
            }
        }
<span class="fc" id="L271">    }</span>

    /**
     * Gets corresponding acceleration triad from provided input sample.
     * This method must store the result into {@link #mTriad}.
     *
     * @param sample input sample.
     */
    @Override
    protected void getAccelerationTriadFromInputSample(
            final TimedBodyKinematics sample) {
<span class="fc" id="L282">        sample.getKinematics().getSpecificForceTriad(mTriad);</span>
<span class="fc" id="L283">    }</span>

    /**
     * Handles a static-to-dynamic interval change.
     *
     * @param accumulatedAvgX   average x-coordinate of measurements during last
     *                          static period expressed in meters per squared
     *                          second (m/s^2).
     * @param accumulatedAvgY   average y-coordinate of specific force during last
     *                          static period expressed in meters per squared
     *                          second (m/s^2).
     * @param accumulatedAvgZ   average z-coordinate of specific force during last
     *                          static period expressed in meters per squared
     *                          second (m/s^2).
     * @param accumulatedStdX   standard deviation of x-coordinate of measurements
     *                          during last static period expressed in meters per
     *                          squared second (m/s^2).
     * @param accumulatedStdY   standard deviation of y-coordinate of measurements
     *                          during last static period expressed in meters per
     *                          squared second (m/s^2).
     * @param accumulatedStdZ   standard deviation of z-coordinate of measurements
     *                          during last static period expressed in meters per
     *                          squared second (m/s^2).
     */
    @Override
    protected void handleStaticToDynamicChange(
            final double accumulatedAvgX,
            final double accumulatedAvgY,
            final double accumulatedAvgZ,
            final double accumulatedStdX,
            final double accumulatedStdY,
            final double accumulatedStdZ) {
<span class="fc" id="L315">        mPreviousStatus = TriadStaticIntervalDetector.Status.STATIC_INTERVAL;</span>
<span class="fc" id="L316">    }</span>

    /**
     * Handles a dynamic-to-static interval change.
     */
    @Override
    protected void handleDynamicToStaticChange() {
<span class="fc" id="L323">        mPreviousStatus = TriadStaticIntervalDetector.Status.DYNAMIC_INTERVAL;</span>
<span class="fc" id="L324">    }</span>

    /**
     * Handles an initialization completion.
     */
    @Override
    protected void handleInitializationCompleted() {
<span class="fc" id="L331">        mAccelerationStandardDeviation = mStaticIntervalDetector.getBaseNoiseLevel();</span>
<span class="fc" id="L332">        mAngularSpeedStandardDeviation = mAccumulatedEstimator.getStandardDeviationNorm();</span>

<span class="fc" id="L334">        mPreviousStatus = mStaticIntervalDetector.getStatus();</span>
<span class="fc" id="L335">    }</span>

    /**
     * Handles an error during initialization.
     */
    @Override
    protected void handleInitializationFailed() {
<span class="fc" id="L342">        mPreviousStatus = null;</span>

        try {
<span class="fc" id="L345">            mAccumulatedEstimator.reset();</span>
<span class="nc" id="L346">        } catch (final LockedException ignore) {</span>
<span class="fc" id="L347">        }</span>
<span class="fc" id="L348">    }</span>

    /**
     * Adds an item to current sequence items.
     *
     * @param sample sample to generate a sequence item from.
     */
    private void addSequenceItem(final TimedBodyKinematics sample) {
<span class="fc bfc" id="L356" title="All 2 branches covered.">        if (mCurrentSequenceItems == null) {</span>
<span class="fc" id="L357">            mCurrentSequenceItems = new ArrayList&lt;&gt;();</span>
        }

<span class="fc" id="L360">        final BodyKinematics kinematics = new BodyKinematics(</span>
<span class="fc" id="L361">                sample.getKinematics());</span>
<span class="fc" id="L362">        final double timestampSeconds = sample.getTimestampSeconds();</span>
<span class="fc" id="L363">        final StandardDeviationTimedBodyKinematics stdTimedKinematics =</span>
                new StandardDeviationTimedBodyKinematics(kinematics,
                        timestampSeconds, mAccelerationStandardDeviation,
                        mAngularSpeedStandardDeviation);
<span class="fc" id="L367">        mCurrentSequenceItems.add(stdTimedKinematics);</span>
<span class="fc" id="L368">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>