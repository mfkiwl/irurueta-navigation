<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MeasurementsGenerator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.irurueta:irurueta-navigation</a> &gt; <a href="index.source.html" class="el_package">com.irurueta.navigation.inertial.calibration.generators</a> &gt; <span class="el_source">MeasurementsGenerator.java</span></div><h1>MeasurementsGenerator.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2020 Alberto Irurueta Carro (alberto@irurueta.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.irurueta.navigation.inertial.calibration.generators;

import com.irurueta.navigation.LockedException;
import com.irurueta.navigation.inertial.calibration.AccelerationTriad;
import com.irurueta.navigation.inertial.calibration.intervals.AccelerationTriadStaticIntervalDetector;
import com.irurueta.navigation.inertial.calibration.intervals.AccelerationTriadStaticIntervalDetectorListener;
import com.irurueta.navigation.inertial.calibration.intervals.TriadStaticIntervalDetector;
import com.irurueta.navigation.inertial.calibration.noise.WindowedTriadNoiseEstimator;
import com.irurueta.units.Acceleration;

/**
 * Base class to generate measurements for the calibration of accelerometers, gyroscopes or
 * magnetometers after detection of static/dynamic intervals.
 *
 * @param &lt;T&gt; type of measurement to be generated.
 * @param &lt;G&gt; type of generator.
 * @param &lt;L&gt; type of listener.
 * @param &lt;I&gt; type of input data to be processed.
 */
public abstract class MeasurementsGenerator&lt;T, G extends MeasurementsGenerator&lt;T, G, L, I&gt;,
        L extends MeasurementsGeneratorListener&lt;T, G, L, I&gt;, I&gt; {

    /**
     * Default minimum number of samples required in a static interval to be taken into account.
     * Smaller static intervals will be discarded.
     */
    public static final int DEFAULT_MIN_STATIC_SAMPLES = 2 * TriadStaticIntervalDetector.DEFAULT_WINDOW_SIZE;

    /**
     * Default maximum number of samples allowed in dynamic intervals.
     * Larger dynamic intervals will be discarded.
     */
    public static final int DEFAULT_MAX_DYNAMIC_SAMPLES = 30 * TriadStaticIntervalDetector.DEFAULT_WINDOW_SIZE;

    /**
     * Listener to handle generated events.
     */
    protected L mListener;

    /**
     * An acceleration triad.
     * This is reused for memory efficiency.
     */
<span class="fc" id="L60">    protected final AccelerationTriad mTriad = new AccelerationTriad();</span>

    /**
     * Static/dynamic interval detector using accelerometer samples.
     */
    protected final AccelerationTriadStaticIntervalDetector mStaticIntervalDetector;

    /**
     * Indicates whether generator is running or not.
     */
    private boolean mRunning;

    /**
     * Minimum number of samples required in a static interval to be taken into account.
     * Smaller static intervals will be discarded.
     */
<span class="fc" id="L76">    private int mMinStaticSamples = DEFAULT_MIN_STATIC_SAMPLES;</span>

    /**
     * Maximum number of samples allowed in dynamic intervals.
     * Larger dynamic intervals will be discarded.
     */
<span class="fc" id="L82">    private int mMaxDynamicSamples = DEFAULT_MAX_DYNAMIC_SAMPLES;</span>

    /**
     * Number of samples that have been processed in a static period so far.
     */
    private int mProcessedStaticSamples;

    /**
     * Number of samples that have been processed in a dynamic period so far.
     */
    private int mProcessedDynamicSamples;

    /**
     * Indicates whether static interval must be skipped.
     */
    private boolean mSkipStaticInterval;

    /**
     * Indicates whether dynamic interval must be skipped.
     */
    private boolean mSkipDynamicInterval;

    /**
     * Constructor.
     */
<span class="fc" id="L107">    public MeasurementsGenerator() {</span>
<span class="fc" id="L108">        mStaticIntervalDetector = new AccelerationTriadStaticIntervalDetector();</span>
        try {
<span class="fc" id="L110">            setupListener();</span>
<span class="nc" id="L111">        } catch (final LockedException ignore) {</span>
<span class="fc" id="L112">        }</span>
<span class="fc" id="L113">    }</span>

    /**
     * Constructor.
     *
     * @param listener listener to handle events raised by this generator.
     */
    public MeasurementsGenerator(final L listener) {
<span class="fc" id="L121">        this();</span>
<span class="fc" id="L122">        mListener = listener;</span>
<span class="fc" id="L123">    }</span>

    /**
     * Gets minimum number of samples required in a static interval to be taken into account.
     * Smaller static intervals will be discarded.
     *
     * @return minimum number of samples required in a static interval to be taken into account.
     */
    public int getMinStaticSamples() {
<span class="fc" id="L132">        return mMinStaticSamples;</span>
    }

    /**
     * Sets minimum number of samples required in a static interval to be taken into account.
     * Smaller static intervals will be discarded.
     *
     * @param minStaticSamples minimum number of samples required in a static interval to be
     *                         taken into account.
     * @throws LockedException          if generator is busy.
     * @throws IllegalArgumentException if provided value is less than 2.
     */
    public void setMinStaticSamples(final int minStaticSamples) throws LockedException {
<span class="fc bfc" id="L145" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L146">            throw new LockedException();</span>
        }

<span class="fc bfc" id="L149" title="All 2 branches covered.">        if (minStaticSamples &lt; WindowedTriadNoiseEstimator.MIN_WINDOW_SIZE) {</span>
<span class="fc" id="L150">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L153">        mMinStaticSamples = minStaticSamples;</span>
<span class="fc" id="L154">    }</span>

    /**
     * Gets maximum number of samples allowed in dynamic intervals.
     *
     * @return maximum number of samples allowed in dynamic intervals.
     */
    public int getMaxDynamicSamples() {
<span class="fc" id="L162">        return mMaxDynamicSamples;</span>
    }

    /**
     * Sets maximum number of samples allowed in dynamic intervals.
     *
     * @param maxDynamicSamples maximum number of samples allowed in dynamic intervals.
     * @throws LockedException          if generator is busy.
     * @throws IllegalArgumentException if provided value is less than 2.
     */
    public void setMaxDynamicSamples(final int maxDynamicSamples) throws LockedException {
<span class="fc bfc" id="L173" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L174">            throw new LockedException();</span>
        }

<span class="fc bfc" id="L177" title="All 2 branches covered.">        if (maxDynamicSamples &lt; WindowedTriadNoiseEstimator.MIN_WINDOW_SIZE) {</span>
<span class="fc" id="L178">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L181">        mMaxDynamicSamples = maxDynamicSamples;</span>
<span class="fc" id="L182">    }</span>

    /**
     * Gets listener to handle generated events.
     *
     * @return listener to handle generated events.
     */
    public L getListener() {
<span class="fc" id="L190">        return mListener;</span>
    }

    /**
     * Sets listener to handle generated events.
     *
     * @param listener listener to handle generated evets.
     * @throws LockedException if generator is busy.
     */
    public void setListener(final L listener) throws LockedException {
<span class="fc bfc" id="L200" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L201">            throw new LockedException();</span>
        }

<span class="fc" id="L204">        mListener = listener;</span>
<span class="fc" id="L205">    }</span>

    /**
     * Gets length of number of samples to keep within the window being processed
     * to determine instantaneous accelerometer noise level.
     *
     * @return length of number of samples to keep within the window.
     */
    public int getWindowSize() {
<span class="fc" id="L214">        return mStaticIntervalDetector.getWindowSize();</span>
    }

    /**
     * Sets length of number of samples to keep within the window being processed
     * to determine instantaneous accelerometer noise level.
     * Window size must always be larger than allowed minimum value, which is 2 and
     * must have an odd value.
     *
     * @param windowSize length of number of samples to keep within the window.
     * @throws LockedException          if detector is busy processing a previous sample.
     * @throws IllegalArgumentException if provided value is not valid.
     */
    public void setWindowSize(final int windowSize) throws LockedException {
<span class="fc bfc" id="L228" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L229">            throw new LockedException();</span>
        }

<span class="fc" id="L232">        mStaticIntervalDetector.setWindowSize(windowSize);</span>
<span class="fc" id="L233">    }</span>

    /**
     * Gets number of samples to be processed initially while keeping the sensor static in order
     * to find the base noise level when device is static.
     *
     * @return number of samples to be processed initially.
     */
    public int getInitialStaticSamples() {
<span class="fc" id="L242">        return mStaticIntervalDetector.getInitialStaticSamples();</span>
    }

    /**
     * Sets number of samples to be processed initially while keeping the sensor static in order
     * to find the base noise level when device is static.
     *
     * @param initialStaticSamples number of samples to be processed initially.
     * @throws LockedException          if detector is busy.
     * @throws IllegalArgumentException if provided value is less than
     *                                  {@link TriadStaticIntervalDetector#MINIMUM_INITIAL_STATIC_SAMPLES}
     */
    public void setInitialStaticSamples(final int initialStaticSamples)
            throws LockedException {
<span class="fc bfc" id="L256" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L257">            throw new LockedException();</span>
        }

<span class="fc" id="L260">        mStaticIntervalDetector.setInitialStaticSamples(initialStaticSamples);</span>
<span class="fc" id="L261">    }</span>

    /**
     * Gets factor to be applied to detected base noise level in order to
     * determine threshold for static/dynamic period changes. This factor is
     * unit-less.
     *
     * @return factor to be applied to detected base noise level.
     */
    public double getThresholdFactor() {
<span class="fc" id="L271">        return mStaticIntervalDetector.getThresholdFactor();</span>
    }

    /**
     * Sets factor to be applied to detected base noise level in order to
     * determine threshold for static/dynamic period changes. This factor is
     * unit-less.
     *
     * @param thresholdFactor factor to be applied to detected base noise level.
     * @throws LockedException          if detector is busy.
     * @throws IllegalArgumentException if provided value is zero or negative.
     */
    public void setThresholdFactor(final double thresholdFactor)
            throws LockedException {
<span class="fc bfc" id="L285" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L286">            throw new LockedException();</span>
        }

<span class="fc" id="L289">        mStaticIntervalDetector.setThresholdFactor(thresholdFactor);</span>
<span class="fc" id="L290">    }</span>

    /**
     * Gets factor to determine that a sudden movement has occurred during
     * initialization if instantaneous noise level exceeds accumulated noise
     * level by this factor amount.
     * This factor is unit-less.
     *
     * @return factor to determine that a sudden movement has occurred.
     */
    public double getInstantaneousNoiseLevelFactor() {
<span class="fc" id="L301">        return mStaticIntervalDetector.getInstantaneousNoiseLevelFactor();</span>
    }

    /**
     * Sets factor to determine that a sudden movement has occurred during
     * initialization if instantaneous noise level exceeds accumulated noise
     * level by this factor amount.
     * This factor is unit-less.
     *
     * @param instantaneousNoiseLevelFactor factor to determine that a sudden
     *                                      movement has occurred during
     *                                      initialization.
     * @throws LockedException          if detector is busy.
     * @throws IllegalArgumentException if provided value is zero or negative.
     */
    public void setInstantaneousNoiseLevelFactor(
            final double instantaneousNoiseLevelFactor) throws LockedException {
<span class="fc bfc" id="L318" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L319">            throw new LockedException();</span>
        }

<span class="fc" id="L322">        mStaticIntervalDetector.setInstantaneousNoiseLevelFactor(</span>
                instantaneousNoiseLevelFactor);
<span class="fc" id="L324">    }</span>

    /**
     * Gets overall absolute threshold to determine whether there has been
     * excessive motion during the whole initialization phase.
     * Failure will be detected if estimated base noise level exceeds this
     * threshold when initialization completes.
     * This threshold is expressed in meters per squared second (m/s^2).
     *
     * @return overall absolute threshold to determine whether there has
     * been excessive motion.
     */
    public double getBaseNoiseLevelAbsoluteThreshold() {
<span class="fc" id="L337">        return mStaticIntervalDetector.getBaseNoiseLevelAbsoluteThreshold();</span>
    }

    /**
     * Sets overall absolute threshold to determine whether there has been
     * excessive motion during the whole initialization phase.
     * Failure will be detected if estimated base noise level exceeds this
     * threshold when initialization completes.
     * This threshold is expressed in meters per squared second (m/s^2).
     *
     * @param baseNoiseLevelAbsoluteThreshold overall absolute threshold to
     *                                        determine whether there has been
     *                                        excessive motion.
     * @throws LockedException          if detector is busy.
     * @throws IllegalArgumentException if provided value is zero or negative.
     */
    public void setBaseNoiseLevelAbsoluteThreshold(
            final double baseNoiseLevelAbsoluteThreshold) throws LockedException {
<span class="fc bfc" id="L355" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L356">            throw new LockedException();</span>
        }

<span class="fc" id="L359">        mStaticIntervalDetector.setBaseNoiseLevelAbsoluteThreshold(</span>
                baseNoiseLevelAbsoluteThreshold);
<span class="fc" id="L361">    }</span>

    /**
     * Gets overall absolute threshold to determine whether there has been
     * excessive motion during the whole initialization phase.
     * Failure will be detected if estimated base noise level exceeds this
     * threshold when initialization completes.
     *
     * @return overall absolute threshold to determine whether there has been
     * excessive motion.
     */
    public Acceleration getBaseNoiseLevelAbsoluteThresholdAsMeasurement() {
<span class="fc" id="L373">        return mStaticIntervalDetector.getBaseNoiseLevelAbsoluteThresholdAsMeasurement();</span>
    }

    /**
     * Gets overall absolute threshold to determine whether there has been
     * excessive motion during the whole initialization phase.
     * Failure will be detected if estimated base noise level exceeds this
     * threshold when initialization completes.
     *
     * @param result instance where result will be stored.
     */
    public void getBaseNoiseLevelAbsoluteThresholdAsMeasurement(
            final Acceleration result) {
<span class="fc" id="L386">        mStaticIntervalDetector.getBaseNoiseLevelAbsoluteThresholdAsMeasurement(</span>
                result);
<span class="fc" id="L388">    }</span>

    /**
     * Sets overall absolute threshold to determine whether there has been
     * excessive motion during the whole initialization phase.
     * Failure will be detected if estimated base noise level exceeds this
     * threshold when initialization completes.
     *
     * @param baseNoiseLevelAbsoluteThreshold overall absolute threshold to
     *                                        determine whether there has been
     *                                        excessive motion.
     * @throws LockedException          if detector is busy.
     * @throws IllegalArgumentException if provided value is zero or negative.
     */
    public void setBaseNoiseLevelAbsoluteThreshold(
            final Acceleration baseNoiseLevelAbsoluteThreshold) throws LockedException {
<span class="fc bfc" id="L404" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L405">            throw new LockedException();</span>
        }

<span class="fc" id="L408">        mStaticIntervalDetector.setBaseNoiseLevelAbsoluteThreshold(</span>
                baseNoiseLevelAbsoluteThreshold);
<span class="fc" id="L410">    }</span>

    /**
     * Gets internal status of this generator.
     *
     * @return internal status of this generator.
     */
    public TriadStaticIntervalDetector.Status getStatus() {
<span class="fc" id="L418">        return mStaticIntervalDetector.getStatus();</span>
    }

    /**
     * Gets accelerometer base noise level that has been detected during
     * initialization expressed in meters per squared second (m/s^2).
     * This is equal to the standard deviation of the accelerometer measurements
     * during initialization phase.
     *
     * @return accelerometer base noise level.
     */
    public double getBaseNoiseLevel() {
<span class="fc" id="L430">        return mStaticIntervalDetector.getBaseNoiseLevel();</span>
    }

    /**
     * Gets accelerometer base noise level that has been detected during
     * initialization.
     * This is equal to the standard deviation of the accelerometer measurements
     * during initialization phase.
     *
     * @return measurement base noise level.
     */
    public Acceleration getBaseNoiseLevelAsMeasurement() {
<span class="fc" id="L442">        return mStaticIntervalDetector.getBaseNoiseLevelAsMeasurement();</span>
    }

    /**
     * Gets accelerometer base noise level that has been detected during
     * initialization.
     *
     * @param result instance where result will be stored.
     */
    public void getBaseNoiseLevelAsMeasurement(final Acceleration result) {
<span class="fc" id="L452">        mStaticIntervalDetector.getBaseNoiseLevelAsMeasurement(result);</span>
<span class="fc" id="L453">    }</span>

    /**
     * Gets threshold to determine static/dynamic period changes expressed in
     * meters per squared second (m/s^2).
     *
     * @return threshold to determine static/dynamic period changes.
     */
    public double getThreshold() {
<span class="fc" id="L462">        return mStaticIntervalDetector.getThreshold();</span>
    }

    /**
     * Gets threshold to determine static/dynamic period changes.
     *
     * @return threshold to determine static/dynamic period changes.
     */
    public Acceleration getThresholdAsMeasurement() {
<span class="fc" id="L471">        return mStaticIntervalDetector.getThresholdAsMeasurement();</span>
    }

    /**
     * Gets threshold to determine static/dynamic period changes.
     *
     * @param result instance where result will be stored.
     */
    public void getThresholdAsMeasurement(final Acceleration result) {
<span class="fc" id="L480">        mStaticIntervalDetector.getThresholdAsMeasurement(result);</span>
<span class="fc" id="L481">    }</span>

    /**
     * Gets number of samples that have been processed in a static period so far.
     *
     * @return number of samples that have been processed in a static period so far.
     */
    public int getProcessedStaticSamples() {
<span class="fc" id="L489">        return mProcessedStaticSamples;</span>
    }

    /**
     * Gets number of samples that have been processed in a dynamic period so far.
     *
     * @return number of samples that have been processed in a dynamic period so far.
     */
    public int getProcessedDynamicSamples() {
<span class="fc" id="L498">        return mProcessedDynamicSamples;</span>
    }

    /**
     * Indicates whether last static interval must be skipped.
     *
     * @return true if last static interval must be skipped.
     */
    public boolean isStaticIntervalSkipped() {
<span class="fc" id="L507">        return mSkipStaticInterval;</span>
    }

    /**
     * Indicates whether last dynamic interval must be skipped.
     *
     * @return true if last dynamic interval must be skipped.
     */
    public boolean isDynamicIntervalSkipped() {
<span class="fc" id="L516">        return mSkipDynamicInterval;</span>
    }

    /**
     * Indicates whether generator is running or not.
     *
     * @return true if generator is running, false otherwise.
     */
    public boolean isRunning() {
<span class="fc" id="L525">        return mRunning;</span>
    }

    /**
     * Processes a sample of data.
     *
     * @param sample sample of data to be processed.
     * @return true if provided samples has been processed, false if provided triad has been skipped because
     * generator previously failed. If generator previously failed, it will need to be reset before
     * processing additional samples.
     * @throws LockedException if generator is busy processing a previous sample.
     */
    public boolean process(final I sample) throws LockedException {
<span class="fc bfc" id="L538" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L539">            throw new LockedException();</span>
        }

<span class="fc" id="L542">        mRunning = true;</span>
<span class="fc" id="L543">        checkProcessedSamples();</span>

<span class="fc" id="L545">        getAccelerationTriadFromInputSample(sample);</span>
<span class="fc" id="L546">        final boolean result = mStaticIntervalDetector.process(mTriad);</span>

<span class="fc bfc" id="L548" title="All 2 branches covered.">        if (result) {</span>
<span class="fc" id="L549">            updateCounters();</span>
<span class="fc" id="L550">            postProcess(sample);</span>
        }
<span class="fc" id="L552">        mRunning = false;</span>

<span class="fc" id="L554">        return result;</span>
    }

    /**
     * Resets this generator.
     *
     * @throws LockedException if generator is busy.
     */
    public void reset() throws LockedException {
<span class="fc bfc" id="L563" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L564">            throw new LockedException();</span>
        }

<span class="fc" id="L567">        mStaticIntervalDetector.reset();</span>

<span class="fc" id="L569">        mProcessedDynamicSamples = 0;</span>
<span class="fc" id="L570">        mProcessedStaticSamples = 0;</span>

<span class="fc" id="L572">        mSkipDynamicInterval = false;</span>
<span class="fc" id="L573">        mSkipStaticInterval = false;</span>

<span class="pc bpc" id="L575" title="1 of 2 branches missed.">        if (mListener != null) {</span>
            //noinspection unchecked
<span class="fc" id="L577">            mListener.onReset((G) this);</span>
        }
<span class="fc" id="L579">    }</span>

    /**
     * Post process provided input sample.
     *
     * @param sample an input sample.
     * @throws LockedException if generator is busy.
     */
    protected abstract void postProcess(final I sample) throws LockedException;

    /**
     * Gets corresponding acceleration triad from provided input sample.
     * This method must store the result into {@link #mTriad}.
     *
     * @param sample input sample.
     */
    protected abstract void getAccelerationTriadFromInputSample(
            final I sample);

    /**
     * Handles a static-to-dynamic interval change.
     *
     * @param accumulatedAvgX average x-coordinate of measurements during last
     *                        static period expressed in meters per squared
     *                        second (m/s^2).
     * @param accumulatedAvgY average y-coordinate of specific force during last
     *                        static period expressed in meters per squared
     *                        second (m/s^2).
     * @param accumulatedAvgZ average z-coordinate of specific force during last
     *                        static period expressed in meters per squared
     *                        second (m/s^2).
     * @param accumulatedStdX standard deviation of x-coordinate of measurements
     *                        during last static period expressed in meters per
     *                        squared second (m/s^2).
     * @param accumulatedStdY standard deviation of y-coordinate of measurements
     *                        during last static period expressed in meters per
     *                        squared second (m/s^2).
     * @param accumulatedStdZ standard deviation of z-coordinate of measurements
     *                        during last static period expressed in meters per
     *                        squared second (m/s^2).
     */
    protected abstract void handleStaticToDynamicChange(
            final double accumulatedAvgX,
            final double accumulatedAvgY,
            final double accumulatedAvgZ,
            final double accumulatedStdX,
            final double accumulatedStdY,
            final double accumulatedStdZ);

    /**
     * Handles a dynamic-to-static interval change.
     */
    protected abstract void handleDynamicToStaticChange();

    /**
     * Handles an initialization completion.
     */
    protected abstract void handleInitializationCompleted();

    /**
     * Handles an error during initialization.
     */
    protected abstract void handleInitializationFailed();

    /**
     * Check processed samples so far before processing a new one.
     */
    protected void checkProcessedSamples() {
<span class="fc bfc" id="L647" title="All 2 branches covered.">        if (mProcessedDynamicSamples &gt; mMaxDynamicSamples) {</span>
<span class="fc" id="L648">            final boolean wasSkipped = mSkipDynamicInterval;</span>
<span class="fc" id="L649">            mSkipDynamicInterval = true;</span>

<span class="pc bpc" id="L651" title="1 of 4 branches missed.">            if (mListener != null &amp;&amp; !wasSkipped) {</span>
                //noinspection unchecked
<span class="fc" id="L653">                mListener.onDynamicIntervalSkipped((G) this);</span>
            }
        }
<span class="fc" id="L656">    }</span>

    /**
     * Updates counters of processed samples.
     */
    protected void updateCounters() {
<span class="fc bfc" id="L662" title="All 3 branches covered.">        switch (mStaticIntervalDetector.getStatus()) {</span>
            case STATIC_INTERVAL:
<span class="fc" id="L664">                mProcessedStaticSamples++;</span>
<span class="fc" id="L665">                mProcessedDynamicSamples = 0;</span>
<span class="fc" id="L666">                break;</span>
            case DYNAMIC_INTERVAL:
<span class="fc" id="L668">                mProcessedDynamicSamples++;</span>
<span class="fc" id="L669">                mProcessedStaticSamples = 0;</span>
                break;
        }
<span class="fc" id="L672">    }</span>

    /**
     * Setups listener for static interval detector.
     *
     * @throws LockedException if static interval detector is busy.
     */
    private void setupListener() throws LockedException {
<span class="fc" id="L680">        final AccelerationTriadStaticIntervalDetectorListener listener =</span>
<span class="fc" id="L681">                new AccelerationTriadStaticIntervalDetectorListener() {</span>
                    @Override
                    public void onInitializationStarted(
                            final AccelerationTriadStaticIntervalDetector detector) {

<span class="pc bpc" id="L686" title="1 of 2 branches missed.">                        if (mListener != null) {</span>
                            //noinspection unchecked
<span class="fc" id="L688">                            mListener.onInitializationStarted((G) MeasurementsGenerator.this);</span>
                        }
<span class="fc" id="L690">                    }</span>

                    @Override
                    public void onInitializationCompleted(
                            final AccelerationTriadStaticIntervalDetector detector,
                            final double baseNoiseLevel) {

<span class="fc" id="L697">                        handleInitializationCompleted();</span>

<span class="pc bpc" id="L699" title="1 of 2 branches missed.">                        if (mListener != null) {</span>
                            //noinspection unchecked
<span class="fc" id="L701">                            mListener.onInitializationCompleted(</span>
                                    (G) MeasurementsGenerator.this,
                                    baseNoiseLevel);
                        }
<span class="fc" id="L705">                    }</span>

                    @Override
                    public void onError(
                            final AccelerationTriadStaticIntervalDetector detector,
                            final double accumulatedNoiseLevel,
                            final double instantaneousNoiseLevel,
                            final TriadStaticIntervalDetector.ErrorReason reason) {

<span class="fc" id="L714">                        handleInitializationFailed();</span>

<span class="pc bpc" id="L716" title="1 of 2 branches missed.">                        if (mListener != null) {</span>
                            //noinspection unchecked
<span class="fc" id="L718">                            mListener.onError((G) MeasurementsGenerator.this, reason);</span>
                        }
<span class="fc" id="L720">                    }</span>

                    @Override
                    public void onStaticIntervalDetected(
                            final AccelerationTriadStaticIntervalDetector detector,
                            final double instantaneousAvgX,
                            final double instantaneousAvgY,
                            final double instantaneousAvgZ,
                            final double instantaneousStdX,
                            final double instantaneousStdY,
                            final double instantaneousStdZ) {

<span class="fc" id="L732">                        handleDynamicToStaticChange();</span>
<span class="fc" id="L733">                        mSkipDynamicInterval = false;</span>

<span class="pc bpc" id="L735" title="1 of 2 branches missed.">                        if (mListener != null) {</span>
                            //noinspection unchecked
<span class="fc" id="L737">                            mListener.onStaticIntervalDetected((G) MeasurementsGenerator.this);</span>
                        }
<span class="fc" id="L739">                    }</span>

                    @Override
                    public void onDynamicIntervalDetected(
                            final AccelerationTriadStaticIntervalDetector detector,
                            final double instantaneousAvgX,
                            final double instantaneousAvgY,
                            final double instantaneousAvgZ,
                            final double instantaneousStdX,
                            final double instantaneousStdY,
                            final double instantaneousStdZ,
                            final double accumulatedAvgX,
                            final double accumulatedAvgY,
                            final double accumulatedAvgZ,
                            final double accumulatedStdX,
                            final double accumulatedStdY,
                            final double accumulatedStdZ) {

<span class="fc bfc" id="L757" title="All 2 branches covered.">                        if (mProcessedStaticSamples &lt; mMinStaticSamples) {</span>
<span class="fc" id="L758">                            final boolean wasSkipped = mSkipStaticInterval;</span>
<span class="fc" id="L759">                            mSkipStaticInterval = true;</span>

<span class="pc bpc" id="L761" title="2 of 4 branches missed.">                            if (mListener != null &amp;&amp; !wasSkipped) {</span>
                                //noinspection unchecked
<span class="fc" id="L763">                                mListener.onStaticIntervalSkipped((G) MeasurementsGenerator.this);</span>
                            }
                        }

<span class="fc" id="L767">                        handleStaticToDynamicChange(</span>
                                accumulatedAvgX, accumulatedAvgY, accumulatedAvgZ,
                                accumulatedStdX, accumulatedStdY, accumulatedStdZ);
<span class="fc" id="L770">                        mSkipStaticInterval = false;</span>

<span class="pc bpc" id="L772" title="1 of 2 branches missed.">                        if (mListener != null) {</span>
                            //noinspection unchecked
<span class="fc" id="L774">                            mListener.onDynamicIntervalDetected((G) MeasurementsGenerator.this);</span>
                        }
<span class="fc" id="L776">                    }</span>

                    @Override
                    public void onReset(
                            final AccelerationTriadStaticIntervalDetector detector) {
<span class="fc" id="L781">                    }</span>
                };
<span class="fc" id="L783">        mStaticIntervalDetector.setListener(listener);</span>
<span class="fc" id="L784">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>