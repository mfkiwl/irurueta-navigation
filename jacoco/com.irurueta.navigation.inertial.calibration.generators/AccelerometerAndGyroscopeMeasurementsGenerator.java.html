<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AccelerometerAndGyroscopeMeasurementsGenerator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.irurueta:irurueta-navigation</a> &gt; <a href="index.source.html" class="el_package">com.irurueta.navigation.inertial.calibration.generators</a> &gt; <span class="el_source">AccelerometerAndGyroscopeMeasurementsGenerator.java</span></div><h1>AccelerometerAndGyroscopeMeasurementsGenerator.java</h1><pre class="source lang-java linenums">package com.irurueta.navigation.inertial.calibration.generators;

import com.irurueta.navigation.LockedException;
import com.irurueta.navigation.inertial.calibration.AngularSpeedTriad;
import com.irurueta.navigation.inertial.calibration.BodyKinematicsSequence;
import com.irurueta.navigation.inertial.calibration.StandardDeviationBodyKinematics;
import com.irurueta.navigation.inertial.calibration.StandardDeviationTimedBodyKinematics;
import com.irurueta.navigation.inertial.calibration.TimedBodyKinematics;
import com.irurueta.navigation.inertial.calibration.intervals.TriadStaticIntervalDetector;
import com.irurueta.units.Acceleration;
import com.irurueta.units.AngularSpeed;

/**
 * Generates measurements for the calibration of accelerometers and gyroscopes by alternating
 * static and dynamic intervals where device is kept static or moved.
 * Generated measurements must be used with accelerometer calibrators based
 * on the knowledge of gravity norm (or Earth position) when the device orientation
 * is unknown, and with easy gyroscope calibrators.
 * Notice that accuracy of the gyroscope calibration is very sensitive to the
 * accuracy of detected dynamic intervals respect the average specific forces
 * during static intervals.
 * In order to increase the accuracy, calibration should be repeated trying different
 * threshold factors {@link #getThresholdFactor()}.
 *
 * @see AccelerometerMeasurementsGenerator
 * @see GyroscopeMeasurementsGenerator
 */
public class AccelerometerAndGyroscopeMeasurementsGenerator {

    /**
     * Listener to handle generated events.
     */
    private AccelerometerAndGyroscopeMeasurementsGeneratorListener mListener;

    /**
     * Listener for internal accelerometer measurements generator.
     */
<span class="fc" id="L38">    private final AccelerometerMeasurementsGeneratorListener mAccelerometerListener =</span>
<span class="fc" id="L39">            new AccelerometerMeasurementsGeneratorListener() {</span>
                @Override
                public void onInitializationStarted(
                        final AccelerometerMeasurementsGenerator generator) {
                    // no action required
<span class="fc" id="L44">                }</span>

                @Override
                public void onInitializationCompleted(
                        final AccelerometerMeasurementsGenerator generator,
                        final double baseNoiseLevel) {
                    // no action required
<span class="fc" id="L51">                }</span>

                @Override
                public void onError(
                        final AccelerometerMeasurementsGenerator generator,
                        final TriadStaticIntervalDetector.ErrorReason reason) {
<span class="pc bpc" id="L57" title="1 of 2 branches missed.">                    if (mListener != null) {</span>
<span class="fc" id="L58">                        mListener.onError(</span>
                                AccelerometerAndGyroscopeMeasurementsGenerator.this,
                                reason);
                    }
<span class="fc" id="L62">                }</span>

                @Override
                public void onStaticIntervalDetected(
                        final AccelerometerMeasurementsGenerator generator) {
                    // no action required
<span class="fc" id="L68">                }</span>

                @Override
                public void onDynamicIntervalDetected(
                        final AccelerometerMeasurementsGenerator generator) {
                    // no action required
<span class="fc" id="L74">                }</span>

                @Override
                public void onStaticIntervalSkipped(
                        final AccelerometerMeasurementsGenerator generator) {
                    // no action required
<span class="fc" id="L80">                }</span>

                @Override
                public void onDynamicIntervalSkipped(
                        final AccelerometerMeasurementsGenerator generator) {
                    // no action required
<span class="fc" id="L86">                }</span>

                @Override
                public void onGeneratedMeasurement(
                        final AccelerometerMeasurementsGenerator generator,
                        final StandardDeviationBodyKinematics measurement) {
<span class="pc bpc" id="L92" title="1 of 2 branches missed.">                    if (mListener != null) {</span>
<span class="fc" id="L93">                        mListener.onGeneratedAccelerometerMeasurement(</span>
                                AccelerometerAndGyroscopeMeasurementsGenerator.this,
                                measurement);
                    }
<span class="fc" id="L97">                }</span>

                @Override
                public void onReset(
                        final AccelerometerMeasurementsGenerator generator) {
                    // no action required
<span class="fc" id="L103">                }</span>
            };

    /**
     * Listener for internal gyroscope measurements generator.
     */
<span class="fc" id="L109">    private final GyroscopeMeasurementGeneratorListener mGyroscopeListener =</span>
<span class="fc" id="L110">            new GyroscopeMeasurementGeneratorListener() {</span>
                @Override
                public void onInitializationStarted(
                        final GyroscopeMeasurementsGenerator generator) {
<span class="pc bpc" id="L114" title="1 of 2 branches missed.">                    if (mListener != null) {</span>
<span class="fc" id="L115">                        mListener.onInitializationStarted(</span>
                                AccelerometerAndGyroscopeMeasurementsGenerator.this);
                    }
<span class="fc" id="L118">                }</span>

                @Override
                public void onInitializationCompleted(
                        final GyroscopeMeasurementsGenerator generator,
                        final double baseNoiseLevel) {
<span class="pc bpc" id="L124" title="1 of 2 branches missed.">                    if (mListener != null) {</span>
<span class="fc" id="L125">                        mListener.onInitializationCompleted(</span>
                                AccelerometerAndGyroscopeMeasurementsGenerator.this,
                                baseNoiseLevel);
                    }
<span class="fc" id="L129">                }</span>

                @Override
                public void onError(
                        final GyroscopeMeasurementsGenerator generator,
                        final TriadStaticIntervalDetector.ErrorReason reason) {
                    // no action required
<span class="fc" id="L136">                }</span>

                @Override
                public void onStaticIntervalDetected(
                        final GyroscopeMeasurementsGenerator generator) {
<span class="pc bpc" id="L141" title="1 of 2 branches missed.">                    if (mListener != null) {</span>
<span class="fc" id="L142">                        mListener.onStaticIntervalDetected(</span>
                                AccelerometerAndGyroscopeMeasurementsGenerator.this);
                    }
<span class="fc" id="L145">                }</span>

                @Override
                public void onDynamicIntervalDetected(
                        final GyroscopeMeasurementsGenerator generator) {
<span class="pc bpc" id="L150" title="1 of 2 branches missed.">                    if (mListener != null) {</span>
<span class="fc" id="L151">                        mListener.onDynamicIntervalDetected(</span>
                                AccelerometerAndGyroscopeMeasurementsGenerator.this);
                    }
<span class="fc" id="L154">                }</span>

                @Override
                public void onStaticIntervalSkipped(
                        final GyroscopeMeasurementsGenerator generator) {
<span class="pc bpc" id="L159" title="1 of 2 branches missed.">                    if (mListener != null) {</span>
<span class="fc" id="L160">                        mListener.onStaticIntervalSkipped(</span>
                                AccelerometerAndGyroscopeMeasurementsGenerator.this);
                    }
<span class="fc" id="L163">                }</span>

                @Override
                public void onDynamicIntervalSkipped(
                        final GyroscopeMeasurementsGenerator generator) {
<span class="pc bpc" id="L168" title="1 of 2 branches missed.">                    if (mListener != null) {</span>
<span class="fc" id="L169">                        mListener.onDynamicIntervalSkipped(</span>
                                AccelerometerAndGyroscopeMeasurementsGenerator.this);
                    }
<span class="fc" id="L172">                }</span>

                @Override
                public void onGeneratedMeasurement(
                        final GyroscopeMeasurementsGenerator generator,
                        final BodyKinematicsSequence&lt;StandardDeviationTimedBodyKinematics&gt; measurement) {
<span class="pc bpc" id="L178" title="1 of 2 branches missed.">                    if (mListener != null) {</span>
<span class="fc" id="L179">                        mListener.onGeneratedGyroscopeMeasurement(</span>
                                AccelerometerAndGyroscopeMeasurementsGenerator.this,
                                measurement);
                    }
<span class="fc" id="L183">                }</span>

                @Override
                public void onReset(
                        final GyroscopeMeasurementsGenerator generator) {
                    // no action required
<span class="fc" id="L189">                }</span>
            };

    /**
     * Internal accelerometer measurements generator.
     */
<span class="fc" id="L195">    private final AccelerometerMeasurementsGenerator mAccelerometerMeasurementsGenerator =</span>
            new AccelerometerMeasurementsGenerator(mAccelerometerListener);

    /**
     * Internal gyroscope measurements generator.
     */
<span class="fc" id="L201">    private final GyroscopeMeasurementsGenerator mGyroscopeMeasurementsGenerator =</span>
            new GyroscopeMeasurementsGenerator(mGyroscopeListener);

    /**
     * Indicates whether generator is running or not.
     */
    private boolean mRunning;

    /**
     * Constructor.
     */
<span class="fc" id="L212">    public AccelerometerAndGyroscopeMeasurementsGenerator() {</span>
<span class="fc" id="L213">    }</span>

    /**
     * Constructor.
     *
     * @param listener listener to handle events raised by this generator.
     */
    public AccelerometerAndGyroscopeMeasurementsGenerator(
            final AccelerometerAndGyroscopeMeasurementsGeneratorListener listener) {
<span class="fc" id="L222">        this();</span>
<span class="fc" id="L223">        mListener = listener;</span>
<span class="fc" id="L224">    }</span>

    /**
     * Gets minimum number of samples required in a static interval to be taken into account.
     * Smaller static intervals will be discarded.
     *
     * @return minimum number of samples required in a static interval to be taken into account.
     */
    public int getMinStaticSamples() {
<span class="fc" id="L233">        return mAccelerometerMeasurementsGenerator.getMinStaticSamples();</span>
    }

    /**
     * Sets minimum number of samples required in a static interval to be taken into account.
     * Smaller static intervals will be discarded.
     *
     * @param minStaticSamples minimum number of samples required in a static interval to be
     *                         taken into account.
     * @throws LockedException          if generator is busy.
     * @throws IllegalArgumentException if provided value is less than 2.
     */
    public void setMinStaticSamples(final int minStaticSamples) throws LockedException {
<span class="fc bfc" id="L246" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L247">            throw new LockedException();</span>
        }

<span class="fc" id="L250">        mAccelerometerMeasurementsGenerator.setMinStaticSamples(minStaticSamples);</span>
<span class="fc" id="L251">        mGyroscopeMeasurementsGenerator.setMinStaticSamples(minStaticSamples);</span>
<span class="fc" id="L252">    }</span>

    /**
     * Gets maximum number of samples allowed in dynamic intervals.
     *
     * @return maximum number of samples allowed in dynamic intervals.
     */
    public int getMaxDynamicSamples() {
<span class="fc" id="L260">        return mAccelerometerMeasurementsGenerator.getMaxDynamicSamples();</span>
    }

    /**
     * Sets maximum number of samples allowed in dynamic intervals.
     *
     * @param maxDynamicSamples maximum number of samples allowed in dynamic intervals.
     * @throws LockedException          if generator is busy.
     * @throws IllegalArgumentException if provided value is less than 2.
     */
    public void setMaxDynamicSamples(final int maxDynamicSamples) throws LockedException {
<span class="fc bfc" id="L271" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L272">            throw new LockedException();</span>
        }

<span class="fc" id="L275">        mAccelerometerMeasurementsGenerator.setMaxDynamicSamples(maxDynamicSamples);</span>
<span class="fc" id="L276">        mGyroscopeMeasurementsGenerator.setMaxDynamicSamples(maxDynamicSamples);</span>
<span class="fc" id="L277">    }</span>

    /**
     * Gets listener to handle generated events.
     *
     * @return listener to handle generated events.
     */
    public AccelerometerAndGyroscopeMeasurementsGeneratorListener getListener() {
<span class="fc" id="L285">        return mListener;</span>
    }

    /**
     * Sets listener to handle generated events.
     *
     * @param listener listener to handle generated evets.
     * @throws LockedException if generator is busy.
     */
    public void setListener(final AccelerometerAndGyroscopeMeasurementsGeneratorListener listener)
            throws LockedException {
<span class="fc bfc" id="L296" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L297">            throw new LockedException();</span>
        }

<span class="fc" id="L300">        mListener = listener;</span>
<span class="fc" id="L301">    }</span>

    /**
     * Gets length of number of samples to keep within the window being processed
     * to determine instantaneous accelerometer noise level.
     *
     * @return length of number of samples to keep within the window.
     */
    public int getWindowSize() {
<span class="fc" id="L310">        return mAccelerometerMeasurementsGenerator.getWindowSize();</span>
    }

    /**
     * Sets length of number of samples to keep within the window being processed
     * to determine instantaneous accelerometer noise level.
     * Window size must always be larger than allowed minimum value, which is 2 and
     * must have an odd value.
     *
     * @param windowSize length of number of samples to keep within the window.
     * @throws LockedException          if detector is busy processing a previous sample.
     * @throws IllegalArgumentException if provided value is not valid.
     */
    public void setWindowSize(final int windowSize) throws LockedException {
<span class="fc bfc" id="L324" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L325">            throw new LockedException();</span>
        }

<span class="fc" id="L328">        mAccelerometerMeasurementsGenerator.setWindowSize(windowSize);</span>
<span class="fc" id="L329">        mGyroscopeMeasurementsGenerator.setWindowSize(windowSize);</span>
<span class="fc" id="L330">    }</span>

    /**
     * Gets number of samples to be processed initially while keeping the sensor static in order
     * to find the base noise level when device is static.
     *
     * @return number of samples to be processed initially.
     */
    public int getInitialStaticSamples() {
<span class="fc" id="L339">        return mAccelerometerMeasurementsGenerator.getInitialStaticSamples();</span>
    }

    /**
     * Sets number of samples to be processed initially while keeping the sensor static in order
     * to find the base noise level when device is static.
     *
     * @param initialStaticSamples number of samples to be processed initially.
     * @throws LockedException          if detector is busy.
     * @throws IllegalArgumentException if provided value is less than
     *                                  {@link TriadStaticIntervalDetector#MINIMUM_INITIAL_STATIC_SAMPLES}
     */
    public void setInitialStaticSamples(final int initialStaticSamples)
            throws LockedException {
<span class="fc bfc" id="L353" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L354">            throw new LockedException();</span>
        }

<span class="fc" id="L357">        mAccelerometerMeasurementsGenerator.setInitialStaticSamples(initialStaticSamples);</span>
<span class="fc" id="L358">        mGyroscopeMeasurementsGenerator.setInitialStaticSamples(initialStaticSamples);</span>
<span class="fc" id="L359">    }</span>

    /**
     * Gets factor to be applied to detected base noise level in order to
     * determine threshold for static/dynamic period changes. This factor is
     * unit-less.
     *
     * @return factor to be applied to detected base noise level.
     */
    public double getThresholdFactor() {
<span class="fc" id="L369">        return mAccelerometerMeasurementsGenerator.getThresholdFactor();</span>
    }

    /**
     * Sets factor to be applied to detected base noise level in order to
     * determine threshold for static/dynamic period changes. This factor is
     * unit-less.
     *
     * @param thresholdFactor factor to be applied to detected base noise level.
     * @throws LockedException          if detector is busy.
     * @throws IllegalArgumentException if provided value is zero or negative.
     */
    public void setThresholdFactor(final double thresholdFactor)
            throws LockedException {
<span class="fc bfc" id="L383" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L384">            throw new LockedException();</span>
        }

<span class="fc" id="L387">        mAccelerometerMeasurementsGenerator.setThresholdFactor(thresholdFactor);</span>
<span class="fc" id="L388">        mGyroscopeMeasurementsGenerator.setThresholdFactor(thresholdFactor);</span>
<span class="fc" id="L389">    }</span>

    /**
     * Gets factor to determine that a sudden movement has occurred during
     * initialization if instantaneous noise level exceeds accumulated noise
     * level by this factor amount.
     * This factor is unit-less.
     *
     * @return factor to determine that a sudden movement has occurred.
     */
    public double getInstantaneousNoiseLevelFactor() {
<span class="fc" id="L400">        return mAccelerometerMeasurementsGenerator.getInstantaneousNoiseLevelFactor();</span>
    }

    /**
     * Sets factor to determine that a sudden movement has occurred during
     * initialization if instantaneous noise level exceeds accumulated noise
     * level by this factor amount.
     * This factor is unit-less.
     *
     * @param instantaneousNoiseLevelFactor factor to determine that a sudden
     *                                      movement has occurred during
     *                                      initialization.
     * @throws LockedException          if detector is busy.
     * @throws IllegalArgumentException if provided value is zero or negative.
     */
    public void setInstantaneousNoiseLevelFactor(
            final double instantaneousNoiseLevelFactor) throws LockedException {
<span class="fc bfc" id="L417" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L418">            throw new LockedException();</span>
        }

<span class="fc" id="L421">        mAccelerometerMeasurementsGenerator.setInstantaneousNoiseLevelFactor(</span>
                instantaneousNoiseLevelFactor);
<span class="fc" id="L423">        mGyroscopeMeasurementsGenerator.setInstantaneousNoiseLevelFactor(</span>
                instantaneousNoiseLevelFactor);
<span class="fc" id="L425">    }</span>

    /**
     * Gets overall absolute threshold to determine whether there has been
     * excessive motion during the whole initialization phase.
     * Failure will be detected if estimated base noise level exceeds this
     * threshold when initialization completes.
     * This threshold is expressed in meters per squared second (m/s^2).
     *
     * @return overall absolute threshold to determine whether there has
     * been excessive motion.
     */
    public double getBaseNoiseLevelAbsoluteThreshold() {
<span class="fc" id="L438">        return mAccelerometerMeasurementsGenerator.getBaseNoiseLevelAbsoluteThreshold();</span>
    }

    /**
     * Sets overall absolute threshold to determine whether there has been
     * excessive motion during the whole initialization phase.
     * Failure will be detected if estimated base noise level exceeds this
     * threshold when initialization completes.
     * This threshold is expressed in meters per squared second (m/s^2).
     *
     * @param baseNoiseLevelAbsoluteThreshold overall absolute threshold to
     *                                        determine whether there has been
     *                                        excessive motion.
     * @throws LockedException          if detector is busy.
     * @throws IllegalArgumentException if provided value is zero or negative.
     */
    public void setBaseNoiseLevelAbsoluteThreshold(
            final double baseNoiseLevelAbsoluteThreshold) throws LockedException {
<span class="fc bfc" id="L456" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L457">            throw new LockedException();</span>
        }

<span class="fc" id="L460">        mAccelerometerMeasurementsGenerator.setBaseNoiseLevelAbsoluteThreshold(</span>
                baseNoiseLevelAbsoluteThreshold);
<span class="fc" id="L462">        mGyroscopeMeasurementsGenerator.setBaseNoiseLevelAbsoluteThreshold(</span>
                baseNoiseLevelAbsoluteThreshold);
<span class="fc" id="L464">    }</span>

    /**
     * Gets overall absolute threshold to determine whether there has been
     * excessive motion during the whole initialization phase.
     * Failure will be detected if estimated base noise level exceeds this
     * threshold when initialization completes.
     *
     * @return overall absolute threshold to determine whether there has been
     * excessive motion.
     */
    public Acceleration getBaseNoiseLevelAbsoluteThresholdAsMeasurement() {
<span class="fc" id="L476">        return mAccelerometerMeasurementsGenerator.getBaseNoiseLevelAbsoluteThresholdAsMeasurement();</span>
    }

    /**
     * Gets overall absolute threshold to determine whether there has been
     * excessive motion during the whole initialization phase.
     * Failure will be detected if estimated base noise level exceeds this
     * threshold when initialization completes.
     *
     * @param result instance where result will be stored.
     */
    public void getBaseNoiseLevelAbsoluteThresholdAsMeasurement(
            final Acceleration result) {
<span class="fc" id="L489">        mAccelerometerMeasurementsGenerator.getBaseNoiseLevelAbsoluteThresholdAsMeasurement(</span>
                result);
<span class="fc" id="L491">    }</span>

    /**
     * Sets overall absolute threshold to determine whether there has been
     * excessive motion during the whole initialization phase.
     * Failure will be detected if estimated base noise level exceeds this
     * threshold when initialization completes.
     *
     * @param baseNoiseLevelAbsoluteThreshold overall absolute threshold to
     *                                        determine whether there has been
     *                                        excessive motion.
     * @throws LockedException          if detector is busy.
     * @throws IllegalArgumentException if provided value is zero or negative.
     */
    public void setBaseNoiseLevelAbsoluteThreshold(
            final Acceleration baseNoiseLevelAbsoluteThreshold) throws LockedException {
<span class="fc bfc" id="L507" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L508">            throw new LockedException();</span>
        }

<span class="fc" id="L511">        mAccelerometerMeasurementsGenerator.setBaseNoiseLevelAbsoluteThreshold(</span>
                baseNoiseLevelAbsoluteThreshold);
<span class="fc" id="L513">        mGyroscopeMeasurementsGenerator.setBaseNoiseLevelAbsoluteThreshold(</span>
                baseNoiseLevelAbsoluteThreshold);
<span class="fc" id="L515">    }</span>

    /**
     * Gets internal status of this generator.
     *
     * @return internal status of this generator.
     */
    public TriadStaticIntervalDetector.Status getStatus() {
<span class="fc" id="L523">        return mAccelerometerMeasurementsGenerator.getStatus();</span>
    }

    /**
     * Gets accelerometer base noise level that has been detected during
     * initialization expressed in meters per squared second (m/s^2).
     * This is equal to the standard deviation of the accelerometer measurements
     * during initialization phase.
     *
     * @return accelerometer base noise level.
     */
    public double getAccelerometerBaseNoiseLevel() {
<span class="fc" id="L535">        return mAccelerometerMeasurementsGenerator.getBaseNoiseLevel();</span>
    }

    /**
     * Gets accelerometer base noise level that has been detected during
     * initialization.
     * This is equal to the standard deviation of the accelerometer measurements
     * during initialization phase.
     *
     * @return measurement base noise level.
     */
    public Acceleration getAccelerometerBaseNoiseLevelAsMeasurement() {
<span class="fc" id="L547">        return mAccelerometerMeasurementsGenerator.getBaseNoiseLevelAsMeasurement();</span>
    }

    /**
     * Gets accelerometer base noise level that has been detected during
     * initialization.
     *
     * @param result instance where result will be stored.
     */
    public void getAccelerometerBaseNoiseLevelAsMeasurement(final Acceleration result) {
<span class="fc" id="L557">        mAccelerometerMeasurementsGenerator.getBaseNoiseLevelAsMeasurement(result);</span>
<span class="fc" id="L558">    }</span>

    /**
     * Gets threshold to determine static/dynamic period changes expressed in
     * meters per squared second (m/s^2).
     *
     * @return threshold to determine static/dynamic period changes.
     */
    public double getThreshold() {
<span class="fc" id="L567">        return mAccelerometerMeasurementsGenerator.getThreshold();</span>
    }

    /**
     * Gets threshold to determine static/dynamic period changes.
     *
     * @return threshold to determine static/dynamic period changes.
     */
    public Acceleration getThresholdAsMeasurement() {
<span class="fc" id="L576">        return mAccelerometerMeasurementsGenerator.getThresholdAsMeasurement();</span>
    }

    /**
     * Gets threshold to determine static/dynamic period changes.
     *
     * @param result instance where result will be stored.
     */
    public void getThresholdAsMeasurement(final Acceleration result) {
<span class="fc" id="L585">        mAccelerometerMeasurementsGenerator.getThresholdAsMeasurement(result);</span>
<span class="fc" id="L586">    }</span>

    /**
     * Gets number of samples that have been processed in a static period so far.
     *
     * @return number of samples that have been processed in a static period so far.
     */
    public int getProcessedStaticSamples() {
<span class="fc" id="L594">        return mAccelerometerMeasurementsGenerator.getProcessedStaticSamples();</span>
    }

    /**
     * Gets number of samples that have been processed in a dynamic period so far.
     *
     * @return number of samples that have been processed in a dynamic period so far.
     */
    public int getProcessedDynamicSamples() {
<span class="fc" id="L603">        return mAccelerometerMeasurementsGenerator.getProcessedDynamicSamples();</span>
    }

    /**
     * Indicates whether last static interval must be skipped.
     *
     * @return true if last static interval must be skipped.
     */
    public boolean isStaticIntervalSkipped() {
<span class="fc" id="L612">        return mAccelerometerMeasurementsGenerator.isStaticIntervalSkipped();</span>
    }

    /**
     * Indicates whether last dynamic interval must be skipped.
     *
     * @return true if last dynamic interval must be skipped.
     */
    public boolean isDynamicIntervalSkipped() {
<span class="fc" id="L621">        return mAccelerometerMeasurementsGenerator.isDynamicIntervalSkipped();</span>
    }

    /**
     * Indicates whether generator is running or not.
     *
     * @return true if generator is running, false otherwise.
     */
    public boolean isRunning() {
<span class="fc" id="L630">        return mRunning;</span>
    }

    /**
     * Processes a sample of data.
     *
     * @param sample sample of data to be processed.
     * @return true if provided samples has been processed, false if provided triad has been skipped because
     * generator previously failed. If generator previously failed, it will need to be reset before
     * processing additional samples.
     * @throws LockedException if generator is busy processing a previous sample.
     */
    public boolean process(final TimedBodyKinematics sample) throws LockedException {
<span class="fc bfc" id="L643" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L644">            throw new LockedException();</span>
        }

        try {
<span class="fc" id="L648">            mRunning = true;</span>
<span class="fc bfc" id="L649" title="All 2 branches covered.">            return mAccelerometerMeasurementsGenerator.process(sample.getKinematics())</span>
<span class="pc bpc" id="L650" title="1 of 2 branches missed.">                    &amp;&amp; mGyroscopeMeasurementsGenerator.process(sample);</span>
        } finally {
<span class="fc" id="L652">            mRunning = false;</span>
        }
    }

    /**
     * Resets this generator.
     *
     * @throws LockedException if generator is busy.
     */
    public void reset() throws LockedException {
<span class="fc bfc" id="L662" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L663">            throw new LockedException();</span>
        }

<span class="fc" id="L666">        mAccelerometerMeasurementsGenerator.reset();</span>
<span class="fc" id="L667">        mGyroscopeMeasurementsGenerator.reset();</span>

<span class="pc bpc" id="L669" title="1 of 2 branches missed.">        if (mListener != null) {</span>
<span class="fc" id="L670">            mListener.onReset(this);</span>
        }
<span class="fc" id="L672">    }</span>

    /**
     * Gets estimated average angular rate during initialization phase.
     *
     * @return estimated average angular rate during initialization phase.
     */
    public AngularSpeedTriad getInitialAvgAngularSpeedTriad() {
<span class="fc" id="L680">        return mGyroscopeMeasurementsGenerator.getInitialAvgAngularSpeedTriad();</span>
    }

    /**
     * Gets estimated average angular rate during initialization phase.
     *
     * @param result instance where result will be stored.
     */
    public void getInitialAvgAngularSpeedTriad(final AngularSpeedTriad result) {
<span class="fc" id="L689">        mGyroscopeMeasurementsGenerator.getInitialAvgAngularSpeedTriad(result);</span>
<span class="fc" id="L690">    }</span>

    /**
     * Gets estimated standard deviation of angular rate during initialization phase.
     *
     * @return estimated standard deviation of angular rate during initialization phase.
     */
    public AngularSpeedTriad getInitialAngularSpeedTriadStandardDeviation() {
<span class="fc" id="L698">        return mGyroscopeMeasurementsGenerator.getInitialAngularSpeedTriadStandardDeviation();</span>
    }

    /**
     * Gets estimated standard deviation of angular rate during initialization phase.
     *
     * @param result instance where result will be stored.
     */
    public void getInitialAngularSpeedTriadStandardDeviation(final AngularSpeedTriad result) {
<span class="fc" id="L707">        mGyroscopeMeasurementsGenerator.getInitialAngularSpeedTriadStandardDeviation(result);</span>
<span class="fc" id="L708">    }</span>

    /**
     * Gets norm of estimated standard deviation of angular rate during initialization phase
     * expressed in radians per second (rad/s).
     *
     * @return norm of estimated standard deviation of angular rate during initialization phase.
     */
    public double getInitialAngularSpeedTriadStandardDeviationNorm() {
<span class="fc" id="L717">        return mGyroscopeMeasurementsGenerator.getInitialAngularSpeedTriadStandardDeviationNorm();</span>
    }

    /**
     * Gets norm of estimated standard deviation of angular rate during initialization phase.
     *
     * @return norm of estimated standard deviation of angular rate during initialization phase.
     */
    public AngularSpeed getInitialAngularSpeedTriadStandardDeviationNormAsMeasurement() {
<span class="fc" id="L726">        return mGyroscopeMeasurementsGenerator.getInitialAngularSpeedTriadStandardDeviationNormAsMeasurement();</span>
    }

    /**
     * Gets norm of estimated standard deviation of angular rate during initialization phase.
     *
     * @param result instance where result will be stored.
     */
    public void getInitialAngularSpeedTriadStandardDeviationNormAsMeasurement(
            final AngularSpeed result) {
<span class="fc" id="L736">        mGyroscopeMeasurementsGenerator.getInitialAngularSpeedTriadStandardDeviationNormAsMeasurement(</span>
                result);
<span class="fc" id="L738">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>