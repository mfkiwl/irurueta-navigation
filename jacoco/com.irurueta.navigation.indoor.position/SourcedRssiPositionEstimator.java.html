<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SourcedRssiPositionEstimator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.irurueta:irurueta-navigation</a> &gt; <a href="index.source.html" class="el_package">com.irurueta.navigation.indoor.position</a> &gt; <span class="el_source">SourcedRssiPositionEstimator.java</span></div><h1>SourcedRssiPositionEstimator.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2018 Alberto Irurueta Carro (alberto@irurueta.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.irurueta.navigation.indoor.position;

import com.irurueta.algebra.AlgebraException;
import com.irurueta.algebra.Matrix;
import com.irurueta.geometry.Point;
import com.irurueta.navigation.LockedException;
import com.irurueta.navigation.NotReadyException;
import com.irurueta.navigation.indoor.*;

import java.util.Collection;
import java.util.List;

/**
 * Base class for position estimators based on located fingerprints containing only
 * RSSI readings and having as well prior knowledge of the location of radio sources
 * associated to those readings.
 * This implementation uses a first-order Taylor approximation over provided located
 * fingerprints to determine an approximate position for a non-located fingerprint.
 * @param &lt;P&gt; a {@link Point} type.
 */
@SuppressWarnings(&quot;WeakerAccess&quot;)
public abstract class SourcedRssiPositionEstimator&lt;P extends Point&gt; extends
        BaseRssiPositionEstimator&lt;P, SourcedRssiPositionEstimatorListener&lt;P&gt;&gt; {

    /**
     * Located radio sources.
     */
    private List&lt;? extends RadioSourceLocated&lt;P&gt;&gt; mSources;

    /**
     * Indicates whether path loss exponent of provided sources must be used when
     * available (if true), or if fallback path loss exponent must be used instead.
     */
<span class="fc" id="L49">    private boolean mUseSourcesPathLossExponentWhenAvailable = true;</span>

    /**
     * True indicates that mean effects are removed to find nearest located fingerprints
     * based on RSSI readings. False indicates that RSSI readings are directly used, which
     * might be inaccurate due to bias effects on new fingerprint readings for unknown
     * locations.
     * By default mean effects are removed to remove possible bias effects due to
     * readings measured by different devices with different hardware.
     */
<span class="fc" id="L59">    private boolean mUseNoMeanNearestFingerprintFinder = true;</span>

    /**
     * True indicates that mean effects are removed from located fingerprints and from
     * new fingerprints whose location is unknown.
     * By default this is enabled to remove possible bias effects due to readings
     * measured by different devices with different hardware.
     */
<span class="fc" id="L67">    private boolean mRemoveMeansFromFingerprintReadings = true;</span>

    /**
     * Constructor.
     */
<span class="fc" id="L72">    public SourcedRssiPositionEstimator() { }</span>

    /**
     * Constructor.
     * @param listener listener in charge of handling events.
     */
    public SourcedRssiPositionEstimator(
            SourcedRssiPositionEstimatorListener&lt;P&gt; listener) {
<span class="fc" id="L80">        super(listener);</span>
<span class="fc" id="L81">    }</span>

    /**
     * Constructor.
     * @param locatedFingerprints located fingerprints containing RSSI readings.
     * @param fingerprint fingerprint containing readings at an unknown location
     *                    for provided located fingerprints.
     * @param sources located radio sources.
     * @throws IllegalArgumentException if provided non located fingerprint is null,
     * located fingerprints value is null or there are not enough fingerprints or
     * readings within provided fingerprints (for 2D position estimation at least 2
     * located total readings are required among all fingerprints, for example 2
     * readings are required in a single fingerprint, or at least 2 fingerprints at
     * different locations containing a single reading are required. For 3D position
     * estimation 3 located total readings are required among all fingerprints).
     */
    public SourcedRssiPositionEstimator(List&lt;? extends RssiFingerprintLocated&lt;? extends RadioSource,
            ? extends RssiReading&lt;? extends RadioSource&gt;, P&gt;&gt; locatedFingerprints,
            RssiFingerprint&lt;? extends RadioSource,
            ? extends RssiReading&lt;? extends RadioSource&gt;&gt; fingerprint,
            List&lt;? extends RadioSourceLocated&lt;P&gt;&gt; sources) {
<span class="fc" id="L102">        super(locatedFingerprints, fingerprint);</span>
<span class="fc" id="L103">        internalSetSources(sources);</span>
<span class="fc" id="L104">    }</span>

    /**
     * Constructor.
     * @param locatedFingerprints located fingerprints containing RSSI readings.
     * @param fingerprint fingerprint containing readings at an unknown location
     *                    for provided located fingerprints.
     * @param sources located radio sources.
     * @param listener listener in charge of handling events.
     * @throws IllegalArgumentException if provided non located fingerprint is null,
     * located fingerprints value is null or there are not enough fingerprints or
     * readings within provided fingerprints (for 2D position estimation at least 2
     * located total readings are required among all fingerprints, for example 2
     * readings are required in a single fingerprint, or at least 2 fingerprints at
     * different locations containing a single reading are required. For 3D position
     * estimation 3 located total readings are required among all fingerprints).
     */
    public SourcedRssiPositionEstimator(List&lt;? extends RssiFingerprintLocated&lt;? extends RadioSource,
            ? extends RssiReading&lt;? extends RadioSource&gt;, P&gt;&gt; locatedFingerprints,
            RssiFingerprint&lt;? extends RadioSource,
            ? extends RssiReading&lt;? extends RadioSource&gt;&gt; fingerprint,
            List&lt;? extends RadioSourceLocated&lt;P&gt;&gt; sources,
            SourcedRssiPositionEstimatorListener&lt;P&gt; listener) {
<span class="fc" id="L127">        super(locatedFingerprints, fingerprint, listener);</span>
<span class="fc" id="L128">        internalSetSources(sources);</span>
<span class="fc" id="L129">    }</span>

    /**
     * Gets located radio sources.
     * @return located radio sources.
     */
    public List&lt;? extends RadioSourceLocated&lt;P&gt;&gt; getSources() {
<span class="fc" id="L136">        return mSources;</span>
    }

    /**
     * Sets located radio sources.
     * @param sources located radio sources.
     * @throws LockedException if estimator is locked.
     */
    public void setSources(List&lt;? extends RadioSourceLocated&lt;P&gt;&gt; sources)
            throws LockedException  {
<span class="fc bfc" id="L146" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L147">            throw new LockedException();</span>
        }

<span class="fc" id="L150">        internalSetSources(sources);</span>
<span class="fc" id="L151">    }</span>

    /**
     * Indicates whether path loss exponent of provided sources must be used when
     * available (if true), or if fallback path loss exponent must be used instead.
     * @return true to use path loss exponent of provided sources when available,
     * false otherwise.
     */
    public boolean getUseSourcesPathLossExponentWhenAvailable() {
<span class="fc" id="L160">        return mUseSourcesPathLossExponentWhenAvailable;</span>
    }

    /**
     * Specifies whether path loss exponent of provided sources must be used when
     * available (if true), or if fallback path loss exponent must be used instead.
     * @param useSourcesPathLossExponentWhenAvailable true to use path loss exponent of
     *                                                provided sources when available,
     *                                                false otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setUseSourcesPathLossExponentWhenAvailable(
            boolean useSourcesPathLossExponentWhenAvailable) throws LockedException {
<span class="fc bfc" id="L173" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L174">            throw new LockedException();</span>
        }
<span class="fc" id="L176">        mUseSourcesPathLossExponentWhenAvailable =</span>
                useSourcesPathLossExponentWhenAvailable;
<span class="fc" id="L178">    }</span>

    /**
     * Indicates which fingerprint finder is used.
     * True indicates that mean effects are removed to find nearest located fingerprints
     * based on RSSI readings. False indicates that RSSI readings are directly used, which
     * might be inaccurate due to bias effects on new fingerprint readings for unknown
     * locations.
     * By default mean effects are removed to remove possible bias effects due to
     * readings measured by different devices with different hardware.
     * @return indicates which fingerprint finder is used.
     */
    public boolean getUseNoMeanNearestFingerprintFinder() {
<span class="fc" id="L191">        return mUseNoMeanNearestFingerprintFinder;</span>
    }

    /**
     * Specifies which fingerprint finder is used.
     * True indicates that mean effects are removed to find nearest located fingerprints
     * based on RSSI readings. False indicates that RSSI readings are directly used, which
     * might be inaccurate due to bias effects on new fingerprint readings for unknown
     * locations.
     * By default mean effects are removed to remove possible bias effects due to
     * readings measured by different devices with different hardware.
     * @param useNoMeanNearestFingerprintFinder indicates which fingerprint finder is used.
     * @throws LockedException if estimator is locked.
     */
    public void setUseNoMeanNearestFingerprintFinder(
            boolean useNoMeanNearestFingerprintFinder) throws LockedException {
<span class="pc bpc" id="L207" title="1 of 2 branches missed.">        if (isLocked()) {</span>
<span class="nc" id="L208">            throw new LockedException();</span>
        }
<span class="fc" id="L210">        mUseNoMeanNearestFingerprintFinder = useNoMeanNearestFingerprintFinder;</span>
<span class="fc" id="L211">    }</span>

    /**
     * Indicates whether mean effects are removed from fingerprints.
     * True indicates that mean effects are removed from located fingerprints and from
     * new fingerprints whose location is unknown.
     * By default this is enabled to remove possible bias effects due to readings
     * measured by different devices with different hardware.
     * @return true to remove mean effects, false otherwise.
     */
    public boolean isMeansFromFingerprintReadingsRemoved() {
<span class="fc" id="L222">        return mRemoveMeansFromFingerprintReadings;</span>
    }

    /**
     * Specifies whether mean effects are removed from fingerprints.
     * True indicates that mean effects are removed from located fingerprints and from
     * new fingerprints whose location is unknown.
     * By default this is enabled to remove possible bias effects due to readings
     * measured by different devices with different hardware.
     * @param removeMeansFromFingerprintReadings true to remove mean effects, false otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setMeansFromFingerprintReadingsRemoved(
            boolean removeMeansFromFingerprintReadings) throws LockedException {
<span class="pc bpc" id="L236" title="1 of 2 branches missed.">        if (isLocked()) {</span>
<span class="nc" id="L237">            throw new LockedException();</span>
        }
<span class="fc" id="L239">        mRemoveMeansFromFingerprintReadings = removeMeansFromFingerprintReadings;</span>
<span class="fc" id="L240">    }</span>

    /**
     * Indicates whether estimator is ready to find a solution.
     * @return true if estimator is ready, false otherwise.
     */
    @Override
    public boolean isReady() {
<span class="pc bpc" id="L248" title="2 of 6 branches missed.">        return mSources != null &amp;&amp; mLocatedFingerprints != null &amp;&amp;</span>
                mFingerprint != null;
    }

    /**
     * Estimates position based on provided located radio sources and readings of such radio sources at
     * an unknown location.
     * @throws LockedException if estimator is locked.
     * @throws NotReadyException if estimator is not ready.
     * @throws PositionEstimationException if estimation fails for some other reason.
     */
    public void estimate() throws LockedException, NotReadyException,
            PositionEstimationException {

<span class="pc bpc" id="L262" title="1 of 2 branches missed.">        if (!isReady()) {</span>
<span class="nc" id="L263">            throw new NotReadyException();</span>
        }
<span class="fc bfc" id="L265" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L266">            throw new LockedException();</span>
        }

        try {
<span class="fc" id="L270">            mLocked = true;</span>

<span class="pc bpc" id="L272" title="1 of 2 branches missed.">            if (mListener != null) {</span>
<span class="fc" id="L273">                mListener.onEstimateStart(this);</span>
            }

<span class="fc" id="L276">            RadioSourceNoMeanKNearestFinder&lt;P, RadioSource&gt; noMeanfinder = null;</span>
<span class="fc" id="L277">            RadioSourceKNearestFinder&lt;P, RadioSource&gt; finder = null;</span>
<span class="fc bfc" id="L278" title="All 2 branches covered.">            if (mUseNoMeanNearestFingerprintFinder) {</span>
                //noinspection unchecked
<span class="fc" id="L280">                noMeanfinder = new RadioSourceNoMeanKNearestFinder&lt;&gt;(</span>
                        (Collection&lt;? extends RssiFingerprintLocated&lt;RadioSource,
                        RssiReading&lt;RadioSource&gt;, P&gt;&gt;)mLocatedFingerprints);
            } else {
                //noinspection unchecked
<span class="fc" id="L285">                finder = new RadioSourceKNearestFinder&lt;&gt;(</span>
                        (Collection&lt;? extends RssiFingerprintLocated&lt;RadioSource,
                        RssiReading&lt;RadioSource&gt;, P&gt;&gt;)mLocatedFingerprints);
            }

<span class="fc" id="L290">            mEstimatedPositionCoordinates = null;</span>
<span class="fc" id="L291">            mNearestFingerprints = null;</span>

<span class="fc" id="L293">            int dims = getNumberOfDimensions();</span>
<span class="pc bpc" id="L294" title="1 of 2 branches missed.">            int max = mMaxNearestFingerprints &lt; 0 ?</span>
<span class="pc" id="L295">                    mLocatedFingerprints.size() : mMaxNearestFingerprints;</span>
<span class="pc bpc" id="L296" title="1 of 2 branches missed.">            for (int k = mMinNearestFingerprints; k &lt; max; k++) {</span>

<span class="fc bfc" id="L298" title="All 2 branches covered.">                if (noMeanfinder != null) {</span>
                    //noinspection unchecked
<span class="fc" id="L300">                    mNearestFingerprints = noMeanfinder.findKNearestTo(</span>
                            (RssiFingerprint&lt;RadioSource, RssiReading&lt;RadioSource&gt;&gt;) mFingerprint, k);
                } else {
                    //noinspection unchecked
<span class="fc" id="L304">                    mNearestFingerprints = finder.findKNearestTo(</span>
                            (RssiFingerprint&lt;RadioSource, RssiReading&lt;RadioSource&gt;&gt;) mFingerprint, k);
                }

                //Demonstration in 2D:
                //--------------------
                //Taylor series expansion can be expressed as:
                //f(x) = f(a) + 1/1!*f'(a)*(x - a) + 1/2!*f''(a)*(x - a)^2 + ...

                //where f'(x) is the derivative of f respect x, which can also be expressed as:
                //f'(x) = diff(f(x))/diff(x)

                //and f'(a) is the derivative of f respect x evaluated at a, which can be expressed
                //as f'(a) = diff(f(a))/diff(x)

                //consequently f''(a) is the second derivative respect x evaluated at a, which can
                //be expressed as:
                //f''(x) = diff(f(x))/diff(x^2)

                //and:
                //f''(a) = diff(f(a))/diff(x^2)

                //Received power expressed in dBm is:
                //k = (c/(4*pi*f))
                //Pr = Pte*k^n / d^n

                //where c is the speed of light, pi is 3.14159..., f is the frequency of the radio source,
                //Pte is the equivalent transmitted power by the radio source, n is the path-loss exponent
                // (typically 2.0), and d is the distance from a point to the location of the radio source.

                //Hence:
                //Pr(dBm) = 10*log(Pte*k^n/d^n) = 10*n*log(k) + 10*log(Pte) - 10*n*log(d) =
                //          10*n*log(k) + 10*log(Pte) - 5*n*log(d^2)

                //The former 2 terms are constant, and only the last terms depends on distance

                //Hence, assuming the constant K = 10*n*log(k) + Pte(dBm), where Pte(dBm) = 10*log(Pte),
                //assuming that transmitted power by the radio source Pte is known (so that K is also known),
                //and assuming that the location of the radio source is known and it is located at pa = (xa, ya)
                //so that d^2 = (x - xa)^2 + (y - ya)^2 then the received power at an unknown point pi = (xi, yi) is:

                //Pr(pi) = Pr(xi,yi) = K - 5*n*log(d^2) = K - 5*n*log((xi - xa)^2 + (yi - ya)^2)

                //Suppose that received power at point p1=(x1,y1) is known on a located fingerprint
                //containing readings Pr(p1).

                //Then, for an unknown point pi=(xi,yi) close to fingerprint 1 located at p1 where we
                //have measured received power Pr(pi), we can get the following second-order Taylor
                //approximation:

                //Pr(pi) ~ Pr(p1) + JPtr(p1)*(pi - p1) + 1/2*(pi - p1)^T*HPr(p1)*(pi - p1) + ...

                //where JPr(p1) is the Jacobian of Pr evaluated at p1. Since Pr is a multivariate function
                //with scalar result, the Jacobian has size 1x2 and is equal to the gradient.
                //HPtr(p1) is the Hessian matrix evaluated at p1, which is a symmetric matrix of size 2x2,
                //and (pi-p1)^T is the transposed vector of (pi-p1)

                //Hence, the Jacobian at any point p=(x,y) is equal to:
                //JPr(p = (x,y)) = [diff(Pr(x,y))/diff(x)   diff(Pr(x,y))/diff(y)]

                //And the Heassian matrix is equal to
                //HPr(p = (x,y)) =  [diff(Pr(x,y))/diff(x^2)    diff(Pr(x,y))/diff(x*y)]
                //                  [diff(Pr(x,y))/diff(x*y)    diff(Pr(x,y))/diff(y^2)]

                //Simplifying Taylor expansion to first-order terms to get a linear (but less accurate)
                //solution, we get:
                //Pr(pi) = Pr(p1) + JPtr(p1)*(pi - p1)
                //Pr(pi) = Pr(p1) + diff(Pr(p1))/diff(x)*(xi - x1) + diff(Pr(p1))/diff(y)*(yi - y1)

                //where the first order derivatives of Pr(p = (x,y)) are:
                //diff(Pr(x,y))/diff(x) = -5*n/(ln(10)*((x - xa)^2 + (y - ya)^2)*2*(x - xa)
                //diff(Pr(x,y))/diff(x) = -10*n*(x - xa)/(ln(10)*((x - xa)^2 + (y - ya)^2))

                //diff(Pr(x,y))/diff(y) = -5*n/(ln(10)*((x - xa)^2 + (y - ya)^2)*2*(y - ya)
                //diff(Pr(x,y))/diff(y) = -10*n*(y - ya)/(ln(10)*((x - xa)^2 + (y - ya)^2))

                //If we evaluate derivatives at p1 = (x1,y1), we get:
                //diff(Pr(p1))/diff(x) = -10*n*(x1 - xa)/(ln(10)*((x1 - xa)^2 + (y1 - ya)^2))
                //diff(Pr(p1))/diff(y) = -10*n*(y1 - ya)/(ln(10)*((x1 - xa)^2 + (y1 - ya)^2))

                //where square distance from fingerprint 1 to radio source a can be expressed as:
                //d1a^2 = (x1 - xa)^2 + (y1 - ya)^2

                //where both the fingerprint and radio source positions are known, and hence d1a is known.

                //Then derivatives can be expressed as:
                //diff(Pr(p1))/diff(x) = -10*n*(x1 - xa)/(ln(10)*d1a^2)
                //diff(Pr(p1))/diff(y) = -10*n*(y1 - ya)/(ln(10)*d1a^2)

                //Hence, first order Taylor expansion can be expressed as:
                //Pr(pi) = Pr(p1) + diff(Pr(p1))/diff(x)*(xi - x1) + diff(Pr(p1))/diff(y)*(yi - y1)
                //Pr(pi) = Pr(p1) - 10*n*(x1 - xa)/(ln(10)*d1a^2)*(xi - x1) - 10*n*(y1 - ya)/(ln(10)*d1a^2)*(yi - y1)

                //where the only unknowns are xi,yi.

                //Reordering expression above, we get:
                //10*n*(x1 - xa)/(ln(10)*d1a^2)*xi + 10*n*(y1 - ya)/(ln(10)*d1a^2)*yi = Pr(p1) - Pr(pi) + 10*n*(x1 - xa)/(ln(10)*d1a^2)*x1 + 10*n*(y1 - ya)/(ln(10)*d1a^2)*y1

                //Which can be expressed in matrix form as:
                //[10*n*(x1 - xa)/(ln(10)*d1a^2)    10*n*(y1 - ya)/(ln(10)*d1a^2)]  [xi] = [Pr(p1) - Pr(pi) + 10*n*(x1 - xa)/(ln(10)*d1a^2)*x1 + 10*n*(y1 - ya)/(ln(10)*d1a^2)*y1]
                //                                                                  [yi]

                //which is the equation obtained for fingerprint 1 and radio source a.

                //Having at least 2 linear independent equations for different fingerprints or radio sources allows
                //solving unknown position pi = (xi,yi)
                //Hence we could have either 2 or more located fingerprints with 1 radio sources, 2 or more radio
                //sources on a single located fingerprint, or any combination resulting in enough equations


                //Demonstration in 3D:
                //--------------------
                //Taylor series expansion can be expressed as:
                //f(x) = f(a) + 1/1!*f'(a)*(x - a) + 1/2!*f''(a)*(x - a)^2 + ...

                //where f'(x) is the derivative of f respect x, which can also be expressed as:
                //f'(x) = diff(f(x))/diff(x)

                //and f'(a) is the derivative of f respect x evaluated at a, which can be expressed
                //as f'(a) = diff(f(a))/diff(x)

                //consequently f''(a) is the second derivative respect x evaluated at a, which can
                //be expressed as:
                //f''(x) = diff(f(x))/diff(x^2)

                //and:
                //f''(a) = diff(f(a))/diff(x^2)

                //Received power expressed in dBm is:
                //k = (c/(4*pi*f))
                //Pr = Pte*k^n / d^n

                //where c is the speed of light, pi is 3.14159..., f is the frequency of the radio source,
                //Pte is the equivalent transmitted power by the radio source, n is the path-loss exponent
                // (typically 2.0), and d is the distance from a point to the location of the radio source.

                //Hence:
                //Pr(dBm) = 10*log(Pte*k^n/d^n) = 10*n*log(k) + 10*log(Pte) - 10*n*log(d) =
                //          10*n*log(k) + 10*log(Pte) - 5*n*log(d^2)

                //The former 2 terms are constant, and only the last terms depends on distance

                //Hence, assuming the constant K = 10*n*log(k) + Pte(dBm), where Pte(dBm) = 10*log(Pte),
                //assuming that transmitted power by the radio source Pte is known (so that K is also known),
                //and assuming that the location of the radio source is known and it is located at pa = (xa, ya, za)
                //so that d^2 = (x - xa)^2 + (y - ya)^2 + (z - za)^2 then the received power at an unknown point
                //pi = (xi, yi, zi) is:

                //Pr(pi) = Pr(xi,yi,zi) = K - 5*n*log(d^2) = K - 5*n*log((xi - xa)^2 + (yi - ya)^2 + (zi - za)^2)

                //Suppose that received power at point p1=(x1,y1,z1) is known on a located fingerprint
                //containing readings Pr(p1).

                //Then, for an unknown point pi=(xi,yi,zi) close to fingerprint 1 located at p1 where we
                //have measured received power Pr(pi), we can get the following second-order Taylor
                //approximation:

                //Pr(pi) ~ Pr(p1) + JPtr(p1)*(pi - p1) + 1/2*(pi - p1)^T*HPr(p1)*(pi - p1) + ...

                //where JPr(p1) is the Jacobian of Pr evaluated at p1. Since Pr is a multivariate function
                //with scalar result, the Jacobian has size 1x3 and is equal to the gradient.
                //HPtr(p1) is the Hessian matrix evaluated at p1, which is a symmetric matrix of size 3x3,
                //and (pi-p1)^T is the transposed vector of (pi-p1)

                //Hence, the Jacobian at any point p=(x,y) is equal to:
                //JPr(p = (x,y)) = [diff(Pr(x,y,z))/diff(x)     diff(Pr(x,y,z))/diff(y)     diff(Pr(x,y,z))/diff(z)]

                //And the Heassian matrix is equal to
                //HPr(p = (x,y)) =  [diff(Pr(x,y,z))/diff(x^2)    diff(Pr(x,y,z))/diff(x*y)     diff(Pr(x,y,z))/diff(x*z)]
                //                  [diff(Pr(x,y,z))/diff(x*y)    diff(Pr(x,y,z))/diff(y^2)     diff(Pr(x,y,z))/diff(y*z)]
                //                  [diff(Pr(x,y,z))/diff(x*z)    diff(Pr(x,y,z))/diff(y*z)     diff(Pr(x,y,z))/diff(z^2)]

                //Simplifying Taylor expansion to first-order terms to get a linear (but less accurate)
                //solution, we get:
                //Pr(pi) = Pr(p1) + JPtr(p1)*(pi - p1)
                //Pr(pi) = Pr(p1) + diff(Pr(p1))/diff(x)*(xi - x1) + diff(Pr(p1))/diff(y)*(yi - y1) + diff(Pr(p1))/diff(z)*(zi - z1)

                //where the first order derivatives of Pr(p = (x,y,z)) are:
                //diff(Pr(x,y,z))/diff(x) = -5*n/(ln(10)*((x - xa)^2 + (y - ya)^2 + (z - za)^2)*2*(x - xa)
                //diff(Pr(x,y,z))/diff(x) = -10*n*(x - xa)/(ln(10)*((x - xa)^2 + (y - ya)^2 + (z - za)^2))

                //diff(Pr(x,y,z))/diff(y) = -5*n/(ln(10)*((x - xa)^2 + (y - ya)^2 + (z - za)^2)*2*(y - ya)
                //diff(Pr(x,y,z))/diff(y) = -10*n*(y - ya)/(ln(10)*((x - xa)^2 + (y - ya)^2 + (z - za)^2))

                //diff(Pr(x,y,z))/diff(z) = -5*n/(ln(10)*((x - xa)^2 + (y - ya)^2 + (z - za)^2)*2*(z - za)
                //diff(Pr(x,y,z))/diff(z) = -10*n*(z - za)/(ln(10)*((x - xa)^2 + (y - ya)^2 + (z - za)^2))

                //If we evaluate derivatives at p1 = (x1,y1,z1), we get:
                //diff(Pr(p1))/diff(x) = -10*n*(x1 - xa)/(ln(10)*((x1 - xa)^2 + (y1 - ya)^2 + (z1 - za)^2))
                //diff(Pr(p1))/diff(y) = -10*n*(y1 - ya)/(ln(10)*((x1 - xa)^2 + (y1 - ya)^2 + (z1 - za)^2))
                //diff(Pr(p1))/diff(z) = -10*n*(z1 - za)/(ln(10)*((x1 - xa)^2 + (y1 - ya)^2 + (z1 - za)^2))

                //where square distance from fingerprint 1 to radio source a can be expressed as:
                //d1a^2 = (x1 - xa)^2 + (y1 - ya)^2 + (z1 - za)^2

                //where both the fingerprint and radio source positions are known, and hence d1a is known.

                //Then derivatives can be expressed as:
                //diff(Pr(p1))/diff(x) = -10*n*(x1 - xa)/(ln(10)*d1a^2)
                //diff(Pr(p1))/diff(y) = -10*n*(y1 - ya)/(ln(10)*d1a^2)
                //diff(Pr(p1))/diff(z) = -10*n*(z1 - za)/(ln(10)*d1a^2)

                //Hence, first order Taylor expansion can be expressed as:
                //Pr(pi) = Pr(p1) + diff(Pr(p1))/diff(x)*(xi - x1) + diff(Pr(p1))/diff(y)*(yi - y1) + diff(Pr(p1))/diff(z)*(zi - z1)
                //Pr(pi) = Pr(p1) - 10*n*(x1 - xa)/(ln(10)*d1a^2)*(xi - x1) - 10*n*(y1 - ya)/(ln(10)*d1a^2)*(yi - y1) - 10*n*(z1 - za)/(ln(10)*d1a^2)*(zi - z1)

                //where the only unknowns are xi,yi,zi.

                //Reordering expression above, we get:
                //10*n*(x1 - xa)/(ln(10)*d1a^2)*xi + 10*n*(y1 - ya)/(ln(10)*d1a^2)*yi + 10*n*(z1 - za)/(ln(10)*d1a^2)*zi = Pr(p1) - Pr(pi) + 10*n*(x1 - xa)/(ln(10)*d1a^2)*x1 + 10*n*(y1 - ya)/(ln(10)*d1a^2)*y1 + 10*n*(z1 - za)/(ln(10)*d1a^2)*z1

                //Which can be expressed in matrix form as:
                //[10*n*(x1 - xa)/(ln(10)*d1a^2)    10*n*(y1 - ya)/(ln(10)*d1a^2)   10*n*(z1 - za)/(ln(10)*d1a^2)]  [xi] = [Pr(p1) - Pr(pi) + 10*n*(x1 - xa)/(ln(10)*d1a^2)*x1 + 10*n*(y1 - ya)/(ln(10)*d1a^2)*y1 + 10*n*(z1 - za)/(ln(10)*d1a^2)*z1]
                //                                                                                                  [yi]
                //                                                                                                  [zi]

                //which is the equation obtained for fingerprint 1 and radio source a.

                //Having at least 3 linear independent equations for different fingerprints or radio sources allows
                //solving unknown position pi = (xi,yi,zi)
                //Hence we could have either 3 or more located fingerprints with 1 radio sources, 3 or more radio
                //sources on a single located fingerprint, or any combination resulting in enough equations


                //build system of equations
<span class="fc" id="L529">                int totalReadings = totalReadings(mNearestFingerprints);</span>

                try {
<span class="fc" id="L532">                    double ln10 = Math.log(10.0);</span>
<span class="fc" id="L533">                    int row = 0;</span>
<span class="fc" id="L534">                    Matrix a = new Matrix(totalReadings, dims);</span>
<span class="fc" id="L535">                    double[] b = new double[totalReadings];</span>
                    for (RssiFingerprintLocated&lt;RadioSource, RssiReading&lt;RadioSource&gt;, P&gt; locatedFingerprint :
<span class="fc bfc" id="L537" title="All 2 branches covered.">                            mNearestFingerprints) {</span>

<span class="fc" id="L539">                        P fingerprintPosition = locatedFingerprint.getPosition();</span>
<span class="fc" id="L540">                        List&lt;RssiReading&lt;RadioSource&gt;&gt; locatedReadings =</span>
<span class="fc" id="L541">                                locatedFingerprint.getReadings();</span>
<span class="pc bpc" id="L542" title="1 of 2 branches missed.">                        if (locatedReadings == null) {</span>
<span class="nc" id="L543">                            continue;</span>
                        }

<span class="fc" id="L546">                        double locatedMeanRssi = 0.0;</span>
<span class="fc" id="L547">                        double meanRssi = 0.0;</span>
<span class="fc bfc" id="L548" title="All 2 branches covered.">                        if (mRemoveMeansFromFingerprintReadings) {</span>
<span class="fc" id="L549">                            locatedMeanRssi = locatedFingerprint.getMeanRssi();</span>
                        }


<span class="fc bfc" id="L553" title="All 2 branches covered.">                        for (RssiReading&lt;RadioSource&gt; locatedReading : locatedReadings) {</span>
<span class="fc" id="L554">                            RadioSource source = locatedReading.getSource();</span>

                            //find within the list of located sources the source of
                            //current located fingerprint reading.
                            //Radio sources are compared by their id
                            //regardless of them being located or not
                            @SuppressWarnings(&quot;SuspiciousMethodCalls&quot;)
<span class="fc" id="L561">                            int pos = mSources.indexOf(source);</span>
<span class="pc bpc" id="L562" title="1 of 2 branches missed.">                            if (pos &lt; 0) {</span>
<span class="nc" id="L563">                                continue;</span>
                            }

<span class="fc" id="L566">                            RadioSourceLocated&lt;P&gt; locatedSource = mSources.get(pos);</span>
<span class="fc" id="L567">                            double pathLossExponent = mPathLossExponent;</span>
<span class="pc bpc" id="L568" title="1 of 4 branches missed.">                            if (mUseSourcesPathLossExponentWhenAvailable &amp;&amp;</span>
                                    locatedSource instanceof RadioSourceWithPower) {
<span class="fc" id="L570">                                pathLossExponent = ((RadioSourceWithPower)locatedSource).</span>
<span class="fc" id="L571">                                        getPathLossExponent();</span>
                            }

<span class="fc" id="L574">                            double tmp = 10.0 * pathLossExponent / ln10;</span>

<span class="fc" id="L576">                            P sourcePosition = locatedSource.getPosition();</span>
<span class="fc" id="L577">                            double locatedRssi = locatedReading.getRssi();</span>
                            //noinspection unchecked
<span class="fc" id="L579">                            double sqrDistance = fingerprintPosition.sqrDistanceTo(sourcePosition);</span>
<span class="fc bfc" id="L580" title="All 2 branches covered.">                            if (mRemoveMeansFromFingerprintReadings) {</span>
<span class="fc" id="L581">                                meanRssi = mFingerprint.getMeanRssi();</span>
                            }

<span class="fc" id="L584">                            List&lt;? extends RssiReading&lt;? extends RadioSource&gt;&gt; readings =</span>
<span class="fc" id="L585">                                    mFingerprint.getReadings();</span>
<span class="fc bfc" id="L586" title="All 2 branches covered.">                            for (RssiReading&lt;? extends RadioSource&gt; reading : readings) {</span>
<span class="pc bpc" id="L587" title="1 of 2 branches missed.">                                if (reading.getSource() == null ||</span>
<span class="fc bfc" id="L588" title="All 2 branches covered.">                                        !reading.getSource().equals(locatedSource)) {</span>
<span class="fc" id="L589">                                    continue;</span>
                                }

                                //only take into account reading for matching sources on located and
                                //non-located readings
<span class="fc" id="L594">                                double rssi = reading.getRssi();</span>

                                //ideally if there was no bias betweeen devices RSSI measures, we should compute:
                                //double diffRssi = locatedRssi - rssi;
                                //However, to account for possible biases, we remove mean of fingerprints from
                                //both readings (ideally both should be equal, but they will only be approximate in
                                // practice).
                                //double diffRssi = (locatedRssi - locatedMeanRssi) - (rssi - meanRssi);
                                double diffRssi;
<span class="fc bfc" id="L603" title="All 2 branches covered.">                                if (mRemoveMeansFromFingerprintReadings) {</span>
<span class="fc" id="L604">                                    diffRssi = (locatedRssi - locatedMeanRssi) - (rssi - meanRssi);</span>
                                } else {
<span class="fc" id="L606">                                    diffRssi = locatedRssi - rssi;</span>
                                }

<span class="fc" id="L609">                                b[row] = diffRssi;</span>
<span class="fc bfc" id="L610" title="All 2 branches covered.">                                for (int i = 0; i &lt; dims; i++) {</span>
<span class="fc" id="L611">                                    double fingerprintCoord = fingerprintPosition.getInhomogeneousCoordinate(i);</span>
<span class="fc" id="L612">                                    double sourceCoord = sourcePosition.getInhomogeneousCoordinate(i);</span>
<span class="fc" id="L613">                                    double diffCoord = fingerprintCoord - sourceCoord;</span>

<span class="fc" id="L615">                                    a.setElementAt(row, i, tmp * diffCoord / sqrDistance);</span>

<span class="fc" id="L617">                                    b[row] += tmp * diffCoord / sqrDistance * fingerprintCoord;</span>
                                }
<span class="fc" id="L619">                                row++;</span>
<span class="fc" id="L620">                            }</span>
<span class="fc" id="L621">                        }</span>
<span class="fc" id="L622">                    }</span>

<span class="fc" id="L624">                    mEstimatedPositionCoordinates = com.irurueta.algebra.Utils.solve(a, b);</span>

                    //a solution was found so we exit loop
<span class="fc" id="L627">                    break;</span>
<span class="fc" id="L628">                } catch (AlgebraException e) {</span>
                    //solution could not be found with current data
                    //Iterate to use additional nearby fingerprints
<span class="fc" id="L631">                    mEstimatedPositionCoordinates = null;</span>
                }
            }

<span class="pc bpc" id="L635" title="1 of 2 branches missed.">            if (mEstimatedPositionCoordinates == null) {</span>
                //no solution could be found
<span class="nc" id="L637">                throw new PositionEstimationException();</span>
            }

<span class="pc bpc" id="L640" title="1 of 2 branches missed.">            if (mListener != null) {</span>
<span class="fc" id="L641">                mListener.onEstimateEnd(this);</span>
            }
        } finally {
<span class="fc" id="L644">            mLocked = false;</span>
        }
<span class="fc" id="L646">    }</span>

    /**
     * Internally sets located radio sources.
     * @param sources located radio sources.
     * @throws IllegalArgumentException if provided value is null.
     */
    private void internalSetSources(List&lt;? extends RadioSourceLocated&lt;P&gt;&gt; sources) {
<span class="fc bfc" id="L654" title="All 2 branches covered.">        if (sources == null) {</span>
<span class="fc" id="L655">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L658">        mSources = sources;</span>
<span class="fc" id="L659">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>