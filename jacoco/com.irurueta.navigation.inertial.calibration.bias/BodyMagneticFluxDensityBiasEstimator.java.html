<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>BodyMagneticFluxDensityBiasEstimator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.irurueta:irurueta-navigation</a> &gt; <a href="index.source.html" class="el_package">com.irurueta.navigation.inertial.calibration.bias</a> &gt; <span class="el_source">BodyMagneticFluxDensityBiasEstimator.java</span></div><h1>BodyMagneticFluxDensityBiasEstimator.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2020 Alberto Irurueta Carro (alberto@irurueta.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.irurueta.navigation.inertial.calibration.bias;

import com.irurueta.geometry.Point3D;
import com.irurueta.navigation.LockedException;
import com.irurueta.navigation.frames.CoordinateTransformation;
import com.irurueta.navigation.frames.ECEFFrame;
import com.irurueta.navigation.frames.FrameType;
import com.irurueta.navigation.frames.InvalidSourceAndDestinationFrameTypeException;
import com.irurueta.navigation.frames.NEDFrame;
import com.irurueta.navigation.frames.converters.ECEFtoNEDFrameConverter;
import com.irurueta.navigation.frames.converters.NEDtoECEFFrameConverter;
import com.irurueta.navigation.geodesic.wmm.WMMEarthMagneticFluxDensityEstimator;
import com.irurueta.navigation.geodesic.wmm.WorldMagneticModel;
import com.irurueta.navigation.inertial.BodyMagneticFluxDensity;
import com.irurueta.navigation.inertial.ECEFPosition;
import com.irurueta.navigation.inertial.NEDMagneticFluxDensity;
import com.irurueta.navigation.inertial.NEDPosition;
import com.irurueta.navigation.inertial.calibration.MagneticFluxDensityTriad;
import com.irurueta.navigation.inertial.estimators.BodyMagneticFluxDensityEstimator;
import com.irurueta.units.Angle;
import com.irurueta.units.Distance;
import com.irurueta.units.MagneticFluxDensity;
import com.irurueta.units.MagneticFluxDensityUnit;
import com.irurueta.units.Time;
import com.irurueta.units.TimeConverter;
import com.irurueta.units.TimeUnit;

import java.io.IOException;
import java.util.Date;
import java.util.GregorianCalendar;

/**
 * Approximately estimated magnetometer biases (hard iron) and noise PSD's by
 * averaging all provided samples when instant, body position and orientation
 * is known while assuming that any soft iron cross coupling errors can be
 * neglected.
 * &lt;p&gt;
 * The estimator must be used when the body where the magnetometer is attached to
 * remains static on the same position with zero velocity and no rotation speed
 * while capturing data.
 * &lt;p&gt;
 * To compute PSD's this estimator assumes that magnetometer samples are obtained at
 * a constant provided rate equal to {@link #getTimeInterval()} seconds.
 * If not available, magnetometer sampling rate average can be estimated using
 * {@link com.irurueta.navigation.inertial.calibration.TimeIntervalEstimator}.
 * &lt;p&gt;
 * Notice that in order to compute magnetometer biases (hard iron), instant, body
 * position and orientation must be known to account for expected magnetic field
 * to be sensed.
 * &lt;p&gt;
 * Even though this estimator obtains approximate bias values, the obtained
 * result can be used to initialize some non-linear calibrators to obtain
 * more accurate results, by using bias values as initial hard iron values.
 * Such calibrators are:
 * - {@link com.irurueta.navigation.inertial.calibration.magnetometer.KnownFrameMagnetometerNonLinearLeastSquaresCalibrator}
 * - {@link com.irurueta.navigation.inertial.calibration.magnetometer.KnownPositionAndInstantMagnetometerCalibrator}
 * - {@link com.irurueta.navigation.inertial.calibration.magnetometer.RobustKnownFrameMagnetometerCalibrator} and any
 * of its subclasses.
 * - {@link com.irurueta.navigation.inertial.calibration.magnetometer.RobustKnownPositionAndInstantMagnetometerCalibrator}
 * and any of its subclasses.
 * &lt;p&gt;
 * Even though this estimator can compute noise PSD's, if only noise PSD's levels
 * are required, estimators in {@link com.irurueta.navigation.inertial.calibration.noise} package should
 * be used instead.
 * &lt;p&gt;
 * This estimator does NOT compute average bias values over a period of time, it only
 * computes accumulated averages.
 * &lt;p&gt;
 */
public class BodyMagneticFluxDensityBiasEstimator {

    /**
     * Default time interval between accelerometer samples expressed in seconds (s).
     */
    public static final double DEFAULT_TIME_INTERVAL_SECONDS = 0.02;

    /**
     * Time interval expressed in seconds (s) between body kinematics samples.
     */
<span class="fc" id="L95">    private double mTimeInterval = DEFAULT_TIME_INTERVAL_SECONDS;</span>

    /**
     * Contains body position, velocity (which will always be zero) and orientation
     * resolved around ECEF axes.
     * By default it is assumed that body is located at zero NED coordinates (latitude,
     * longitude and height) and with zero Euler angles representing rotation (roll = 0,
     * pith = 0, yaw = 0), which for Android devices it means that the device is flat
     * on a horizontal surface with the screen facing down.
     */
    private final ECEFFrame mFrame;

    /**
     * Contains year expressed in decimal format.
     */
    private double mYear;

    /**
     * Listener to handle events raised by this estimator.
     */
    private BodyMagneticFluxDensityBiasEstimatorListener mListener;

    /**
     * Contains Earth's magnetic model.
     */
    private WorldMagneticModel mMagneticModel;

    /**
     * World Magnetic Model of Earth.
     */
    private WMMEarthMagneticFluxDensityEstimator mWmmEstimator;

    /**
     * Last provided body magnetic flux density values.
     */
    private BodyMagneticFluxDensity mLastBodyMagneticFluxDensity;

    /**
     * Contains estimated bias of x coordinate of body magnetic flux density
     * expressed in Teslas (T). Notice that bias is equivalent to hard iron
     * component on a magnetometer calibrator.
     */
    private double mBiasX;

    /**
     * Contains estimated bias of y coordinate of body magnetic flux density
     * expressed in Teslas (T). Notice that bias is equivalent to hard iron
     * component on a magnetometer calibrator.
     */
    private double mBiasY;

    /**
     * Contains estimated bias of z coordinate of body magnetic flux density
     * expressed in Teslas (T). Notice that bias is equivalent to hard iron
     * component on a magnetometer calibrator.
     */
    private double mBiasZ;

    /**
     * Contains estimated variance of x coordinate of body magnetic flux density
     * expressed in squared Teslas (T^2).
     */
    private double mVarianceX;

    /**
     * Contains estimated variance of y coordinate of body magnetic flux density
     * expressed in squared Teslas (T^2).
     */
    private double mVarianceY;

    /**
     * Contains estimated variance of z coordinate of body magnetic flux density
     * expressed in squared Teslas (T^2).
     */
    private double mVarianceZ;

    /**
     * Number of processed magnetometer samples.
     */
    private int mNumberOfProcessedSamples;

    /**
     * Number of processed magnetometer samples plus one.
     */
<span class="fc" id="L179">    private int mNumberOfProcessedSamplesPlusOne = 1;</span>

    /**
     * Indicates that estimator is running.
     */
    private boolean mRunning;

    /**
     * Theoretical expected body magnetic flux density for provided instant,
     * body position and orientation, assuming that body remains at the same
     * position (zero velocity).
     * When body remains static, sensed magentic flux density will remain constant
     * for a few minutes respect to provided time instant.
     */
    private BodyMagneticFluxDensity mExpectedBodyMagneticFluxDensity;

    /**
     * Constructor.
     * It is assumed that body is located at zero NED coordinates (latitude = 0,
     * longitude = 0 and height = 0) and with zero Euler angles representing rotation
     * (roll = 0, pith = 0, yaw = 0), which for Android devices it means that the
     * device is flat on a horizontal surface with the screen facing down.
     * This constructor assumes that time is current time instant.
     *
     * @throws IOException if initialization of world magnetic model fails.
     */
    public BodyMagneticFluxDensityBiasEstimator()
            throws IOException {
<span class="fc" id="L207">        this(new Date(), (WorldMagneticModel) null);</span>
<span class="fc" id="L208">    }</span>

    /**
     * Constructor.
     * It is assumed that body is located at zero NED coordinates (latitude = 0,
     * longitude = 0, and height = 0) with provided orientation.
     * This constructor assumes that time is current time instant.
     *
     * @param nedC coordinate transformation from body to local navigation
     *             (NED) coordinates. This contains orientation respect the horizon
     *             at current body location.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not
     *                                                       from body to local
     *                                                       navigation coordinates.
     * @throws IOException                                   if initialization of
     *                                                       world magnetic model
     *                                                       fails.
     */
    public BodyMagneticFluxDensityBiasEstimator(
            final CoordinateTransformation nedC)
            throws InvalidSourceAndDestinationFrameTypeException, IOException {
<span class="fc" id="L230">        this(nedC, new Date(), (WorldMagneticModel) null);</span>
<span class="fc" id="L231">    }</span>

    /**
     * Constructor.
     * It is assumed that body has zero Euler angles representing rotation (roll = 0,
     * pitch = 0, yaw = 0) respect the horizon at provided body location.
     * For Android devices this means that the device is flat on a horizontal surface
     * with the screen facing down.
     * This constructor assumes that time is current time instant.
     *
     * @param latitude  latitude expressed in radians (rad).
     * @param longitude longitude expressed in radians (rad).
     * @param height    height expressed in meters (m).
     * @throws IOException if initialization of world magnetic model fails.
     */
    public BodyMagneticFluxDensityBiasEstimator(
            final double latitude, final double longitude, final double height)
            throws IOException {
<span class="fc" id="L249">        this(latitude, longitude, height, new Date(), (WorldMagneticModel) null);</span>
<span class="fc" id="L250">    }</span>

    /**
     * Constructor.
     * It is assumed that body has zero Euler angles representing rotation (roll = 0,
     * pitch = 0, yaw = 0) respect the horizon at provided body location.
     * For Android devices this means that the device is flat on a horizontal surface
     * with the screen facing down.
     * This constructor assumes that time is current time instant.
     *
     * @param latitude  latitude.
     * @param longitude longitude.
     * @param height    height expressed in meters (m).
     * @throws IOException if initialization of world magnetic model fails.
     */
    public BodyMagneticFluxDensityBiasEstimator(
            final Angle latitude, final Angle longitude, final double height)
            throws IOException {
<span class="fc" id="L268">        this(latitude, longitude, height, new Date(), (WorldMagneticModel) null);</span>
<span class="fc" id="L269">    }</span>

    /**
     * Constructor.
     * It is assumed that body has zero Euler angles representing rotation (roll = 0,
     * pitch = 0, yaw = 0) respect the horizon at provided body location.
     * For Android devices this means that the device is flat on a horizontal surface
     * with the screen facing down.
     * This constructor assumes that time is current time instant.
     *
     * @param latitude  latitude.
     * @param longitude longitude.
     * @param height    height.
     * @throws IOException if initialization of world magnetic model fails.
     */
    public BodyMagneticFluxDensityBiasEstimator(
            final Angle latitude, final Angle longitude, final Distance height)
            throws IOException {
<span class="fc" id="L287">        this(latitude, longitude, height, new Date(), (WorldMagneticModel) null);</span>
<span class="fc" id="L288">    }</span>

    /**
     * Constructor.
     * This constructor assumes that time is current time instant.
     *
     * @param position body position expressed in NED coordinates.
     * @param nedC     coordinate transformation from body to local navigation
     *                 (NED) coordinates. This contains orientation respect the
     *                 horizon at current body location.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not
     *                                                       from body to local
     *                                                       navigation coordinates.
     * @throws IOException                                   if initialization of
     *                                                       world magnetic model
     *                                                       fails.
     */
    public BodyMagneticFluxDensityBiasEstimator(
            final NEDPosition position, final CoordinateTransformation nedC)
            throws InvalidSourceAndDestinationFrameTypeException, IOException {
<span class="fc" id="L309">        this(position, nedC, new Date(), (WorldMagneticModel) null);</span>
<span class="fc" id="L310">    }</span>

    /**
     * Constructor.
     * This constructor assumes that time is current time instant.
     *
     * @param position body position expressed in ECEF coordinates.
     * @param nedC     coordinate transformation from body to local navigation
     *                 (NED) coordinates. This contains orientation respect the
     *                 horizon at current body location.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not
     *                                                       from body to local
     *                                                       navigation coordinates.
     * @throws IOException                                   if initialization of
     *                                                       world magnetic model
     *                                                       fails.
     */
    public BodyMagneticFluxDensityBiasEstimator(
            final ECEFPosition position, final CoordinateTransformation nedC)
            throws InvalidSourceAndDestinationFrameTypeException, IOException {
<span class="fc" id="L331">        this(position, nedC, new Date(), (WorldMagneticModel) null);</span>
<span class="fc" id="L332">    }</span>

    /**
     * Constructor.
     * It is assumed that body is located at zero NED coordinates (latitude = 0,
     * longitude = 0 and height = 0) and with zero Euler angles representing rotation
     * (roll = 0, pith = 0, yaw = 0), which for Android devices it means that the
     * device is flat on a horizontal surface with the screen facing down.
     * This constructor assumes that time is current time instant.
     *
     * @param listener listener to handle events raised by this estimator.
     * @throws IOException if initialization of world magnetic model fails.
     */
    public BodyMagneticFluxDensityBiasEstimator(
            final BodyMagneticFluxDensityBiasEstimatorListener listener)
            throws IOException {
<span class="fc" id="L348">        this(new Date());</span>
<span class="fc" id="L349">        mListener = listener;</span>
<span class="fc" id="L350">    }</span>

    /**
     * Constructor.
     * It is assumed that body is located at zero NED coordinates (latitude = 0,
     * longitude = 0, and height = 0) with provided orientation.
     * This constructor assumes that time is current time instant.
     *
     * @param nedC     coordinate transformation from body to local navigation
     *                 (NED) coordinates. This contains orientation respect the
     *                 horizon at current body location.
     * @param listener listener to handle events raised by this estimator.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not
     *                                                       from body to local
     *                                                       navigation coordinates.
     * @throws IOException                                   if initialization of
     *                                                       world magnetic model
     *                                                       fails.
     */
    public BodyMagneticFluxDensityBiasEstimator(
            final CoordinateTransformation nedC,
            final BodyMagneticFluxDensityBiasEstimatorListener listener)
            throws InvalidSourceAndDestinationFrameTypeException, IOException {
<span class="fc" id="L374">        this(nedC, new Date());</span>
<span class="fc" id="L375">        mListener = listener;</span>
<span class="fc" id="L376">    }</span>

    /**
     * Constructor.
     * It is assumed that body has zero Euler angles representing rotation (roll = 0,
     * pitch = 0, yaw = 0) respect the horizon at provided body location.
     * For Android devices this means that the device is flat on a horizontal surface
     * with the screen facing down.
     * This constructor assumes that time is current time instant.
     *
     * @param latitude  latitude expressed in radians (rad).
     * @param longitude longitude expressed in radians (rad).
     * @param height    height expressed in meters (m).
     * @param listener  listener to handle events raised by this estimator.
     * @throws IOException if initialization of world magnetic model fails.
     */
    public BodyMagneticFluxDensityBiasEstimator(
            final double latitude, final double longitude, final double height,
            final BodyMagneticFluxDensityBiasEstimatorListener listener)
            throws IOException {
<span class="fc" id="L396">        this(latitude, longitude, height, new Date());</span>
<span class="fc" id="L397">        mListener = listener;</span>
<span class="fc" id="L398">    }</span>

    /**
     * Constructor.
     * It is assumed that body has zero Euler angles representing rotation (roll = 0,
     * pitch = 0, yaw = 0) respect the horizon at provided body location.
     * For Android devices this means that the device is flat on a horizontal surface
     * with the screen facing down.
     * This constructor assumes that time is current time instant.
     *
     * @param latitude  latitude.
     * @param longitude longitude.
     * @param height    height expressed in meters (m).
     * @param listener  listener to handle events raised by this estimator.
     * @throws IOException if initialization of world magnetic model fails.
     */
    public BodyMagneticFluxDensityBiasEstimator(
            final Angle latitude, final Angle longitude, final double height,
            final BodyMagneticFluxDensityBiasEstimatorListener listener)
            throws IOException {
<span class="fc" id="L418">        this(latitude, longitude, height, new Date());</span>
<span class="fc" id="L419">        mListener = listener;</span>
<span class="fc" id="L420">    }</span>

    /**
     * Constructor.
     * It is assumed that body has zero Euler angles representing rotation (roll = 0,
     * pitch = 0, yaw = 0) respect the horizon at provided body location.
     * For Android devices this means that the device is flat on a horizontal surface
     * with the screen facing down.
     * This constructor assumes that time is current time instant.
     *
     * @param latitude  latitude.
     * @param longitude longitude.
     * @param height    height.
     * @param listener  listener to handle events raised by this estimator.
     * @throws IOException if initialization of world magnetic model fails.
     */
    public BodyMagneticFluxDensityBiasEstimator(
            final Angle latitude, final Angle longitude, final Distance height,
            final BodyMagneticFluxDensityBiasEstimatorListener listener)
            throws IOException {
<span class="fc" id="L440">        this(latitude, longitude, height, new Date());</span>
<span class="fc" id="L441">        mListener = listener;</span>
<span class="fc" id="L442">    }</span>

    /**
     * Constructor.
     * This constructor assumes that time is current time instant.
     *
     * @param position body position expressed in NED coordinates.
     * @param nedC     coordinate transformation from body to local navigation
     *                 (NED) coordinates. This contains orientation respect the
     *                 horizon at current body location.
     * @param listener listener to handle events raised by this estimator.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not
     *                                                       from body to local
     *                                                       navigation coordinates.
     * @throws IOException                                   if initialization of
     *                                                       world magnetic model
     *                                                       fails.
     */
    public BodyMagneticFluxDensityBiasEstimator(
            final NEDPosition position, final CoordinateTransformation nedC,
            final BodyMagneticFluxDensityBiasEstimatorListener listener)
            throws InvalidSourceAndDestinationFrameTypeException, IOException {
<span class="fc" id="L465">        this(position, nedC, new Date());</span>
<span class="fc" id="L466">        mListener = listener;</span>
<span class="fc" id="L467">    }</span>

    /**
     * Constructor.
     *
     * @param position body position expressed in ECEF coordinates.
     * @param nedC     coordinate transformation from body to local navigation
     *                 (NED) coordinates. This contains orientation respect the
     *                 horizon at current body location.
     * @param listener listener to handle events raised by this estimator.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not
     *                                                       from body to local
     *                                                       navigation coordinates.
     * @throws IOException                                   if initialization of
     *                                                       world magnetic model
     *                                                       fails.
     */
    public BodyMagneticFluxDensityBiasEstimator(
            final ECEFPosition position, final CoordinateTransformation nedC,
            final BodyMagneticFluxDensityBiasEstimatorListener listener)
            throws InvalidSourceAndDestinationFrameTypeException, IOException {
<span class="fc" id="L489">        this(position, nedC, new Date());</span>
<span class="fc" id="L490">        mListener = listener;</span>
<span class="fc" id="L491">    }</span>

    /**
     * Constructor.
     * It is assumed that body is located at zero NED coordinates (latitude = 0,
     * longitude = 0 and height = 0) and with zero Euler angles representing rotation
     * (roll = 0, pith = 0, yaw = 0), which for Android devices it means that the
     * device is flat on a horizontal surface with the screen facing down.
     *
     * @param year time expressed as decimal year.
     * @throws IOException if initialization of world magnetic model fails.
     */
    public BodyMagneticFluxDensityBiasEstimator(final double year)
            throws IOException {
<span class="fc" id="L505">        this(year, (WorldMagneticModel) null);</span>
<span class="fc" id="L506">    }</span>

    /**
     * Constructor.
     * It is assumed that body is located at zero NED coordinates (latitude = 0,
     * longitude = 0, and height = 0) with provided orientation.
     *
     * @param nedC coordinate transformation from body to local navigation
     *             (NED) coordinates. This contains orientation respect the horizon
     *             at current body location.
     * @param year time expressed as decimal year.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not
     *                                                       from body to local
     *                                                       navigation coordinates.
     * @throws IOException                                   if initialization of
     *                                                       world magnetic model
     *                                                       fails.
     */
    public BodyMagneticFluxDensityBiasEstimator(
            final CoordinateTransformation nedC, final double year)
            throws InvalidSourceAndDestinationFrameTypeException, IOException {
<span class="fc" id="L528">        this(nedC, year, (WorldMagneticModel) null);</span>
<span class="fc" id="L529">    }</span>

    /**
     * Constructor.
     * It is assumed that body has zero Euler angles representing rotation (roll = 0,
     * pitch = 0, yaw = 0) respect the horizon at provided body location.
     * For Android devices this means that the device is flat on a horizontal surface
     * with the screen facing down.
     *
     * @param latitude  latitude expressed in radians (rad).
     * @param longitude longitude expressed in radians (rad).
     * @param height    height expressed in meters (m).
     * @param year      time expressed as decimal year.
     * @throws IOException if initialization of world magnetic model fails.
     */
    public BodyMagneticFluxDensityBiasEstimator(
            final double latitude, final double longitude, final double height,
            final double year) throws IOException {
<span class="fc" id="L547">        this(latitude, longitude, height, year, (WorldMagneticModel) null);</span>
<span class="fc" id="L548">    }</span>

    /**
     * Constructor.
     * It is assumed that body has zero Euler angles representing rotation (roll = 0,
     * pitch = 0, yaw = 0) respect the horizon at provided body location.
     * For Android devices this means that the device is flat on a horizontal surface
     * with the screen facing down.
     *
     * @param latitude  latitude.
     * @param longitude longitude.
     * @param height    height expressed in meters (m).
     * @param year      time expressed as decimal year.
     * @throws IOException if initialization of world magnetic model fails.
     */
    public BodyMagneticFluxDensityBiasEstimator(
            final Angle latitude, final Angle longitude, final double height,
            final double year) throws IOException {
<span class="fc" id="L566">        this(latitude, longitude, height, year, (WorldMagneticModel) null);</span>
<span class="fc" id="L567">    }</span>

    /**
     * Constructor.
     * It is assumed that body has zero Euler angles representing rotation (roll = 0,
     * pitch = 0, yaw = 0) respect the horizon at provided body location.
     * For Android devices this means that the device is flat on a horizontal surface
     * with the screen facing down.
     *
     * @param latitude  latitude.
     * @param longitude longitude.
     * @param height    height.
     * @param year      time expressed as decimal year.
     * @throws IOException if initialization of world magnetic model fails.
     */
    public BodyMagneticFluxDensityBiasEstimator(
            final Angle latitude, final Angle longitude, final Distance height,
            final double year) throws IOException {
<span class="fc" id="L585">        this(latitude, longitude, height, year, (WorldMagneticModel) null);</span>
<span class="fc" id="L586">    }</span>

    /**
     * Constructor.
     *
     * @param position body position expressed in NED coordinates.
     * @param nedC     coordinate transformation from body to local navigation
     *                 (NED) coordinates. This contains orientation respect the
     *                 horizon at current body location.
     * @param year     time expressed as decimal year.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not
     *                                                       from body to local
     *                                                       navigation coordinates.
     * @throws IOException                                   if initialization of
     *                                                       world magnetic model
     *                                                       fails.
     */
    public BodyMagneticFluxDensityBiasEstimator(
            final NEDPosition position, final CoordinateTransformation nedC,
            final double year)
            throws InvalidSourceAndDestinationFrameTypeException, IOException {
<span class="fc" id="L608">        this(position, nedC, year, (WorldMagneticModel) null);</span>
<span class="fc" id="L609">    }</span>

    /**
     * Constructor.
     *
     * @param position body position expressed in ECEF coordinates.
     * @param nedC     coordinate transformation from body to local navigation
     *                 (NED) coordinates. This contains orientation respect the
     *                 horizon at current body location.
     * @param year     time expressed as decimal year.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not
     *                                                       from body to local
     *                                                       navigation coordinates.
     * @throws IOException                                   if initialization of
     *                                                       world magnetic model
     *                                                       fails.
     */
    public BodyMagneticFluxDensityBiasEstimator(
            final ECEFPosition position, final CoordinateTransformation nedC,
            final double year)
            throws InvalidSourceAndDestinationFrameTypeException, IOException {
<span class="fc" id="L631">        this(position, nedC, year, (WorldMagneticModel) null);</span>
<span class="fc" id="L632">    }</span>

    /**
     * Constructor.
     * It is assumed that body is located at zero NED coordinates (latitude = 0,
     * longitude = 0 and height = 0) and with zero Euler angles representing rotation
     * (roll = 0, pith = 0, yaw = 0), which for Android devices it means that the
     * device is flat on a horizontal surface with the screen facing down.
     *
     * @param year     time expressed as decimal year.
     * @param listener listener to handle events raised by this estimator.
     * @throws IOException if initialization of world magnetic model fails.
     */
    public BodyMagneticFluxDensityBiasEstimator(
            final double year,
            final BodyMagneticFluxDensityBiasEstimatorListener listener)
            throws IOException {
<span class="fc" id="L649">        this(year);</span>
<span class="fc" id="L650">        mListener = listener;</span>
<span class="fc" id="L651">    }</span>

    /**
     * Constructor.
     * It is assumed that body is located at zero NED coordinates (latitude = 0,
     * longitude = 0, and height = 0) with provided orientation.
     *
     * @param nedC     coordinate transformation from body to local navigation
     *                 (NED) coordinates. This contains orientation respect the
     *                 horizon at current body location.
     * @param year     time expressed as decimal year.
     * @param listener listener to handle events raised by this estimator.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not
     *                                                       from body to local
     *                                                       navigation coordinates.
     * @throws IOException                                   if initialization of
     *                                                       world magnetic model
     *                                                       fails.
     */
    public BodyMagneticFluxDensityBiasEstimator(
            final CoordinateTransformation nedC,
            final double year,
            final BodyMagneticFluxDensityBiasEstimatorListener listener)
            throws InvalidSourceAndDestinationFrameTypeException, IOException {
<span class="fc" id="L676">        this(nedC, year);</span>
<span class="fc" id="L677">        mListener = listener;</span>
<span class="fc" id="L678">    }</span>

    /**
     * Constructor.
     * It is assumed that body has zero Euler angles representing rotation (roll = 0,
     * pitch = 0, yaw = 0) respect the horizon at provided body location.
     * For Android devices this means that the device is flat on a horizontal surface
     * with the screen facing down.
     *
     * @param latitude  latitude expressed in radians (rad).
     * @param longitude longitude expressed in radians (rad).
     * @param height    height expressed in meters (m).
     * @param year      time expressed as decimal year.
     * @param listener  listener to handle events raised by this estimator.
     * @throws IOException if initialization of world magnetic model fails.
     */
    public BodyMagneticFluxDensityBiasEstimator(
            final double latitude, final double longitude, final double height,
            final double year,
            final BodyMagneticFluxDensityBiasEstimatorListener listener)
            throws IOException {
<span class="fc" id="L699">        this(latitude, longitude, height, year);</span>
<span class="fc" id="L700">        mListener = listener;</span>
<span class="fc" id="L701">    }</span>

    /**
     * Constructor.
     * It is assumed that body has zero Euler angles representing rotation (roll = 0,
     * pitch = 0, yaw = 0) respect the horizon at provided body location.
     * For Android devices this means that the device is flat on a horizontal surface
     * with the screen facing down.
     *
     * @param latitude  latitude.
     * @param longitude longitude.
     * @param height    height expressed in meters (m).
     * @param year      time expressed as decimal year.
     * @param listener  listener to handle events raised by this estimator.
     * @throws IOException if initialization of world magnetic model fails.
     */
    public BodyMagneticFluxDensityBiasEstimator(
            final Angle latitude, final Angle longitude, final double height,
            final double year,
            final BodyMagneticFluxDensityBiasEstimatorListener listener)
            throws IOException {
<span class="fc" id="L722">        this(latitude, longitude, height, year);</span>
<span class="fc" id="L723">        mListener = listener;</span>
<span class="fc" id="L724">    }</span>

    /**
     * Constructor.
     * It is assumed that body has zero Euler angles representing rotation (roll = 0,
     * pitch = 0, yaw = 0) respect the horizon at provided body location.
     * For Android devices this means that the device is flat on a horizontal surface
     * with the screen facing down.
     *
     * @param latitude  latitude.
     * @param longitude longitude.
     * @param height    height.
     * @param year      time expressed as decimal year.
     * @param listener  listener to handle events raised by this estimator.
     * @throws IOException if initialization of world magnetic model fails.
     */
    public BodyMagneticFluxDensityBiasEstimator(
            final Angle latitude, final Angle longitude, final Distance height,
            final double year,
            final BodyMagneticFluxDensityBiasEstimatorListener listener)
            throws IOException {
<span class="fc" id="L745">        this(latitude, longitude, height, year);</span>
<span class="fc" id="L746">        mListener = listener;</span>
<span class="fc" id="L747">    }</span>

    /**
     * Constructor.
     *
     * @param position body position expressed in NED coordinates.
     * @param nedC     coordinate transformation from body to local navigation
     *                 (NED) coordinates. This contains orientation respect the
     *                 horizon at current body location.
     * @param year     time expressed as decimal year.
     * @param listener listener to handle events raised by this estimator.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not
     *                                                       from body to local
     *                                                       navigation coordinates.
     * @throws IOException                                   if initialization of
     *                                                       world magnetic model
     *                                                       fails.
     */
    public BodyMagneticFluxDensityBiasEstimator(
            final NEDPosition position, final CoordinateTransformation nedC,
            final double year,
            final BodyMagneticFluxDensityBiasEstimatorListener listener)
            throws InvalidSourceAndDestinationFrameTypeException, IOException {
<span class="fc" id="L771">        this(position, nedC, year);</span>
<span class="fc" id="L772">        mListener = listener;</span>
<span class="fc" id="L773">    }</span>

    /**
     * Constructor.
     *
     * @param position body position expressed in ECEF coordinates.
     * @param nedC     coordinate transformation from body to local navigation
     *                 (NED) coordinates. This contains orientation respect the
     *                 horizon at current body location.
     * @param year     time expressed as decimal year.
     * @param listener listener to handle events raised by this estimator.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not
     *                                                       from body to local
     *                                                       navigation coordinates.
     * @throws IOException                                   if initialization of
     *                                                       world magnetic model
     *                                                       fails.
     */
    public BodyMagneticFluxDensityBiasEstimator(
            final ECEFPosition position, final CoordinateTransformation nedC,
            final double year,
            final BodyMagneticFluxDensityBiasEstimatorListener listener)
            throws InvalidSourceAndDestinationFrameTypeException, IOException {
<span class="fc" id="L797">        this(position, nedC, year);</span>
<span class="fc" id="L798">        mListener = listener;</span>
<span class="fc" id="L799">    }</span>

    /**
     * Constructor.
     * It is assumed that body is located at zero NED coordinates (latitude = 0,
     * longitude = 0 and height = 0) and with zero Euler angles representing rotation
     * (roll = 0, pith = 0, yaw = 0), which for Android devices it means that the
     * device is flat on a horizontal surface with the screen facing down.
     *
     * @param date a time instance to be converted.
     * @throws IOException if initialization of world magnetic model fails.
     */
    public BodyMagneticFluxDensityBiasEstimator(final Date date) throws IOException {
<span class="fc" id="L812">        this(convertTime(date));</span>
<span class="fc" id="L813">    }</span>

    /**
     * Constructor.
     * It is assumed that body is located at zero NED coordinates (latitude = 0,
     * longitude = 0, and height = 0) with provided orientation.
     *
     * @param nedC coordinate transformation from body to local navigation
     *             (NED) coordinates. This contains orientation respect the horizon
     *             at current body location.
     * @param date a time instance to be converted.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not
     *                                                       from body to local
     *                                                       navigation coordinates.
     * @throws IOException                                   if initialization of
     *                                                       world magnetic model
     *                                                       fails.
     */
    public BodyMagneticFluxDensityBiasEstimator(
            final CoordinateTransformation nedC, final Date date)
            throws InvalidSourceAndDestinationFrameTypeException, IOException {
<span class="fc" id="L835">        this(nedC, convertTime(date));</span>
<span class="fc" id="L836">    }</span>

    /**
     * Constructor.
     * It is assumed that body has zero Euler angles representing rotation (roll = 0,
     * pitch = 0, yaw = 0) respect the horizon at provided body location.
     * For Android devices this means that the device is flat on a horizontal surface
     * with the screen facing down.
     *
     * @param latitude  latitude expressed in radians (rad).
     * @param longitude longitude expressed in radians (rad).
     * @param height    height expressed in meters (m).
     * @param date      a time instance to be converted.
     * @throws IOException if initialization of world magnetic model fails.
     */
    public BodyMagneticFluxDensityBiasEstimator(
            final double latitude, final double longitude, final double height,
            final Date date) throws IOException {
<span class="fc" id="L854">        this(latitude, longitude, height, convertTime(date));</span>
<span class="fc" id="L855">    }</span>

    /**
     * Constructor.
     * It is assumed that body has zero Euler angles representing rotation (roll = 0,
     * pitch = 0, yaw = 0) respect the horizon at provided body location.
     * For Android devices this means that the device is flat on a horizontal surface
     * with the screen facing down.
     *
     * @param latitude  latitude.
     * @param longitude longitude.
     * @param height    height expressed in meters (m).
     * @param date      a time instance to be converted.
     * @throws IOException if initialization of world magnetic model fails.
     */
    public BodyMagneticFluxDensityBiasEstimator(
            final Angle latitude, final Angle longitude, final double height,
            final Date date) throws IOException {
<span class="fc" id="L873">        this(latitude, longitude, height, convertTime(date));</span>
<span class="fc" id="L874">    }</span>

    /**
     * Constructor.
     * It is assumed that body has zero Euler angles representing rotation (roll = 0,
     * pitch = 0, yaw = 0) respect the horizon at provided body location.
     * For Android devices this means that the device is flat on a horizontal surface
     * with the screen facing down.
     *
     * @param latitude  latitude.
     * @param longitude longitude.
     * @param height    height.
     * @param date      a time instance to be converted.
     * @throws IOException if initialization of world magnetic model fails.
     */
    public BodyMagneticFluxDensityBiasEstimator(
            final Angle latitude, final Angle longitude, final Distance height,
            final Date date) throws IOException {
<span class="fc" id="L892">        this(latitude, longitude, height, convertTime(date));</span>
<span class="fc" id="L893">    }</span>

    /**
     * Constructor.
     *
     * @param position body position expressed in NED coordinates.
     * @param nedC     coordinate transformation from body to local navigation
     *                 (NED) coordinates. This contains orientation respect the
     *                 horizon at current body location.
     * @param date     a time instance to be converted.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not
     *                                                       from body to local
     *                                                       navigation coordinates.
     * @throws IOException                                   if initialization of
     *                                                       world magnetic model
     *                                                       fails.
     */
    public BodyMagneticFluxDensityBiasEstimator(
            final NEDPosition position, final CoordinateTransformation nedC,
            final Date date)
            throws InvalidSourceAndDestinationFrameTypeException, IOException {
<span class="fc" id="L915">        this(position, nedC, convertTime(date));</span>
<span class="fc" id="L916">    }</span>

    /**
     * Constructor.
     *
     * @param position body position expressed in ECEF coordinates.
     * @param nedC     coordinate transformation from body to local navigation
     *                 (NED) coordinates. This contains orientation respect the
     *                 horizon at current body location.
     * @param date     a time instance to be converted.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not
     *                                                       from body to local
     *                                                       navigation coordinates.
     * @throws IOException                                   if initialization of
     *                                                       world magnetic model
     *                                                       fails.
     */
    public BodyMagneticFluxDensityBiasEstimator(
            final ECEFPosition position, final CoordinateTransformation nedC,
            final Date date)
            throws InvalidSourceAndDestinationFrameTypeException, IOException {
<span class="fc" id="L938">        this(position, nedC, convertTime(date));</span>
<span class="fc" id="L939">    }</span>

    /**
     * Constructor.
     * It is assumed that body is located at zero NED coordinates (latitude = 0,
     * longitude = 0 and height = 0) and with zero Euler angles representing rotation
     * (roll = 0, pith = 0, yaw = 0), which for Android devices it means that the
     * device is flat on a horizontal surface with the screen facing down.
     *
     * @param date     a time instance to be converted.
     * @param listener listener to handle events raised by this estimator.
     * @throws IOException if initialization of world magnetic model fails.
     */
    public BodyMagneticFluxDensityBiasEstimator(
            final Date date,
            final BodyMagneticFluxDensityBiasEstimatorListener listener)
            throws IOException {
<span class="fc" id="L956">        this(convertTime(date), listener);</span>
<span class="fc" id="L957">    }</span>

    /**
     * Constructor.
     * It is assumed that body is located at zero NED coordinates (latitude = 0,
     * longitude = 0, and height = 0) with provided orientation.
     *
     * @param nedC     coordinate transformation from body to local navigation
     *                 (NED) coordinates. This contains orientation respect the
     *                 horizon at current body location.
     * @param date     a time instance to be converted.
     * @param listener listener to handle events raised by this estimator.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not
     *                                                       from body to local
     *                                                       navigation coordinates.
     * @throws IOException                                   if initialization of
     *                                                       world magnetic model
     *                                                       fails.
     */
    public BodyMagneticFluxDensityBiasEstimator(
            final CoordinateTransformation nedC,
            final Date date,
            final BodyMagneticFluxDensityBiasEstimatorListener listener)
            throws InvalidSourceAndDestinationFrameTypeException, IOException {
<span class="fc" id="L982">        this(nedC, convertTime(date), listener);</span>
<span class="fc" id="L983">    }</span>

    /**
     * Constructor.
     * It is assumed that body has zero Euler angles representing rotation (roll = 0,
     * pitch = 0, yaw = 0) respect the horizon at provided body location.
     * For Android devices this means that the device is flat on a horizontal surface
     * with the screen facing down.
     *
     * @param latitude  latitude expressed in radians (rad).
     * @param longitude longitude expressed in radians (rad).
     * @param height    height expressed in meters (m).
     * @param date      a time instance to be converted.
     * @param listener  listener to handle events raised by this estimator.
     * @throws IOException if initialization of world magnetic model fails.
     */
    public BodyMagneticFluxDensityBiasEstimator(
            final double latitude, final double longitude, final double height,
            final Date date,
            final BodyMagneticFluxDensityBiasEstimatorListener listener)
            throws IOException {
<span class="fc" id="L1004">        this(latitude, longitude, height, convertTime(date), listener);</span>
<span class="fc" id="L1005">    }</span>

    /**
     * Constructor.
     * It is assumed that body has zero Euler angles representing rotation (roll = 0,
     * pitch = 0, yaw = 0) respect the horizon at provided body location.
     * For Android devices this means that the device is flat on a horizontal surface
     * with the screen facing down.
     *
     * @param latitude  latitude.
     * @param longitude longitude.
     * @param height    height expressed in meters (m).
     * @param date      a time instance to be converted.
     * @param listener  listener to handle events raised by this estimator.
     * @throws IOException if initialization of world magnetic model fails.
     */
    public BodyMagneticFluxDensityBiasEstimator(
            final Angle latitude, final Angle longitude, final double height,
            final Date date,
            final BodyMagneticFluxDensityBiasEstimatorListener listener)
            throws IOException {
<span class="fc" id="L1026">        this(latitude, longitude, height, convertTime(date), listener);</span>
<span class="fc" id="L1027">    }</span>

    /**
     * Constructor.
     * It is assumed that body has zero Euler angles representing rotation (roll = 0,
     * pitch = 0, yaw = 0) respect the horizon at provided body location.
     * For Android devices this means that the device is flat on a horizontal surface
     * with the screen facing down.
     *
     * @param latitude  latitude.
     * @param longitude longitude.
     * @param height    height.
     * @param date      a time instance to be converted.
     * @param listener  listener to handle events raised by this estimator.
     * @throws IOException if initialization of world magnetic model fails.
     */
    public BodyMagneticFluxDensityBiasEstimator(
            final Angle latitude, final Angle longitude, final Distance height,
            final Date date,
            final BodyMagneticFluxDensityBiasEstimatorListener listener)
            throws IOException {
<span class="fc" id="L1048">        this(latitude, longitude, height, convertTime(date), listener);</span>
<span class="fc" id="L1049">    }</span>

    /**
     * Constructor.
     *
     * @param position body position expressed in NED coordinates.
     * @param nedC     coordinate transformation from body to local navigation
     *                 (NED) coordinates. This contains orientation respect the
     *                 horizon at current body location.
     * @param date     a time instance to be converted.
     * @param listener listener to handle events raised by this estimator.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not
     *                                                       from body to local
     *                                                       navigation coordinates.
     * @throws IOException                                   if initialization of
     *                                                       world magnetic model
     *                                                       fails.
     */
    public BodyMagneticFluxDensityBiasEstimator(
            final NEDPosition position, final CoordinateTransformation nedC,
            final Date date,
            final BodyMagneticFluxDensityBiasEstimatorListener listener)
            throws InvalidSourceAndDestinationFrameTypeException, IOException {
<span class="fc" id="L1073">        this(position, nedC, convertTime(date), listener);</span>
<span class="fc" id="L1074">    }</span>

    /**
     * Constructor.
     *
     * @param position body position expressed in ECEF coordinates.
     * @param nedC     coordinate transformation from body to local navigation
     *                 (NED) coordinates. This contains orientation respect the
     *                 horizon at current body location.
     * @param date     a time instance to be converted.
     * @param listener listener to handle events raised by this estimator.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not
     *                                                       from body to local
     *                                                       navigation coordinates.
     * @throws IOException                                   if initialization of
     *                                                       world magnetic model
     *                                                       fails.
     */
    public BodyMagneticFluxDensityBiasEstimator(
            final ECEFPosition position, final CoordinateTransformation nedC,
            final Date date,
            final BodyMagneticFluxDensityBiasEstimatorListener listener)
            throws InvalidSourceAndDestinationFrameTypeException, IOException {
<span class="fc" id="L1098">        this(position, nedC, convertTime(date), listener);</span>
<span class="fc" id="L1099">    }</span>

    /**
     * Constructor.
     * It is assumed that body is located at zero NED coordinates (latitude = 0,
     * longitude = 0 and height = 0) and with zero Euler angles representing rotation
     * (roll = 0, pith = 0, yaw = 0), which for Android devices it means that the
     * device is flat on a horizontal surface with the screen facing down.
     *
     * @param year          time expressed as decimal year.
     * @param magneticModel world magnetic model of Earth or null if default
     *                      model is used.
     * @throws IOException if initialization of world magnetic model fails.
     */
    public BodyMagneticFluxDensityBiasEstimator(
            final double year, final WorldMagneticModel magneticModel)
<span class="fc" id="L1115">            throws IOException {</span>
<span class="fc" id="L1116">        mFrame = NEDtoECEFFrameConverter.convertNEDtoECEFAndReturnNew(</span>
                new NEDFrame());
<span class="fc" id="L1118">        mYear = year;</span>
<span class="fc" id="L1119">        mMagneticModel = magneticModel;</span>
<span class="fc" id="L1120">        initialize();</span>
<span class="fc" id="L1121">    }</span>

    /**
     * Constructor.
     * It is assumed that body is located at zero NED coordinates (latitude = 0,
     * longitude = 0, and height = 0) with provided orientation.
     *
     * @param nedC          coordinate transformation from body to local navigation
     *                      (NED) coordinates. This contains orientation respect the horizon
     *                      at current body location.
     * @param year          time expressed as decimal year.
     * @param magneticModel world magnetic model of Earth or null if default
     *                      model is used.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not
     *                                                       from body to local
     *                                                       navigation coordinates.
     * @throws IOException                                   if initialization of
     *                                                       world magnetic model fails.
     */
    public BodyMagneticFluxDensityBiasEstimator(
            final CoordinateTransformation nedC, final double year,
            final WorldMagneticModel magneticModel)
<span class="fc" id="L1144">            throws InvalidSourceAndDestinationFrameTypeException, IOException {</span>
<span class="fc" id="L1145">        mFrame = NEDtoECEFFrameConverter.convertNEDtoECEFAndReturnNew(</span>
                new NEDFrame(nedC));
<span class="fc" id="L1147">        mYear = year;</span>
<span class="fc" id="L1148">        mMagneticModel = magneticModel;</span>
<span class="fc" id="L1149">        initialize();</span>
<span class="fc" id="L1150">    }</span>

    /**
     * Constructor.
     * It is assumed that body has zero Euler angles representing rotation (roll = 0,
     * pitch = 0, yaw = 0) respect the horizon at provided body location.
     * For Android devices this means that the device is flat on a horizontal surface
     * with the screen facing down.
     *
     * @param latitude      latitude expressed in radians (rad).
     * @param longitude     longitude expressed in radians (rad).
     * @param height        height expressed in meters (m).
     * @param year          time expressed as decimal year.
     * @param magneticModel world magnetic model of Earth or null if default
     *                      model is used.
     * @throws IOException if initialization of world magnetic model fails.
     */
    public BodyMagneticFluxDensityBiasEstimator(
            final double latitude, final double longitude, final double height,
            final double year, final WorldMagneticModel magneticModel)
<span class="fc" id="L1170">            throws IOException {</span>
<span class="fc" id="L1171">        mFrame = NEDtoECEFFrameConverter.convertNEDtoECEFAndReturnNew(</span>
                new NEDFrame(latitude, longitude, height));
<span class="fc" id="L1173">        mYear = year;</span>
<span class="fc" id="L1174">        mMagneticModel = magneticModel;</span>
<span class="fc" id="L1175">        initialize();</span>
<span class="fc" id="L1176">    }</span>

    /**
     * Constructor.
     * It is assumed that body has zero Euler angles representing rotation (roll = 0,
     * pitch = 0, yaw = 0) respect the horizon at provided body location.
     * For Android devices this means that the device is flat on a horizontal surface
     * with the screen facing down.
     *
     * @param latitude      latitude.
     * @param longitude     longitude.
     * @param height        height expressed in meters (m).
     * @param year          time expressed as decimal year.
     * @param magneticModel world magnetic model of Earth or null if default
     *                      model is used.
     * @throws IOException if initialization of world magnetic model fails.
     */
    public BodyMagneticFluxDensityBiasEstimator(
            final Angle latitude, final Angle longitude, final double height,
            final double year, final WorldMagneticModel magneticModel)
<span class="fc" id="L1196">            throws IOException {</span>
<span class="fc" id="L1197">        mFrame = NEDtoECEFFrameConverter.convertNEDtoECEFAndReturnNew(</span>
                new NEDFrame(latitude, longitude, height));
<span class="fc" id="L1199">        mYear = year;</span>
<span class="fc" id="L1200">        mMagneticModel = magneticModel;</span>
<span class="fc" id="L1201">        initialize();</span>
<span class="fc" id="L1202">    }</span>

    /**
     * Constructor.
     * It is assumed that body has zero Euler angles representing rotation (roll = 0,
     * pitch = 0, yaw = 0) respect the horizon at provided body location.
     * For Android devices this means that the device is flat on a horizontal surface
     * with the screen facing down.
     *
     * @param latitude      latitude.
     * @param longitude     longitude.
     * @param height        height.
     * @param year          time expressed as decimal year.
     * @param magneticModel world magnetic model of Earth or null if default
     *                      model is used.
     * @throws IOException if initialization of world magnetic model fails.
     */
    public BodyMagneticFluxDensityBiasEstimator(
            final Angle latitude, final Angle longitude, final Distance height,
            final double year, final WorldMagneticModel magneticModel)
<span class="fc" id="L1222">            throws IOException {</span>
<span class="fc" id="L1223">        mFrame = NEDtoECEFFrameConverter.convertNEDtoECEFAndReturnNew(</span>
                new NEDFrame(latitude, longitude, height));
<span class="fc" id="L1225">        mYear = year;</span>
<span class="fc" id="L1226">        mMagneticModel = magneticModel;</span>
<span class="fc" id="L1227">        initialize();</span>
<span class="fc" id="L1228">    }</span>

    /**
     * Constructor.
     *
     * @param position      body position expressed in NED coordinates.
     * @param nedC          coordinate transformation from body to local navigation
     *                      (NED) coordinates. This contains orientation respect the
     *                      horizon at current body location.
     * @param year          time expressed as decimal year.
     * @param magneticModel world magnetic model of Earth or null if default
     *                      model is used.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not
     *                                                       from body to local
     *                                                       navigation coordinates.
     * @throws IOException                                   if initialization of
     *                                                       world magnetic model
     *                                                       fails.
     */
    public BodyMagneticFluxDensityBiasEstimator(
            final NEDPosition position, final CoordinateTransformation nedC,
            final double year, final WorldMagneticModel magneticModel)
<span class="fc" id="L1251">            throws InvalidSourceAndDestinationFrameTypeException, IOException {</span>
<span class="fc" id="L1252">        mFrame = NEDtoECEFFrameConverter.convertNEDtoECEFAndReturnNew(</span>
                new NEDFrame(position, nedC));
<span class="fc" id="L1254">        mYear = year;</span>
<span class="fc" id="L1255">        mMagneticModel = magneticModel;</span>
<span class="fc" id="L1256">        initialize();</span>
<span class="fc" id="L1257">    }</span>

    /**
     * Constructor.
     *
     * @param position      body position expressed in ECEF coordinates.
     * @param nedC          coordinate transformation from body to local navigation
     *                      (NED) coordinates. This contains orientation respect the
     *                      horizon at current body location.
     * @param year          time expressed as decimal year.
     * @param magneticModel world magnetic model of Earth or null if default
     *                      model is used.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not
     *                                                       from body to local
     *                                                       navigation coordinates.
     * @throws IOException                                   if initialization of
     *                                                       world magnetic model
     *                                                       fails.
     */
    public BodyMagneticFluxDensityBiasEstimator(
            final ECEFPosition position, final CoordinateTransformation nedC,
            final double year, final WorldMagneticModel magneticModel)
<span class="fc" id="L1280">            throws InvalidSourceAndDestinationFrameTypeException, IOException {</span>
<span class="fc" id="L1281">        mFrame = new ECEFFrame(position);</span>
<span class="fc" id="L1282">        final NEDFrame nedFrame = ECEFtoNEDFrameConverter</span>
<span class="fc" id="L1283">                .convertECEFtoNEDAndReturnNew(mFrame);</span>
<span class="fc" id="L1284">        nedFrame.setCoordinateTransformation(nedC);</span>
<span class="fc" id="L1285">        NEDtoECEFFrameConverter.convertNEDtoECEF(nedFrame, mFrame);</span>
<span class="fc" id="L1286">        mYear = year;</span>
<span class="fc" id="L1287">        mMagneticModel = magneticModel;</span>
<span class="fc" id="L1288">        initialize();</span>
<span class="fc" id="L1289">    }</span>

    /**
     * Constructor.
     * It is assumed that body is located at zero NED coordinates (latitude = 0,
     * longitude = 0 and height = 0) and with zero Euler angles representing rotation
     * (roll = 0, pith = 0, yaw = 0), which for Android devices it means that the
     * device is flat on a horizontal surface with the screen facing down.
     *
     * @param year          time expressed as decimal year.
     * @param listener      listener to handle events raised by this estimator.
     * @param magneticModel world magnetic model of Earth or null if default
     *                      model is used.
     * @throws IOException if initialization of world magnetic model fails.
     */
    public BodyMagneticFluxDensityBiasEstimator(
            final double year, final WorldMagneticModel magneticModel,
            final BodyMagneticFluxDensityBiasEstimatorListener listener)
            throws IOException {
<span class="fc" id="L1308">        this(year, magneticModel);</span>
<span class="fc" id="L1309">        mListener = listener;</span>
<span class="fc" id="L1310">    }</span>

    /**
     * Constructor.
     * It is assumed that body is located at zero NED coordinates (latitude = 0,
     * longitude = 0, and height = 0) with provided orientation.
     *
     * @param nedC          coordinate transformation from body to local navigation
     *                      (NED) coordinates. This contains orientation respect the
     *                      horizon at current body location.
     * @param year          time expressed as decimal year.
     * @param magneticModel world magnetic model of Earth or null if default
     *                      model is used.
     * @param listener      listener to handle events raised by this estimator.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not
     *                                                       from body to local
     *                                                       navigation coordinates.
     * @throws IOException                                   if initialization of
     *                                                       world magnetic model
     *                                                       fails.
     */
    public BodyMagneticFluxDensityBiasEstimator(
            final CoordinateTransformation nedC,
            final double year, final WorldMagneticModel magneticModel,
            final BodyMagneticFluxDensityBiasEstimatorListener listener)
            throws InvalidSourceAndDestinationFrameTypeException, IOException {
<span class="fc" id="L1337">        this(nedC, year, magneticModel);</span>
<span class="fc" id="L1338">        mListener = listener;</span>
<span class="fc" id="L1339">    }</span>

    /**
     * Constructor.
     * It is assumed that body has zero Euler angles representing rotation (roll = 0,
     * pitch = 0, yaw = 0) respect the horizon at provided body location.
     * For Android devices this means that the device is flat on a horizontal surface
     * with the screen facing down.
     *
     * @param latitude      latitude expressed in radians (rad).
     * @param longitude     longitude expressed in radians (rad).
     * @param height        height expressed in meters (m).
     * @param year          time expressed as decimal year.
     * @param magneticModel world magnetic model of Earth or null if default
     *                      model is used.
     * @param listener      listener to handle events raised by this estimator.
     * @throws IOException if initialization of world magnetic model fails.
     */
    public BodyMagneticFluxDensityBiasEstimator(
            final double latitude, final double longitude, final double height,
            final double year, final WorldMagneticModel magneticModel,
            final BodyMagneticFluxDensityBiasEstimatorListener listener)
            throws IOException {
<span class="fc" id="L1362">        this(latitude, longitude, height, year, magneticModel);</span>
<span class="fc" id="L1363">        mListener = listener;</span>
<span class="fc" id="L1364">    }</span>

    /**
     * Constructor.
     * It is assumed that body has zero Euler angles representing rotation (roll = 0,
     * pitch = 0, yaw = 0) respect the horizon at provided body location.
     * For Android devices this means that the device is flat on a horizontal surface
     * with the screen facing down.
     *
     * @param latitude      latitude.
     * @param longitude     longitude.
     * @param height        height expressed in meters (m).
     * @param year          time expressed as decimal year.
     * @param magneticModel world magnetic model of Earth or null if default
     *                      model is used.
     * @param listener      listener to handle events raised by this estimator.
     * @throws IOException if initialization of world magnetic model fails.
     */
    public BodyMagneticFluxDensityBiasEstimator(
            final Angle latitude, final Angle longitude, final double height,
            final double year, final WorldMagneticModel magneticModel,
            final BodyMagneticFluxDensityBiasEstimatorListener listener)
            throws IOException {
<span class="fc" id="L1387">        this(latitude, longitude, height, year, magneticModel);</span>
<span class="fc" id="L1388">        mListener = listener;</span>
<span class="fc" id="L1389">    }</span>

    /**
     * Constructor.
     * It is assumed that body has zero Euler angles representing rotation (roll = 0,
     * pitch = 0, yaw = 0) respect the horizon at provided body location.
     * For Android devices this means that the device is flat on a horizontal surface
     * with the screen facing down.
     *
     * @param latitude      latitude.
     * @param longitude     longitude.
     * @param height        height.
     * @param year          time expressed as decimal year.
     * @param magneticModel world magnetic model of Earth or null if default
     *                      model is used.
     * @param listener      listener to handle events raised by this estimator.
     * @throws IOException if initialization of world magnetic model fails.
     */
    public BodyMagneticFluxDensityBiasEstimator(
            final Angle latitude, final Angle longitude, final Distance height,
            final double year, final WorldMagneticModel magneticModel,
            final BodyMagneticFluxDensityBiasEstimatorListener listener)
            throws IOException {
<span class="fc" id="L1412">        this(latitude, longitude, height, year, magneticModel);</span>
<span class="fc" id="L1413">        mListener = listener;</span>
<span class="fc" id="L1414">    }</span>

    /**
     * Constructor.
     *
     * @param position      body position expressed in NED coordinates.
     * @param nedC          coordinate transformation from body to local navigation
     *                      (NED) coordinates. This contains orientation respect the
     *                      horizon at current body location.
     * @param year          time expressed as decimal year.
     * @param magneticModel world magnetic model of Earth or null if default
     *                      model is used.
     * @param listener      listener to handle events raised by this estimator.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not
     *                                                       from body to local
     *                                                       navigation coordinates.
     * @throws IOException                                   if initialization of
     *                                                       world magnetic model
     *                                                       fails.
     */
    public BodyMagneticFluxDensityBiasEstimator(
            final NEDPosition position, final CoordinateTransformation nedC,
            final double year,
            final WorldMagneticModel magneticModel,
            final BodyMagneticFluxDensityBiasEstimatorListener listener)
            throws InvalidSourceAndDestinationFrameTypeException, IOException {
<span class="fc" id="L1441">        this(position, nedC, year, magneticModel);</span>
<span class="fc" id="L1442">        mListener = listener;</span>
<span class="fc" id="L1443">    }</span>

    /**
     * Constructor.
     *
     * @param position      body position expressed in ECEF coordinates.
     * @param nedC          coordinate transformation from body to local navigation
     *                      (NED) coordinates. This contains orientation respect the
     *                      horizon at current body location.
     * @param year          time expressed as decimal year.
     * @param magneticModel world magnetic model of Earth or null if default
     *                      model is used.
     * @param listener      listener to handle events raised by this estimator.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not
     *                                                       from body to local
     *                                                       navigation coordinates.
     * @throws IOException                                   if initialization of
     *                                                       world magnetic model
     *                                                       fails.
     */
    public BodyMagneticFluxDensityBiasEstimator(
            final ECEFPosition position, final CoordinateTransformation nedC,
            final double year, final WorldMagneticModel magneticModel,
            final BodyMagneticFluxDensityBiasEstimatorListener listener)
            throws InvalidSourceAndDestinationFrameTypeException, IOException {
<span class="fc" id="L1469">        this(position, nedC, year, magneticModel);</span>
<span class="fc" id="L1470">        mListener = listener;</span>
<span class="fc" id="L1471">    }</span>

    /**
     * Constructor.
     * It is assumed that body is located at zero NED coordinates (latitude = 0,
     * longitude = 0 and height = 0) and with zero Euler angles representing rotation
     * (roll = 0, pith = 0, yaw = 0), which for Android devices it means that the
     * device is flat on a horizontal surface with the screen facing down.
     *
     * @param date          a time instance to be converted.
     * @param magneticModel world magnetic model of Earth or null if default
     *                      model is used.
     * @throws IOException if initialization of world magnetic model fails.
     */
    public BodyMagneticFluxDensityBiasEstimator(
            final Date date, final WorldMagneticModel magneticModel)
            throws IOException {
<span class="fc" id="L1488">        this(convertTime(date), magneticModel);</span>
<span class="fc" id="L1489">    }</span>

    /**
     * Constructor.
     * It is assumed that body is located at zero NED coordinates (latitude = 0,
     * longitude = 0, and height = 0) with provided orientation.
     *
     * @param nedC          coordinate transformation from body to local navigation
     *                      (NED) coordinates. This contains orientation respect the horizon
     *                      at current body location.
     * @param date          a time instance to be converted.
     * @param magneticModel world magnetic model of Earth or null if default
     *                      model is used.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not
     *                                                       from body to local
     *                                                       navigation coordinates.
     * @throws IOException                                   if initialization of
     *                                                       world magnetic model
     *                                                       fails.
     */
    public BodyMagneticFluxDensityBiasEstimator(
            final CoordinateTransformation nedC, final Date date,
            final WorldMagneticModel magneticModel)
            throws InvalidSourceAndDestinationFrameTypeException, IOException {
<span class="fc" id="L1514">        this(nedC, convertTime(date), magneticModel);</span>
<span class="fc" id="L1515">    }</span>

    /**
     * Constructor.
     * It is assumed that body has zero Euler angles representing rotation (roll = 0,
     * pitch = 0, yaw = 0) respect the horizon at provided body location.
     * For Android devices this means that the device is flat on a horizontal surface
     * with the screen facing down.
     *
     * @param latitude      latitude expressed in radians (rad).
     * @param longitude     longitude expressed in radians (rad).
     * @param height        height expressed in meters (m).
     * @param date          a time instance to be converted.
     * @param magneticModel world magnetic model of Earth or null if default
     *                      model is used.
     * @throws IOException if initialization of world magnetic model fails.
     */
    public BodyMagneticFluxDensityBiasEstimator(
            final double latitude, final double longitude, final double height,
            final Date date, final WorldMagneticModel magneticModel)
            throws IOException {
<span class="fc" id="L1536">        this(latitude, longitude, height, convertTime(date), magneticModel);</span>
<span class="fc" id="L1537">    }</span>

    /**
     * Constructor.
     * It is assumed that body has zero Euler angles representing rotation (roll = 0,
     * pitch = 0, yaw = 0) respect the horizon at provided body location.
     * For Android devices this means that the device is flat on a horizontal surface
     * with the screen facing down.
     *
     * @param latitude      latitude.
     * @param longitude     longitude.
     * @param height        height expressed in meters (m).
     * @param date          a time instance to be converted.
     * @param magneticModel world magnetic model of Earth or null if default
     *                      model is used.
     * @throws IOException if initialization of world magnetic model fails.
     */
    public BodyMagneticFluxDensityBiasEstimator(
            final Angle latitude, final Angle longitude, final double height,
            final Date date, final WorldMagneticModel magneticModel)
            throws IOException {
<span class="fc" id="L1558">        this(latitude, longitude, height, convertTime(date), magneticModel);</span>
<span class="fc" id="L1559">    }</span>

    /**
     * Constructor.
     * It is assumed that body has zero Euler angles representing rotation (roll = 0,
     * pitch = 0, yaw = 0) respect the horizon at provided body location.
     * For Android devices this means that the device is flat on a horizontal surface
     * with the screen facing down.
     *
     * @param latitude      latitude.
     * @param longitude     longitude.
     * @param height        height.
     * @param date          a time instance to be converted.
     * @param magneticModel world magnetic model of Earth or null if default
     *                      model is used.
     * @throws IOException if initialization of world magnetic model fails.
     */
    public BodyMagneticFluxDensityBiasEstimator(
            final Angle latitude, final Angle longitude, final Distance height,
            final Date date, final WorldMagneticModel magneticModel)
            throws IOException {
<span class="fc" id="L1580">        this(latitude, longitude, height, convertTime(date), magneticModel);</span>
<span class="fc" id="L1581">    }</span>

    /**
     * Constructor.
     *
     * @param position      body position expressed in NED coordinates.
     * @param nedC          coordinate transformation from body to local navigation
     *                      (NED) coordinates. This contains orientation respect the
     *                      horizon at current body location.
     * @param date          a time instance to be converted.
     * @param magneticModel world magnetic model of Earth or null if default
     *                      model is used.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not
     *                                                       from body to local
     *                                                       navigation coordinates.
     * @throws IOException                                   if initialization of
     *                                                       world magnetic model
     *                                                       fails.
     */
    public BodyMagneticFluxDensityBiasEstimator(
            final NEDPosition position, final CoordinateTransformation nedC,
            final Date date, final WorldMagneticModel magneticModel)
            throws InvalidSourceAndDestinationFrameTypeException, IOException {
<span class="fc" id="L1605">        this(position, nedC, convertTime(date), magneticModel);</span>
<span class="fc" id="L1606">    }</span>

    /**
     * Constructor.
     *
     * @param position      body position expressed in ECEF coordinates.
     * @param nedC          coordinate transformation from body to local navigation
     *                      (NED) coordinates. This contains orientation respect the
     *                      horizon at current body location.
     * @param date          a time instance to be converted.
     * @param magneticModel world magnetic model of Earth or null if default
     *                      model is used.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not
     *                                                       from body to local
     *                                                       navigation coordinates.
     * @throws IOException                                   if initialization of
     *                                                       world magnetic model
     *                                                       fails.
     */
    public BodyMagneticFluxDensityBiasEstimator(
            final ECEFPosition position, final CoordinateTransformation nedC,
            final Date date, final WorldMagneticModel magneticModel)
            throws InvalidSourceAndDestinationFrameTypeException, IOException {
<span class="fc" id="L1630">        this(position, nedC, convertTime(date), magneticModel);</span>
<span class="fc" id="L1631">    }</span>

    /**
     * Constructor.
     * It is assumed that body is located at zero NED coordinates (latitude = 0,
     * longitude = 0 and height = 0) and with zero Euler angles representing rotation
     * (roll = 0, pith = 0, yaw = 0), which for Android devices it means that the
     * device is flat on a horizontal surface with the screen facing down.
     *
     * @param date          a time instance to be converted.
     * @param magneticModel world magnetic model of Earth or null if default
     *                      model is used.
     * @param listener      listener to handle events raised by this estimator.
     * @throws IOException if initialization of world magnetic model fails.
     */
    public BodyMagneticFluxDensityBiasEstimator(
            final Date date, final WorldMagneticModel magneticModel,
            final BodyMagneticFluxDensityBiasEstimatorListener listener)
            throws IOException {
<span class="fc" id="L1650">        this(convertTime(date), magneticModel, listener);</span>
<span class="fc" id="L1651">    }</span>

    /**
     * Constructor.
     * It is assumed that body is located at zero NED coordinates (latitude = 0,
     * longitude = 0, and height = 0) with provided orientation.
     *
     * @param nedC          coordinate transformation from body to local navigation
     *                      (NED) coordinates. This contains orientation respect the
     *                      horizon at current body location.
     * @param date          a time instance to be converted.
     * @param magneticModel world magnetic model of Earth or null if default
     *                      model is used.
     * @param listener      listener to handle events raised by this estimator.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not
     *                                                       from body to local
     *                                                       navigation coordinates.
     * @throws IOException                                   if initialization of
     *                                                       world magnetic model
     *                                                       fails.
     */
    public BodyMagneticFluxDensityBiasEstimator(
            final CoordinateTransformation nedC,
            final Date date, final WorldMagneticModel magneticModel,
            final BodyMagneticFluxDensityBiasEstimatorListener listener)
            throws InvalidSourceAndDestinationFrameTypeException, IOException {
<span class="fc" id="L1678">        this(nedC, convertTime(date), magneticModel, listener);</span>
<span class="fc" id="L1679">    }</span>

    /**
     * Constructor.
     * It is assumed that body has zero Euler angles representing rotation (roll = 0,
     * pitch = 0, yaw = 0) respect the horizon at provided body location.
     * For Android devices this means that the device is flat on a horizontal surface
     * with the screen facing down.
     *
     * @param latitude      latitude expressed in radians (rad).
     * @param longitude     longitude expressed in radians (rad).
     * @param height        height expressed in meters (m).
     * @param date          a time instance to be converted.
     * @param magneticModel world magnetic model of Earth or null if default
     *                      model is used.
     * @param listener      listener to handle events raised by this estimator.
     * @throws IOException if initialization of world magnetic model fails.
     */
    public BodyMagneticFluxDensityBiasEstimator(
            final double latitude, final double longitude, final double height,
            final Date date, final WorldMagneticModel magneticModel,
            final BodyMagneticFluxDensityBiasEstimatorListener listener)
            throws IOException {
<span class="fc" id="L1702">        this(latitude, longitude, height, convertTime(date), magneticModel,</span>
                listener);
<span class="fc" id="L1704">    }</span>

    /**
     * Constructor.
     * It is assumed that body has zero Euler angles representing rotation (roll = 0,
     * pitch = 0, yaw = 0) respect the horizon at provided body location.
     * For Android devices this means that the device is flat on a horizontal surface
     * with the screen facing down.
     *
     * @param latitude      latitude.
     * @param longitude     longitude.
     * @param height        height expressed in meters (m).
     * @param date          a time instance to be converted.
     * @param magneticModel world magnetic model of Earth or null if default
     *                      model is used.
     * @param listener      listener to handle events raised by this estimator.
     * @throws IOException if initialization of world magnetic model fails.
     */
    public BodyMagneticFluxDensityBiasEstimator(
            final Angle latitude, final Angle longitude, final double height,
            final Date date, final WorldMagneticModel magneticModel,
            final BodyMagneticFluxDensityBiasEstimatorListener listener)
            throws IOException {
<span class="fc" id="L1727">        this(latitude, longitude, height, convertTime(date), magneticModel,</span>
                listener);
<span class="fc" id="L1729">    }</span>

    /**
     * Constructor.
     * It is assumed that body has zero Euler angles representing rotation (roll = 0,
     * pitch = 0, yaw = 0) respect the horizon at provided body location.
     * For Android devices this means that the device is flat on a horizontal surface
     * with the screen facing down.
     *
     * @param latitude      latitude.
     * @param longitude     longitude.
     * @param height        height.
     * @param date          a time instance to be converted.
     * @param magneticModel world magnetic model of Earth or null if default
     *                      model is used.
     * @param listener      listener to handle events raised by this estimator.
     * @throws IOException if initialization of world magnetic model fails.
     */
    public BodyMagneticFluxDensityBiasEstimator(
            final Angle latitude, final Angle longitude, final Distance height,
            final Date date, final WorldMagneticModel magneticModel,
            final BodyMagneticFluxDensityBiasEstimatorListener listener)
            throws IOException {
<span class="fc" id="L1752">        this(latitude, longitude, height, convertTime(date), magneticModel,</span>
                listener);
<span class="fc" id="L1754">    }</span>

    /**
     * Constructor.
     *
     * @param position      body position expressed in NED coordinates.
     * @param nedC          coordinate transformation from body to local navigation
     *                      (NED) coordinates. This contains orientation respect the
     *                      horizon at current body location.
     * @param date          a time instance to be converted.
     * @param magneticModel world magnetic model of Earth or null if default
     *                      model is used.
     * @param listener      listener to handle events raised by this estimator.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not
     *                                                       from body to local
     *                                                       navigation coordinates.
     * @throws IOException                                   if initialization of
     *                                                       world magnetic model
     *                                                       fails.
     */
    public BodyMagneticFluxDensityBiasEstimator(
            final NEDPosition position, final CoordinateTransformation nedC,
            final Date date, final WorldMagneticModel magneticModel,
            final BodyMagneticFluxDensityBiasEstimatorListener listener)
            throws InvalidSourceAndDestinationFrameTypeException, IOException {
<span class="fc" id="L1780">        this(position, nedC, convertTime(date), magneticModel, listener);</span>
<span class="fc" id="L1781">    }</span>

    /**
     * Constructor.
     *
     * @param position      body position expressed in ECEF coordinates.
     * @param nedC          coordinate transformation from body to local navigation
     *                      (NED) coordinates. This contains orientation respect the
     *                      horizon at current body location.
     * @param date          a time instance to be converted.
     * @param magneticModel world magnetic model of Earth or null if default
     *                      model is used.
     * @param listener      listener to handle events raised by this estimator.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not
     *                                                       from body to local
     *                                                       navigation coordinates.
     * @throws IOException                                   if initialization of
     *                                                       world magnetic model
     *                                                       fails.
     */
    public BodyMagneticFluxDensityBiasEstimator(
            final ECEFPosition position, final CoordinateTransformation nedC,
            final Date date, final WorldMagneticModel magneticModel,
            final BodyMagneticFluxDensityBiasEstimatorListener listener)
            throws InvalidSourceAndDestinationFrameTypeException, IOException {
<span class="fc" id="L1807">        this(position, nedC, convertTime(date), magneticModel, listener);</span>
<span class="fc" id="L1808">    }</span>


    /**
     * Gets time interval between body kinematics (IMU acceleration + gyroscope)
     * samples expressed in seconds (s).
     *
     * @return time interval between body kinematics samples.
     */
    public double getTimeInterval() {
<span class="fc" id="L1818">        return mTimeInterval;</span>
    }

    /**
     * Sets time interval between body kinematics (IMU acceleration + gyroscope)
     * samples expressed in seconds (s).
     *
     * @param timeInterval time interval between body kinematics samples.
     * @throws LockedException if estimator is currently running.
     */
    public void setTimeInterval(final double timeInterval) throws LockedException {
<span class="fc bfc" id="L1829" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L1830">            throw new LockedException();</span>
        }

<span class="fc bfc" id="L1833" title="All 2 branches covered.">        if (timeInterval &lt; 0.0) {</span>
<span class="fc" id="L1834">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L1837">        mTimeInterval = timeInterval;</span>
<span class="fc" id="L1838">    }</span>

    /**
     * Gets time interval between body kinematics (IMU acceleration + gyroscope)
     * samples.
     *
     * @return time interval between body kinematics samples.
     */
    public Time getTimeIntervalAsTime() {
<span class="fc" id="L1847">        return new Time(mTimeInterval, TimeUnit.SECOND);</span>
    }

    /**
     * Gets time interval between body kinematics (IMU acceleration + gyroscope)
     * samples.
     *
     * @param result instance where time interval will be stored.
     */
    public void getTimeIntervalAsTime(final Time result) {
<span class="fc" id="L1857">        result.setValue(mTimeInterval);</span>
<span class="fc" id="L1858">        result.setUnit(TimeUnit.SECOND);</span>
<span class="fc" id="L1859">    }</span>

    /**
     * Sets time interval between body kinematics (IMU acceleration + gyroscope)
     * samples.
     *
     * @param timeInterval time interval between body kinematics samples.
     * @throws LockedException if estimator is currently running.
     */
    public void setTimeInterval(final Time timeInterval) throws LockedException {
<span class="fc" id="L1869">        setTimeInterval(convertTime(timeInterval));</span>
<span class="fc" id="L1870">    }</span>

    /**
     * Gets current body position expressed in ECEF coordinates.
     *
     * @return current body position expressed in ECEF coordinates.
     */
    public ECEFPosition getEcefPosition() {
<span class="fc" id="L1878">        return mFrame.getECEFPosition();</span>
    }

    /**
     * Gets current body position expressed in ECEF coordinates.
     *
     * @param result instance where current body position will be stored.
     */
    public void getEcefPosition(final ECEFPosition result) {
<span class="fc" id="L1887">        mFrame.getECEFPosition(result);</span>
<span class="fc" id="L1888">    }</span>

    /**
     * Sets current body position expressed in ECEF coordinates.
     *
     * @param position current body position to be set.
     * @throws LockedException if estimator is currently running.
     */
    public void setEcefPosition(final ECEFPosition position) throws LockedException {
<span class="fc bfc" id="L1897" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L1898">            throw new LockedException();</span>
        }

<span class="fc" id="L1901">        mFrame.setPosition(position);</span>

<span class="fc" id="L1903">        rebuildExpectedBodyMagneticFluxDensity();</span>
<span class="fc" id="L1904">    }</span>

    /**
     * Sets current body position expressed in ECEF coordinates.
     *
     * @param x x position resolved around ECEF axes and expressed in meters (m).
     * @param y y position resolved around ECEF axes and expressed in meters (m).
     * @param z z position resolved around ECEF axes and expressed in meters (m).
     * @throws LockedException if estimator is currently running.
     */
    public void setEcefPosition(final double x, final double y, final double z)
            throws LockedException {
<span class="fc bfc" id="L1916" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L1917">            throw new LockedException();</span>
        }

<span class="fc" id="L1920">        mFrame.setCoordinates(x, y, z);</span>

<span class="fc" id="L1922">        rebuildExpectedBodyMagneticFluxDensity();</span>
<span class="fc" id="L1923">    }</span>

    /**
     * Sets current body position expressed in ECEF coordinates.
     *
     * @param x x position resolved around ECEF axes.
     * @param y y position resolved around ECEF axes.
     * @param z z position resolved around ECEF axes.
     * @throws LockedException if estimator is currently running.
     */
    public void setEcefPosition(
            final Distance x, final Distance y, final Distance z)
            throws LockedException {
<span class="fc bfc" id="L1936" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L1937">            throw new LockedException();</span>
        }

<span class="fc" id="L1940">        mFrame.setPositionCoordinates(x, y, z);</span>

<span class="fc" id="L1942">        rebuildExpectedBodyMagneticFluxDensity();</span>
<span class="fc" id="L1943">    }</span>

    /**
     * Sets current body position expressed in ECEF coordinates.
     *
     * @param position position resolved around ECEF axes and expressed in meters (m).
     * @throws LockedException if estimator is currently running.
     */
    public void setEcefPosition(final Point3D position) throws LockedException {
<span class="fc bfc" id="L1952" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L1953">            throw new LockedException();</span>
        }

<span class="fc" id="L1956">        mFrame.setPosition(position);</span>

<span class="fc" id="L1958">        rebuildExpectedBodyMagneticFluxDensity();</span>
<span class="fc" id="L1959">    }</span>

    /**
     * Gets ECEF frame containing current body position and orientation expressed
     * in ECEF coordinates. Frame also contains body velocity, but it is always
     * assumed to be zero during calibration.
     *
     * @return ECEF frame containing current body position and orientation resolved
     * around ECEF axes.
     */
    public ECEFFrame getEcefFrame() {
<span class="fc" id="L1970">        return new ECEFFrame(mFrame);</span>
    }

    /**
     * Gets ECEF frame containing current body position and orientation expressed
     * in ECEF coordinates. Frame also contains body velocity, but it is always
     * assumed to be zero during calibration.
     *
     * @param result instance where ECEF frame containing current body position and
     *               orientation resolved around ECEF axes will be stored.
     */
    public void getEcefFrame(final ECEFFrame result) {
<span class="fc" id="L1982">        mFrame.copyTo(result);</span>
<span class="fc" id="L1983">    }</span>

    /**
     * Gets NED frame containing current body position and orientation expressed
     * in NED coordinates. Frame also contains body velocity, but it is always
     * assumed to be zero during calibration.
     *
     * @return NED frame containing current body position and orientation resolved
     * around NED axes.
     */
    public NEDFrame getNedFrame() {
<span class="fc" id="L1994">        return ECEFtoNEDFrameConverter.convertECEFtoNEDAndReturnNew(mFrame);</span>
    }

    /**
     * Gets NED frame containing current body position and orientation expressed
     * in NED coordinates. Frame also contains body velocity, but it is always
     * assumed to be zero during calibration.
     *
     * @param result instance where NED frame containing current body position and
     *               orientation resolved around NED axes will be stored.
     */
    public void getNedFrame(final NEDFrame result) {
<span class="fc" id="L2006">        ECEFtoNEDFrameConverter.convertECEFtoNED(mFrame, result);</span>
<span class="fc" id="L2007">    }</span>

    /**
     * Gets current body position expressed in NED coordinates.
     *
     * @return current body position expressed in NED coordinates.
     */
    public NEDPosition getNedPosition() {
<span class="fc" id="L2015">        return getNedFrame().getPosition();</span>
    }

    /**
     * Gets current body position expressed in NED coordinates.
     *
     * @param result instance where current body position will be stored.
     */
    public void getNedPosition(final NEDPosition result) {
<span class="fc" id="L2024">        getNedFrame().getPosition(result);</span>
<span class="fc" id="L2025">    }</span>

    /**
     * Sets current body position expressed in NED coordinates.
     *
     * @param position current body position to be set.
     * @throws LockedException if estimator is currently running.
     */
    public void setNedPosition(final NEDPosition position)
            throws LockedException {
<span class="fc bfc" id="L2035" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L2036">            throw new LockedException();</span>
        }

<span class="fc" id="L2039">        final NEDFrame nedFrame = getNedFrame();</span>
<span class="fc" id="L2040">        nedFrame.setPosition(position);</span>
<span class="fc" id="L2041">        NEDtoECEFFrameConverter.convertNEDtoECEF(nedFrame, mFrame);</span>

<span class="fc" id="L2043">        rebuildExpectedBodyMagneticFluxDensity();</span>
<span class="fc" id="L2044">    }</span>

    /**
     * Sets current body position expressed in NED coordinates.
     *
     * @param latitude  latitude NED coordinate expressed in radians (rad).
     * @param longitude longitude NED coordinate expressed in radians (rad).
     * @param height    height NED coordinate expressed in meters (m).
     * @throws LockedException if estimator is currently running.
     */
    public void setNedPosition(
            final double latitude, final double longitude, final double height)
            throws LockedException {
<span class="fc bfc" id="L2057" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L2058">            throw new LockedException();</span>
        }

<span class="fc" id="L2061">        final NEDFrame nedFrame = getNedFrame();</span>
<span class="fc" id="L2062">        nedFrame.setPosition(latitude, longitude, height);</span>
<span class="fc" id="L2063">        NEDtoECEFFrameConverter.convertNEDtoECEF(nedFrame, mFrame);</span>

<span class="fc" id="L2065">        rebuildExpectedBodyMagneticFluxDensity();</span>
<span class="fc" id="L2066">    }</span>

    /**
     * Sets current body position expressed in NED coordinates.
     *
     * @param latitude  latitude NED coordinate.
     * @param longitude longitude NED coordinate.
     * @param height    height NED coordinate expressed in meters (m).
     * @throws LockedException if estimator is currently running.
     */
    public void setNedPosition(
            final Angle latitude, final Angle longitude, final double height)
            throws LockedException {
<span class="fc bfc" id="L2079" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L2080">            throw new LockedException();</span>
        }

<span class="fc" id="L2083">        final NEDFrame nedFrame = getNedFrame();</span>
<span class="fc" id="L2084">        nedFrame.setPosition(latitude, longitude, height);</span>
<span class="fc" id="L2085">        NEDtoECEFFrameConverter.convertNEDtoECEF(nedFrame, mFrame);</span>

<span class="fc" id="L2087">        rebuildExpectedBodyMagneticFluxDensity();</span>
<span class="fc" id="L2088">    }</span>

    /**
     * Sets current body position expressed in NED coordinates.
     *
     * @param latitude  latitude NED coordinate.
     * @param longitude longitude NED coordinate.
     * @param height    height NED coordinate.
     * @throws LockedException if estimator is currently running.
     */
    public void setNedPosition(
            final Angle latitude, final Angle longitude, final Distance height)
            throws LockedException {
<span class="fc bfc" id="L2101" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L2102">            throw new LockedException();</span>
        }

<span class="fc" id="L2105">        final NEDFrame nedFrame = getNedFrame();</span>
<span class="fc" id="L2106">        nedFrame.setPosition(latitude, longitude, height);</span>
<span class="fc" id="L2107">        NEDtoECEFFrameConverter.convertNEDtoECEF(nedFrame, mFrame);</span>

<span class="fc" id="L2109">        rebuildExpectedBodyMagneticFluxDensity();</span>
<span class="fc" id="L2110">    }</span>

    /**
     * Gets current body orientation as a transformation from body to ECEF coordinates.
     * Notice that returned orientation refers to ECEF Earth axes, which means that
     * orientation is not relative to the ground or horizon at current body position.
     * Typically it is more convenient to use {@link #getNedC()} to obtain orientation
     * relative to the ground or horizon at current body position. For instance, on
     * Android devices a NED orientation with Euler angles (roll = 0, pitch = 0,
     * yaw = 0) means that the device is laying flat on a horizontal surface with the
     * screen facing down towards the ground.
     *
     * @return current body orientation resolved on ECEF axes.
     */
    public CoordinateTransformation getEcefC() {
<span class="fc" id="L2125">        return mFrame.getCoordinateTransformation();</span>
    }

    /**
     * Gets current body orientation as a transformation from body to ECEF coordinates.
     * Notice that returned orientation refers to ECEF Earth axes, which means that
     * orientation is not relative to the ground or horizon at current body position.
     * Typically it is more convenient to use {@link #getNedC()} to obtain orientation
     * relative to the ground or horizon at current body position. For instance, on
     * Android devices a NED orientation with Euler angles (roll = 0, pitch = 0,
     * yaw = 0) means that the device is laying flat on a horizontal surface with the
     * screen facing down towards the ground.
     *
     * @param result instance where current body orientation resolved on ECEF axes
     *               will be stored.
     */
    public void getEcefC(final CoordinateTransformation result) {
<span class="fc" id="L2142">        mFrame.getCoordinateTransformation(result);</span>
<span class="fc" id="L2143">    }</span>

    /**
     * Sets current body orientation as a transformation from body to ECEF coordinates.
     * Notice that ECEF orientation refers to ECEF Earth axes, which means that
     * orientation is not relative to the ground or horizont at current body position.
     * Typically it is more convenient to use
     * {@link #setNedC(CoordinateTransformation)} to specify orientation relative to
     * the ground or horizon at current body position.
     * For instance, on Android devices a NED orientation with Euler angles (roll = 0,
     * pitch = 0, yaw = 0) means that the device is laying flat on a horizontal surface
     * with the screen facing down towards the ground.
     *
     * @param ecefC body orientation resolved on ECEF axes to be set.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not from
     *                                                       body to ECEF coordinates.
     * @throws LockedException                               if estimator is currently
     *                                                       running.
     */
    public void setEcefC(final CoordinateTransformation ecefC)
            throws InvalidSourceAndDestinationFrameTypeException, LockedException {
<span class="fc bfc" id="L2165" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L2166">            throw new LockedException();</span>
        }

<span class="fc" id="L2169">        mFrame.setCoordinateTransformation(ecefC);</span>

<span class="fc" id="L2171">        rebuildExpectedBodyMagneticFluxDensity();</span>
<span class="fc" id="L2172">    }</span>

    /**
     * Gets current body orientation as a transformation from body to NED coordinates.
     * Notice that returned orientation refers to current local position. This means
     * that two equal NED orientations will transform into different ECEF orientations
     * if the body is located at different positions.
     * As a reference, on Android devices a NED orientation with Euler angles
     * (roll = 0, pitch = 0, yaw = 0) means that the device is laying flat on a
     * horizontal surface with the screen facing down towards the ground.
     *
     * @return current body orientation resolved on NED axes.
     */
    public CoordinateTransformation getNedC() {
<span class="fc" id="L2186">        return getNedFrame().getCoordinateTransformation();</span>
    }

    /**
     * Gets current body orientation as a transformation from body to NED coordinates.
     * Notice that returned orientation refers to current local position. This means
     * that two equal NED orientations will transform into different ECEF orientations
     * if the body is located at different positions.
     * As a reference, on Android devices a NED orientation with Euler angles
     * (roll = 0, pitch = 0, yaw = 0) means that the device is laying flat on a
     * horizontal surface with the screen facing down towards the ground.
     *
     * @param result instance where current body orientation resolved on NED axes
     *               will be stored.
     */
    public void getNedC(final CoordinateTransformation result) {
<span class="fc" id="L2202">        getNedFrame().getCoordinateTransformation(result);</span>
<span class="fc" id="L2203">    }</span>

    /**
     * Sets current body orientation as a transformation from body to NED coordinates.
     * Notice that provided orientation refers to current local position. This means
     * that two equal NED orientations will transform into different ECEF orientations
     * if the body is located at different positions.
     * As a reference, on Android devices a NED orientation with Euler angles
     * (roll = 0, pitch = 0, yaw = 0) means that the device is laying flat on a
     * horizontal surface with the screen facing down towards the ground.
     *
     * @param nedC orientation resolved on NED axes to be set.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not from
     *                                                       body to NED coordinates.
     * @throws LockedException                               if estimator is currently
     *                                                       running.
     */
    public void setNedC(final CoordinateTransformation nedC)
            throws InvalidSourceAndDestinationFrameTypeException, LockedException {
<span class="fc bfc" id="L2223" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L2224">            throw new LockedException();</span>
        }

<span class="fc" id="L2227">        final NEDFrame nedFrame = getNedFrame();</span>
<span class="fc" id="L2228">        nedFrame.setCoordinateTransformation(nedC);</span>
<span class="fc" id="L2229">        NEDtoECEFFrameConverter.convertNEDtoECEF(nedFrame, mFrame);</span>

<span class="fc" id="L2231">        rebuildExpectedBodyMagneticFluxDensity();</span>
<span class="fc" id="L2232">    }</span>

    /**
     * Sets position and orientation both expressed on NED coordinates.
     *
     * @param nedPosition position expressed on NED coordinates.
     * @param nedC        body to NED coordinate transformation indicating
     *                    body orientation.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not from
     *                                                       body to NED coordinates.
     * @throws LockedException                               if estimator is currently
     *                                                       running.
     * @see #setNedPosition(NEDPosition)
     * @see #setNedC(CoordinateTransformation)
     */
    public void setNedPositionAndNedOrientation(
            final NEDPosition nedPosition, final CoordinateTransformation nedC)
            throws InvalidSourceAndDestinationFrameTypeException, LockedException {
<span class="fc bfc" id="L2251" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L2252">            throw new LockedException();</span>
        }

<span class="fc" id="L2255">        final NEDFrame nedFrame = getNedFrame();</span>
<span class="fc" id="L2256">        nedFrame.setPosition(nedPosition);</span>
<span class="fc" id="L2257">        nedFrame.setCoordinateTransformation(nedC);</span>
<span class="fc" id="L2258">        NEDtoECEFFrameConverter.convertNEDtoECEF(nedFrame, mFrame);</span>

<span class="fc" id="L2260">        rebuildExpectedBodyMagneticFluxDensity();</span>
<span class="fc" id="L2261">    }</span>

    /**
     * Sets position and orientation both expressed on NED coordinates.
     *
     * @param latitude  latitude expressed in radians (rad).
     * @param longitude longitude expressed in radians (rad).
     * @param height    height expressed in meters (m).
     * @param nedC      body to NED coordinate transformation indicating
     *                  body orientation.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not from
     *                                                       body to NED coordinates.
     * @throws LockedException                               if estimator is currently
     *                                                       running.
     * @see #setNedPosition(double, double, double)
     * @see #setNedC(CoordinateTransformation)
     */
    public void setNedPositionAndNedOrientation(
            final double latitude, final double longitude, final double height,
            final CoordinateTransformation nedC)
            throws InvalidSourceAndDestinationFrameTypeException, LockedException {
<span class="fc bfc" id="L2283" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L2284">            throw new LockedException();</span>
        }

<span class="fc" id="L2287">        final NEDFrame nedFrame = getNedFrame();</span>
<span class="fc" id="L2288">        nedFrame.setPosition(latitude, longitude, height);</span>
<span class="fc" id="L2289">        nedFrame.setCoordinateTransformation(nedC);</span>
<span class="fc" id="L2290">        NEDtoECEFFrameConverter.convertNEDtoECEF(nedFrame, mFrame);</span>

<span class="fc" id="L2292">        rebuildExpectedBodyMagneticFluxDensity();</span>
<span class="fc" id="L2293">    }</span>

    /**
     * Sets position and orientation both expressed on NED coordinates.
     *
     * @param latitude  latitude.
     * @param longitude longitude.
     * @param height    height expressed in meters (m).
     * @param nedC      body to NED coordinate transformation indicating
     *                  body orientation.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not from
     *                                                       body to NED coordinates.
     * @throws LockedException                               if estimator is currently
     *                                                       running.
     * @see #setNedPosition(Angle, Angle, double)
     * @see #setNedC(CoordinateTransformation)
     */
    public void setNedPositionAndNedOrientation(
            final Angle latitude, final Angle longitude, final double height,
            final CoordinateTransformation nedC)
            throws InvalidSourceAndDestinationFrameTypeException, LockedException {
<span class="fc bfc" id="L2315" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L2316">            throw new LockedException();</span>
        }

<span class="fc" id="L2319">        final NEDFrame nedFrame = getNedFrame();</span>
<span class="fc" id="L2320">        nedFrame.setPosition(latitude, longitude, height);</span>
<span class="fc" id="L2321">        nedFrame.setCoordinateTransformation(nedC);</span>
<span class="fc" id="L2322">        NEDtoECEFFrameConverter.convertNEDtoECEF(nedFrame, mFrame);</span>

<span class="fc" id="L2324">        rebuildExpectedBodyMagneticFluxDensity();</span>
<span class="fc" id="L2325">    }</span>

    /**
     * Sets position and orientation both expressed on NED coordinates.
     *
     * @param latitude  latitude.
     * @param longitude longitude.
     * @param height    height.
     * @param nedC      body to NED coordinate transformation indicating
     *                  body orientation.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not from
     *                                                       body to NED coordinates.
     * @throws LockedException                               if estimator is currently
     *                                                       running.
     * @see #setNedPosition(Angle, Angle, Distance)
     * @see #setNedC(CoordinateTransformation)
     */
    public void setNedPositionAndNedOrientation(
            final Angle latitude, final Angle longitude, final Distance height,
            final CoordinateTransformation nedC)
            throws InvalidSourceAndDestinationFrameTypeException, LockedException {
<span class="fc bfc" id="L2347" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L2348">            throw new LockedException();</span>
        }

<span class="fc" id="L2351">        final NEDFrame nedFrame = getNedFrame();</span>
<span class="fc" id="L2352">        nedFrame.setPosition(latitude, longitude, height);</span>
<span class="fc" id="L2353">        nedFrame.setCoordinateTransformation(nedC);</span>
<span class="fc" id="L2354">        NEDtoECEFFrameConverter.convertNEDtoECEF(nedFrame, mFrame);</span>

<span class="fc" id="L2356">        rebuildExpectedBodyMagneticFluxDensity();</span>
<span class="fc" id="L2357">    }</span>

    /**
     * Sets position and orientation both expressed on ECEF coordinates.
     *
     * @param ecefPosition position expressed on ECEF coordinates.
     * @param ecefC        body to ECEF coordinate transformation indicating body
     *                     orientation.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not from
     *                                                       body to ECEF coordinates.
     * @throws LockedException                               if estimator is currently
     *                                                       running.
     * @see #setEcefPosition(ECEFPosition)
     * @see #setEcefC(CoordinateTransformation)
     */
    public void setEcefPositionAndEcefOrientation(
            final ECEFPosition ecefPosition, final CoordinateTransformation ecefC)
            throws InvalidSourceAndDestinationFrameTypeException, LockedException {
<span class="fc bfc" id="L2376" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L2377">            throw new LockedException();</span>
        }

<span class="fc" id="L2380">        mFrame.setPosition(ecefPosition);</span>
<span class="fc" id="L2381">        mFrame.setCoordinateTransformation(ecefC);</span>

<span class="fc" id="L2383">        rebuildExpectedBodyMagneticFluxDensity();</span>
<span class="fc" id="L2384">    }</span>

    /**
     * Sets position and orientation both expressed on ECEF coordinates.
     *
     * @param x     x coordinate of ECEF position expressed in meters (m).
     * @param y     y coordinate of ECEF position expressed in meters (m).
     * @param z     z coordinate of ECEF position expressed in meters (m).
     * @param ecefC body to ECEF coordinate transformation indicating body
     *              orientation.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not from
     *                                                       body to ECEF coordinates.
     * @throws LockedException                               if estimator is currently
     *                                                       running.
     * @see #setEcefPosition(double, double, double)
     * @see #setEcefC(CoordinateTransformation)
     */
    public void setEcefPositionAndEcefOrientation(
            final double x, final double y, final double z,
            final CoordinateTransformation ecefC)
            throws InvalidSourceAndDestinationFrameTypeException, LockedException {
<span class="fc bfc" id="L2406" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L2407">            throw new LockedException();</span>
        }

<span class="fc" id="L2410">        mFrame.setCoordinates(x, y, z);</span>
<span class="fc" id="L2411">        mFrame.setCoordinateTransformation(ecefC);</span>

<span class="fc" id="L2413">        rebuildExpectedBodyMagneticFluxDensity();</span>
<span class="fc" id="L2414">    }</span>

    /**
     * Sets position and orientation both expressed on ECEF coordinates.
     *
     * @param x     x coordinate of ECEF position.
     * @param y     y coordinate of ECEF position.
     * @param z     z coordinate of ECEF position.
     * @param ecefC body to ECEF coordinate transformation indicating body
     *              orientation.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not from
     *                                                       body to ECEF coordinates.
     * @throws LockedException                               if estimator is currently
     *                                                       running.
     * @see #setEcefPosition(Distance, Distance, Distance)
     * @see #setEcefC(CoordinateTransformation)
     */
    public void setEcefPositionAndEcefOrientation(
            final Distance x, final Distance y, final Distance z,
            final CoordinateTransformation ecefC)
            throws InvalidSourceAndDestinationFrameTypeException, LockedException {
<span class="fc bfc" id="L2436" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L2437">            throw new LockedException();</span>
        }

<span class="fc" id="L2440">        mFrame.setPositionCoordinates(x, y, z);</span>
<span class="fc" id="L2441">        mFrame.setCoordinateTransformation(ecefC);</span>

<span class="fc" id="L2443">        rebuildExpectedBodyMagneticFluxDensity();</span>
<span class="fc" id="L2444">    }</span>

    /**
     * Sets position and orientation both expressed on ECEF coordinates.
     *
     * @param position position resolved around ECEF axes and expressed in meters (m).
     * @param ecefC    body to ECEF coordinate transformation indicating body
     *                 orientation.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not from
     *                                                       body to ECEF coordinates.
     * @throws LockedException                               if estimator is currently
     *                                                       running.
     * @see #setEcefPosition(Point3D)
     * @see #setEcefC(CoordinateTransformation)
     */
    public void setEcefPositionAndEcefOrientation(
            final Point3D position, final CoordinateTransformation ecefC)
            throws InvalidSourceAndDestinationFrameTypeException, LockedException {
<span class="fc bfc" id="L2463" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L2464">            throw new LockedException();</span>
        }

<span class="fc" id="L2467">        mFrame.setPosition(position);</span>
<span class="fc" id="L2468">        mFrame.setCoordinateTransformation(ecefC);</span>

<span class="fc" id="L2470">        rebuildExpectedBodyMagneticFluxDensity();</span>
<span class="fc" id="L2471">    }</span>

    /**
     * Sets position expressed on NED coordinates and orientation respect to ECEF
     * axes.
     *
     * @param position position expressed on NED coordinates.
     * @param ecefC    body to ECEF coordinate transformation indicating body
     *                 orientation.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not from
     *                                                       body to ECEF coordinates.
     * @throws LockedException                               if estimator is currently
     *                                                       running.
     * @see #setNedPosition(NEDPosition)
     * @see #setEcefC(CoordinateTransformation)
     */
    public void setNedPositionAndEcefOrientation(
            final NEDPosition position,
            final CoordinateTransformation ecefC)
            throws InvalidSourceAndDestinationFrameTypeException, LockedException {
<span class="fc bfc" id="L2492" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L2493">            throw new LockedException();</span>
        }

<span class="fc" id="L2496">        final NEDFrame nedFrame = getNedFrame();</span>
<span class="fc" id="L2497">        nedFrame.setPosition(position);</span>
<span class="fc" id="L2498">        NEDtoECEFFrameConverter.convertNEDtoECEF(nedFrame, mFrame);</span>
<span class="fc" id="L2499">        mFrame.setCoordinateTransformation(ecefC);</span>

<span class="fc" id="L2501">        rebuildExpectedBodyMagneticFluxDensity();</span>
<span class="fc" id="L2502">    }</span>

    /**
     * Sets position expressed on NED coordinates and orientation respect to ECEF
     * axes.
     *
     * @param latitude  latitude expressed in radians (rad).
     * @param longitude longitude expressed in radians (rad).
     * @param height    height expressed in meters (m).
     * @param ecefC     body to ECEF coordinate transformation indicating body
     *                  orientation.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not from
     *                                                       body to ECEF coordinates.
     * @throws LockedException                               if estimator is currently
     *                                                       running.
     * @see #setNedPosition(double, double, double)
     * @see #setEcefC(CoordinateTransformation)
     */
    public void setNedPositionAndEcefOrientation(
            final double latitude, final double longitude, final double height,
            final CoordinateTransformation ecefC)
            throws InvalidSourceAndDestinationFrameTypeException, LockedException {
<span class="fc bfc" id="L2525" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L2526">            throw new LockedException();</span>
        }

<span class="fc" id="L2529">        final NEDFrame nedFrame = getNedFrame();</span>
<span class="fc" id="L2530">        nedFrame.setPosition(latitude, longitude, height);</span>
<span class="fc" id="L2531">        NEDtoECEFFrameConverter.convertNEDtoECEF(nedFrame, mFrame);</span>
<span class="fc" id="L2532">        mFrame.setCoordinateTransformation(ecefC);</span>

<span class="fc" id="L2534">        rebuildExpectedBodyMagneticFluxDensity();</span>
<span class="fc" id="L2535">    }</span>

    /**
     * Sets position expressed on NED coordinates and orientation respect to ECEF
     * axes.
     *
     * @param latitude  latitude.
     * @param longitude longitude.
     * @param height    height expressed in meters (m).
     * @param ecefC     body to ECEF coordinate transformation indicating body
     *                  orientation.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not from
     *                                                       body to ECEF coordinates.
     * @throws LockedException                               if estimator is currently
     *                                                       running.
     * @see #setNedPosition(Angle, Angle, double)
     * @see #setEcefC(CoordinateTransformation)
     */
    public void setNedPositionAndEcefOrientation(
            final Angle latitude, final Angle longitude, final double height,
            final CoordinateTransformation ecefC)
            throws InvalidSourceAndDestinationFrameTypeException, LockedException {
<span class="fc bfc" id="L2558" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L2559">            throw new LockedException();</span>
        }

<span class="fc" id="L2562">        final NEDFrame nedFrame = getNedFrame();</span>
<span class="fc" id="L2563">        nedFrame.setPosition(latitude, longitude, height);</span>
<span class="fc" id="L2564">        NEDtoECEFFrameConverter.convertNEDtoECEF(nedFrame, mFrame);</span>
<span class="fc" id="L2565">        mFrame.setCoordinateTransformation(ecefC);</span>

<span class="fc" id="L2567">        rebuildExpectedBodyMagneticFluxDensity();</span>
<span class="fc" id="L2568">    }</span>

    /**
     * Sets position expressed on NED coordinates and orientation respect to ECEF
     * axes.
     *
     * @param latitude  latitude.
     * @param longitude longitude.
     * @param height    height.
     * @param ecefC     body to ECEF coordinate transformation indicating body
     *                  orientation.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not from
     *                                                       body to ECEF coordinates.
     * @throws LockedException                               if estimator is currently
     *                                                       running.
     * @see #setNedPosition(Angle, Angle, Distance)
     * @see #setEcefC(CoordinateTransformation)
     */
    public void setNedPositionAndEcefOrientation(
            final Angle latitude, final Angle longitude, final Distance height,
            final CoordinateTransformation ecefC)
            throws InvalidSourceAndDestinationFrameTypeException, LockedException {
<span class="fc bfc" id="L2591" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L2592">            throw new LockedException();</span>
        }

<span class="fc" id="L2595">        final NEDFrame nedFrame = getNedFrame();</span>
<span class="fc" id="L2596">        nedFrame.setPosition(latitude, longitude, height);</span>
<span class="fc" id="L2597">        NEDtoECEFFrameConverter.convertNEDtoECEF(nedFrame, mFrame);</span>
<span class="fc" id="L2598">        mFrame.setCoordinateTransformation(ecefC);</span>

<span class="fc" id="L2600">        rebuildExpectedBodyMagneticFluxDensity();</span>
<span class="fc" id="L2601">    }</span>

    /**
     * Sets position expressed on ECEF coordinates and orientation respect to
     * NED axes.
     * In order to preserve provided orientation, first position is set and
     * then orientation is applied.
     *
     * @param ecefPosition position expressed on ECEF coordinates.
     * @param nedC         body to NED coordinate transformation indicating body
     *                     orientation.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not from
     *                                                       body to NED coordinates.
     * @throws LockedException                               if estimator is currently
     *                                                       running.
     * @see #setEcefPosition(ECEFPosition)
     * @see #setNedC(CoordinateTransformation)
     */
    public void setEcefPositionAndNedOrientation(
            final ECEFPosition ecefPosition, final CoordinateTransformation nedC)
            throws InvalidSourceAndDestinationFrameTypeException, LockedException {
<span class="fc bfc" id="L2623" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L2624">            throw new LockedException();</span>
        }

<span class="fc" id="L2627">        mFrame.setPosition(ecefPosition);</span>

<span class="fc" id="L2629">        final NEDFrame nedFrame = getNedFrame();</span>
<span class="fc" id="L2630">        nedFrame.setCoordinateTransformation(nedC);</span>
<span class="fc" id="L2631">        NEDtoECEFFrameConverter.convertNEDtoECEF(nedFrame, mFrame);</span>

<span class="fc" id="L2633">        rebuildExpectedBodyMagneticFluxDensity();</span>
<span class="fc" id="L2634">    }</span>

    /**
     * Sets position expressed on ECEF coordinates and orientation respect to
     * NED axes.
     * In order to preserve provided orientation, first position is set and
     * then orientation is applied.
     *
     * @param x    x coordinate of ECEF position expressed in meters (m).
     * @param y    y coordinate of ECEF position expressed in meters (m).
     * @param z    z coordinate of ECEF position expressed in meters (m).
     * @param nedC body to NED coordinate transformation indicating body
     *             orientation.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not from
     *                                                       body to NED coordinates.
     * @throws LockedException                               if estimator is currently
     *                                                       running.
     * @see #setEcefPosition(double, double, double)
     * @see #setNedC(CoordinateTransformation)
     */
    public void setEcefPositionAndNedOrientation(
            final double x, final double y, final double z,
            final CoordinateTransformation nedC)
            throws InvalidSourceAndDestinationFrameTypeException, LockedException {
<span class="fc bfc" id="L2659" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L2660">            throw new LockedException();</span>
        }

<span class="fc" id="L2663">        mFrame.setCoordinates(x, y, z);</span>

<span class="fc" id="L2665">        final NEDFrame nedFrame = getNedFrame();</span>
<span class="fc" id="L2666">        nedFrame.setCoordinateTransformation(nedC);</span>
<span class="fc" id="L2667">        NEDtoECEFFrameConverter.convertNEDtoECEF(nedFrame, mFrame);</span>

<span class="fc" id="L2669">        rebuildExpectedBodyMagneticFluxDensity();</span>
<span class="fc" id="L2670">    }</span>

    /**
     * Sets position expressed on ECEF coordinates and orientation respect to
     * NED axes.
     * In order to preserve provided orientation, first position is set and
     * then orientation is applied.
     *
     * @param x    x coordinate of ECEF position.
     * @param y    y coordinate of ECEF position.
     * @param z    z coordinate of ECEF position.
     * @param nedC body to NED coordinate transformation indicating body
     *             orientation.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not from
     *                                                       body to NED coordinates.
     * @throws LockedException                               if estimator is currently
     *                                                       running.
     * @see #setEcefPosition(Distance, Distance, Distance)
     * @see #setNedC(CoordinateTransformation)
     */
    public void setEcefPositionAndNedOrientation(
            final Distance x, final Distance y, final Distance z,
            final CoordinateTransformation nedC)
            throws InvalidSourceAndDestinationFrameTypeException, LockedException {
<span class="fc bfc" id="L2695" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L2696">            throw new LockedException();</span>
        }

<span class="fc" id="L2699">        mFrame.setPositionCoordinates(x, y, z);</span>

<span class="fc" id="L2701">        final NEDFrame nedFrame = getNedFrame();</span>
<span class="fc" id="L2702">        nedFrame.setCoordinateTransformation(nedC);</span>
<span class="fc" id="L2703">        NEDtoECEFFrameConverter.convertNEDtoECEF(nedFrame, mFrame);</span>

<span class="fc" id="L2705">        rebuildExpectedBodyMagneticFluxDensity();</span>
<span class="fc" id="L2706">    }</span>

    /**
     * Sets position expressed on ECEF coordinates and orientation respect to
     * NED axes.
     * In order to preserve provided orientation, first position is set and
     * then orientation is applied.
     *
     * @param position position resolved around ECEF axes and expressed in meters (m).
     * @param nedC     body to NED coordinate transformation indicating body
     *                 orientation.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not from
     *                                                       body to NED coordinates.
     * @throws LockedException                               if estimator is currently
     *                                                       running.
     * @see #setEcefPosition(Point3D)
     * @see #setNedC(CoordinateTransformation)
     */
    public void setEcefPositionAndNedOrientation(
            final Point3D position, final CoordinateTransformation nedC)
            throws InvalidSourceAndDestinationFrameTypeException, LockedException {
<span class="fc bfc" id="L2728" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L2729">            throw new LockedException();</span>
        }

<span class="fc" id="L2732">        mFrame.setPosition(position);</span>

<span class="fc" id="L2734">        final NEDFrame nedFrame = getNedFrame();</span>
<span class="fc" id="L2735">        nedFrame.setCoordinateTransformation(nedC);</span>
<span class="fc" id="L2736">        NEDtoECEFFrameConverter.convertNEDtoECEF(nedFrame, mFrame);</span>

<span class="fc" id="L2738">        rebuildExpectedBodyMagneticFluxDensity();</span>
<span class="fc" id="L2739">    }</span>

    /**
     * Gets year expressed in decimal format.
     *
     * @return year expressed in decimal format.
     */
    public double getYear() {
<span class="fc" id="L2747">        return mYear;</span>
    }

    /**
     * Sets year expressed in decimal format.
     *
     * @param year year expressed in decimal format.
     * @throws LockedException if estimator is running.
     */
    public void setYear(final double year) throws LockedException {
<span class="fc bfc" id="L2757" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L2758">            throw new LockedException();</span>
        }

<span class="fc" id="L2761">        mYear = year;</span>

<span class="fc" id="L2763">        rebuildExpectedBodyMagneticFluxDensity();</span>
<span class="fc" id="L2764">    }</span>

    /**
     * Sets decimal year from provided date instance.
     *
     * @param date a date instance containing a timestamp.
     * @throws LockedException if estimator is running.
     */
    public void setTime(final Date date) throws LockedException {
<span class="fc bfc" id="L2773" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L2774">            throw new LockedException();</span>
        }

<span class="fc" id="L2777">        mYear = convertTime(date);</span>

<span class="fc" id="L2779">        rebuildExpectedBodyMagneticFluxDensity();</span>
<span class="fc" id="L2780">    }</span>

    /**
     * Sets decimal year from provided calendar instance.
     *
     * @param calendar a calendar instance containing a timestamp.
     * @throws LockedException if estimator is running.
     */
    public void setTime(final GregorianCalendar calendar)
            throws LockedException {
<span class="fc bfc" id="L2790" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L2791">            throw new LockedException();</span>
        }

<span class="fc" id="L2794">        mYear = convertTime(calendar);</span>

<span class="fc" id="L2796">        rebuildExpectedBodyMagneticFluxDensity();</span>
<span class="fc" id="L2797">    }</span>

    /**
     * Gets Earth's magnetic model.
     *
     * @return Earth's magnetic model or null if not provided.
     */
    public WorldMagneticModel getMagneticModel() {
<span class="fc" id="L2805">        return mMagneticModel;</span>
    }

    /**
     * Sets Earth's magnetic model.
     * If not provided a default model will be loaded internally.
     *
     * @param magneticModel Earth's magnetic model to be set.
     * @throws LockedException if calibrator is currently running.
     * @throws IOException     if initialization of world magnetic model fails.
     */
    public void setMagneticModel(final WorldMagneticModel magneticModel)
            throws LockedException, IOException {
<span class="fc bfc" id="L2818" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L2819">            throw new LockedException();</span>
        }
<span class="fc" id="L2821">        mMagneticModel = magneticModel;</span>
<span class="fc" id="L2822">        initialize();</span>
<span class="fc" id="L2823">    }</span>

    /**
     * Gets listener to handle events raised by this estimator.
     *
     * @return listener to handle events raised by this estimator.
     */
    public BodyMagneticFluxDensityBiasEstimatorListener getListener() {
<span class="fc" id="L2831">        return mListener;</span>
    }

    /**
     * Sets listener to handle events raised by this estimator.
     *
     * @param listener listener to handle events raised by this estimator.
     * @throws LockedException if this estimator is running.
     */
    public void setListener(
            final BodyMagneticFluxDensityBiasEstimatorListener listener)
            throws LockedException {
<span class="fc bfc" id="L2843" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L2844">            throw new LockedException();</span>
        }

<span class="fc" id="L2847">        mListener = listener;</span>
<span class="fc" id="L2848">    }</span>

    /**
     * Gets last provided body magnetic flux density values or null if not
     * available.
     *
     * @return last provided body magnetic flux density values or null.
     */
    public BodyMagneticFluxDensity getLastBodyMagneticFluxDensity() {
<span class="fc bfc" id="L2857" title="All 2 branches covered.">        return mLastBodyMagneticFluxDensity != null ?</span>
<span class="fc" id="L2858">                new BodyMagneticFluxDensity(mLastBodyMagneticFluxDensity) : null;</span>
    }

    /**
     * Gets last provided body magnetic flux density values.
     *
     * @param result instance where last provided body magnetic flux density will
     *               be stored.
     * @return true if result instance was updated, false otherwise.
     */
    public boolean getLastBodyMagneticFluxDensity(final BodyMagneticFluxDensity result) {
<span class="fc bfc" id="L2869" title="All 2 branches covered.">        if (mLastBodyMagneticFluxDensity != null) {</span>
<span class="fc" id="L2870">            mLastBodyMagneticFluxDensity.copyTo(result);</span>
<span class="fc" id="L2871">            return true;</span>
        } else {
<span class="fc" id="L2873">            return false;</span>
        }
    }

    /**
     * Gets estimated bias of x coordinate of body magnetic flux density
     * expressed in Teslas (T). Notice that bias is equivalent to hard iron
     * component on a magnetometer calibrator.
     *
     * @return bias of x coordinate of body magnetic flux density.
     */
    public double getBiasX() {
<span class="fc" id="L2885">        return mBiasX;</span>
    }

    /**
     * Gets estimated bias of x coordinate of body magnetic flux density.
     * Notice that bias is equivalent to hard iron component on a magnetometer
     * calibrator.
     *
     * @return bias of x coordinate of body magnetic flux density.
     */
    public MagneticFluxDensity getBiasXAsMagneticFluxDensity() {
<span class="fc" id="L2896">        return new MagneticFluxDensity(mBiasX, MagneticFluxDensityUnit.TESLA);</span>
    }

    /**
     * Gets estimated bias of x coordinate of body magnetic flux density.
     * Notice that bias is equivalent to hard iron component on a magnetometer
     * calibrator.
     *
     * @param result instance where bias of x coordinate of body magnetic flux
     *               density will be stored.
     */
    public void getBiasXAsMagneticFluxDensity(final MagneticFluxDensity result) {
<span class="fc" id="L2908">        result.setValue(mBiasX);</span>
<span class="fc" id="L2909">        result.setUnit(MagneticFluxDensityUnit.TESLA);</span>
<span class="fc" id="L2910">    }</span>

    /**
     * Gets estimated bias of y coordinate of body magnetic flux density
     * expressed in Teslas (T). Notice that bias is equivalent to hard iron
     * component on a magnetometer calibrator.
     *
     * @return bias of y coordinate of body magnetic flux density.
     */
    public double getBiasY() {
<span class="fc" id="L2920">        return mBiasY;</span>
    }

    /**
     * Gets estimated bias of y coordinate of body magnetic flux density.
     * Notice that bias is equivalent to hard iron component on a
     * magnetometer calibrator.
     *
     * @return bias of y coordinate of body magnetic flux density.
     */
    public MagneticFluxDensity getBiasYAsMagneticFluxDensity() {
<span class="fc" id="L2931">        return new MagneticFluxDensity(mBiasY, MagneticFluxDensityUnit.TESLA);</span>
    }

    /**
     * Gets estimated bias of y coordinate of body magnetic flux density.
     * Notice that bias is equivalent to hard iron component on a
     * magnetometer calibrator.
     *
     * @param result instance where bias of y coordinate of body magnetic flux
     *               density will be stored.
     */
    public void getBiasYAsMagneticFluxDensity(final MagneticFluxDensity result) {
<span class="fc" id="L2943">        result.setValue(mBiasY);</span>
<span class="fc" id="L2944">        result.setUnit(MagneticFluxDensityUnit.TESLA);</span>
<span class="fc" id="L2945">    }</span>

    /**
     * Gets estimated bias of z coordinate of body magnetic flux density
     * expressed in Teslas (T). Notice that bias is equivalent to hard iron
     * component on a magnetometer calibrator.
     *
     * @return bias of z coordinate of body magnetic flux density.
     */
    public double getBiasZ() {
<span class="fc" id="L2955">        return mBiasZ;</span>
    }

    /**
     * Gets estimated bias of z coordinate of body magnetic flux density.
     * Notice that bias is equivalent to hard iron component on a magnetometer
     * calibrator.
     *
     * @return bias of z coordinate of body magnetic flux density.
     */
    public MagneticFluxDensity getBiasZAsMagneticFluxDensity() {
<span class="fc" id="L2966">        return new MagneticFluxDensity(mBiasZ, MagneticFluxDensityUnit.TESLA);</span>
    }

    /**
     * Gets estimated bias of z coordinate of body magnetic flux density.
     * Notice that bias is equivalent to hard iron component on a magnetometer
     * calibrator.
     *
     * @param result instance where bias of z coordinate of body magnetic flux
     *               density will be stored.
     */
    public void getBiasZAsMagneticFluxDensity(final MagneticFluxDensity result) {
<span class="fc" id="L2978">        result.setValue(mBiasZ);</span>
<span class="fc" id="L2979">        result.setUnit(MagneticFluxDensityUnit.TESLA);</span>
<span class="fc" id="L2980">    }</span>

    /**
     * Gets estimated bias of body magnetic flux density.
     *
     * @return estimated bias of magnetic flux density.
     */
    public MagneticFluxDensityTriad getBiasTriad() {
<span class="fc" id="L2988">        return new MagneticFluxDensityTriad(MagneticFluxDensityUnit.TESLA,</span>
                mBiasX, mBiasY, mBiasZ);
    }

    /**
     * Gets estimated bias of body magnetic flux density.
     *
     * @param result instance where bias of body magnetic flux density will
     *               be stored.
     */
    public void getBiasTriad(final MagneticFluxDensityTriad result) {
<span class="fc" id="L2999">        result.setValueCoordinatesAndUnit(mBiasX, mBiasY, mBiasZ,</span>
                MagneticFluxDensityUnit.TESLA);
<span class="fc" id="L3001">    }</span>

    /**
     * Gets estimated variance of x coordinate of body magnetic flux density
     * expressed in squared Teslas (T^2).
     *
     * @return estimated variance of x coordinate of body magnetic flux density.
     */
    public double getVarianceX() {
<span class="fc" id="L3010">        return mVarianceX;</span>
    }

    /**
     * Gets estimated variance of y coordinate of body magnetic flux density
     * expressed in squared Teslas (T^2).
     *
     * @return estimated variance of y coordinate of body magnetic flux density.
     */
    public double getVarianceY() {
<span class="fc" id="L3020">        return mVarianceY;</span>
    }

    /**
     * Gets estimated variance of z coordinate of body magnetic flux density
     * expressed in squared Teslas (T^2).
     *
     * @return estimated variance of z coordinate of body magnetic flux density.
     */
    public double getVarianceZ() {
<span class="fc" id="L3030">        return mVarianceZ;</span>
    }

    /**
     * Gets estimated standard deviation of x coordinate of body magnetic flux
     * density expressed in Teslas (T).
     *
     * @return estimated standard deviation of x coordinate of body magnetic
     * flux density.
     */
    public double getStandardDeviationX() {
<span class="fc" id="L3041">        return Math.sqrt(mVarianceX);</span>
    }

    /**
     * Gets estimated standard deviation of x coordinate of body magnetic flux
     * density.
     *
     * @return estimated standard deviation of x coordinate of body magnetic
     * flux density.
     */
    public MagneticFluxDensity getStandardDeviationXAsMagneticFluxDensity() {
<span class="fc" id="L3052">        return new MagneticFluxDensity(getStandardDeviationX(),</span>
                MagneticFluxDensityUnit.TESLA);
    }

    /**
     * Gets estimated standard deviation of x coordinate of body magnetic flux
     * density.
     *
     * @param result instance where estimated standard deviation of x coordinate
     *               of body magnetic flux density will be stored.
     */
    public void getStandardDeviationXAsMagneticFluxDensity(
            final MagneticFluxDensity result) {
<span class="fc" id="L3065">        result.setValue(getStandardDeviationX());</span>
<span class="fc" id="L3066">        result.setUnit(MagneticFluxDensityUnit.TESLA);</span>
<span class="fc" id="L3067">    }</span>

    /**
     * Gets estimated standard deviation of y coordinate of body magnetic flux
     * density expressed in Teslas (T).
     *
     * @return estimated standard deviation of y coordinate of body magnetic
     * flux density.
     */
    public double getStandardDeviationY() {
<span class="fc" id="L3077">        return Math.sqrt(mVarianceY);</span>
    }

    /**
     * Gets estimated standard deviation of y coordinate of body magnetic flux
     * density.
     *
     * @return estimated standard deviation of y coordinate of body magnetic
     * flux density.
     */
    public MagneticFluxDensity getStandardDeviationYAsMagneticFluxDensity() {
<span class="fc" id="L3088">        return new MagneticFluxDensity(getStandardDeviationY(),</span>
                MagneticFluxDensityUnit.TESLA);
    }

    /**
     * Gets estimated standard deviation of y coordinate of body magnetic flux
     * density.
     *
     * @param result instance where estimated standard deviation of y coordinate
     *               of body magnetic flux density will be stored.
     */
    public void getStandardDeviationYAsMagneticFluxDensity(
            final MagneticFluxDensity result) {
<span class="fc" id="L3101">        result.setValue(getStandardDeviationY());</span>
<span class="fc" id="L3102">        result.setUnit(MagneticFluxDensityUnit.TESLA);</span>
<span class="fc" id="L3103">    }</span>

    /**
     * Gets estimated standard deviation of z coordinate of body magnetic flux
     * density expressed in Teslas (T).
     *
     * @return estimated standard deviation of z coordinate of body magnetic
     * flux density.
     */
    public double getStandardDeviationZ() {
<span class="fc" id="L3113">        return Math.sqrt(mVarianceZ);</span>
    }

    /**
     * Gets estimated standard deviation of z coordinate of body magnetic flux
     * density.
     *
     * @return estimated standard deviation of z coordinate of body magnetic
     * flux density.
     */
    public MagneticFluxDensity getStandardDeviationZAsMagneticFluxDensity() {
<span class="fc" id="L3124">        return new MagneticFluxDensity(getStandardDeviationZ(),</span>
                MagneticFluxDensityUnit.TESLA);
    }

    /**
     * Gets estimated standard deviation of z coordinate of body magnetic flux
     * density.
     *
     * @param result instance where estimated standard deviation of z coordinate
     *               of body magnetic flux density will be stored.
     */
    public void getStandardDeviationZAsMagneticFluxDensity(
            final MagneticFluxDensity result) {
<span class="fc" id="L3137">        result.setValue(getStandardDeviationZ());</span>
<span class="fc" id="L3138">        result.setUnit(MagneticFluxDensityUnit.TESLA);</span>
<span class="fc" id="L3139">    }</span>

    /**
     * Gets estimated standard deviation of body magnetic flux density.
     *
     * @return estimated standard deviation of body magnetic flux density.
     */
    public MagneticFluxDensityTriad getStandardDeviationTriad() {
<span class="fc" id="L3147">        return new MagneticFluxDensityTriad(MagneticFluxDensityUnit.TESLA,</span>
<span class="fc" id="L3148">                getStandardDeviationX(),</span>
<span class="fc" id="L3149">                getStandardDeviationY(),</span>
<span class="fc" id="L3150">                getStandardDeviationZ());</span>
    }

    /**
     * Gets estimated standard deviation of body magnetic flux density.
     *
     * @param result instance where estimated standard deviation of body magnetic
     *               flux density will be stored.
     */
    public void getStandardDeviationTriad(final MagneticFluxDensityTriad result) {
<span class="fc" id="L3160">        result.setValueCoordinatesAndUnit(getStandardDeviationX(),</span>
<span class="fc" id="L3161">                getStandardDeviationY(), getStandardDeviationZ(),</span>
                MagneticFluxDensityUnit.TESLA);
<span class="fc" id="L3163">    }</span>

    /**
     * Gets average of estimated standard deviation of body magnetic flux density
     * expressed in Teslas (T).
     *
     * @return average of estimated standard deviation of body magnetic flux
     * density.
     */
    public double getAverageStandardDeviation() {
<span class="fc" id="L3173">        return (getStandardDeviationX() + getStandardDeviationY()</span>
<span class="fc" id="L3174">                + getStandardDeviationZ()) / 3.0;</span>
    }

    /**
     * Gets average of estimated standard deviation of body magnetic flux density.
     *
     * @return average of estimated standard deviation of body magnetic flux
     * density.
     */
    public MagneticFluxDensity getAverageStandardDeviationAsMagneticFluxDensity() {
<span class="fc" id="L3184">        return new MagneticFluxDensity(getAverageStandardDeviation(),</span>
                MagneticFluxDensityUnit.TESLA);
    }

    /**
     * Gets average of estimated standard deviation of body magnetic flux density.
     *
     * @param result instance where average of estimated standard deviation of
     *               body magnetic flux density will be stored.
     */
    public void getAverageStandardDeviationAsMagneticFluxDensity(
            final MagneticFluxDensity result) {
<span class="fc" id="L3196">        result.setValue(getAverageStandardDeviation());</span>
<span class="fc" id="L3197">        result.setUnit(MagneticFluxDensityUnit.TESLA);</span>
<span class="fc" id="L3198">    }</span>

    /**
     * Gets magnetometer noise PSD (Power Spectral Density) on x axis expressed
     * in (T^2 * s).
     *
     * @return magnetometer noise PSD on x axis.
     */
    public double getPsdX() {
<span class="fc" id="L3207">        return mVarianceX * mTimeInterval;</span>
    }

    /**
     * Gets magnetometer noise PSD (Power Spectral Density) on y axis expressed
     * in (T^2 * s).
     *
     * @return magnetometer noise PSD on y axis.
     */
    public double getPsdY() {
<span class="fc" id="L3217">        return mVarianceY * mTimeInterval;</span>
    }

    /**
     * Gets magnetometer noise PSD (Power Spectral Density) on z axis expressed
     * in (T^2 * s).
     *
     * @return magnetometer noise PSD on z axis.
     */
    public double getPsdZ() {
<span class="fc" id="L3227">        return mVarianceZ * mTimeInterval;</span>
    }

    /**
     * Gets magnetometer noise root PSD (Power Spectral Density) on x axis
     * expressed in (T * s^0.5).
     *
     * @return magnetometer noise root PSD on x axis.
     */
    public double getRootPsdX() {
<span class="fc" id="L3237">        return Math.sqrt(getPsdX());</span>
    }

    /**
     * Gets magnetometer noise root PSD (Power Spectral Density) on y axis
     * expressed in (T * s^0.5).
     *
     * @return magnetometer noise root PSD on y axis.
     */
    public double getRootPsdY() {
<span class="fc" id="L3247">        return Math.sqrt(getPsdY());</span>
    }

    /**
     * Gets magnetometer noise root PSD (Power Spectral Density) on z axis
     * expressed in (T * s^0.5).
     *
     * @return magnetometer noise root PSD on z axis.
     */
    public double getRootPsdZ() {
<span class="fc" id="L3257">        return Math.sqrt(getPsdZ());</span>
    }

    /**
     * Gets average magnetometer noise PSD (Power Spectral Density) among
     * x,y,z components expressed as (T^2 * s).
     *
     * @return average magnetometer noise PSD.
     */
    public double getAvgPsd() {
<span class="fc" id="L3267">        return (getPsdX() + getPsdY() + getPsdZ()) / 3.0;</span>
    }

    /**
     * Gets average magnetometer noise root PSD (Power Spectral Density) among
     * x,y,z components expressed as (T * s^0.5).
     *
     * @return average magnetometer noise root PSD.
     */
    public double getAvgRootPsd() {
<span class="fc" id="L3277">        return Math.sqrt(getAvgPsd());</span>
    }

    /**
     * Gets number of samples that have been processed so far.
     *
     * @return number of samples that have been processed so far.
     */
    public int getNumberOfProcessedSamples() {
<span class="fc" id="L3286">        return mNumberOfProcessedSamples;</span>
    }

    /**
     * Indicates whether estimator is currently running or not.
     *
     * @return true if estimator is running, false otherwise.
     */
    public boolean isRunning() {
<span class="fc" id="L3295">        return mRunning;</span>
    }

    /**
     * Gets theoretically expected body magnetic flux density for provided instant,
     * body position and orientation, assuming that body remains at the same
     * position (zero velocity).
     * When body remains static, sensed magentic flux density will remain constant
     * for a few minutes respect to provided time instant.
     *
     * @return expected body magnetic flux density.
     */
    public BodyMagneticFluxDensity getExpectedBodyMagneticFluxDensity() {
<span class="fc" id="L3308">        return new BodyMagneticFluxDensity(mExpectedBodyMagneticFluxDensity);</span>
    }

    /**
     * Gets theoretically expected body magnetic flux density for provided instant,
     * body position and orientation, assuming that body remains at the same
     * position (zero velocity).
     * When body remains static, sensed magentic flux density will remain constant
     * for a few minutes respect to provided time instant.
     *
     * @param result instance where expected body magnetic flux density will be
     *               stored.
     */
    public void getExpectedBodyMagneticFluxDensity(
            final BodyMagneticFluxDensity result) {
<span class="fc" id="L3323">        mExpectedBodyMagneticFluxDensity.copyTo(result);</span>
<span class="fc" id="L3324">    }</span>

    /**
     * Adds a sample of body magnetic flux density. If estimator is already
     *
     * @param bodyMagneticFluxDensity body magnetic flux density to be added
     *                                and processed.
     * @throws LockedException if estimator is currently running.
     */
    public void addBodyMagneticFluxDensity(
            final BodyMagneticFluxDensity bodyMagneticFluxDensity)
            throws LockedException {

<span class="pc bpc" id="L3337" title="1 of 2 branches missed.">        if (mRunning) {</span>
<span class="nc" id="L3338">            throw new LockedException();</span>
        }

<span class="fc" id="L3341">        mRunning = true;</span>

<span class="pc bpc" id="L3343" title="1 of 4 branches missed.">        if (mLastBodyMagneticFluxDensity == null &amp;&amp; mListener != null) {</span>
<span class="fc" id="L3344">            mListener.onStart(this);</span>
        }

<span class="fc" id="L3347">        final double bx = bodyMagneticFluxDensity.getBx();</span>
<span class="fc" id="L3348">        final double by = bodyMagneticFluxDensity.getBy();</span>
<span class="fc" id="L3349">        final double bz = bodyMagneticFluxDensity.getBz();</span>

<span class="fc" id="L3351">        final double expectedBx = mExpectedBodyMagneticFluxDensity.getBx();</span>
<span class="fc" id="L3352">        final double expectedBy = mExpectedBodyMagneticFluxDensity.getBy();</span>
<span class="fc" id="L3353">        final double expectedBz = mExpectedBodyMagneticFluxDensity.getBz();</span>

<span class="fc" id="L3355">        final double diffBx = bx - expectedBx;</span>
<span class="fc" id="L3356">        final double diffBy = by - expectedBy;</span>
<span class="fc" id="L3357">        final double diffBz = bz - expectedBz;</span>

        // compute biases
<span class="fc" id="L3360">        final double tmp = (double) mNumberOfProcessedSamples</span>
                / (double) mNumberOfProcessedSamplesPlusOne;
<span class="fc" id="L3362">        mBiasX = mBiasX * tmp + diffBx / (double) mNumberOfProcessedSamplesPlusOne;</span>
<span class="fc" id="L3363">        mBiasY = mBiasY * tmp + diffBy / (double) mNumberOfProcessedSamplesPlusOne;</span>
<span class="fc" id="L3364">        mBiasZ = mBiasZ * tmp + diffBz / (double) mNumberOfProcessedSamplesPlusOne;</span>

        // compute variances
<span class="fc" id="L3367">        final double diffBiasX = diffBx - mBiasX;</span>
<span class="fc" id="L3368">        final double diffBiasY = diffBy - mBiasY;</span>
<span class="fc" id="L3369">        final double diffBiasZ = diffBz - mBiasZ;</span>

<span class="fc" id="L3371">        final double diffBiasX2 = diffBiasX * diffBiasX;</span>
<span class="fc" id="L3372">        final double diffBiasY2 = diffBiasY * diffBiasY;</span>
<span class="fc" id="L3373">        final double diffBiasZ2 = diffBiasZ * diffBiasZ;</span>

<span class="fc" id="L3375">        mVarianceX = mVarianceX * tmp</span>
                + diffBiasX2 / (double) mNumberOfProcessedSamplesPlusOne;
<span class="fc" id="L3377">        mVarianceY = mVarianceY * tmp</span>
                + diffBiasY2 / (double) mNumberOfProcessedSamplesPlusOne;
<span class="fc" id="L3379">        mVarianceZ = mVarianceZ * tmp</span>
                + diffBiasZ2 / (double) mNumberOfProcessedSamplesPlusOne;

<span class="fc" id="L3382">        mLastBodyMagneticFluxDensity = bodyMagneticFluxDensity;</span>

<span class="fc" id="L3384">        mNumberOfProcessedSamples++;</span>
<span class="fc" id="L3385">        mNumberOfProcessedSamplesPlusOne++;</span>

<span class="pc bpc" id="L3387" title="1 of 2 branches missed.">        if (mListener != null) {</span>
<span class="fc" id="L3388">            mListener.onBodyMagneticFluxDensityAdded(this);</span>
        }

<span class="fc" id="L3391">        mRunning = false;</span>
<span class="fc" id="L3392">    }</span>

    /**
     * Resets current estimator.
     *
     * @return true if estimator was successfully reset, false if no reset
     * was needed.
     * @throws LockedException if estimator is currently running.
     */
    public boolean reset() throws LockedException {
<span class="pc bpc" id="L3402" title="1 of 2 branches missed.">        if (mRunning) {</span>
<span class="nc" id="L3403">            throw new LockedException();</span>
        }

<span class="fc bfc" id="L3406" title="All 2 branches covered.">        if (mNumberOfProcessedSamples == 0) {</span>
<span class="fc" id="L3407">            return false;</span>
        }

<span class="fc" id="L3410">        mRunning = true;</span>
<span class="fc" id="L3411">        mLastBodyMagneticFluxDensity = null;</span>
<span class="fc" id="L3412">        mBiasX = 0.0;</span>
<span class="fc" id="L3413">        mBiasY = 0.0;</span>
<span class="fc" id="L3414">        mBiasZ = 0.0;</span>
<span class="fc" id="L3415">        mVarianceX = 0.0;</span>
<span class="fc" id="L3416">        mVarianceY = 0.0;</span>
<span class="fc" id="L3417">        mVarianceZ = 0.0;</span>
<span class="fc" id="L3418">        mNumberOfProcessedSamples = 0;</span>
<span class="fc" id="L3419">        mNumberOfProcessedSamplesPlusOne = 1;</span>

<span class="pc bpc" id="L3421" title="1 of 2 branches missed.">        if (mListener != null) {</span>
<span class="fc" id="L3422">            mListener.onReset(this);</span>
        }

<span class="fc" id="L3425">        mRunning = false;</span>

<span class="fc" id="L3427">        return true;</span>
    }

    /**
     * Converts a time instant contained ina date object to a
     * decimal year.
     *
     * @param date a time instance to be converted.
     * @return converted value expressed in decimal years.
     */
    public static double convertTime(final Date date) {
<span class="fc" id="L3438">        final GregorianCalendar calendar = new GregorianCalendar();</span>
<span class="fc" id="L3439">        calendar.setTime(date);</span>
<span class="fc" id="L3440">        return convertTime(calendar);</span>
    }

    /**
     * Converts a time instant contained in a gregorian calendar to a
     * decimal year.
     *
     * @param calendar calendar containing a specific instant to be
     *                 converted.
     * @return converted value expressed in decimal years.
     */
    public static double convertTime(final GregorianCalendar calendar) {
<span class="fc" id="L3452">        return WMMEarthMagneticFluxDensityEstimator.convertTime(calendar);</span>
    }

    /**
     * Converts provided time instance to seconds.
     *
     * @param time instance to be converted.
     * @return obtained conversion in seconds.
     */
    private static double convertTime(final Time time) {
<span class="fc" id="L3462">        return TimeConverter.convert(time.getValue().doubleValue(),</span>
<span class="fc" id="L3463">                time.getUnit(), TimeUnit.SECOND);</span>
    }

    /**
     * Initializes world magnetic model and estimates expected body magnetic flux
     * density.
     *
     * @throws IOException if world magnetic model loading fails.
     */
    private void initialize() throws IOException {
<span class="fc bfc" id="L3473" title="All 2 branches covered.">        if (mMagneticModel != null) {</span>
<span class="fc" id="L3474">            mWmmEstimator = new WMMEarthMagneticFluxDensityEstimator(mMagneticModel);</span>
        } else {
<span class="fc" id="L3476">            mWmmEstimator = new WMMEarthMagneticFluxDensityEstimator();</span>
        }

<span class="fc" id="L3479">        rebuildExpectedBodyMagneticFluxDensity();</span>
<span class="fc" id="L3480">    }</span>

    /**
     * Rebuilds expected body magnetic flux density based on current instant,
     * location and body orientation.
     */
    private void rebuildExpectedBodyMagneticFluxDensity() {
<span class="fc" id="L3487">        final NEDFrame nedFrame = ECEFtoNEDFrameConverter</span>
<span class="fc" id="L3488">                .convertECEFtoNEDAndReturnNew(mFrame);</span>

<span class="fc" id="L3490">        final double latitude = nedFrame.getLatitude();</span>
<span class="fc" id="L3491">        final double longitude = nedFrame.getLongitude();</span>
<span class="fc" id="L3492">        final double height = nedFrame.getHeight();</span>

<span class="fc" id="L3494">        final CoordinateTransformation cbn = new CoordinateTransformation(</span>
                FrameType.BODY_FRAME, FrameType.LOCAL_NAVIGATION_FRAME);
<span class="fc" id="L3496">        final CoordinateTransformation cnb = new CoordinateTransformation(</span>
                FrameType.LOCAL_NAVIGATION_FRAME, FrameType.BODY_FRAME);
<span class="fc" id="L3498">        nedFrame.getCoordinateTransformation(cbn);</span>
<span class="fc" id="L3499">        cbn.inverse(cnb);</span>

<span class="fc" id="L3501">        final NEDMagneticFluxDensity earthB = mWmmEstimator.estimate(</span>
                latitude, longitude, height, mYear);

        // estimate expected body mangetic flux density taking into
        // account body attitude (inverse of frame orientation) and
        // estimated Earth magnetic flux density
<span class="fc bfc" id="L3507" title="All 2 branches covered.">        if (mExpectedBodyMagneticFluxDensity == null) {</span>
<span class="fc" id="L3508">            mExpectedBodyMagneticFluxDensity = new BodyMagneticFluxDensity();</span>
        }
<span class="fc" id="L3510">        BodyMagneticFluxDensityEstimator.estimate(earthB, cnb,</span>
                mExpectedBodyMagneticFluxDensity);
<span class="fc" id="L3512">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>