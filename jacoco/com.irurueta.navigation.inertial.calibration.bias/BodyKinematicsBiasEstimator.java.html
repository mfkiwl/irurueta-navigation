<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>BodyKinematicsBiasEstimator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.irurueta:irurueta-navigation</a> &gt; <a href="index.source.html" class="el_package">com.irurueta.navigation.inertial.calibration.bias</a> &gt; <span class="el_source">BodyKinematicsBiasEstimator.java</span></div><h1>BodyKinematicsBiasEstimator.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2020 Alberto Irurueta Carro (alberto@irurueta.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.irurueta.navigation.inertial.calibration.bias;

import com.irurueta.algebra.Matrix;
import com.irurueta.algebra.WrongSizeException;
import com.irurueta.geometry.Point3D;
import com.irurueta.navigation.LockedException;
import com.irurueta.navigation.frames.CoordinateTransformation;
import com.irurueta.navigation.frames.ECEFFrame;
import com.irurueta.navigation.frames.InvalidSourceAndDestinationFrameTypeException;
import com.irurueta.navigation.frames.NEDFrame;
import com.irurueta.navigation.frames.converters.ECEFtoNEDFrameConverter;
import com.irurueta.navigation.frames.converters.NEDtoECEFFrameConverter;
import com.irurueta.navigation.inertial.BodyKinematics;
import com.irurueta.navigation.inertial.ECEFPosition;
import com.irurueta.navigation.inertial.NEDPosition;
import com.irurueta.navigation.inertial.calibration.AccelerationTriad;
import com.irurueta.navigation.inertial.calibration.AngularSpeedTriad;
import com.irurueta.navigation.inertial.estimators.ECEFKinematicsEstimator;
import com.irurueta.units.Acceleration;
import com.irurueta.units.AccelerationUnit;
import com.irurueta.units.Angle;
import com.irurueta.units.AngularSpeed;
import com.irurueta.units.AngularSpeedUnit;
import com.irurueta.units.Distance;
import com.irurueta.units.Time;
import com.irurueta.units.TimeConverter;
import com.irurueta.units.TimeUnit;

/**
 * Approximately estimates accelerometer and gyroscope biases and noise PSD's
 * by averaging all provided samples when body position and orientation is known
 * while assuming that any cross coupling errors can be neglected.
 *
 * This estimator must be used when the body where the accelerometer and gyroscope
 * is attached remains static on the same position with zero velocity and no rotation
 * speed while capturing data.
 *
 * To compute PSD's this estimator assumes that accelerometer samples are obtained
 * at a constant provided rate equal to {@link #getTimeInterval()} seconds.
 * If not available, accelerometer and gyroscope sampling rate average can be
 * estimated using {@link com.irurueta.navigation.inertial.calibration.TimeIntervalEstimator}.
 *
 * Notice that in order to compute accelerometer and gyroscope biases, body position
 * and orientation must be known to account for gravity and Earth rotation effects.
 *
 * Even though this estimator obtains approximate bias values, the obtained
 * result can be used to initialize some non-linear calibrators to obtain
 * more accurate results. Such calibrators are:
 * - {@link com.irurueta.navigation.inertial.calibration.accelerometer.KnownFrameAccelerometerNonLinearLeastSquaresCalibrator}
 * - {@link com.irurueta.navigation.inertial.calibration.accelerometer.KnownGravityNormAccelerometerCalibrator}
 * - {@link com.irurueta.navigation.inertial.calibration.accelerometer.KnownPositionAccelerometerCalibrator}
 * - {@link com.irurueta.navigation.inertial.calibration.accelerometer.RobustKnownFrameAccelerometerCalibrator} and
 * any of its subclasses.
 * - {@link com.irurueta.navigation.inertial.calibration.accelerometer.RobustKnownGravityNormAccelerometerCalibrator}
 * and any of its subclasses.
 * - {@link com.irurueta.navigation.inertial.calibration.accelerometer.RobustKnownPositionAccelerometerCalibrator} and
 * any of its subclasses.
 * - {@link com.irurueta.navigation.inertial.calibration.gyroscope.KnownBiasAndFrameGyroscopeLinearLeastSquaresCalibrator}
 * - {@link com.irurueta.navigation.inertial.calibration.gyroscope.KnownBiasAndFrameGyroscopeNonLinearLeastSquaresCalibrator}
 * - {@link com.irurueta.navigation.inertial.calibration.gyroscope.KnownBiasEasyGyroscopeCalibrator}
 * - {@link com.irurueta.navigation.inertial.calibration.gyroscope.KnownBiasTurntableGyroscopeCalibrator}
 * - {@link com.irurueta.navigation.inertial.calibration.gyroscope.RobustKnownBiasAndFrameGyroscopeCalibrator} and any
 * of its subclasses.
 * - {@link com.irurueta.navigation.inertial.calibration.gyroscope.RobustKnownBiasEasyGyroscopeCalibrator} and any of
 * its subclasses.
 * - {@link com.irurueta.navigation.inertial.calibration.gyroscope.RobustKnownBiasTurntableGyroscopeCalibrator} and any
 * of its subclasses.
 *
 * Even though this estimator can compute noise PSD's, if only noise PSD's levels
 * are required, estimators in {@link com.irurueta.navigation.inertial.calibration.noise} package should
 * be used instead.
 *
 * This estimator does NOT compute average bias values over a period of time, it only
 * computes accumulated averages.
 */
public class BodyKinematicsBiasEstimator {

    /**
     * Default time interval between accelerometer samples expressed in seconds (s).
     */
    public static final double DEFAULT_TIME_INTERVAL_SECONDS = 0.02;

    /**
     * Time interval expressed in seconds (s) between body kinematics samples.
     */
<span class="fc" id="L101">    private double mTimeInterval = DEFAULT_TIME_INTERVAL_SECONDS;</span>

    /**
     * Contains body position, velocity (which will always be zero) and orientation
     * resolved around ECEF axes.
     * By default it is assumed that body is located at zero NED coordinates (latitude,
     * longitude and height) and with zero Euler angles representing rotation (roll = 0,
     * pith = 0, yaw = 0), which for Android devices it means that the device is flat
     * on a horizontal surface with the screen facing down.
     */
    private final ECEFFrame mFrame;

    /**
     * Listener to handle events raised by this estimator.
     */
    private BodyKinematicsBiasEstimatorListener mListener;

    /**
     * Last provided body kinematics values.
     */
    private BodyKinematics mLastBodyKinematics;

    /**
     * Contains estimated bias of x coordinate of accelerometer sensed specific force
     * expressed in meters per squared second (m/s^2).
     */
    private double mBiasFx;

    /**
     * Contains estimated bias of y coordinate of accelerometer sensed specific force
     * expressed in meters per squared second (m/s^2).
     */
    private double mBiasFy;

    /**
     * Contains estimated bias of z coordinate of accelerometer sensed specific force
     * expressed in meters per squared second (m/s^2).
     */
    private double mBiasFz;

    /**
     * Contains estimated bias of x coordinate of gyroscope sensed angular rate
     * expressed in radians per second (rad/s).
     */
    private double mBiasAngularRateX;

    /**
     * Contains estimated bias of y coordinate of gyroscope sensed angular rate
     * expressed in radians per second (rad/s).
     */
    private double mBiasAngularRateY;

    /**
     * Contains estimated bias of z coordinate of gyroscope sensed angular rate
     * expressed in radians per second (rad/s).
     */
    private double mBiasAngularRateZ;

    /**
     * Contains estimated variance of x coordinate of accelerometer sensed specific
     * force expressed in (m^2/s^4).
     */
    private double mVarianceFx;

    /**
     * Contains estimated variance of y coordinate of accelerometer sensed specific
     * force expressed in (m^2/s^4).
     */
    private double mVarianceFy;

    /**
     * Contains estimated variance of z coordinate of accelerometer sensed specific
     * force expressed in (m^2/s4).
     */
    private double mVarianceFz;

    /**
     * Contains estimated variance of x coordinate of gyroscope sensed angular rate
     * expressed in (rad^2/s^2).
     */
    private double mVarianceAngularRateX;

    /**
     * Contains estimated variance of y coordinate of gyroscope sensed angular rate
     * expressed in (rad^2/s^2).
     */
    private double mVarianceAngularRateY;

    /**
     * Contains estimated variance of z coordinate of gyroscope sensed angular rate
     * expressed in (rad^2/s^2).
     */
    private double mVarianceAngularRateZ;

    /**
     * Number of processed body kinematics samples.
     */
    private int mNumberOfProcessedSamples;

    /**
     * Number of processed body kinematics samples plus one.
     */
<span class="fc" id="L203">    private int mNumberOfProcessedSamplesPlusOne = 1;</span>

    /**
     * Indicates that estimator is running.
     */
    private boolean mRunning;

    /**
     * Theoretical expected body kinematics for provided body position and orientation,
     * and provided time interval, assuming that body remains at the same position
     * (zero velocity).
     * When body remains static, sensed specific force and angular rates will remain
     * constant due to gravity and Earth rotation.
     */
    private BodyKinematics mExpectedKinematics;

    /**
     * Constructor.
     * It is assumed that body is located at zero NED coordinates (latitude = 0,
     * longitude = 0 and height = 0) and with zero Euler angles representing rotation
     * (roll = 0, pith = 0, yaw = 0), which for Android devices it means that the
     * device is flat on a horizontal surface with the screen facing down.
     */
<span class="fc" id="L226">    public BodyKinematicsBiasEstimator() {</span>
<span class="fc" id="L227">        mFrame = NEDtoECEFFrameConverter.convertNEDtoECEFAndReturnNew(new NEDFrame());</span>
<span class="fc" id="L228">        rebuildExpectedKinematics();</span>
<span class="fc" id="L229">    }</span>

    /**
     * Constructor.
     * It is assumed that body is located at zero NED coordinates (latitude = 0,
     * longitude = 0, and height = 0) with provided orientation.
     *
     * @param nedC coordinate transformation from body to local navigation
     *             (NED) coordinates. This contains orientation respect the horizon
     *             at current body location.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not
     *                                                       from body to local
     *                                                       navigation coordinates.
     */
    public BodyKinematicsBiasEstimator(final CoordinateTransformation nedC)
<span class="fc" id="L245">            throws InvalidSourceAndDestinationFrameTypeException {</span>
<span class="fc" id="L246">        mFrame = NEDtoECEFFrameConverter.convertNEDtoECEFAndReturnNew(</span>
                new NEDFrame(nedC));
<span class="fc" id="L248">        rebuildExpectedKinematics();</span>
<span class="fc" id="L249">    }</span>

    /**
     * Constructor.
     * It is assumed that body has zero Euler angles representing rotation (roll = 0,
     * pitch = 0, yaw = 0) respect the horizon at provided body location.
     * For Android devices this means that the device is flat on a horizontal surface
     * with the screen facing down.
     *
     * @param latitude  latitude expressed in radians (rad).
     * @param longitude longitude expressed in radians (rad).
     * @param height    height expressed in meters (m).
     */
    public BodyKinematicsBiasEstimator(
<span class="fc" id="L263">            final double latitude, final double longitude, final double height) {</span>
<span class="fc" id="L264">        mFrame = NEDtoECEFFrameConverter.convertNEDtoECEFAndReturnNew(</span>
                new NEDFrame(latitude, longitude, height));
<span class="fc" id="L266">        rebuildExpectedKinematics();</span>
<span class="fc" id="L267">    }</span>

    /**
     * Constructor.
     * It is assumed that body has zero Euler angles representing rotation (roll = 0,
     * pitch = 0, yaw = 0) respect the horizon at provided body location.
     * For Android devices this means that the device is flat on a horizontal surface
     * with the screen facing down.
     *
     * @param latitude  latitude.
     * @param longitude longitude.
     * @param height    height expressed in meters (m).
     */
    public BodyKinematicsBiasEstimator(
<span class="fc" id="L281">            final Angle latitude, final Angle longitude, final double height) {</span>
<span class="fc" id="L282">        mFrame = NEDtoECEFFrameConverter.convertNEDtoECEFAndReturnNew(</span>
                new NEDFrame(latitude, longitude, height));
<span class="fc" id="L284">        rebuildExpectedKinematics();</span>
<span class="fc" id="L285">    }</span>

    /**
     * Constructor.
     * It is assumed that body has zero Euler angles representing rotation (roll = 0,
     * pitch = 0, yaw = 0) respect the horizon at provided body location.
     * For Android devices this means that the device is flat on a horizontal surface
     * with the screen facing down.
     *
     * @param latitude  latitude.
     * @param longitude longitude.
     * @param height    height.
     */
    public BodyKinematicsBiasEstimator(
<span class="fc" id="L299">            final Angle latitude, final Angle longitude, final Distance height) {</span>
<span class="fc" id="L300">        mFrame = NEDtoECEFFrameConverter.convertNEDtoECEFAndReturnNew(</span>
                new NEDFrame(latitude, longitude, height));
<span class="fc" id="L302">        rebuildExpectedKinematics();</span>
<span class="fc" id="L303">    }</span>

    /**
     * Constructor.
     *
     * @param position body position expressed in NED coordinates.
     * @param nedC     coordinate transformation from body to local navigation
     *                 (NED) coordinates. This contains orientation respect the
     *                 horizon at current body location.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not
     *                                                       from body to local
     *                                                       navigation coordinates.
     */
    public BodyKinematicsBiasEstimator(
            final NEDPosition position, final CoordinateTransformation nedC)
<span class="fc" id="L319">            throws InvalidSourceAndDestinationFrameTypeException {</span>
<span class="fc" id="L320">        mFrame = NEDtoECEFFrameConverter.convertNEDtoECEFAndReturnNew(</span>
                new NEDFrame(position, nedC));
<span class="fc" id="L322">        rebuildExpectedKinematics();</span>
<span class="fc" id="L323">    }</span>

    /**
     * Constructor.
     *
     * @param position body position expressed in ECEF coordinates.
     * @param nedC     coordinate transformation from body to local navigation
     *                 (NED) coordinates. This contains orientation respect the
     *                 horizon at current body location.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not
     *                                                       from body to local
     *                                                       navigation coordinates.
     */
    public BodyKinematicsBiasEstimator(
            final ECEFPosition position, final CoordinateTransformation nedC)
<span class="fc" id="L339">            throws InvalidSourceAndDestinationFrameTypeException {</span>
<span class="fc" id="L340">        mFrame = new ECEFFrame(position);</span>
<span class="fc" id="L341">        final NEDFrame nedFrame = ECEFtoNEDFrameConverter</span>
<span class="fc" id="L342">                .convertECEFtoNEDAndReturnNew(mFrame);</span>
<span class="fc" id="L343">        nedFrame.setCoordinateTransformation(nedC);</span>
<span class="fc" id="L344">        NEDtoECEFFrameConverter.convertNEDtoECEF(nedFrame, mFrame);</span>
<span class="fc" id="L345">        rebuildExpectedKinematics();</span>
<span class="fc" id="L346">    }</span>

    /**
     * Constructor.
     * It is assumed that body is located at zero NED coordinates (latitude = 0,
     * longitude = 0 and height = 0) and with zero Euler angles representing rotation
     * (roll = 0, pith = 0, yaw = 0), which for Android devices it means that the
     * device is flat on a horizontal surface with the screen facing down.
     *
     * @param listener listener to handle events raised by this estimator.
     */
    public BodyKinematicsBiasEstimator(final BodyKinematicsBiasEstimatorListener listener) {
<span class="fc" id="L358">        this();</span>
<span class="fc" id="L359">        mListener = listener;</span>
<span class="fc" id="L360">    }</span>

    /**
     * Constructor.
     * It is assumed that body is located at zero NED coordinates (latitude = 0,
     * longitude = 0, and height = 0) with provided orientation.
     *
     * @param nedC     coordinate transformation from body to local navigation
     *                 (NED) coordinates. This contains orientation respect the
     *                 horizon at current body location.
     * @param listener listener to handle events raised by this estimator.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not
     *                                                       from body to local
     *                                                       navigation coordinates.
     */
    public BodyKinematicsBiasEstimator(
            final CoordinateTransformation nedC,
            final BodyKinematicsBiasEstimatorListener listener)
            throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L380">        this(nedC);</span>
<span class="fc" id="L381">        mListener = listener;</span>
<span class="fc" id="L382">    }</span>

    /**
     * Constructor.
     * It is assumed that body has zero Euler angles representing rotation (roll = 0,
     * pitch = 0, yaw = 0) respect the horizon at provided body location.
     * For Android devices this means that the device is flat on a horizontal surface
     * with the screen facing down.
     *
     * @param latitude  latitude expressed in radians (rad).
     * @param longitude longitude expressed in radians (rad).
     * @param height    height expressed in meters (m).
     * @param listener  listener to handle events raised by this estimator.
     */
    public BodyKinematicsBiasEstimator(
            final double latitude, final double longitude, final double height,
            final BodyKinematicsBiasEstimatorListener listener) {
<span class="fc" id="L399">        this(latitude, longitude, height);</span>
<span class="fc" id="L400">        mListener = listener;</span>
<span class="fc" id="L401">    }</span>

    /**
     * Constructor.
     * It is assumed that body has zero Euler angles representing rotation (roll = 0,
     * pitch = 0, yaw = 0) respect the horizon at provided body location.
     * For Android devices this means that the device is flat on a horizontal surface
     * with the screen facing down.
     *
     * @param latitude  latitude.
     * @param longitude longitude.
     * @param height    height expressed in meters (m).
     * @param listener  listener to handle events raised by this estimator.
     */
    public BodyKinematicsBiasEstimator(
            final Angle latitude, final Angle longitude, final double height,
            final BodyKinematicsBiasEstimatorListener listener) {
<span class="fc" id="L418">        this(latitude, longitude, height);</span>
<span class="fc" id="L419">        mListener = listener;</span>
<span class="fc" id="L420">    }</span>

    /**
     * Constructor.
     * It is assumed that body has zero Euler angles representing rotation (roll = 0,
     * pitch = 0, yaw = 0) respect the horizon at provided body location.
     * For Android devices this means that the device is flat on a horizontal surface
     * with the screen facing down.
     *
     * @param latitude  latitude.
     * @param longitude longitude.
     * @param height    height.
     * @param listener  listener to handle events raised by this estimator.
     */
    public BodyKinematicsBiasEstimator(
            final Angle latitude, final Angle longitude, final Distance height,
            final BodyKinematicsBiasEstimatorListener listener) {
<span class="fc" id="L437">        this(latitude, longitude, height);</span>
<span class="fc" id="L438">        mListener = listener;</span>
<span class="fc" id="L439">    }</span>

    /**
     * Constructor.
     *
     * @param position body position expressed in NED coordinates.
     * @param nedC     coordinate transformation from body to local navigation
     *                 (NED) coordinates. This contains orientation respect the
     *                 horizon at current body location.
     * @param listener listener to handle events raised by this estimator.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not
     *                                                       from body to local
     *                                                       navigation coordinates.
     */
    public BodyKinematicsBiasEstimator(
            final NEDPosition position, final CoordinateTransformation nedC,
            final BodyKinematicsBiasEstimatorListener listener)
            throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L458">        this(position, nedC);</span>
<span class="fc" id="L459">        mListener = listener;</span>
<span class="fc" id="L460">    }</span>

    /**
     * Constructor.
     *
     * @param position body position expressed in ECEF coordinates.
     * @param nedC     coordinate transformation from body to local navigation
     *                 (NED) coordinates. This contains orientation respect the
     *                 horizon at current body location.
     * @param listener listener to handle events raised by this estimator.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not
     *                                                       from body to local
     *                                                       navigation coordinates.
     */
    public BodyKinematicsBiasEstimator(
            final ECEFPosition position, final CoordinateTransformation nedC,
            final BodyKinematicsBiasEstimatorListener listener)
            throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L479">        this(position, nedC);</span>
<span class="fc" id="L480">        mListener = listener;</span>
<span class="fc" id="L481">    }</span>

    /**
     * Constructor.
     * It is assumed that body is located at zero NED coordinates (latitude = 0,
     * longitude = 0 and height = 0) and with zero Euler angles representing rotation
     * (roll = 0, pith = 0, yaw = 0), which for Android devices it means that the
     * device is flat on a horizontal surface with the screen facing down.
     *
     * @param timeInterval time interval between body kinematics
     *                     (IMU acceleration + gyroscope) samples
     *                     expressed in seconds (s).
     * @throws IllegalArgumentException if provided time interval is negative.
     */
    public BodyKinematicsBiasEstimator(final double timeInterval) {
<span class="fc" id="L496">        this();</span>
        try {
<span class="fc" id="L498">            setTimeInterval(timeInterval);</span>
<span class="nc" id="L499">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L501">        }</span>
<span class="fc" id="L502">    }</span>

    /**
     * Constructor.
     * It is assumed that body is located at zero NED coordinates (latitude = 0,
     * longitude = 0, and height = 0) with provided orientation.
     *
     * @param nedC         coordinate transformation from body to local navigation
     *                     (NED) coordinates. This contains orientation respect the
     *                     horizon at current body location.
     * @param timeInterval time interval between body kinematics
     *                     (IMU acceleration + gyroscope) samples
     *                     expressed in seconds (s).
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not
     *                                                       from body to local
     *                                                       navigation coordinates.
     * @throws IllegalArgumentException                      if provided time interval
     *                                                       is negative.
     */
    public BodyKinematicsBiasEstimator(
            final CoordinateTransformation nedC, final double timeInterval)
            throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L525">        this(nedC);</span>
        try {
<span class="fc" id="L527">            setTimeInterval(timeInterval);</span>
<span class="nc" id="L528">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L530">        }</span>
<span class="fc" id="L531">    }</span>

    /**
     * Constructor.
     * It is assumed that body has zero Euler angles representing rotation (roll = 0,
     * pitch = 0, yaw = 0) respect the horizon at provided body location.
     * For Android devices this means that the device is flat on a horizontal surface
     * with the screen facing down.
     *
     * @param latitude     latitude expressed in radians (rad).
     * @param longitude    longitude expressed in radians (rad).
     * @param height       height expressed in meters (m).
     * @param timeInterval time interval between body kinematics
     *                     (IMU acceleration + gyroscope) samples
     *                     expressed in seconds (s).
     * @throws IllegalArgumentException if provided time interval is negative.
     */
    public BodyKinematicsBiasEstimator(final double latitude, final double longitude,
                            final double height, final double timeInterval) {
<span class="fc" id="L550">        this(latitude, longitude, height);</span>
        try {
<span class="fc" id="L552">            setTimeInterval(timeInterval);</span>
<span class="nc" id="L553">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L555">        }</span>
<span class="fc" id="L556">    }</span>

    /**
     * Constructor.
     * It is assumed that body has zero Euler angles representing rotation (roll = 0,
     * pitch = 0, yaw = 0) respect the horizon at provided body location.
     * For Android devices this means that the device is flat on a horizontal surface
     * with the screen facing down.
     *
     * @param latitude     latitude.
     * @param longitude    longitude.
     * @param height       height expressed in meters (m).
     * @param timeInterval time interval between body kinematics
     *                     (IMU acceleration + gyroscope) samples
     *                     expressed in seconds (s).
     * @throws IllegalArgumentException if provided time interval is negative.
     */
    public BodyKinematicsBiasEstimator(final Angle latitude, final Angle longitude,
                            final double height, final double timeInterval) {
<span class="fc" id="L575">        this(latitude, longitude, height);</span>
        try {
<span class="fc" id="L577">            setTimeInterval(timeInterval);</span>
<span class="nc" id="L578">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L580">        }</span>
<span class="fc" id="L581">    }</span>

    /**
     * Constructor.
     * It is assumed that body has zero Euler angles representing rotation (roll = 0,
     * pitch = 0, yaw = 0) respect the horizon at provided body location.
     * For Android devices this means that the device is flat on a horizontal surface
     * with the screen facing down.
     *
     * @param latitude     latitude.
     * @param longitude    longitude.
     * @param height       height.
     * @param timeInterval time interval between body kinematics
     *                     (IMU acceleration + gyroscope) samples
     *                     expressed in seconds (s).
     * @throws IllegalArgumentException if provided time interval is negative.
     */
    public BodyKinematicsBiasEstimator(final Angle latitude, final Angle longitude,
                            final Distance height, final double timeInterval) {
<span class="fc" id="L600">        this(latitude, longitude, height);</span>
        try {
<span class="fc" id="L602">            setTimeInterval(timeInterval);</span>
<span class="nc" id="L603">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L605">        }</span>
<span class="fc" id="L606">    }</span>

    /**
     * Constructor.
     *
     * @param position     body position expressed in NED coordinates.
     * @param nedC         coordinate transformation from body to local navigation
     *                     (NED) coordinates. This contains orientation respect the
     *                     horizon at current body location.
     * @param timeInterval time interval between body kinematics
     *                     (IMU acceleration + gyroscope) samples
     *                     expressed in seconds (s).
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not
     *                                                       from body to local
     *                                                       navigation coordinates.
     * @throws IllegalArgumentException                      if provided time interval
     *                                                       is negative.
     */
    public BodyKinematicsBiasEstimator(
            final NEDPosition position, final CoordinateTransformation nedC,
            final double timeInterval)
            throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L629">        this(position, nedC);</span>
        try {
<span class="fc" id="L631">            setTimeInterval(timeInterval);</span>
<span class="nc" id="L632">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L634">        }</span>
<span class="fc" id="L635">    }</span>

    /**
     * Constructor.
     *
     * @param position     body position expressed in ECEF coordinates.
     * @param nedC         coordinate transformation from body to local navigation
     *                     (NED) coordinates. This contains orientation respect the
     *                     horizon at current body location.
     * @param timeInterval time interval between body kinematics
     *                     (IMU acceleration + gyroscope) samples
     *                     expressed in seconds (s).
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not
     *                                                       from body to local
     *                                                       navigation coordinates.
     * @throws IllegalArgumentException                      if provided time interval
     *                                                       is negative.
     */
    public BodyKinematicsBiasEstimator(
            final ECEFPosition position, final CoordinateTransformation nedC,
            final double timeInterval)
            throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L658">        this(position, nedC);</span>
        try {
<span class="fc" id="L660">            setTimeInterval(timeInterval);</span>
<span class="nc" id="L661">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L663">        }</span>
<span class="fc" id="L664">    }</span>

    /**
     * Constructor.
     * It is assumed that body is located at zero NED coordinates (latitude = 0,
     * longitude = 0 and height = 0) and with zero Euler angles representing rotation
     * (roll = 0, pith = 0, yaw = 0), which for Android devices it means that the
     * device is flat on a horizontal surface with the screen facing down.
     *
     * @param timeInterval time interval between body kinematics
     *                     (IMU acceleration + gyroscope) samples
     *                     expressed in seconds (s).
     * @param listener     listener to handle events raised by this estimator.
     * @throws IllegalArgumentException if provided time interval is negative.
     */
    public BodyKinematicsBiasEstimator(final double timeInterval,
                            final BodyKinematicsBiasEstimatorListener listener) {
<span class="fc" id="L681">        this(timeInterval);</span>
<span class="fc" id="L682">        mListener = listener;</span>
<span class="fc" id="L683">    }</span>

    /**
     * Constructor.
     * It is assumed that body is located at zero NED coordinates (latitude = 0,
     * longitude = 0, and height = 0) with provided orientation.
     *
     * @param nedC         coordinate transformation from body to local navigation
     *                     (NED) coordinates. This contains orientation respect the
     *                     horizon at current body location.
     * @param timeInterval time interval between body kinematics
     *                     (IMU acceleration + gyroscope) samples
     *                     expressed in seconds (s).
     * @param listener     listener to handle events raised by this estimator.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not
     *                                                       from body to local
     *                                                       navigation coordinates.
     * @throws IllegalArgumentException                      if provided time interval
     *                                                       is negative.
     */
    public BodyKinematicsBiasEstimator(
            final CoordinateTransformation nedC, final double timeInterval,
            final BodyKinematicsBiasEstimatorListener listener)
            throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L708">        this(nedC, timeInterval);</span>
<span class="fc" id="L709">        mListener = listener;</span>
<span class="fc" id="L710">    }</span>

    /**
     * Constructor.
     * It is assumed that body has zero Euler angles representing rotation (roll = 0,
     * pitch = 0, yaw = 0) respect the horizon at provided body location.
     * For Android devices this means that the device is flat on a horizontal surface
     * with the screen facing down.
     *
     * @param latitude     latitude expressed in radians (rad).
     * @param longitude    longitude expressed in radians (rad).
     * @param height       height expressed in meters (m).
     * @param timeInterval time interval between body kinematics
     *                     (IMU acceleration + gyroscope) samples
     *                     expressed in seconds (s).
     * @param listener     listener to handle events raised by this estimator.
     * @throws IllegalArgumentException if provided time interval is negative.
     */
    public BodyKinematicsBiasEstimator(
            final double latitude, final double longitude, final double height,
            final double timeInterval, final BodyKinematicsBiasEstimatorListener listener) {
<span class="fc" id="L731">        this(latitude, longitude, height, timeInterval);</span>
<span class="fc" id="L732">        mListener = listener;</span>
<span class="fc" id="L733">    }</span>

    /**
     * Constructor.
     * It is assumed that body has zero Euler angles representing rotation (roll = 0,
     * pitch = 0, yaw = 0) respect the horizon at provided body location.
     * For Android devices this means that the device is flat on a horizontal surface
     * with the screen facing down.
     *
     * @param latitude     latitude.
     * @param longitude    longitude.
     * @param height       height expressed in meters (m).
     * @param timeInterval time interval between body kinematics
     *                     (IMU acceleration + gyroscope) samples
     *                     expressed in seconds (s).
     * @param listener     listener to handle events raised by this estimator.
     * @throws IllegalArgumentException if provided time interval is negative.
     */
    public BodyKinematicsBiasEstimator(
            final Angle latitude, final Angle longitude, final double height,
            final double timeInterval, final BodyKinematicsBiasEstimatorListener listener) {
<span class="fc" id="L754">        this(latitude, longitude, height, timeInterval);</span>
<span class="fc" id="L755">        mListener = listener;</span>
<span class="fc" id="L756">    }</span>

    /**
     * Constructor.
     * It is assumed that body has zero Euler angles representing rotation (roll = 0,
     * pitch = 0, yaw = 0) respect the horizon at provided body location.
     * For Android devices this means that the device is flat on a horizontal surface
     * with the screen facing down.
     *
     * @param latitude     latitude.
     * @param longitude    longitude.
     * @param height       height.
     * @param timeInterval time interval between body kinematics
     *                     (IMU acceleration + gyroscope) samples
     *                     expressed in seconds (s).
     * @param listener     listener to handle events raised by this estimator.
     * @throws IllegalArgumentException if provided time interval is negative.
     */
    public BodyKinematicsBiasEstimator(
            final Angle latitude, final Angle longitude, final Distance height,
            final double timeInterval, final BodyKinematicsBiasEstimatorListener listener) {
<span class="fc" id="L777">        this(latitude, longitude, height, timeInterval);</span>
<span class="fc" id="L778">        mListener = listener;</span>
<span class="fc" id="L779">    }</span>

    /**
     * Constructor.
     *
     * @param position     body position expressed in NED coordinates.
     * @param nedC         coordinate transformation from body to local navigation
     *                     (NED) coordinates. This contains orientation respect the
     *                     horizon at current body location.
     * @param timeInterval time interval between body kinematics
     *                     (IMU acceleration + gyroscope) samples
     *                     expressed in seconds (s).
     * @param listener     listener to handle events raised by this estimator.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not
     *                                                       from body to local
     *                                                       navigation coordinates.
     * @throws IllegalArgumentException                      if provided time interval
     *                                                       is negative.
     */
    public BodyKinematicsBiasEstimator(
            final NEDPosition position, final CoordinateTransformation nedC,
            final double timeInterval, final BodyKinematicsBiasEstimatorListener listener)
            throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L803">        this(position, nedC, timeInterval);</span>
<span class="fc" id="L804">        mListener = listener;</span>
<span class="fc" id="L805">    }</span>

    /**
     * Constructor.
     *
     * @param position     body position expressed in ECEF coordinates.
     * @param nedC         coordinate transformation from body to local navigation
     *                     (NED) coordinates. This contains orientation respect the
     *                     horizon at current body location.
     * @param timeInterval time interval between body kinematics
     *                     (IMU acceleration + gyroscope) samples
     *                     expressed in seconds (s).
     * @param listener     listener to handle events raised by this estimator.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not
     *                                                       from body to local
     *                                                       navigation coordinates.
     * @throws IllegalArgumentException                      if provided time interval
     *                                                       is negative.
     */
    public BodyKinematicsBiasEstimator(
            final ECEFPosition position, final CoordinateTransformation nedC,
            final double timeInterval, final BodyKinematicsBiasEstimatorListener listener)
            throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L829">        this(position, nedC, timeInterval);</span>
<span class="fc" id="L830">        mListener = listener;</span>
<span class="fc" id="L831">    }</span>

    /**
     * Constructor.
     * It is assumed that body is located at zero NED coordinates (latitude = 0,
     * longitude = 0 and height = 0) and with zero Euler angles representing rotation
     * (roll = 0, pith = 0, yaw = 0), which for Android devices it means that the
     * device is flat on a horizontal surface with the screen facing down.
     *
     * @param timeInterval time interval between body kinematics
     *                     (IMU acceleration + gyroscope) samples.
     * @throws IllegalArgumentException if provided time interval is negative.
     */
    public BodyKinematicsBiasEstimator(final Time timeInterval) {
<span class="fc" id="L845">        this(convertTime(timeInterval));</span>
<span class="fc" id="L846">    }</span>

    /**
     * Constructor.
     * It is assumed that body is located at zero NED coordinates (latitude = 0,
     * longitude = 0, and height = 0) with provided orientation.
     *
     * @param nedC         coordinate transformation from body to local navigation
     *                     (NED) coordinates. This contains orientation respect the
     *                     horizon at current body location.
     * @param timeInterval time interval between body kinematics
     *                     (IMU acceleration + gyroscope) samples.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not
     *                                                       from body to local
     *                                                       navigation coordinates.
     * @throws IllegalArgumentException                      if provided time interval
     *                                                       is negative.
     */
    public BodyKinematicsBiasEstimator(
            final CoordinateTransformation nedC, final Time timeInterval)
            throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L868">        this(nedC, convertTime(timeInterval));</span>
<span class="fc" id="L869">    }</span>

    /**
     * Constructor.
     * It is assumed that body has zero Euler angles representing rotation (roll = 0,
     * pitch = 0, yaw = 0) respect the horizon at provided body location.
     * For Android devices this means that the device is flat on a horizontal surface
     * with the screen facing down.
     *
     * @param latitude     latitude expressed in radians (rad).
     * @param longitude    longitude expressed in radians (rad).
     * @param height       height expressed in meters (m).
     * @param timeInterval time interval between body kinematics
     *                     (IMU acceleration + gyroscope) samples.
     * @throws IllegalArgumentException if provided time interval is negative.
     */
    public BodyKinematicsBiasEstimator(final double latitude, final double longitude,
                            final double height, final Time timeInterval) {
<span class="fc" id="L887">        this(latitude, longitude, height, convertTime(timeInterval));</span>
<span class="fc" id="L888">    }</span>

    /**
     * Constructor.
     * It is assumed that body has zero Euler angles representing rotation (roll = 0,
     * pitch = 0, yaw = 0) respect the horizon at provided body location.
     * For Android devices this means that the device is flat on a horizontal surface
     * with the screen facing down.
     *
     * @param latitude     latitude.
     * @param longitude    longitude.
     * @param height       height expressed in meters (m).
     * @param timeInterval time interval between body kinematics
     *                     (IMU acceleration + gyroscope) samples.
     * @throws IllegalArgumentException if provided time interval is negative.
     */
    public BodyKinematicsBiasEstimator(final Angle latitude, final Angle longitude,
                            final double height, final Time timeInterval) {
<span class="fc" id="L906">        this(latitude, longitude, height, convertTime(timeInterval));</span>
<span class="fc" id="L907">    }</span>

    /**
     * Constructor.
     * It is assumed that body has zero Euler angles representing rotation (roll = 0,
     * pitch = 0, yaw = 0) respect the horizon at provided body location.
     * For Android devices this means that the device is flat on a horizontal surface
     * with the screen facing down.
     *
     * @param latitude     latitude.
     * @param longitude    longitude.
     * @param height       height.
     * @param timeInterval time interval between body kinematics
     *                     (IMU acceleration + gyroscope) samples.
     * @throws IllegalArgumentException if provided time interval is negative.
     */
    public BodyKinematicsBiasEstimator(final Angle latitude, final Angle longitude,
                            final Distance height, final Time timeInterval) {
<span class="fc" id="L925">        this(latitude, longitude, height, convertTime(timeInterval));</span>
<span class="fc" id="L926">    }</span>

    /**
     * Constructor.
     *
     * @param position     body position expressed in NED coordinates.
     * @param nedC         coordinate transformation from body to local navigation
     *                     (NED) coordinates. This contains orientation respect the
     *                     horizon at current body location.
     * @param timeInterval time interval between body kinematics
     *                     (IMU acceleration + gyroscope) samples.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not
     *                                                       from body to local
     *                                                       navigation coordinates.
     * @throws IllegalArgumentException                      if provided time interval
     *                                                       is negative.
     */
    public BodyKinematicsBiasEstimator(
            final NEDPosition position, final CoordinateTransformation nedC,
            final Time timeInterval)
            throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L948">        this(position, nedC, convertTime(timeInterval));</span>
<span class="fc" id="L949">    }</span>

    /**
     * Constructor.
     *
     * @param position     body position expressed in ECEF coordinates.
     * @param nedC         coordinate transformation from body to local navigation
     *                     (NED) coordinates. This contains orientation respect the
     *                     horizon at current body location.
     * @param timeInterval time interval between body kinematics
     *                     (IMU acceleration + gyroscope) samples.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not
     *                                                       from body to local
     *                                                       navigation coordinates.
     * @throws IllegalArgumentException                      if provided time interval
     *                                                       is negative.
     */
    public BodyKinematicsBiasEstimator(
            final ECEFPosition position, final CoordinateTransformation nedC,
            final Time timeInterval)
            throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L971">        this(position, nedC, convertTime(timeInterval));</span>
<span class="fc" id="L972">    }</span>

    /**
     * Constructor.
     * It is assumed that body is located at zero NED coordinates (latitude = 0,
     * longitude = 0 and height = 0) and with zero Euler angles representing rotation
     * (roll = 0, pith = 0, yaw = 0), which for Android devices it means that the
     * device is flat on a horizontal surface with the screen facing down.
     *
     * @param timeInterval time interval between body kinematics
     *                     (IMU acceleration + gyroscope) samples.
     * @param listener     listener to handle events raised by this estimator.
     * @throws IllegalArgumentException if provided time interval is negative.
     */
    public BodyKinematicsBiasEstimator(final Time timeInterval,
                            final BodyKinematicsBiasEstimatorListener listener) {
<span class="fc" id="L988">        this(convertTime(timeInterval), listener);</span>
<span class="fc" id="L989">    }</span>

    /**
     * Constructor.
     * It is assumed that body is located at zero NED coordinates (latitude = 0,
     * longitude = 0, and height = 0) with provided orientation.
     *
     * @param nedC         coordinate transformation from body to local navigation
     *                     (NED) coordinates. This contains orientation respect the
     *                     horizon at current body location.
     * @param timeInterval time interval between body kinematics
     *                     (IMU acceleration + gyroscope) samples.
     * @param listener     listener to handle events raised by this estimator.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not
     *                                                       from body to local
     *                                                       navigation coordinates.
     * @throws IllegalArgumentException                      if provided time interval
     *                                                       is negative.
     */
    public BodyKinematicsBiasEstimator(
            final CoordinateTransformation nedC, final Time timeInterval,
            final BodyKinematicsBiasEstimatorListener listener)
            throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L1013">        this(nedC, convertTime(timeInterval), listener);</span>
<span class="fc" id="L1014">    }</span>

    /**
     * Constructor.
     * It is assumed that body has zero Euler angles representing rotation (roll = 0,
     * pitch = 0, yaw = 0) respect the horizon at provided body location.
     * For Android devices this means that the device is flat on a horizontal surface
     * with the screen facing down.
     *
     * @param latitude     latitude expressed in radians (rad).
     * @param longitude    longitude expressed in radians (rad).
     * @param height       height expressed in meters (m).
     * @param timeInterval time interval between body kinematics
     *                     (IMU acceleration + gyroscope) samples.
     * @param listener     listener to handle events raised by this estimator.
     * @throws IllegalArgumentException if provided time interval is negative.
     */
    public BodyKinematicsBiasEstimator(
            final double latitude, final double longitude, final double height,
            final Time timeInterval, final BodyKinematicsBiasEstimatorListener listener) {
<span class="fc" id="L1034">        this(latitude, longitude, height, convertTime(timeInterval), listener);</span>
<span class="fc" id="L1035">    }</span>

    /**
     * Constructor.
     * It is assumed that body has zero Euler angles representing rotation (roll = 0,
     * pitch = 0, yaw = 0) respect the horizon at provided body location.
     * For Android devices this means that the device is flat on a horizontal surface
     * with the screen facing down.
     *
     * @param latitude     latitude.
     * @param longitude    longitude.
     * @param height       height expressed in meters (m).
     * @param timeInterval time interval between body kinematics
     *                     (IMU acceleration + gyroscope) samples.
     * @param listener     listener to handle events raised by this estimator.
     * @throws IllegalArgumentException if provided time interval is negative.
     */
    public BodyKinematicsBiasEstimator(
            final Angle latitude, final Angle longitude, final double height,
            final Time timeInterval, final BodyKinematicsBiasEstimatorListener listener) {
<span class="fc" id="L1055">        this(latitude, longitude, height, convertTime(timeInterval), listener);</span>
<span class="fc" id="L1056">    }</span>

    /**
     * Constructor.
     * It is assumed that body has zero Euler angles representing rotation (roll = 0,
     * pitch = 0, yaw = 0) respect the horizon at provided body location.
     * For Android devices this means that the device is flat on a horizontal surface
     * with the screen facing down.
     *
     * @param latitude     latitude.
     * @param longitude    longitude.
     * @param height       height.
     * @param timeInterval time interval between body kinematics
     *                     (IMU acceleration + gyroscope) samples.
     * @param listener     listener to handle events raised by this estimator.
     * @throws IllegalArgumentException if provided time interval is negative.
     */
    public BodyKinematicsBiasEstimator(
            final Angle latitude, final Angle longitude, final Distance height,
            final Time timeInterval, final BodyKinematicsBiasEstimatorListener listener) {
<span class="fc" id="L1076">        this(latitude, longitude, height, convertTime(timeInterval), listener);</span>
<span class="fc" id="L1077">    }</span>

    /**
     * Constructor.
     *
     * @param position     body position expressed in NED coordinates.
     * @param nedC         coordinate transformation from body to local navigation
     *                     (NED) coordinates. This contains orientation respect the
     *                     horizon at current body location.
     * @param timeInterval time interval between body kinematics
     *                     (IMU acceleration + gyroscope) samples.
     * @param listener     listener to handle events raised by this estimator.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not
     *                                                       from body to local
     *                                                       navigation coordinates.
     * @throws IllegalArgumentException                      if provided time interval
     *                                                       is negative.
     */
    public BodyKinematicsBiasEstimator(
            final NEDPosition position, final CoordinateTransformation nedC,
            final Time timeInterval, final BodyKinematicsBiasEstimatorListener listener)
            throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L1100">        this(position, nedC, convertTime(timeInterval), listener);</span>
<span class="fc" id="L1101">    }</span>

    /**
     * Constructor.
     *
     * @param position     body position expressed in ECEF coordinates.
     * @param nedC         coordinate transformation from body to local navigation
     *                     (NED) coordinates. This contains orientation respect the
     *                     horizon at current body location.
     * @param timeInterval time interval between body kinematics
     *                     (IMU acceleration + gyroscope) samples.
     * @param listener     listener to handle events raised by this estimator.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not
     *                                                       from body to local
     *                                                       navigation coordinates.
     * @throws IllegalArgumentException                      if provided time interval
     *                                                       is negative.
     */
    public BodyKinematicsBiasEstimator(
            final ECEFPosition position, final CoordinateTransformation nedC,
            final Time timeInterval, final BodyKinematicsBiasEstimatorListener listener)
            throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L1124">        this(position, nedC, convertTime(timeInterval), listener);</span>
<span class="fc" id="L1125">    }</span>

    /**
     * Gets time interval between body kinematics (IMU acceleration + gyroscope)
     * samples expressed in seconds (s).
     *
     * @return time interval between body kinematics samples.
     */
    public double getTimeInterval() {
<span class="fc" id="L1134">        return mTimeInterval;</span>
    }

    /**
     * Sets time interval between body kinematics (IMU acceleration + gyroscope)
     * samples expressed in seconds (s).
     *
     * @param timeInterval time interval between body kinematics samples.
     * @throws LockedException if estimator is currently running.
     */
    public void setTimeInterval(final double timeInterval) throws LockedException {
<span class="fc bfc" id="L1145" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L1146">            throw new LockedException();</span>
        }

<span class="fc bfc" id="L1149" title="All 2 branches covered.">        if (timeInterval &lt; 0.0) {</span>
<span class="fc" id="L1150">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L1153">        mTimeInterval = timeInterval;</span>

<span class="fc" id="L1155">        rebuildExpectedKinematics();</span>
<span class="fc" id="L1156">    }</span>

    /**
     * Gets time interval between body kinematics (IMU acceleration + gyroscope)
     * samples.
     *
     * @return time interval between body kinematics samples.
     */
    public Time getTimeIntervalAsTime() {
<span class="fc" id="L1165">        return new Time(mTimeInterval, TimeUnit.SECOND);</span>
    }

    /**
     * Gets time interval between body kinematics (IMU acceleration + gyroscope)
     * samples.
     *
     * @param result instance where time interval will be stored.
     */
    public void getTimeIntervalAsTime(final Time result) {
<span class="fc" id="L1175">        result.setValue(mTimeInterval);</span>
<span class="fc" id="L1176">        result.setUnit(TimeUnit.SECOND);</span>
<span class="fc" id="L1177">    }</span>

    /**
     * Sets time interval between body kinematics (IMU acceleration + gyroscope)
     * samples.
     *
     * @param timeInterval time interval between body kinematics samples.
     * @throws LockedException if estimator is currently running.
     */
    public void setTimeInterval(final Time timeInterval) throws LockedException {
<span class="fc" id="L1187">        setTimeInterval(convertTime(timeInterval));</span>
<span class="fc" id="L1188">    }</span>

    /**
     * Gets current body position expressed in ECEF coordinates.
     *
     * @return current body position expressed in ECEF coordinates.
     */
    public ECEFPosition getEcefPosition() {
<span class="fc" id="L1196">        return mFrame.getECEFPosition();</span>
    }

    /**
     * Gets current body position expressed in ECEF coordinates.
     *
     * @param result instance where current body position will be stored.
     */
    public void getEcefPosition(final ECEFPosition result) {
<span class="fc" id="L1205">        mFrame.getECEFPosition(result);</span>
<span class="fc" id="L1206">    }</span>

    /**
     * Sets current body position expressed in ECEF coordinates.
     *
     * @param position current body position to be set.
     * @throws LockedException if estimator is currently running.
     */
    public void setEcefPosition(final ECEFPosition position) throws LockedException {
<span class="fc bfc" id="L1215" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L1216">            throw new LockedException();</span>
        }

<span class="fc" id="L1219">        mFrame.setPosition(position);</span>
<span class="fc" id="L1220">        rebuildExpectedKinematics();</span>
<span class="fc" id="L1221">    }</span>

    /**
     * Sets current body position expressed in ECEF coordinates.
     *
     * @param x x position resolved around ECEF axes and expressed in meters (m).
     * @param y y position resolved around ECEF axes and expressed in meters (m).
     * @param z z position resolved around ECEF axes and expressed in meters (m).
     * @throws LockedException if estimator is currently running.
     */
    public void setEcefPosition(final double x, final double y, final double z)
            throws LockedException {
<span class="fc bfc" id="L1233" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L1234">            throw new LockedException();</span>
        }

<span class="fc" id="L1237">        mFrame.setCoordinates(x, y, z);</span>
<span class="fc" id="L1238">        rebuildExpectedKinematics();</span>
<span class="fc" id="L1239">    }</span>

    /**
     * Sets current body position expressed in ECEF coordinates.
     *
     * @param x x position resolved around ECEF axes.
     * @param y y position resolved around ECEF axes.
     * @param z z position resolved around ECEF axes.
     * @throws LockedException if estimator is currently running.
     */
    public void setEcefPosition(final Distance x, final Distance y, final Distance z)
            throws LockedException {
<span class="fc bfc" id="L1251" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L1252">            throw new LockedException();</span>
        }

<span class="fc" id="L1255">        mFrame.setPositionCoordinates(x, y, z);</span>
<span class="fc" id="L1256">        rebuildExpectedKinematics();</span>
<span class="fc" id="L1257">    }</span>

    /**
     * Sets current body position expressed in ECEF coordinates.
     *
     * @param position position resolved around ECEF axes and expressed in meters (m).
     * @throws LockedException if estimator is currently running.
     */
    public void setEcefPosition(final Point3D position) throws LockedException {
<span class="fc bfc" id="L1266" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L1267">            throw new LockedException();</span>
        }

<span class="fc" id="L1270">        mFrame.setPosition(position);</span>
<span class="fc" id="L1271">        rebuildExpectedKinematics();</span>
<span class="fc" id="L1272">    }</span>

    /**
     * Gets ECEF frame containing current body position and orientation expressed
     * in ECEF coordinates. Frame also contains body velocity, but it is always
     * assumed to be zero during calibration.
     *
     * @return ECEF frame containing current body position and orientation resolved
     * around ECEF axes.
     */
    public ECEFFrame getEcefFrame() {
<span class="fc" id="L1283">        return new ECEFFrame(mFrame);</span>
    }

    /**
     * Gets ECEF frame containing current body position and orientation expressed
     * in ECEF coordinates. Frame also contains body velocity, but it is always
     * assumed to be zero during calibration.
     *
     * @param result instance where ECEF frame containing current body position and
     *               orientation resolved around ECEF axes will be stored.
     */
    public void getEcefFrame(final ECEFFrame result) {
<span class="fc" id="L1295">        mFrame.copyTo(result);</span>
<span class="fc" id="L1296">    }</span>

    /**
     * Gets NED frame containing current body position and orientation expressed
     * in NED coordinates. Frame also contains body velocity, but it is always
     * assumed to be zero during calibration.
     *
     * @return NED frame containing current body position and orientation resolved
     * around NED axes.
     */
    public NEDFrame getNedFrame() {
<span class="fc" id="L1307">        return ECEFtoNEDFrameConverter.convertECEFtoNEDAndReturnNew(mFrame);</span>
    }

    /**
     * Gets NED frame containing current body position and orientation expressed
     * in NED coordinates. Frame also contains body velocity, but it is always
     * assumed to be zero during calibration.
     *
     * @param result instance where NED frame containing current body position and
     *               orientation resolved around NED axes will be stored.
     */
    public void getNedFrame(final NEDFrame result) {
<span class="fc" id="L1319">        ECEFtoNEDFrameConverter.convertECEFtoNED(mFrame, result);</span>
<span class="fc" id="L1320">    }</span>

    /**
     * Gets current body position expressed in NED coordinates.
     *
     * @return current body position expressed in NED coordinates.
     */
    public NEDPosition getNedPosition() {
<span class="fc" id="L1328">        return getNedFrame().getPosition();</span>
    }

    /**
     * Gets current body position expressed in NED coordinates.
     *
     * @param result instance where current body position will be stored.
     */
    public void getNedPosition(final NEDPosition result) {
<span class="fc" id="L1337">        getNedFrame().getPosition(result);</span>
<span class="fc" id="L1338">    }</span>

    /**
     * Sets current body position expressed in NED coordinates.
     *
     * @param position current body position to be set.
     * @throws LockedException if estimator is currently running.
     */
    public void setNedPosition(final NEDPosition position) throws LockedException {
<span class="fc bfc" id="L1347" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L1348">            throw new LockedException();</span>
        }

<span class="fc" id="L1351">        final NEDFrame nedFrame = getNedFrame();</span>
<span class="fc" id="L1352">        nedFrame.setPosition(position);</span>
<span class="fc" id="L1353">        NEDtoECEFFrameConverter.convertNEDtoECEF(nedFrame, mFrame);</span>
<span class="fc" id="L1354">        rebuildExpectedKinematics();</span>
<span class="fc" id="L1355">    }</span>

    /**
     * Sets current body position expressed in NED coordinates.
     *
     * @param latitude  latitude NED coordinate expressed in radians (rad).
     * @param longitude longitude NED coordinate expressed in radians (rad).
     * @param height    height NED coordinate expressed in meters (m).
     * @throws LockedException if estimator is currently running.
     */
    public void setNedPosition(
            final double latitude, final double longitude, final double height)
            throws LockedException {
<span class="fc bfc" id="L1368" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L1369">            throw new LockedException();</span>
        }

<span class="fc" id="L1372">        final NEDFrame nedFrame = getNedFrame();</span>
<span class="fc" id="L1373">        nedFrame.setPosition(latitude, longitude, height);</span>
<span class="fc" id="L1374">        NEDtoECEFFrameConverter.convertNEDtoECEF(nedFrame, mFrame);</span>
<span class="fc" id="L1375">        rebuildExpectedKinematics();</span>
<span class="fc" id="L1376">    }</span>

    /**
     * Sets current body position expressed in NED coordinates.
     *
     * @param latitude  latitude NED coordinate.
     * @param longitude longitude NED coordinate.
     * @param height    height NED coordinate expressed in meters (m).
     * @throws LockedException if estimator is currently running.
     */
    public void setNedPosition(
            final Angle latitude, final Angle longitude, final double height)
            throws LockedException {
<span class="fc bfc" id="L1389" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L1390">            throw new LockedException();</span>
        }

<span class="fc" id="L1393">        final NEDFrame nedFrame = getNedFrame();</span>
<span class="fc" id="L1394">        nedFrame.setPosition(latitude, longitude, height);</span>
<span class="fc" id="L1395">        NEDtoECEFFrameConverter.convertNEDtoECEF(nedFrame, mFrame);</span>
<span class="fc" id="L1396">        rebuildExpectedKinematics();</span>
<span class="fc" id="L1397">    }</span>

    /**
     * Sets current body position expressed in NED coordinates.
     *
     * @param latitude  latitude NED coordinate.
     * @param longitude longitude NED coordinate.
     * @param height    height NED coordinate.
     * @throws LockedException if estimator is currently running.
     */
    public void setNedPosition(
            final Angle latitude, final Angle longitude, final Distance height)
            throws LockedException {
<span class="fc bfc" id="L1410" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L1411">            throw new LockedException();</span>
        }

<span class="fc" id="L1414">        final NEDFrame nedFrame = getNedFrame();</span>
<span class="fc" id="L1415">        nedFrame.setPosition(latitude, longitude, height);</span>
<span class="fc" id="L1416">        NEDtoECEFFrameConverter.convertNEDtoECEF(nedFrame, mFrame);</span>
<span class="fc" id="L1417">        rebuildExpectedKinematics();</span>
<span class="fc" id="L1418">    }</span>

    /**
     * Gets current body orientation as a transformation from body to ECEF coordinates.
     * Notice that returned orientation refers to ECEF Earth axes, which means that
     * orientation is not relative to the ground or horizon at current body position.
     * Typically it is more convenient to use {@link #getNedC()} to obtain orientation
     * relative to the ground or horizon at current body position. For instance, on
     * Android devices a NED orientation with Euler angles (roll = 0, pitch = 0,
     * yaw = 0) means that the device is laying flat on a horizontal surface with the
     * screen facing down towards the ground.
     *
     * @return current body orientation resolved on ECEF axes.
     */
    public CoordinateTransformation getEcefC() {
<span class="fc" id="L1433">        return mFrame.getCoordinateTransformation();</span>
    }

    /**
     * Gets current body orientation as a transformation from body to ECEF coordinates.
     * Notice that returned orientation refers to ECEF Earth axes, which means that
     * orientation is not relative to the ground or horizon at current body position.
     * Typically it is more convenient to use {@link #getNedC()} to obtain orientation
     * relative to the ground or horizon at current body position. For instance, on
     * Android devices a NED orientation with Euler angles (roll = 0, pitch = 0,
     * yaw = 0) means that the device is laying flat on a horizontal surface with the
     * screen facing down towards the ground.
     *
     * @param result instance where current body orientation resolved on ECEF axes
     *               will be stored.
     */
    public void getEcefC(final CoordinateTransformation result) {
<span class="fc" id="L1450">        mFrame.getCoordinateTransformation(result);</span>
<span class="fc" id="L1451">    }</span>

    /**
     * Sets current body orientation as a transformation from body to ECEF coordinates.
     * Notice that ECEF orientation refers to ECEF Earth axes, which means that
     * orientation is not relative to the ground or horizont at current body position.
     * Typically it is more convenient to use
     * {@link #setNedC(CoordinateTransformation)} to specify orientation relative to
     * the ground or horizon at current body position.
     * For instance, on Android devices a NED orientation with Euler angles (roll = 0,
     * pitch = 0, yaw = 0) means that the device is laying flat on a horizontal surface
     * with the screen facing down towards the ground.
     *
     * @param ecefC body orientation resolved on ECEF axes to be set.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not from
     *                                                       body to ECEF coordinates.
     * @throws LockedException                               if estimator is currently
     *                                                       running.
     */
    public void setEcefC(final CoordinateTransformation ecefC)
            throws InvalidSourceAndDestinationFrameTypeException, LockedException {
<span class="fc bfc" id="L1473" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L1474">            throw new LockedException();</span>
        }

<span class="fc" id="L1477">        mFrame.setCoordinateTransformation(ecefC);</span>
<span class="fc" id="L1478">        rebuildExpectedKinematics();</span>
<span class="fc" id="L1479">    }</span>

    /**
     * Gets current body orientation as a transformation from body to NED coordinates.
     * Notice that returned orientation refers to current local position. This means
     * that two equal NED orientations will transform into different ECEF orientations
     * if the body is located at different positions.
     * As a reference, on Android devices a NED orientation with Euler angles
     * (roll = 0, pitch = 0, yaw = 0) means that the device is laying flat on a
     * horizontal surface with the screen facing down towards the ground.
     *
     * @return current body orientation resolved on NED axes.
     */
    public CoordinateTransformation getNedC() {
<span class="fc" id="L1493">        return getNedFrame().getCoordinateTransformation();</span>
    }

    /**
     * Gets current body orientation as a transformation from body to NED coordinates.
     * Notice that returned orientation refers to current local position. This means
     * that two equal NED orientations will transform into different ECEF orientations
     * if the body is located at different positions.
     * As a reference, on Android devices a NED orientation with Euler angles
     * (roll = 0, pitch = 0, yaw = 0) means that the device is laying flat on a
     * horizontal surface with the screen facing down towards the ground.
     *
     * @param result instance where current body orientation resolved on NED axes
     *               will be stored.
     */
    public void getNedC(final CoordinateTransformation result) {
<span class="fc" id="L1509">        getNedFrame().getCoordinateTransformation(result);</span>
<span class="fc" id="L1510">    }</span>

    /**
     * Sets current body orientation as a transformation from body to NED coordinates.
     * Notice that provided orientation refers to current local position. This means
     * that two equal NED orientations will transform into different ECEF orientations
     * if the body is located at different positions.
     * As a reference, on Android devices a NED orientation with Euler angles
     * (roll = 0, pitch = 0, yaw = 0) means that the device is laying flat on a
     * horizontal surface with the screen facing down towards the ground.
     *
     * @param nedC orientation resolved on NED axes to be set.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not from
     *                                                       body to NED coordinates.
     * @throws LockedException                               if estimator is currently
     *                                                       running.
     */
    public void setNedC(final CoordinateTransformation nedC)
            throws InvalidSourceAndDestinationFrameTypeException, LockedException {
<span class="fc bfc" id="L1530" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L1531">            throw new LockedException();</span>
        }

<span class="fc" id="L1534">        final NEDFrame nedFrame = getNedFrame();</span>
<span class="fc" id="L1535">        nedFrame.setCoordinateTransformation(nedC);</span>
<span class="fc" id="L1536">        NEDtoECEFFrameConverter.convertNEDtoECEF(nedFrame, mFrame);</span>
<span class="fc" id="L1537">        rebuildExpectedKinematics();</span>
<span class="fc" id="L1538">    }</span>

    /**
     * Sets position and orientation both expressed on NED coordinates.
     *
     * @param nedPosition position expressed on NED coordinates.
     * @param nedC        body to NED coordinate transformation indicating
     *                    body orientation.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not from
     *                                                       body to NED coordinates.
     * @throws LockedException                               if estimator is currently
     *                                                       running.
     * @see #setNedPosition(NEDPosition)
     * @see #setNedC(CoordinateTransformation)
     */
    public void setNedPositionAndNedOrientation(
            final NEDPosition nedPosition, final CoordinateTransformation nedC)
            throws InvalidSourceAndDestinationFrameTypeException, LockedException {
<span class="fc bfc" id="L1557" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L1558">            throw new LockedException();</span>
        }

<span class="fc" id="L1561">        final NEDFrame nedFrame = getNedFrame();</span>
<span class="fc" id="L1562">        nedFrame.setPosition(nedPosition);</span>
<span class="fc" id="L1563">        nedFrame.setCoordinateTransformation(nedC);</span>
<span class="fc" id="L1564">        NEDtoECEFFrameConverter.convertNEDtoECEF(nedFrame, mFrame);</span>
<span class="fc" id="L1565">        rebuildExpectedKinematics();</span>
<span class="fc" id="L1566">    }</span>

    /**
     * Sets position and orientation both expressed on NED coordinates.
     *
     * @param latitude  latitude expressed in radians (rad).
     * @param longitude longitude expressed in radians (rad).
     * @param height    height expressed in meters (m).
     * @param nedC      body to NED coordinate transformation indicating
     *                  body orientation.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not from
     *                                                       body to NED coordinates.
     * @throws LockedException                               if estimator is currently
     *                                                       running.
     * @see #setNedPosition(double, double, double)
     * @see #setNedC(CoordinateTransformation)
     */
    public void setNedPositionAndNedOrientation(
            final double latitude, final double longitude, final double height,
            final CoordinateTransformation nedC)
            throws InvalidSourceAndDestinationFrameTypeException, LockedException {
<span class="fc bfc" id="L1588" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L1589">            throw new LockedException();</span>
        }

<span class="fc" id="L1592">        final NEDFrame nedFrame = getNedFrame();</span>
<span class="fc" id="L1593">        nedFrame.setPosition(latitude, longitude, height);</span>
<span class="fc" id="L1594">        nedFrame.setCoordinateTransformation(nedC);</span>
<span class="fc" id="L1595">        NEDtoECEFFrameConverter.convertNEDtoECEF(nedFrame, mFrame);</span>
<span class="fc" id="L1596">        rebuildExpectedKinematics();</span>
<span class="fc" id="L1597">    }</span>

    /**
     * Sets position and orientation both expressed on NED coordinates.
     *
     * @param latitude  latitude.
     * @param longitude longitude.
     * @param height    height expressed in meters (m).
     * @param nedC      body to NED coordinate transformation indicating
     *                  body orientation.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not from
     *                                                       body to NED coordinates.
     * @throws LockedException                               if estimator is currently
     *                                                       running.
     * @see #setNedPosition(Angle, Angle, double)
     * @see #setNedC(CoordinateTransformation)
     */
    public void setNedPositionAndNedOrientation(
            final Angle latitude, final Angle longitude, final double height,
            final CoordinateTransformation nedC)
            throws InvalidSourceAndDestinationFrameTypeException, LockedException {
<span class="fc bfc" id="L1619" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L1620">            throw new LockedException();</span>
        }

<span class="fc" id="L1623">        final NEDFrame nedFrame = getNedFrame();</span>
<span class="fc" id="L1624">        nedFrame.setPosition(latitude, longitude, height);</span>
<span class="fc" id="L1625">        nedFrame.setCoordinateTransformation(nedC);</span>
<span class="fc" id="L1626">        NEDtoECEFFrameConverter.convertNEDtoECEF(nedFrame, mFrame);</span>
<span class="fc" id="L1627">        rebuildExpectedKinematics();</span>
<span class="fc" id="L1628">    }</span>

    /**
     * Sets position and orientation both expressed on NED coordinates.
     *
     * @param latitude  latitude.
     * @param longitude longitude.
     * @param height    height.
     * @param nedC      body to NED coordinate transformation indicating
     *                  body orientation.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not from
     *                                                       body to NED coordinates.
     * @throws LockedException                               if estimator is currently
     *                                                       running.
     * @see #setNedPosition(Angle, Angle, Distance)
     * @see #setNedC(CoordinateTransformation)
     */
    public void setNedPositionAndNedOrientation(
            final Angle latitude, final Angle longitude, final Distance height,
            final CoordinateTransformation nedC)
            throws InvalidSourceAndDestinationFrameTypeException, LockedException {
<span class="fc bfc" id="L1650" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L1651">            throw new LockedException();</span>
        }

<span class="fc" id="L1654">        final NEDFrame nedFrame = getNedFrame();</span>
<span class="fc" id="L1655">        nedFrame.setPosition(latitude, longitude, height);</span>
<span class="fc" id="L1656">        nedFrame.setCoordinateTransformation(nedC);</span>
<span class="fc" id="L1657">        NEDtoECEFFrameConverter.convertNEDtoECEF(nedFrame, mFrame);</span>
<span class="fc" id="L1658">        rebuildExpectedKinematics();</span>
<span class="fc" id="L1659">    }</span>

    /**
     * Sets position and orientation both expressed on ECEF coordinates.
     *
     * @param ecefPosition position expressed on ECEF coordinates.
     * @param ecefC        body to ECEF coordinate transformation indicating body
     *                     orientation.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not from
     *                                                       body to ECEF coordinates.
     * @throws LockedException                               if estimator is currently
     *                                                       running.
     * @see #setEcefPosition(ECEFPosition)
     * @see #setEcefC(CoordinateTransformation)
     */
    public void setEcefPositionAndEcefOrientation(
            final ECEFPosition ecefPosition, final CoordinateTransformation ecefC)
            throws InvalidSourceAndDestinationFrameTypeException, LockedException {
<span class="fc bfc" id="L1678" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L1679">            throw new LockedException();</span>
        }

<span class="fc" id="L1682">        mFrame.setPosition(ecefPosition);</span>
<span class="fc" id="L1683">        mFrame.setCoordinateTransformation(ecefC);</span>
<span class="fc" id="L1684">        rebuildExpectedKinematics();</span>
<span class="fc" id="L1685">    }</span>

    /**
     * Sets position and orientation both expressed on ECEF coordinates.
     *
     * @param x     x coordinate of ECEF position expressed in meters (m).
     * @param y     y coordinate of ECEF position expressed in meters (m).
     * @param z     z coordinate of ECEF position expressed in meters (m).
     * @param ecefC body to ECEF coordinate transformation indicating body
     *              orientation.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not from
     *                                                       body to ECEF coordinates.
     * @throws LockedException                               if estimator is currently
     *                                                       running.
     * @see #setEcefPosition(double, double, double)
     * @see #setEcefC(CoordinateTransformation)
     */
    public void setEcefPositionAndEcefOrientation(
            final double x, final double y, final double z,
            final CoordinateTransformation ecefC)
            throws InvalidSourceAndDestinationFrameTypeException, LockedException {
<span class="fc bfc" id="L1707" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L1708">            throw new LockedException();</span>
        }

<span class="fc" id="L1711">        mFrame.setCoordinates(x, y, z);</span>
<span class="fc" id="L1712">        mFrame.setCoordinateTransformation(ecefC);</span>
<span class="fc" id="L1713">        rebuildExpectedKinematics();</span>
<span class="fc" id="L1714">    }</span>

    /**
     * Sets position and orientation both expressed on ECEF coordinates.
     *
     * @param x     x coordinate of ECEF position.
     * @param y     y coordinate of ECEF position.
     * @param z     z coordinate of ECEF position.
     * @param ecefC body to ECEF coordinate transformation indicating body
     *              orientation.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not from
     *                                                       body to ECEF coordinates.
     * @throws LockedException                               if estimator is currently
     *                                                       running.
     * @see #setEcefPosition(Distance, Distance, Distance)
     * @see #setEcefC(CoordinateTransformation)
     */
    public void setEcefPositionAndEcefOrientation(
            final Distance x, final Distance y, final Distance z,
            final CoordinateTransformation ecefC)
            throws InvalidSourceAndDestinationFrameTypeException, LockedException {
<span class="fc bfc" id="L1736" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L1737">            throw new LockedException();</span>
        }

<span class="fc" id="L1740">        mFrame.setPositionCoordinates(x, y, z);</span>
<span class="fc" id="L1741">        mFrame.setCoordinateTransformation(ecefC);</span>
<span class="fc" id="L1742">        rebuildExpectedKinematics();</span>
<span class="fc" id="L1743">    }</span>

    /**
     * Sets position and orientation both expressed on ECEF coordinates.
     *
     * @param position position resolved around ECEF axes and expressed in meters (m).
     * @param ecefC    body to ECEF coordinate transformation indicating body
     *                 orientation.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not from
     *                                                       body to ECEF coordinates.
     * @throws LockedException                               if estimator is currently
     *                                                       running.
     * @see #setEcefPosition(Point3D)
     * @see #setEcefC(CoordinateTransformation)
     */
    public void setEcefPositionAndEcefOrientation(
            final Point3D position, final CoordinateTransformation ecefC)
            throws InvalidSourceAndDestinationFrameTypeException, LockedException {
<span class="fc bfc" id="L1762" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L1763">            throw new LockedException();</span>
        }

<span class="fc" id="L1766">        mFrame.setPosition(position);</span>
<span class="fc" id="L1767">        mFrame.setCoordinateTransformation(ecefC);</span>
<span class="fc" id="L1768">        rebuildExpectedKinematics();</span>
<span class="fc" id="L1769">    }</span>

    /**
     * Sets position expressed on NED coordinates and orientation respect to ECEF
     * axes.
     *
     * @param position position expressed on NED coordinates.
     * @param ecefC    body to ECEF coordinate transformation indicating body
     *                 orientation.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not from
     *                                                       body to ECEF coordinates.
     * @throws LockedException                               if estimator is currently
     *                                                       running.
     * @see #setNedPosition(NEDPosition)
     * @see #setEcefC(CoordinateTransformation)
     */
    public void setNedPositionAndEcefOrientation(
            final NEDPosition position,
            final CoordinateTransformation ecefC)
            throws InvalidSourceAndDestinationFrameTypeException, LockedException {
<span class="fc bfc" id="L1790" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L1791">            throw new LockedException();</span>
        }

<span class="fc" id="L1794">        final NEDFrame nedFrame = getNedFrame();</span>
<span class="fc" id="L1795">        nedFrame.setPosition(position);</span>
<span class="fc" id="L1796">        NEDtoECEFFrameConverter.convertNEDtoECEF(nedFrame, mFrame);</span>
<span class="fc" id="L1797">        mFrame.setCoordinateTransformation(ecefC);</span>
<span class="fc" id="L1798">        rebuildExpectedKinematics();</span>
<span class="fc" id="L1799">    }</span>

    /**
     * Sets position expressed on NED coordinates and orientation respect to ECEF
     * axes.
     *
     * @param latitude  latitude expressed in radians (rad).
     * @param longitude longitude expressed in radians (rad).
     * @param height    height expressed in meters (m).
     * @param ecefC     body to ECEF coordinate transformation indicating body
     *                  orientation.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not from
     *                                                       body to ECEF coordinates.
     * @throws LockedException                               if estimator is currently
     *                                                       running.
     * @see #setNedPosition(double, double, double)
     * @see #setEcefC(CoordinateTransformation)
     */
    public void setNedPositionAndEcefOrientation(
            final double latitude, final double longitude, final double height,
            final CoordinateTransformation ecefC)
            throws InvalidSourceAndDestinationFrameTypeException, LockedException {
<span class="fc bfc" id="L1822" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L1823">            throw new LockedException();</span>
        }

<span class="fc" id="L1826">        final NEDFrame nedFrame = getNedFrame();</span>
<span class="fc" id="L1827">        nedFrame.setPosition(latitude, longitude, height);</span>
<span class="fc" id="L1828">        NEDtoECEFFrameConverter.convertNEDtoECEF(nedFrame, mFrame);</span>
<span class="fc" id="L1829">        mFrame.setCoordinateTransformation(ecefC);</span>
<span class="fc" id="L1830">        rebuildExpectedKinematics();</span>
<span class="fc" id="L1831">    }</span>

    /**
     * Sets position expressed on NED coordinates and orientation respect to ECEF
     * axes.
     *
     * @param latitude  latitude.
     * @param longitude longitude.
     * @param height    height expressed in meters (m).
     * @param ecefC     body to ECEF coordinate transformation indicating body
     *                  orientation.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not from
     *                                                       body to ECEF coordinates.
     * @throws LockedException                               if estimator is currently
     *                                                       running.
     * @see #setNedPosition(Angle, Angle, double)
     * @see #setEcefC(CoordinateTransformation)
     */
    public void setNedPositionAndEcefOrientation(
            final Angle latitude, final Angle longitude, final double height,
            final CoordinateTransformation ecefC)
            throws InvalidSourceAndDestinationFrameTypeException, LockedException {
<span class="fc bfc" id="L1854" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L1855">            throw new LockedException();</span>
        }

<span class="fc" id="L1858">        final NEDFrame nedFrame = getNedFrame();</span>
<span class="fc" id="L1859">        nedFrame.setPosition(latitude, longitude, height);</span>
<span class="fc" id="L1860">        NEDtoECEFFrameConverter.convertNEDtoECEF(nedFrame, mFrame);</span>
<span class="fc" id="L1861">        mFrame.setCoordinateTransformation(ecefC);</span>
<span class="fc" id="L1862">        rebuildExpectedKinematics();</span>
<span class="fc" id="L1863">    }</span>

    /**
     * Sets position expressed on NED coordinates and orientation respect to ECEF
     * axes.
     *
     * @param latitude  latitude.
     * @param longitude longitude.
     * @param height    height.
     * @param ecefC     body to ECEF coordinate transformation indicating body
     *                  orientation.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not from
     *                                                       body to ECEF coordinates.
     * @throws LockedException                               if estimator is currently
     *                                                       running.
     * @see #setNedPosition(Angle, Angle, Distance)
     * @see #setEcefC(CoordinateTransformation)
     */
    public void setNedPositionAndEcefOrientation(
            final Angle latitude, final Angle longitude, final Distance height,
            final CoordinateTransformation ecefC)
            throws InvalidSourceAndDestinationFrameTypeException, LockedException {
<span class="fc bfc" id="L1886" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L1887">            throw new LockedException();</span>
        }

<span class="fc" id="L1890">        final NEDFrame nedFrame = getNedFrame();</span>
<span class="fc" id="L1891">        nedFrame.setPosition(latitude, longitude, height);</span>
<span class="fc" id="L1892">        NEDtoECEFFrameConverter.convertNEDtoECEF(nedFrame, mFrame);</span>
<span class="fc" id="L1893">        mFrame.setCoordinateTransformation(ecefC);</span>
<span class="fc" id="L1894">        rebuildExpectedKinematics();</span>
<span class="fc" id="L1895">    }</span>

    /**
     * Sets position expressed on ECEF coordinates and orientation respect to
     * NED axes.
     * In order to preserve provided orientation, first position is set and
     * then orientation is applied.
     *
     * @param ecefPosition position expressed on ECEF coordinates.
     * @param nedC         body to NED coordinate transformation indicating body
     *                     orientation.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not from
     *                                                       body to NED coordinates.
     * @throws LockedException                               if estimator is currently
     *                                                       running.
     * @see #setEcefPosition(ECEFPosition)
     * @see #setNedC(CoordinateTransformation)
     */
    public void setEcefPositionAndNedOrientation(
            final ECEFPosition ecefPosition, final CoordinateTransformation nedC)
            throws InvalidSourceAndDestinationFrameTypeException, LockedException {
<span class="fc bfc" id="L1917" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L1918">            throw new LockedException();</span>
        }

<span class="fc" id="L1921">        mFrame.setPosition(ecefPosition);</span>

<span class="fc" id="L1923">        final NEDFrame nedFrame = getNedFrame();</span>
<span class="fc" id="L1924">        nedFrame.setCoordinateTransformation(nedC);</span>
<span class="fc" id="L1925">        NEDtoECEFFrameConverter.convertNEDtoECEF(nedFrame, mFrame);</span>
<span class="fc" id="L1926">        rebuildExpectedKinematics();</span>
<span class="fc" id="L1927">    }</span>

    /**
     * Sets position expressed on ECEF coordinates and orientation respect to
     * NED axes.
     * In order to preserve provided orientation, first position is set and
     * then orientation is applied.
     *
     * @param x    x coordinate of ECEF position expressed in meters (m).
     * @param y    y coordinate of ECEF position expressed in meters (m).
     * @param z    z coordinate of ECEF position expressed in meters (m).
     * @param nedC body to NED coordinate transformation indicating body
     *             orientation.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not from
     *                                                       body to NED coordinates.
     * @throws LockedException                               if estimator is currently
     *                                                       running.
     * @see #setEcefPosition(double, double, double)
     * @see #setNedC(CoordinateTransformation)
     */
    public void setEcefPositionAndNedOrientation(
            final double x, final double y, final double z,
            final CoordinateTransformation nedC)
            throws InvalidSourceAndDestinationFrameTypeException, LockedException {
<span class="fc bfc" id="L1952" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L1953">            throw new LockedException();</span>
        }

<span class="fc" id="L1956">        mFrame.setCoordinates(x, y, z);</span>

<span class="fc" id="L1958">        final NEDFrame nedFrame = getNedFrame();</span>
<span class="fc" id="L1959">        nedFrame.setCoordinateTransformation(nedC);</span>
<span class="fc" id="L1960">        NEDtoECEFFrameConverter.convertNEDtoECEF(nedFrame, mFrame);</span>
<span class="fc" id="L1961">        rebuildExpectedKinematics();</span>
<span class="fc" id="L1962">    }</span>

    /**
     * Sets position expressed on ECEF coordinates and orientation respect to
     * NED axes.
     * In order to preserve provided orientation, first position is set and
     * then orientation is applied.
     *
     * @param x    x coordinate of ECEF position.
     * @param y    y coordinate of ECEF position.
     * @param z    z coordinate of ECEF position.
     * @param nedC body to NED coordinate transformation indicating body
     *             orientation.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not from
     *                                                       body to NED coordinates.
     * @throws LockedException                               if estimator is currently
     *                                                       running.
     * @see #setEcefPosition(Distance, Distance, Distance)
     * @see #setNedC(CoordinateTransformation)
     */
    public void setEcefPositionAndNedOrientation(
            final Distance x, final Distance y, final Distance z,
            final CoordinateTransformation nedC)
            throws InvalidSourceAndDestinationFrameTypeException, LockedException {
<span class="fc bfc" id="L1987" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L1988">            throw new LockedException();</span>
        }

<span class="fc" id="L1991">        mFrame.setPositionCoordinates(x, y, z);</span>

<span class="fc" id="L1993">        final NEDFrame nedFrame = getNedFrame();</span>
<span class="fc" id="L1994">        nedFrame.setCoordinateTransformation(nedC);</span>
<span class="fc" id="L1995">        NEDtoECEFFrameConverter.convertNEDtoECEF(nedFrame, mFrame);</span>
<span class="fc" id="L1996">        rebuildExpectedKinematics();</span>
<span class="fc" id="L1997">    }</span>

    /**
     * Sets position expressed on ECEF coordinates and orientation respect to
     * NED axes.
     * In order to preserve provided orientation, first position is set and
     * then orientation is applied.
     *
     * @param position position resolved around ECEF axes and expressed in meters (m).
     * @param nedC     body to NED coordinate transformation indicating body
     *                 orientation.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not from
     *                                                       body to NED coordinates.
     * @throws LockedException                               if estimator is currently
     *                                                       running.
     * @see #setEcefPosition(Point3D)
     * @see #setNedC(CoordinateTransformation)
     */
    public void setEcefPositionAndNedOrientation(
            final Point3D position, final CoordinateTransformation nedC)
            throws InvalidSourceAndDestinationFrameTypeException, LockedException {
<span class="fc bfc" id="L2019" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L2020">            throw new LockedException();</span>
        }

<span class="fc" id="L2023">        mFrame.setPosition(position);</span>

<span class="fc" id="L2025">        final NEDFrame nedFrame = getNedFrame();</span>
<span class="fc" id="L2026">        nedFrame.setCoordinateTransformation(nedC);</span>
<span class="fc" id="L2027">        NEDtoECEFFrameConverter.convertNEDtoECEF(nedFrame, mFrame);</span>
<span class="fc" id="L2028">        rebuildExpectedKinematics();</span>
<span class="fc" id="L2029">    }</span>

    /**
     * Gets listener to handle events raised by this estimator.
     *
     * @return listener to handle events raised by this estimator.
     */
    public BodyKinematicsBiasEstimatorListener getListener() {
<span class="fc" id="L2037">        return mListener;</span>
    }

    /**
     * Sets listener to handle events raised by this estimator.
     *
     * @param listener listener to handle events raised by this estimator.
     * @throws LockedException if this estimator is running.
     */
    public void setListener(final BodyKinematicsBiasEstimatorListener listener)
            throws LockedException {
<span class="fc bfc" id="L2048" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L2049">            throw new LockedException();</span>
        }

<span class="fc" id="L2052">        mListener = listener;</span>
<span class="fc" id="L2053">    }</span>

    /**
     * Gets last provided body kinematics values or null if not available.
     *
     * @return last provided body kinematics values or null.
     */
    public BodyKinematics getLastBodyKinematics() {
<span class="fc bfc" id="L2061" title="All 2 branches covered.">        return mLastBodyKinematics != null ?</span>
<span class="fc" id="L2062">                new BodyKinematics(mLastBodyKinematics) : null;</span>
    }

    /**
     * Gets last provided body kinematics values.
     *
     * @param result instance where last provided body kinematics will be stored.
     * @return true if result instance was updated, false otherwise.
     */
    public boolean getLastBodyKinematics(final BodyKinematics result) {
<span class="fc bfc" id="L2072" title="All 2 branches covered.">        if (mLastBodyKinematics != null) {</span>
<span class="fc" id="L2073">            mLastBodyKinematics.copyTo(result);</span>
<span class="fc" id="L2074">            return true;</span>
        } else {
<span class="fc" id="L2076">            return false;</span>
        }
    }

    /**
     * Gets estimated bias of x coordinate of accelerometer sensed specific force
     * expressed in meters per squared second (m/s^2).
     *
     * @return bias of x coordinate of sensed specific force.
     */
    public double getBiasFx() {
<span class="fc" id="L2087">        return mBiasFx;</span>
    }

    /**
     * Gets estimated bias of x coordinate of accelerometer sensed specific force.
     *
     * @return bias of x coordinate of sensed specific force.
     */
    public Acceleration getBiasFxAsAcceleration() {
<span class="fc" id="L2096">        return new Acceleration(mBiasFx, AccelerationUnit.METERS_PER_SQUARED_SECOND);</span>
    }

    /**
     * Gets estimated bias of x coordinate of accelerometer sensed specific force.
     *
     * @param result instance where bias of x coordinate of sensed specific force
     *               will be stored.
     */
    public void getBiasFxAsAcceleration(final Acceleration result) {
<span class="fc" id="L2106">        result.setValue(mBiasFx);</span>
<span class="fc" id="L2107">        result.setUnit(AccelerationUnit.METERS_PER_SQUARED_SECOND);</span>
<span class="fc" id="L2108">    }</span>

    /**
     * Gets estimated bias of x coordinate of accelerometer sensed specific force
     * expressed in meters per squared second (m/s^2).
     *
     * @return bias of y coordinate of sensed specific force.
     */
    public double getBiasFy() {
<span class="fc" id="L2117">        return mBiasFy;</span>
    }

    /**
     * Gets estimated bias of y coordinate of accelerometer sensed specific force.
     *
     * @return bias of y coordinate of sensed specific force.
     */
    public Acceleration getBiasFyAsAcceleration() {
<span class="fc" id="L2126">        return new Acceleration(mBiasFy, AccelerationUnit.METERS_PER_SQUARED_SECOND);</span>
    }

    /**
     * Gets estimated bias of y coordinate of accelerometer sensed specific force.
     *
     * @param result instance where bias of y coordinate of sensed specific force
     *               will be stored.
     */
    public void getBiasFyAsAcceleration(final Acceleration result) {
<span class="fc" id="L2136">        result.setValue(mBiasFy);</span>
<span class="fc" id="L2137">        result.setUnit(AccelerationUnit.METERS_PER_SQUARED_SECOND);</span>
<span class="fc" id="L2138">    }</span>

    /**
     * Gets estimated bias of z coordinate of accelerometer sensed specific force
     * expressed in meters per squared second (m/s^2).
     *
     * @return bias of z coordinate of sensed specific force.
     */
    public double getBiasFz() {
<span class="fc" id="L2147">        return mBiasFz;</span>
    }

    /**
     * Gets estimated bias of z coordinate of accelerometer sensed specific force.
     *
     * @return bias of z coordinate of sensed specific force.
     */
    public Acceleration getBiasFzAsAcceleration() {
<span class="fc" id="L2156">        return new Acceleration(mBiasFz, AccelerationUnit.METERS_PER_SQUARED_SECOND);</span>
    }

    /**
     * Gets estimated bias of z coordinate of accelerometer sensed specific force.
     *
     * @param result instance where bias of z coordinate of sensed specific force
     *               will be stored.
     */
    public void getBiasFzAsAcceleration(final Acceleration result) {
<span class="fc" id="L2166">        result.setValue(mBiasFz);</span>
<span class="fc" id="L2167">        result.setUnit(AccelerationUnit.METERS_PER_SQUARED_SECOND);</span>
<span class="fc" id="L2168">    }</span>

    /**
     * Gets estimated bias of x coordinate of gyroscope sensed angular rate
     * expressed in radians per second (rad/s).
     *
     * @return bias of x coordinate of sensed angular rate.
     */
    public double getBiasAngularRateX() {
<span class="fc" id="L2177">        return mBiasAngularRateX;</span>
    }

    /**
     * Gets estimated bias of x coordinate of gyroscope sensed angular rate.
     *
     * @return bias of x coordinate of sensed angular rate.
     */
    public AngularSpeed getBiasAngularRateXAsAngularSpeed() {
<span class="fc" id="L2186">        return new AngularSpeed(mBiasAngularRateX,</span>
                AngularSpeedUnit.RADIANS_PER_SECOND);
    }

    /**
     * Gets estimated bias of x coordinate of gyroscope sensed angular rate.
     *
     * @param result instance where bias of x coordinate of sensed angular rate
     *               will be stored.
     */
    public void getBiasAngularRateXAsAngularSpeed(final AngularSpeed result) {
<span class="fc" id="L2197">        result.setValue(mBiasAngularRateX);</span>
<span class="fc" id="L2198">        result.setUnit(AngularSpeedUnit.RADIANS_PER_SECOND);</span>
<span class="fc" id="L2199">    }</span>

    /**
     * Gets estimated bias of y coordinate of gyroscope sensed angular rate
     * expressed in radians per second (rad/s).
     *
     * @return bias of y coordinate of sensed angular rate.
     */
    public double getBiasAngularRateY() {
<span class="fc" id="L2208">        return mBiasAngularRateY;</span>
    }

    /**
     * Gets estimated bias of y coordinate of gyroscope sensed angular rate.
     *
     * @return bias of y coordinate of sensed angular rate.
     */
    public AngularSpeed getBiasAngularRateYAsAngularSpeed() {
<span class="fc" id="L2217">        return new AngularSpeed(mBiasAngularRateY,</span>
                AngularSpeedUnit.RADIANS_PER_SECOND);
    }

    /**
     * Gets estimated bias of y coordinate of gyroscope sensed angular rate.
     *
     * @param result instance where bias of y coordinate of sensed angular rate
     *               will be stored.
     */
    public void getBiasAngularRateYAsAngularSpeed(final AngularSpeed result) {
<span class="fc" id="L2228">        result.setValue(mBiasAngularRateY);</span>
<span class="fc" id="L2229">        result.setUnit(AngularSpeedUnit.RADIANS_PER_SECOND);</span>
<span class="fc" id="L2230">    }</span>

    /**
     * Gets estimated bias of z coordinate of gyroscope sensed angular rate
     * expressed in radians per second (rad/s).
     *
     * @return bias of z coordinate of sensed angular rate.
     */
    public double getBiasAngularRateZ() {
<span class="fc" id="L2239">        return mBiasAngularRateZ;</span>
    }

    /**
     * Gets estimated bias of z coordinate of gyroscope sensed angular rate.
     *
     * @return bias of z coordinate of sensed angular rate.
     */
    public AngularSpeed getBiasAngularRateZAsAngularSpeed() {
<span class="fc" id="L2248">        return new AngularSpeed(mBiasAngularRateZ,</span>
                AngularSpeedUnit.RADIANS_PER_SECOND);
    }

    /**
     * Gets estimated bias of z coordinate of gyroscope sensed angular rate.
     *
     * @param result instance where bias of z coordinate of sensed angular rate
     *               will be stored.
     */
    public void getBiasAngularRateZAsAngularSpeed(final AngularSpeed result) {
<span class="fc" id="L2259">        result.setValue(mBiasAngularRateZ);</span>
<span class="fc" id="L2260">        result.setUnit(AngularSpeedUnit.RADIANS_PER_SECOND);</span>
<span class="fc" id="L2261">    }</span>

    /**
     * Gets estimated bias of accelerometer sensed specific force.
     *
     * @return estimated bias of accelerometer sensed specific force.
     */
    public AccelerationTriad getBiasF() {
<span class="fc" id="L2269">        return new AccelerationTriad(AccelerationUnit.METERS_PER_SQUARED_SECOND,</span>
                mBiasFx, mBiasFy, mBiasFz);
    }

    /**
     * Gets estimated bias of accelerometer sensed specific force.
     *
     * @param result instance where bias of sensed specific force will
     *               be stored.
     */
    public void getBiasF(final AccelerationTriad result) {
<span class="fc" id="L2280">        result.setValueCoordinatesAndUnit(mBiasFx, mBiasFy, mBiasFz,</span>
                AccelerationUnit.METERS_PER_SQUARED_SECOND);
<span class="fc" id="L2282">    }</span>

    /**
     * Gets estimated bias of gyroscope sensed angular rate.
     *
     * @return estimated bias of gyroscope sensed angular rate.
     */
    public AngularSpeedTriad getBiasAngularRate() {
<span class="fc" id="L2290">        return new AngularSpeedTriad(AngularSpeedUnit.RADIANS_PER_SECOND,</span>
                mBiasAngularRateX, mBiasAngularRateY, mBiasAngularRateZ);
    }

    /**
     * Gets estimated bias of gyroscope sensed angular rate.
     *
     * @param result instance where bias of gyroscope sensed angular
     *               rate will be stored.
     */
    public void getBiasAngularRate(final AngularSpeedTriad result) {
<span class="fc" id="L2301">        result.setValueCoordinatesAndUnit(</span>
                mBiasAngularRateX, mBiasAngularRateY, mBiasAngularRateZ,
                AngularSpeedUnit.RADIANS_PER_SECOND);
<span class="fc" id="L2304">    }</span>

    /**
     * Gets body kinematics containing estimated bias values for accelerometer
     * and gyroscope.
     *
     * @return body kinematics containing estimated bias values.
     */
    public BodyKinematics getBiasesAsBodyKinematics() {
<span class="fc" id="L2313">        final BodyKinematics result = new BodyKinematics();</span>
<span class="fc" id="L2314">        getBiasesAsBodyKinematics(result);</span>
<span class="fc" id="L2315">        return result;</span>
    }

    /**
     * Gets body kinematics containing estimated bias values for accelerometer
     * and gyroscope.
     *
     * @param result instance where body kinematics containing estimated bias
     *               values will be stored.
     */
    public void getBiasesAsBodyKinematics(final BodyKinematics result) {
<span class="fc" id="L2326">        result.setSpecificForceCoordinates(mBiasFx, mBiasFy, mBiasFz);</span>
<span class="fc" id="L2327">        result.setAngularRateCoordinates(</span>
                mBiasAngularRateX, mBiasAngularRateY, mBiasAngularRateZ);
<span class="fc" id="L2329">    }</span>

    /**
     * Gets estimated variance of x coordinate of accelerometer sensed specific
     * force expressed in (m^2/s^4).
     *
     * @return estimated variance of x coordinate of sensed specific force.
     */
    public double getVarianceFx() {
<span class="fc" id="L2338">        return mVarianceFx;</span>
    }

    /**
     * Gets estimated variance of y coordinate of accelerometer sensed specific
     * force expressed in (m^2/s^4).
     *
     * @return estimated variance of y coordinate of sensed specific force.
     */
    public double getVarianceFy() {
<span class="fc" id="L2348">        return mVarianceFy;</span>
    }

    /**
     * Gets estimated variance of z coordinate of accelerometer sensed specific
     * force expressed in (m^2/s^4).
     *
     * @return estimated variance of z coordinate of sensed specific force.
     */
    public double getVarianceFz() {
<span class="fc" id="L2358">        return mVarianceFz;</span>
    }

    /**
     * Gets estimated variance of x coordinate of gyroscope sensed angular rate
     * expressed in (rad^2/s^2).
     *
     * @return estimated variance of x coordinate of sensed angular rate.
     */
    public double getVarianceAngularRateX() {
<span class="fc" id="L2368">        return mVarianceAngularRateX;</span>
    }

    /**
     * Gets estimated variance of y coordinate of gyroscope sensed angular rate
     * expressed in (rad^2/s^2).
     *
     * @return estimated variance of y coordinate of sensed angular rate.
     */
    public double getVarianceAngularRateY() {
<span class="fc" id="L2378">        return mVarianceAngularRateY;</span>
    }

    /**
     * Gets estimated variance of z coordinate of gyroscope sensed angular rate
     * expressed in (rad^2/s^2).
     *
     * @return estimated variance of z coordinate of sensed angular rate.
     */
    public double getVarianceAngularRateZ() {
<span class="fc" id="L2388">        return mVarianceAngularRateZ;</span>
    }

    /**
     * Gets estimated standard deviation of x coordinate of accelerometer
     * sensed specific force expressed in (m/s^2).
     *
     * @return estimated standard deviation of x coordinate of sensed specific force.
     */
    public double getStandardDeviationFx() {
<span class="fc" id="L2398">        return Math.sqrt(mVarianceFx);</span>
    }

    /**
     * Gets estimated standard deviation of x coordinate of accelerometer
     * sensed specific force.
     *
     * @return estimated standard deviation of x coordinate of sensed specific force.
     */
    public Acceleration getStandardDeviationFxAsAcceleration() {
<span class="fc" id="L2408">        return new Acceleration(getStandardDeviationFx(),</span>
                AccelerationUnit.METERS_PER_SQUARED_SECOND);
    }

    /**
     * Gets estimated standard deviation of x coordinate of accelerometer
     * sensed specific force.
     *
     * @param result instance where estimated standard deviation of x coordinate
     *               of sensed specific force will be stored.
     */
    public void getStandardDeviationFxAsAcceleration(final Acceleration result) {
<span class="fc" id="L2420">        result.setValue(getStandardDeviationFx());</span>
<span class="fc" id="L2421">        result.setUnit(AccelerationUnit.METERS_PER_SQUARED_SECOND);</span>
<span class="fc" id="L2422">    }</span>

    /**
     * Gets estimated standard deviation of y coordinate of accelerometer
     * sensed specific force expressed in (m/s^2).
     *
     * @return estimated standard deviation of y coordinate of sensed specific
     * force.
     */
    public double getStandardDeviationFy() {
<span class="fc" id="L2432">        return Math.sqrt(mVarianceFy);</span>
    }

    /**
     * Gets estimated standard deviation of y coordinate of accelerometer
     * sensed specific force.
     *
     * @return estimated standard deviation of y coordinate of sensed specific
     * force.
     */
    public Acceleration getStandardDeviationFyAsAcceleration() {
<span class="fc" id="L2443">        return new Acceleration(getStandardDeviationFy(),</span>
                AccelerationUnit.METERS_PER_SQUARED_SECOND);
    }

    /**
     * Gets estimated standard deviation of y coordinate of accelerometer
     * sensed specific force.
     *
     * @param result instance where estimated standard deviation of y coordinate
     *               of sensed specific force will be stored.
     */
    public void getStandardDeviationFyAsAcceleration(final Acceleration result) {
<span class="fc" id="L2455">        result.setValue(getStandardDeviationFy());</span>
<span class="fc" id="L2456">        result.setUnit(AccelerationUnit.METERS_PER_SQUARED_SECOND);</span>
<span class="fc" id="L2457">    }</span>

    /**
     * Gets estimated standard deviation of z coordinate of accelerometer
     * sensed specific force expressed in (m/s^2).
     *
     * @return estimated standard deviation of z coordinate of sensed specific
     * force.
     */
    public double getStandardDeviationFz() {
<span class="fc" id="L2467">        return Math.sqrt(mVarianceFz);</span>
    }

    /**
     * Gets estimated standard deviation of z coordinate of accelerometer
     * sensed specific force.
     *
     * @return estimated standard deviation of z coordinate of sensed specific
     * force.
     */
    public Acceleration getStandardDeviationFzAsAcceleration() {
<span class="fc" id="L2478">        return new Acceleration(getStandardDeviationFz(),</span>
                AccelerationUnit.METERS_PER_SQUARED_SECOND);
    }

    /**
     * Gets estimated standard deviation of z coordinate of accelerometer
     * sensed specific force.
     *
     * @param result instance where estimated standard deviation of z coordinate
     *               of sensed specific force will be stored.
     */
    public void getStandardDeviationFzAsAcceleration(final Acceleration result) {
<span class="fc" id="L2490">        result.setValue(getStandardDeviationFz());</span>
<span class="fc" id="L2491">        result.setUnit(AccelerationUnit.METERS_PER_SQUARED_SECOND);</span>
<span class="fc" id="L2492">    }</span>

    /**
     * Gets estimated standard deviation of accelerometer sensed
     * specific force.
     *
     * @return estimated standard deviation of accelerometer
     */
    public AccelerationTriad getStandardDeviationF() {
<span class="fc" id="L2501">        return new AccelerationTriad(AccelerationUnit.METERS_PER_SQUARED_SECOND,</span>
<span class="fc" id="L2502">                getStandardDeviationFx(),</span>
<span class="fc" id="L2503">                getStandardDeviationFy(),</span>
<span class="fc" id="L2504">                getStandardDeviationFz());</span>
    }

    /**
     * Gets estimated standard deviation of accelerometer sensed
     * specific force.
     *
     * @param result instance where estimated standard deviation of
     *               accelerometer will be stored.
     */
    public void getStandardDeviationF(final AccelerationTriad result) {
<span class="fc" id="L2515">        result.setValueCoordinatesAndUnit(</span>
<span class="fc" id="L2516">                getStandardDeviationFx(), getStandardDeviationFy(), getStandardDeviationFz(),</span>
                AccelerationUnit.METERS_PER_SQUARED_SECOND);
<span class="fc" id="L2518">    }</span>

    /**
     * Gets average of estimated standard deviation of accelerometer sensed specific
     * force for all coordinates expressed in meters per squared second (m/s^2).
     *
     * @return average of estimated standard deviation of accelerometer.
     */
    public double getAverageAccelerometerStandardDeviation() {
<span class="fc" id="L2527">        return (getStandardDeviationFx() + getStandardDeviationFy()</span>
<span class="fc" id="L2528">                + getStandardDeviationFz()) / 3.0;</span>
    }

    /**
     * Gets average of estimated standard deviation of accelerometer sensed specific
     * force for all coordinates.
     *
     * @return average of estimated standard deviation of accelerometer.
     */
    public Acceleration getAverageAccelerometerStandardDeviationAsAcceleration() {
<span class="fc" id="L2538">        return new Acceleration(getAverageAccelerometerStandardDeviation(),</span>
                AccelerationUnit.METERS_PER_SQUARED_SECOND);
    }

    /**
     * Gets average of estimated standard deviation of accelerometer sensed specific
     * force for all coordinates.
     *
     * @param result instance where result data will be copied to.
     */
    public void getAverageAccelerometerStandardDeviationAsAcceleration(
            final Acceleration result) {
<span class="fc" id="L2550">        result.setValue(getAverageAccelerometerStandardDeviation());</span>
<span class="fc" id="L2551">        result.setUnit(AccelerationUnit.METERS_PER_SQUARED_SECOND);</span>
<span class="fc" id="L2552">    }</span>

    /**
     * Gets estimated standard deviation of x coordinate of gyroscope sensed angular
     * rate expressed in (rad/s).
     *
     * @return estimated standard deviaton of x coordinate of sensed angular rate.
     */
    public double getStandardDeviationAngularRateX() {
<span class="fc" id="L2561">        return Math.sqrt(mVarianceAngularRateX);</span>
    }

    /**
     * Gets estimated standard deviation of x coordinate of gyroscope sensed angular
     * rate.
     *
     * @return estimated standard deviation of x coordinate of sensed angular rate.
     */
    public AngularSpeed getStandardDeviationAngularRateXAsAngularSpeed() {
<span class="fc" id="L2571">        return new AngularSpeed(getStandardDeviationAngularRateX(),</span>
                AngularSpeedUnit.RADIANS_PER_SECOND);
    }

    /**
     * Gets estimated standard deviation of x coordinate of gyroscope sensed angular
     * rate.
     *
     * @param result instance where estimated standard deviation of x coordinate of
     *               sensed angular rate will be stored.
     */
    public void getStandardDeviationAngularRateXAsAngularSpeed(
            final AngularSpeed result) {
<span class="fc" id="L2584">        result.setValue(getStandardDeviationAngularRateX());</span>
<span class="fc" id="L2585">        result.setUnit(AngularSpeedUnit.RADIANS_PER_SECOND);</span>
<span class="fc" id="L2586">    }</span>

    /**
     * Gets estimated standard deviation of y coordinate of gyroscope sensed angular
     * rate expressed in (rad/s).
     *
     * @return estimated standard deviation of y coordinate of sensed angular rate.
     */
    public double getStandardDeviationAngularRateY() {
<span class="fc" id="L2595">        return Math.sqrt(mVarianceAngularRateY);</span>
    }

    /**
     * Gets estimated standard deviation of y coordinate of gyroscope sensed angular
     * rate.
     *
     * @return estimated standard deviation of y coordinate of sensed angular rate.
     */
    public AngularSpeed getStandardDeviationAngularRateYAsAngularSpeed() {
<span class="fc" id="L2605">        return new AngularSpeed(getStandardDeviationAngularRateY(),</span>
                AngularSpeedUnit.RADIANS_PER_SECOND);
    }

    /**
     * Gets estimated standard deviation of y coordinate of gyroscope sensed angular
     * rate.
     *
     * @param result instance where estimated standard deviation of y coordinate of
     *               sensed angular rate will be stored.
     */
    public void getStandardDeviationAngularRateYAsAngularSpeed(
            final AngularSpeed result) {
<span class="fc" id="L2618">        result.setValue(getStandardDeviationAngularRateY());</span>
<span class="fc" id="L2619">        result.setUnit(AngularSpeedUnit.RADIANS_PER_SECOND);</span>
<span class="fc" id="L2620">    }</span>

    /**
     * Gets estimated standard deviation of z coordinate of gyroscope sensed angular
     * rate expressed in (rad/s).
     *
     * @return estimated standard deviation of z coordinate of sensed angular rate.
     */
    public double getStandardDeviationAngularRateZ() {
<span class="fc" id="L2629">        return Math.sqrt(mVarianceAngularRateZ);</span>
    }

    /**
     * Gets estimated standard deviation of z coordinate of gyroscope sensed angular
     * rate.
     *
     * @return estimated standard deviation of z coordinate of sensed angular rate.
     */
    public AngularSpeed getStandardDeviationAngularRateZAsAngularSpeed() {
<span class="fc" id="L2639">        return new AngularSpeed(getStandardDeviationAngularRateZ(),</span>
                AngularSpeedUnit.RADIANS_PER_SECOND);
    }

    /**
     * Gets estimated standard deviation of z coordinate of gyroscope sensed angular
     * rate.
     *
     * @param result instance where estimated standard deviation of z coordinate of
     *               sensed angular rate will be stored.
     */
    public void getStandardDeviationAngularRateZAsAngularSpeed(
            final AngularSpeed result) {
<span class="fc" id="L2652">        result.setValue(getStandardDeviationAngularRateZ());</span>
<span class="fc" id="L2653">        result.setUnit(AngularSpeedUnit.RADIANS_PER_SECOND);</span>
<span class="fc" id="L2654">    }</span>

    /**
     * Gets estimated standard deviation of sensed angular rate.
     *
     * @return estimated standard deviation of sensed angular rate.
     */
    public AngularSpeedTriad getStandardDeviationAngularRate() {
<span class="fc" id="L2662">        return new AngularSpeedTriad(AngularSpeedUnit.RADIANS_PER_SECOND,</span>
<span class="fc" id="L2663">                getStandardDeviationAngularRateX(),</span>
<span class="fc" id="L2664">                getStandardDeviationAngularRateY(),</span>
<span class="fc" id="L2665">                getStandardDeviationAngularRateZ());</span>
    }

    /**
     * Gets estimated standard deviation of sensed angular rate.
     *
     * @param result instance where estimated standard deviation of
     *               sensed angular rate.
     */
    public void getStandardDeviationAngularRate(final AngularSpeedTriad result) {
<span class="fc" id="L2675">        result.setValueCoordinatesAndUnit(getStandardDeviationAngularRateX(),</span>
<span class="fc" id="L2676">                getStandardDeviationAngularRateY(),</span>
<span class="fc" id="L2677">                getStandardDeviationAngularRateZ(),</span>
                AngularSpeedUnit.RADIANS_PER_SECOND);
<span class="fc" id="L2679">    }</span>

    /**
     * Gets average of estimated standard deviation of gyroscope sensed angular rate
     * for all coordinates expressed in radians per second (rad/s).
     *
     * @return average of estimated standard deviation of gyroscope.
     */
    public double getAverageGyroscopeStandardDeviation() {
<span class="fc" id="L2688">        return (getStandardDeviationAngularRateX() + getStandardDeviationAngularRateY()</span>
<span class="fc" id="L2689">                + getStandardDeviationAngularRateZ()) / 3.0;</span>
    }

    /**
     * Gets average of estimated standard deviation of gyroscope sensed angular rate
     * for all coordinates.
     *
     * @return average of estimated standard deviation of gyroscope.
     */
    public AngularSpeed getAverageGyroscopeStandardDeviationAsAngularSpeed() {
<span class="fc" id="L2699">        return new AngularSpeed(getAverageGyroscopeStandardDeviation(),</span>
                AngularSpeedUnit.RADIANS_PER_SECOND);
    }

    /**
     * Gets average of estimated standard deviation of gyroscope sensed angular rate
     * for all coordinates.
     *
     * @param result instance where result data will be copied to.
     */
    public void getAverageGyroscopeStandardDeviationAsAngularSpeed(
            final AngularSpeed result) {
<span class="fc" id="L2711">        result.setValue(getAverageGyroscopeStandardDeviation());</span>
<span class="fc" id="L2712">        result.setUnit(AngularSpeedUnit.RADIANS_PER_SECOND);</span>
<span class="fc" id="L2713">    }</span>

    /**
     * Gets estimated standard deviations of accelerometer and gyroscope components
     * as a body kinematics instance.
     *
     * @return a body kinematics instance containing standard deviation values.
     */
    public BodyKinematics getStandardDeviationsAsBodyKinematics() {
<span class="fc" id="L2722">        return new BodyKinematics(getStandardDeviationFx(),</span>
<span class="fc" id="L2723">                getStandardDeviationFy(),</span>
<span class="fc" id="L2724">                getStandardDeviationFz(),</span>
<span class="fc" id="L2725">                getStandardDeviationAngularRateX(),</span>
<span class="fc" id="L2726">                getStandardDeviationAngularRateY(),</span>
<span class="fc" id="L2727">                getStandardDeviationAngularRateZ());</span>
    }

    /**
     * Gets estimated standard deviations of accelerometer and gyroscope components
     * as a body kinematics instance.
     *
     * @param result instance where data will be stored.
     */
    public void getStandardDeviationsAsBodyKinematics(final BodyKinematics result) {
<span class="fc" id="L2737">        result.setSpecificForceCoordinates(getStandardDeviationFx(),</span>
<span class="fc" id="L2738">                getStandardDeviationFy(), getStandardDeviationFz());</span>
<span class="fc" id="L2739">        result.setAngularRateCoordinates(getStandardDeviationAngularRateX(),</span>
<span class="fc" id="L2740">                getStandardDeviationAngularRateY(),</span>
<span class="fc" id="L2741">                getStandardDeviationAngularRateZ());</span>
<span class="fc" id="L2742">    }</span>

    /**
     * Gets accelerometer noise PSD (Power Spectral Density) on x axis expressed
     * in (m^2 * s^-3).
     *
     * @return accelerometer noise PSD on x axis.
     */
    public double getPSDFx() {
<span class="fc" id="L2751">        return mVarianceFx * mTimeInterval;</span>
    }

    /**
     * Gets accelerometer noise PSD (Power Spectral Density) on y axis expressed
     * in (m^2 * s^-3).
     *
     * @return accelerometer noise PSD on y axis.
     */
    public double getPSDFy() {
<span class="fc" id="L2761">        return mVarianceFy * mTimeInterval;</span>
    }

    /**
     * Gets accelerometer noise PSD (Power Spectral Density) on z axis expressed
     * in (m^2 * s^-3).
     *
     * @return accelerometer noise PSD on z axis.
     */
    public double getPSDFz() {
<span class="fc" id="L2771">        return mVarianceFz * mTimeInterval;</span>
    }

    /**
     * Gets gyroscope noise PSD (Power Spectral Density) on x axis expressed
     * in (rad^2/s).
     *
     * @return gyroscope noise PSD on x axis.
     */
    public double getPSDAngularRateX() {
<span class="fc" id="L2781">        return mVarianceAngularRateX * mTimeInterval;</span>
    }

    /**
     * Gets gyroscope noise PSD (Power Spectral Density) on y axis expressed
     * in (rad^2/s).
     *
     * @return gyroscope noise PSD on y axis.
     */
    public double getPSDAngularRateY() {
<span class="fc" id="L2791">        return mVarianceAngularRateY * mTimeInterval;</span>
    }

    /**
     * Gets gyroscope noise PSD (Power Spectral Density) on z axis expressed
     * in (rad^2/s).
     *
     * @return gyroscope noise PSD on z axis.
     */
    public double getPSDAngularRateZ() {
<span class="fc" id="L2801">        return mVarianceAngularRateZ * mTimeInterval;</span>
    }

    /**
     * Gets accelerometer noise root PSD (Power Spectral Density) on x axis
     * expressed in (m * s^-1.5).
     *
     * @return accelerometer noise root PSD on x axis.
     */
    public double getRootPSDFx() {
<span class="fc" id="L2811">        return Math.sqrt(getPSDFx());</span>
    }

    /**
     * Gets accelerometer noise root PSD (Power Spectral Density) on y axis
     * expressed in (m * s^-1.5).
     *
     * @return accelerometer noise root PSD on y axis.
     */
    public double getRootPSDFy() {
<span class="fc" id="L2821">        return Math.sqrt(getPSDFy());</span>
    }

    /**
     * Gets accelerometer noise root PSD (Power Spectral Density) on z axis
     * expressed in (m * s^-1.5).
     *
     * @return accelerometer noise root PSD on z axis.
     */
    public double getRootPSDFz() {
<span class="fc" id="L2831">        return Math.sqrt(getPSDFz());</span>
    }

    /**
     * Gets gyroscope noise root PSD (Power Spectral Density) on x axis
     * expressed in (rad * s^-0.5).
     *
     * @return gyroscope noise root PSD on x axis.
     */
    public double getRootPSDAngularRateX() {
<span class="fc" id="L2841">        return Math.sqrt(getPSDAngularRateX());</span>
    }

    /**
     * Gets gyroscope noise root PSD (Power Spectral Density) on y axis
     * expressed in (rad * s^-0.5).
     *
     * @return gyroscope noise root PSD on y axis.
     */
    public double getRootPSDAngularRateY() {
<span class="fc" id="L2851">        return Math.sqrt(getPSDAngularRateY());</span>
    }

    /**
     * Gets gyroscope noise root PSD (Power Spectral Density) on z axis
     * expressed in (rad * s^-0.5).
     *
     * @return gyroscope noise root PSD on z axis.
     */
    public double getRootPSDAngularRateZ() {
<span class="fc" id="L2861">        return Math.sqrt(getPSDAngularRateZ());</span>
    }

    /**
     * Gets average accelerometer noise PSD (Power Spectral Density) among
     * x,y,z components expressed as (m^2/s^3).
     *
     * @return average accelerometer noise PSD.
     */
    public double getAccelerometerNoisePSD() {
<span class="fc" id="L2871">        return (getPSDFx() + getPSDFy() + getPSDFz()) / 3.0;</span>
    }

    /**
     * Gets average accelerometer noise root PSD (Power Spectral Density) among
     * x,y,z components expressed as (m * s^-1.5).
     *
     * @return average accelerometer noise root PSD.
     */
    public double getAccelerometerNoiseRootPSD() {
<span class="fc" id="L2881">        return Math.sqrt(getAccelerometerNoisePSD());</span>
    }

    /**
     * Gets average gyroscope noise PSD (Power Spectral Density) among
     * x,y,z components expressed in (rad^2/s).
     *
     * @return average gyroscope noise PSD.
     */
    public double getGyroNoisePSD() {
<span class="fc" id="L2891">        return (getPSDAngularRateX() + getPSDAngularRateY() + getPSDAngularRateZ())</span>
                / 3.0;
    }

    /**
     * Gets average gyroscope noise root PSD (Power Spectral Density) among
     * x,y,z components expressed in (rad * s^-0.5).
     *
     * @return average gyroscope noise root PSD.
     */
    public double getGyroNoiseRootPSD() {
<span class="fc" id="L2902">        return Math.sqrt(getGyroNoisePSD());</span>
    }

    /**
     * Gets estimated bias of accelerometer sensed specific force
     * expressed in meters per squared second (m/s^2) as a 3x1 matrix column vector.
     *
     * @return estimated bias of accelerometer sensed specific force.
     */
    public Matrix getAccelerometerBias() {
        Matrix result;
        try {
<span class="fc" id="L2914">            result = new Matrix(BodyKinematics.COMPONENTS, 1);</span>
<span class="fc" id="L2915">            getAccelerometerBias(result);</span>
<span class="nc" id="L2916">        } catch (final WrongSizeException ignore) {</span>
            // never happens
<span class="nc" id="L2918">            result = null;</span>
<span class="fc" id="L2919">        }</span>

<span class="fc" id="L2921">        return result;</span>
    }

    /**
     * Gets estimated bias of accelerometer sensed specific force
     * expressed in meters per squared second (m/s^2) as a 3x1 matrix column vector.
     *
     * @param result instance where data will be copied to. Must be 3x1.
     * @throws IllegalArgumentException if provided result matrix is not 3x1.
     */
    public void getAccelerometerBias(final Matrix result) {
<span class="fc bfc" id="L2932" title="All 2 branches covered.">        if (result.getRows() != BodyKinematics.COMPONENTS</span>
<span class="fc bfc" id="L2933" title="All 2 branches covered.">                || result.getColumns() != 1) {</span>
<span class="fc" id="L2934">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L2937">        result.setElementAtIndex(0, mBiasFx);</span>
<span class="fc" id="L2938">        result.setElementAtIndex(1, mBiasFy);</span>
<span class="fc" id="L2939">        result.setElementAtIndex(2, mBiasFz);</span>
<span class="fc" id="L2940">    }</span>

    /**
     * Gets estimated bias of gyroscope sensed angular rates
     * expressed in radians per second (rad/s) as a 3x1 matrix column vector.
     *
     * @return estimated bias of gyroscope sensed angular rates.
     */
    public Matrix getGyroBias() {
        Matrix result;
        try {
<span class="fc" id="L2951">            result = new Matrix(BodyKinematics.COMPONENTS, 1);</span>
<span class="fc" id="L2952">            getGyroBias(result);</span>
<span class="nc" id="L2953">        } catch (final WrongSizeException ignore) {</span>
            // never happens
<span class="nc" id="L2955">            result = null;</span>
<span class="fc" id="L2956">        }</span>

<span class="fc" id="L2958">        return result;</span>
    }

    /**
     * Gets estimated bias of gyroscope sensed angular rates
     * expressed in radians per second (rad/s) as a 3x1 matrix column vector.
     *
     * @param result instance where data will be copied to. Must be 3x1.
     * @throws IllegalArgumentException if provided result matrix is not 3x1.
     */
    public void getGyroBias(final Matrix result) {
<span class="fc bfc" id="L2969" title="All 2 branches covered.">        if (result.getRows() != BodyKinematics.COMPONENTS</span>
<span class="fc bfc" id="L2970" title="All 2 branches covered.">                || result.getColumns() != 1) {</span>
<span class="fc" id="L2971">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L2974">        result.setElementAtIndex(0, mBiasAngularRateX);</span>
<span class="fc" id="L2975">        result.setElementAtIndex(1, mBiasAngularRateY);</span>
<span class="fc" id="L2976">        result.setElementAtIndex(2, mBiasAngularRateZ);</span>
<span class="fc" id="L2977">    }</span>

    /**
     * Gets number of samples that have been processed so far.
     *
     * @return number of samples that have been processed so far.
     */
    public int getNumberOfProcessedSamples() {
<span class="fc" id="L2985">        return mNumberOfProcessedSamples;</span>
    }

    /**
     * Indicates whether estimator is currently running or not.
     *
     * @return true if estimator is running, false otherwise.
     */
    public boolean isRunning() {
<span class="fc" id="L2994">        return mRunning;</span>
    }

    /**
     * Gets theoretically expected body kinematics for provided body position and
     * orientation, and provided time interval, assuming that body remains at the
     * same position (zero velocity).
     * When body remains static, sensed specific force and angular rates will remain
     * constant due to gravity and Earth rotation.
     *
     * @return expected body kinematics.
     */
    public BodyKinematics getExpectedKinematics() {
<span class="fc" id="L3007">        return new BodyKinematics(mExpectedKinematics);</span>
    }

    /**
     * Gets theoretically expected body kinematics for provided body position and
     * orientation, and provided time interval, assuming that body remains at the
     * same position (zero velocity).
     * When body remains static, sensed specific force and angular rates will remain
     * constant due to gravity and Earth rotation.
     *
     * @param result instance where expected body kinematics will be stored.
     */
    public void getExpectedKinematics(final BodyKinematics result) {
<span class="fc" id="L3020">        mExpectedKinematics.copyTo(result);</span>
<span class="fc" id="L3021">    }</span>

    /**
     * Adds a sample of body kinematics (accelerometer + gyroscope readings) obtained
     * from an IMU.
     *
     * @param kinematics kinematics instance to be added and processed.
     * @throws LockedException if estimator is currently running.
     */
    public void addBodyKinematics(final BodyKinematics kinematics)
            throws LockedException {

<span class="fc bfc" id="L3033" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L3034">            throw new LockedException();</span>
        }

<span class="fc" id="L3037">        mRunning = true;</span>

<span class="pc bpc" id="L3039" title="1 of 4 branches missed.">        if (mLastBodyKinematics == null &amp;&amp; mListener != null) {</span>
<span class="fc" id="L3040">            mListener.onStart(this);</span>
        }

<span class="fc" id="L3043">        final double fx = kinematics.getFx();</span>
<span class="fc" id="L3044">        final double fy = kinematics.getFy();</span>
<span class="fc" id="L3045">        final double fz = kinematics.getFz();</span>
<span class="fc" id="L3046">        final double angularRateX = kinematics.getAngularRateX();</span>
<span class="fc" id="L3047">        final double angularRateY = kinematics.getAngularRateY();</span>
<span class="fc" id="L3048">        final double angularRateZ = kinematics.getAngularRateZ();</span>

<span class="fc" id="L3050">        final double expectedFx = mExpectedKinematics.getFx();</span>
<span class="fc" id="L3051">        final double expectedFy = mExpectedKinematics.getFy();</span>
<span class="fc" id="L3052">        final double expectedFz = mExpectedKinematics.getFz();</span>
<span class="fc" id="L3053">        final double expectedAngularRateX = mExpectedKinematics.getAngularRateX();</span>
<span class="fc" id="L3054">        final double expectedAngularRateY = mExpectedKinematics.getAngularRateY();</span>
<span class="fc" id="L3055">        final double expectedAngularRateZ = mExpectedKinematics.getAngularRateZ();</span>

<span class="fc" id="L3057">        final double diffFx = fx - expectedFx;</span>
<span class="fc" id="L3058">        final double diffFy = fy - expectedFy;</span>
<span class="fc" id="L3059">        final double diffFz = fz - expectedFz;</span>
<span class="fc" id="L3060">        final double diffAngularRateX = angularRateX - expectedAngularRateX;</span>
<span class="fc" id="L3061">        final double diffAngularRateY = angularRateY - expectedAngularRateY;</span>
<span class="fc" id="L3062">        final double diffAngularRateZ = angularRateZ - expectedAngularRateZ;</span>

        // compute biases
<span class="fc" id="L3065">        final double tmp = (double) mNumberOfProcessedSamples</span>
                / (double) mNumberOfProcessedSamplesPlusOne;
<span class="fc" id="L3067">        mBiasFx = mBiasFx * tmp + diffFx / (double) mNumberOfProcessedSamplesPlusOne;</span>
<span class="fc" id="L3068">        mBiasFy = mBiasFy * tmp + diffFy / (double) mNumberOfProcessedSamplesPlusOne;</span>
<span class="fc" id="L3069">        mBiasFz = mBiasFz * tmp + diffFz / (double) mNumberOfProcessedSamplesPlusOne;</span>

<span class="fc" id="L3071">        mBiasAngularRateX = mBiasAngularRateX * tmp</span>
                + diffAngularRateX / (double) mNumberOfProcessedSamplesPlusOne;
<span class="fc" id="L3073">        mBiasAngularRateY = mBiasAngularRateY * tmp</span>
                + diffAngularRateY / (double) mNumberOfProcessedSamplesPlusOne;
<span class="fc" id="L3075">        mBiasAngularRateZ = mBiasAngularRateZ * tmp</span>
                + diffAngularRateZ / (double) mNumberOfProcessedSamplesPlusOne;

        // compute variances
<span class="fc" id="L3079">        final double diffBiasFx = diffFx - mBiasFx;</span>
<span class="fc" id="L3080">        final double diffBiasFy = diffFy - mBiasFy;</span>
<span class="fc" id="L3081">        final double diffBiasFz = diffFz - mBiasFz;</span>
<span class="fc" id="L3082">        final double diffBiasAngularRateX = diffAngularRateX - mBiasAngularRateX;</span>
<span class="fc" id="L3083">        final double diffBiasAngularRateY = diffAngularRateY - mBiasAngularRateY;</span>
<span class="fc" id="L3084">        final double diffBiasAngularRateZ = diffAngularRateZ - mBiasAngularRateZ;</span>

<span class="fc" id="L3086">        final double diffBiasFx2 = diffBiasFx * diffBiasFx;</span>
<span class="fc" id="L3087">        final double diffBiasFy2 = diffBiasFy * diffBiasFy;</span>
<span class="fc" id="L3088">        final double diffBiasFz2 = diffBiasFz * diffBiasFz;</span>
<span class="fc" id="L3089">        final double diffBiasAngularRateX2 =</span>
                diffBiasAngularRateX * diffBiasAngularRateX;
<span class="fc" id="L3091">        final double diffBiasAngularRateY2 =</span>
                diffBiasAngularRateY * diffBiasAngularRateY;
<span class="fc" id="L3093">        final double diffBiasAngularRateZ2 =</span>
                diffBiasAngularRateZ * diffBiasAngularRateZ;

<span class="fc" id="L3096">        mVarianceFx = mVarianceFx * tmp</span>
                + diffBiasFx2 / (double) mNumberOfProcessedSamplesPlusOne;
<span class="fc" id="L3098">        mVarianceFy = mVarianceFy * tmp</span>
                + diffBiasFy2 / (double) mNumberOfProcessedSamplesPlusOne;
<span class="fc" id="L3100">        mVarianceFz = mVarianceFz * tmp</span>
                + diffBiasFz2 / (double) mNumberOfProcessedSamplesPlusOne;

<span class="fc" id="L3103">        mVarianceAngularRateX = mVarianceAngularRateX * tmp</span>
                + diffBiasAngularRateX2 / (double) mNumberOfProcessedSamplesPlusOne;
<span class="fc" id="L3105">        mVarianceAngularRateY = mVarianceAngularRateY * tmp</span>
                + diffBiasAngularRateY2 / (double) mNumberOfProcessedSamplesPlusOne;
<span class="fc" id="L3107">        mVarianceAngularRateZ = mVarianceAngularRateZ * tmp</span>
                + diffBiasAngularRateZ2 / (double) mNumberOfProcessedSamplesPlusOne;

<span class="fc" id="L3110">        mLastBodyKinematics = kinematics;</span>

<span class="fc" id="L3112">        mNumberOfProcessedSamples++;</span>
<span class="fc" id="L3113">        mNumberOfProcessedSamplesPlusOne++;</span>

<span class="pc bpc" id="L3115" title="1 of 2 branches missed.">        if (mListener != null) {</span>
<span class="fc" id="L3116">            mListener.onBodyKinematicsAdded(this);</span>
        }

<span class="fc" id="L3119">        mRunning = false;</span>
<span class="fc" id="L3120">    }</span>

    /**
     * Resets current estimator.
     *
     * @return true if estimator was successfully reset, false if no reset was needed.
     * @throws LockedException if estimator is currently running.
     */
    public boolean reset() throws LockedException {
<span class="fc bfc" id="L3129" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L3130">            throw new LockedException();</span>
        }

<span class="pc bpc" id="L3133" title="1 of 2 branches missed.">        if (mNumberOfProcessedSamples == 0) {</span>
<span class="nc" id="L3134">            return false;</span>
        }

<span class="fc" id="L3137">        mRunning = true;</span>
<span class="fc" id="L3138">        mLastBodyKinematics = null;</span>
<span class="fc" id="L3139">        mBiasFx = 0.0;</span>
<span class="fc" id="L3140">        mBiasFy = 0.0;</span>
<span class="fc" id="L3141">        mBiasFz = 0.0;</span>
<span class="fc" id="L3142">        mBiasAngularRateX = 0.0;</span>
<span class="fc" id="L3143">        mBiasAngularRateY = 0.0;</span>
<span class="fc" id="L3144">        mBiasAngularRateZ = 0.0;</span>
<span class="fc" id="L3145">        mVarianceFx = 0.0;</span>
<span class="fc" id="L3146">        mVarianceFy = 0.0;</span>
<span class="fc" id="L3147">        mVarianceFz = 0.0;</span>
<span class="fc" id="L3148">        mVarianceAngularRateX = 0.0;</span>
<span class="fc" id="L3149">        mVarianceAngularRateY = 0.0;</span>
<span class="fc" id="L3150">        mVarianceAngularRateZ = 0.0;</span>
<span class="fc" id="L3151">        mNumberOfProcessedSamples = 0;</span>
<span class="fc" id="L3152">        mNumberOfProcessedSamplesPlusOne = 1;</span>

<span class="pc bpc" id="L3154" title="1 of 2 branches missed.">        if (mListener != null) {</span>
<span class="fc" id="L3155">            mListener.onReset(this);</span>
        }

<span class="fc" id="L3158">        mRunning = false;</span>

<span class="fc" id="L3160">        return true;</span>
    }

    /**
     * Converts provided time instance to seconds.
     *
     * @param time instance to be converted.
     * @return obtained conversion in seconds.
     */
    private static double convertTime(final Time time) {
<span class="fc" id="L3170">        return TimeConverter.convert(time.getValue().doubleValue(),</span>
<span class="fc" id="L3171">                time.getUnit(), TimeUnit.SECOND);</span>
    }

    /**
     * Rebuilds expected theoretical kinematics for provided body position
     * and orientation and provided time interval, assuming that body
     * remains at the same position (zero velocity).
     * When body remains static, sensed specific force and angular rates will remain
     * constant due to gravity and Earth rotation.
     */
    private void rebuildExpectedKinematics() {
<span class="pc bpc" id="L3182" title="1 of 2 branches missed.">        if (mFrame == null) {</span>
<span class="nc" id="L3183">            return;</span>
        }
<span class="fc bfc" id="L3185" title="All 2 branches covered.">        if (mExpectedKinematics == null) {</span>
<span class="fc" id="L3186">            mExpectedKinematics = new BodyKinematics();</span>
        }

<span class="fc" id="L3189">        final CoordinateTransformation ecefC = getEcefC();</span>
<span class="fc" id="L3190">        final double x = mFrame.getX();</span>
<span class="fc" id="L3191">        final double y = mFrame.getY();</span>
<span class="fc" id="L3192">        final double z = mFrame.getZ();</span>
<span class="fc" id="L3193">        ECEFKinematicsEstimator.estimateKinematics(mTimeInterval, ecefC, ecefC,</span>
                0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
                x, y, z, mExpectedKinematics);
<span class="fc" id="L3196">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>