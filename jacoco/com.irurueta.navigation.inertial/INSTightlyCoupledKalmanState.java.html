<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>INSTightlyCoupledKalmanState.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.irurueta:irurueta-navigation</a> &gt; <a href="index.source.html" class="el_package">com.irurueta.navigation.inertial</a> &gt; <span class="el_source">INSTightlyCoupledKalmanState.java</span></div><h1>INSTightlyCoupledKalmanState.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2019 Alberto Irurueta Carro (alberto@irurueta.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.irurueta.navigation.inertial;

import com.irurueta.algebra.Matrix;
import com.irurueta.geometry.InhomogeneousPoint3D;
import com.irurueta.geometry.InvalidRotationMatrixException;
import com.irurueta.geometry.Point3D;
import com.irurueta.navigation.frames.CoordinateTransformation;
import com.irurueta.navigation.frames.ECEFFrame;
import com.irurueta.navigation.frames.FrameType;
import com.irurueta.navigation.frames.InvalidSourceAndDestinationFrameTypeException;
import com.irurueta.navigation.gnss.ECEFPositionAndVelocity;
import com.irurueta.navigation.gnss.GNSSEstimation;
import com.irurueta.units.*;

import java.io.Serializable;
import java.util.Objects;

/**
 * Kalman filter state for tightly coupled INS/GNSS extended Kalman filter.
 */
public class INSTightlyCoupledKalmanState implements Serializable, Cloneable {

    /**
     * Number of parameters of the Kalman filter.
     */
    public static final int NUM_PARAMS = 17;

    /**
     * Estimated body to ECEF coordinate transformation matrix.
     */
    private Matrix mBodyToEcefCoordinateTransformationMatrix;

    /**
     * Estimated ECEF user velocity resolved around x axis and expressed in meters per second (m/s).
     */
    private double mVx;

    /**
     * Estimated ECEF user velocity resolved around y axis and expressed in meters per second (m/s).
     */
    private double mVy;

    /**
     * Estimated ECEF user velocity resolved around z axis and expressed in meters per second (m/s).
     */
    private double mVz;

    /**
     * X coordinate of estimated ECEF user position expressed in meters (m).
     */
    private double mX;

    /**
     * Y coordinate of estimated ECEF user position expressed in meters (m).
     */
    private double mY;

    /**
     * Z coordinate of estimated ECEF user position expressed in meters (m).
     */
    private double mZ;

    /**
     * Estimated accelerometer bias resolved around x axis and expressed in
     * meters per squared second (m/s^2).
     */
    private double mAccelerationBiasX;

    /**
     * Estimated accelerometer bias resolved around y axis and expressed in
     * meters per squared second (m/s^2).
     */
    private double mAccelerationBiasY;

    /**
     * Estimated accelerometer bias resolved around z axis and expressed in
     * meters per squared second (m/s^2).
     */
    private double mAccelerationBiasZ;

    /**
     * Estimated gyroscope bias resolved around x axis and expressed in
     * radians per second (rad/s).
     */
    private double mGyroBiasX;

    /**
     * Estimated gyroscope bias resolved around y axis and expressed in
     * radians per second (rad/s).
     */
    private double mGyroBiasY;

    /**
     * Estimated gyroscope bias resolved around z axis and expressed in
     * radians per second (rad/s).
     */
    private double mGyroBiasZ;

    /**
     * Estimated receiver clock offset expressed in meters (m).
     */
    private double mReceiverClockOffset;

    /**
     * Estimated receiver clock drift expressed in meters per second (m/s).
     */
    private double mReceiverClockDrift;

    /**
     * Estimated Kalman filter error covariance matrix.
     * Notice that covariance is expressed in terms of ECEF coordinates.
     * If accuracy of position, attitude or velocity needs to be expressed in terms
     * of NED coordinates, their respective submatrices of this covariance matrix
     * must be rotated, taking into account the Jacobian of the matrix transformation
     * relating both coordinates, the covariance can be expressed following the law
     * of propagation of uncertainties (https://en.wikipedia.org/wiki/Propagation_of_uncertainty)
     * as: cov(f(x)) = J*cov(x)*J'.
     */
    private Matrix mCovariance;

    /**
     * Constructor.
     */
<span class="fc" id="L139">    public INSTightlyCoupledKalmanState() {</span>
<span class="fc" id="L140">    }</span>

    /**
     * Constructor.
     *
     * @param bodyToEcefCoordinateTransformationMatrix estimated body to ECEF coordinate transformation matrix.
     * @param vx                                       estimated ECEF user velocity resolved around x axis and
     *                                                 expressed in meters per second (m/s).
     * @param vy                                       estimated ECEF user velocity resolved around y axis and
     *                                                 expressed in meters per second (m/s).
     * @param vz                                       estimated ECEF user velocity resolved around z axis and
     *                                                 expressed in meters per second (m/s).
     * @param x                                        x coordinate of estimated ECEF user position expressed
     *                                                 in meters (m).
     * @param y                                        y coordinate of estimated ECEF user position expressed
     *                                                 in meters (m).
     * @param z                                        z coordinate of estimated ECEF user position expressed
     *                                                 in meters (m).
     * @param accelerationBiasX                        estimated accelerometer bias resolved around x axis and
     *                                                 expressed in meters per squared second (m/s^2).
     * @param accelerationBiasY                        estimated accelerometer bias resolved around y axis and
     *                                                 expressed in meters per squared second (m/s^2).
     * @param accelerationBiasZ                        estimated accelerometer bias resolved around z axis and
     *                                                 expressed in meters per squared second (m/s^2).
     * @param gyroBiasX                                estimated gyroscope bias resolved around x axis and
     *                                                 expressed in radians per second (rad/s).
     * @param gyroBiasY                                estimated gyroscope bias resolved around y axis and
     *                                                 expressed in radians per second (rad/s).
     * @param gyroBiasZ                                estimated gyroscope bias resolved around z axis and
     *                                                 expressed in radians per second (rad/s).
     * @param receiverClockOffset                      estimated receiver clock offset expressed in meters (m).
     * @param receiverClockDrift                       estimated receiver clock drift expressed in meters per
     *                                                 second (m/s).
     * @param covariance                               estimated Kalman filter error covariance matrix.
     * @throws IllegalArgumentException if provided body to ECEF coordinate transformation matrix is not 3x3
     *                                  or if provided covariance matrix is not 17x17.
     */
    public INSTightlyCoupledKalmanState(
            final Matrix bodyToEcefCoordinateTransformationMatrix,
            final double vx, final double vy, final double vz,
            final double x, final double y, final double z,
            final double accelerationBiasX,
            final double accelerationBiasY,
            final double accelerationBiasZ,
            final double gyroBiasX,
            final double gyroBiasY,
            final double gyroBiasZ,
            final double receiverClockOffset,
            final double receiverClockDrift,
<span class="fc" id="L189">            final Matrix covariance) {</span>
<span class="fc" id="L190">        setBodyToEcefCoordinateTransformationMatrix(bodyToEcefCoordinateTransformationMatrix);</span>
<span class="fc" id="L191">        setVelocityCoordinates(vx, vy, vz);</span>
<span class="fc" id="L192">        setPositionCoordinates(x, y, z);</span>
<span class="fc" id="L193">        setAccelerationBiasCoordinates(accelerationBiasX, accelerationBiasY, accelerationBiasZ);</span>
<span class="fc" id="L194">        setGyroBiasCoordinates(gyroBiasX, gyroBiasY, gyroBiasZ);</span>
<span class="fc" id="L195">        setReceiverClockOffset(receiverClockOffset);</span>
<span class="fc" id="L196">        setReceiverClockDrift(receiverClockDrift);</span>
<span class="fc" id="L197">        setCovariance(covariance);</span>
<span class="fc" id="L198">    }</span>

    /**
     * Constructor.
     *
     * @param c                   body to ECEF coordinate transformation.
     * @param vx                  estimated ECEF user velocity resolved around x axis.
     * @param vy                  estimated ECEF user velocity resolved around y axis.
     * @param vz                  estimated ECEF user velocity resolved around z axis.
     * @param x                   x coordinate of estimated ECEF user position.
     * @param y                   y coordinate of estimated ECEF user position.
     * @param z                   z coordinate of estimated ECEF user position.
     * @param accelerationBiasX   estimated accelerometer bias resolved around x axis and
     *                            expressed in meters per squared second (m/s^2).
     * @param accelerationBiasY   estimated accelerometer bias resolved around y axis and
     *                            expressed in meters per squared second (m/s^2).
     * @param accelerationBiasZ   estimated accelerometer bias resolved around z axis and
     *                            expressed in meters per squared second (m/s^2).
     * @param gyroBiasX           estimated gyroscope bias resolved around x axis and
     *                            expressed in radians per second (rad/s).
     * @param gyroBiasY           estimated gyroscope bias resolved around y axis and
     *                            expressed in radians per second (rad/s).
     * @param gyroBiasZ           estimated gyroscope bias resolved around z axis and
     *                            expressed in radians per second (rad/s).
     * @param receiverClockOffset estimated receiver clock offset expressed in meters (m).
     * @param receiverClockDrift  estimated receiver clock drift expressed in meters per
     *                            second (m/s).
     * @param covariance          estimated Kalman filter error covariance matrix.
     * @throws IllegalArgumentException if provided covariance matrix is not 17x17.
     */
    public INSTightlyCoupledKalmanState(
            final CoordinateTransformation c,
            final Speed vx, final Speed vy, final Speed vz,
            final Distance x, final Distance y, final Distance z,
            final double accelerationBiasX,
            final double accelerationBiasY,
            final double accelerationBiasZ,
            final double gyroBiasX,
            final double gyroBiasY,
            final double gyroBiasZ,
            final double receiverClockOffset,
            final double receiverClockDrift,
<span class="fc" id="L240">            final Matrix covariance) {</span>
<span class="fc" id="L241">        setC(c);</span>
<span class="fc" id="L242">        setVelocityCoordinates(vx, vy, vz);</span>
<span class="fc" id="L243">        setPositionCoordinates(x, y, z);</span>
<span class="fc" id="L244">        setAccelerationBiasCoordinates(accelerationBiasX, accelerationBiasY, accelerationBiasZ);</span>
<span class="fc" id="L245">        setGyroBiasCoordinates(gyroBiasX, gyroBiasY, gyroBiasZ);</span>
<span class="fc" id="L246">        setReceiverClockOffset(receiverClockOffset);</span>
<span class="fc" id="L247">        setReceiverClockDrift(receiverClockDrift);</span>
<span class="fc" id="L248">        setCovariance(covariance);</span>
<span class="fc" id="L249">    }</span>

    /**
     * Constructor.
     *
     * @param c                   body to ECEF coordinate transformation.
     * @param vx                  estimated ECEF user velocity resolved around x axis.
     * @param vy                  estimated ECEF user velocity resolved around y axis.
     * @param vz                  estimated ECEF user velocity resolved around z axis.
     * @param position            estimated ECEF user position.
     * @param accelerationBiasX   estimated accelerometer bias resolved around x axis and
     *                            expressed in meters per squared second (m/s^2).
     * @param accelerationBiasY   estimated accelerometer bias resolved around y axis and
     *                            expressed in meters per squared second (m/s^2).
     * @param accelerationBiasZ   estimated accelerometer bias resolved around z axis and
     *                            expressed in meters per squared second (m/s^2).
     * @param gyroBiasX           estimated gyroscope bias resolved around x axis and
     *                            expressed in radians per second (rad/s).
     * @param gyroBiasY           estimated gyroscope bias resolved around y axis and
     *                            expressed in radians per second (rad/s).
     * @param gyroBiasZ           estimated gyroscope bias resolved around z axis and
     *                            expressed in radians per second (rad/s).
     * @param receiverClockOffset estimated receiver clock offset expressed in meters (m).
     * @param receiverClockDrift  estimated receiver clock drift expressed in meters per
     *                            second (m/s).
     * @param covariance          estimated Kalman filter error covariance matrix.
     * @throws IllegalArgumentException if provided covariance matrix is not 17x17.
     */
    public INSTightlyCoupledKalmanState(
            final CoordinateTransformation c,
            final Speed vx, final Speed vy, final Speed vz,
            final Point3D position,
            final double accelerationBiasX,
            final double accelerationBiasY,
            final double accelerationBiasZ,
            final double gyroBiasX,
            final double gyroBiasY,
            final double gyroBiasZ,
            final double receiverClockOffset,
            final double receiverClockDrift,
<span class="fc" id="L289">            final Matrix covariance) {</span>
<span class="fc" id="L290">        setC(c);</span>
<span class="fc" id="L291">        setVelocityCoordinates(vx, vy, vz);</span>
<span class="fc" id="L292">        setPosition(position);</span>
<span class="fc" id="L293">        setAccelerationBiasCoordinates(accelerationBiasX, accelerationBiasY, accelerationBiasZ);</span>
<span class="fc" id="L294">        setGyroBiasCoordinates(gyroBiasX, gyroBiasY, gyroBiasZ);</span>
<span class="fc" id="L295">        setReceiverClockOffset(receiverClockOffset);</span>
<span class="fc" id="L296">        setReceiverClockDrift(receiverClockDrift);</span>
<span class="fc" id="L297">        setCovariance(covariance);</span>
<span class="fc" id="L298">    }</span>

    /**
     * Constructor.
     *
     * @param c                   body to ECEF coordinate transformation.
     * @param velocity            estimated ECEF user velocity.
     * @param position            estimated ECEF user position.
     * @param accelerationBiasX   estimated accelerometer bias resolved around x axis and
     *                            expressed in meters per squared second (m/s^2).
     * @param accelerationBiasY   estimated accelerometer bias resolved around y axis and
     *                            expressed in meters per squared second (m/s^2).
     * @param accelerationBiasZ   estimated accelerometer bias resolved around z axis and
     *                            expressed in meters per squared second (m/s^2).
     * @param gyroBiasX           estimated gyroscope bias resolved around x axis and
     *                            expressed in radians per second (rad/s).
     * @param gyroBiasY           estimated gyroscope bias resolved around y axis and
     *                            expressed in radians per second (rad/s).
     * @param gyroBiasZ           estimated gyroscope bias resolved around z axis and
     *                            expressed in radians per second (rad/s).
     * @param receiverClockOffset estimated receiver clock offset expressed in meters (m).
     * @param receiverClockDrift  estimated receiver clock drift expressed in meters per
     *                            second (m/s).
     * @param covariance          estimated Kalman filter error covariance matrix.
     * @throws IllegalArgumentException if provided covariance matrix is not 17x17.
     */
    public INSTightlyCoupledKalmanState(
            final CoordinateTransformation c,
            final ECEFVelocity velocity,
            final ECEFPosition position,
            final double accelerationBiasX,
            final double accelerationBiasY,
            final double accelerationBiasZ,
            final double gyroBiasX,
            final double gyroBiasY,
            final double gyroBiasZ,
            final double receiverClockOffset,
            final double receiverClockDrift,
<span class="fc" id="L336">            final Matrix covariance) {</span>
<span class="fc" id="L337">        setC(c);</span>
<span class="fc" id="L338">        setEcefVelocity(velocity);</span>
<span class="fc" id="L339">        setEcefPosition(position);</span>
<span class="fc" id="L340">        setAccelerationBiasCoordinates(accelerationBiasX, accelerationBiasY, accelerationBiasZ);</span>
<span class="fc" id="L341">        setGyroBiasCoordinates(gyroBiasX, gyroBiasY, gyroBiasZ);</span>
<span class="fc" id="L342">        setReceiverClockOffset(receiverClockOffset);</span>
<span class="fc" id="L343">        setReceiverClockDrift(receiverClockDrift);</span>
<span class="fc" id="L344">        setCovariance(covariance);</span>
<span class="fc" id="L345">    }</span>

    /**
     * Constructor.
     *
     * @param c                   body to ECEF coordinate transformation.
     * @param positionAndVelocity estimated ECEF user velocity and position.
     * @param accelerationBiasX   estimated accelerometer bias resolved around x axis and
     *                            expressed in meters per squared second (m/s^2).
     * @param accelerationBiasY   estimated accelerometer bias resolved around y axis and
     *                            expressed in meters per squared second (m/s^2).
     * @param accelerationBiasZ   estimated accelerometer bias resolved around z axis and
     *                            expressed in meters per squared second (m/s^2).
     * @param gyroBiasX           estimated gyroscope bias resolved around x axis and
     *                            expressed in radians per second (rad/s).
     * @param gyroBiasY           estimated gyroscope bias resolved around y axis and
     *                            expressed in radians per second (rad/s).
     * @param gyroBiasZ           estimated gyroscope bias resolved around z axis and
     *                            expressed in radians per second (rad/s).
     * @param receiverClockOffset estimated receiver clock offset expressed in meters (m).
     * @param receiverClockDrift  estimated receiver clock drift expressed in meters per
     *                            second (m/s).
     * @param covariance          estimated Kalman filter error covariance matrix.
     * @throws IllegalArgumentException if provided covariance matrix is not 17x17.
     */
    public INSTightlyCoupledKalmanState(
            final CoordinateTransformation c,
            final ECEFPositionAndVelocity positionAndVelocity,
            final double accelerationBiasX,
            final double accelerationBiasY,
            final double accelerationBiasZ,
            final double gyroBiasX,
            final double gyroBiasY,
            final double gyroBiasZ,
            final double receiverClockOffset,
            final double receiverClockDrift,
<span class="fc" id="L381">            final Matrix covariance) {</span>
<span class="fc" id="L382">        setC(c);</span>
<span class="fc" id="L383">        setPositionAndVelocity(positionAndVelocity);</span>
<span class="fc" id="L384">        setAccelerationBiasCoordinates(accelerationBiasX, accelerationBiasY, accelerationBiasZ);</span>
<span class="fc" id="L385">        setGyroBiasCoordinates(gyroBiasX, gyroBiasY, gyroBiasZ);</span>
<span class="fc" id="L386">        setReceiverClockOffset(receiverClockOffset);</span>
<span class="fc" id="L387">        setReceiverClockDrift(receiverClockDrift);</span>
<span class="fc" id="L388">        setCovariance(covariance);</span>
<span class="fc" id="L389">    }</span>

    /**
     * Constructor.
     *
     * @param frame               estimated user ECEF frame.
     * @param accelerationBiasX   estimated accelerometer bias resolved around x axis and
     *                            expressed in meters per squared second (m/s^2).
     * @param accelerationBiasY   estimated accelerometer bias resolved around y axis and
     *                            expressed in meters per squared second (m/s^2).
     * @param accelerationBiasZ   estimated accelerometer bias resolved around z axis and
     *                            expressed in meters per squared second (m/s^2).
     * @param gyroBiasX           estimated gyroscope bias resolved around x axis and
     *                            expressed in radians per second (rad/s).
     * @param gyroBiasY           estimated gyroscope bias resolved around y axis and
     *                            expressed in radians per second (rad/s).
     * @param gyroBiasZ           estimated gyroscope bias resolved around z axis and
     *                            expressed in radians per second (rad/s).
     * @param receiverClockOffset estimated receiver clock offset expressed in meters (m).
     * @param receiverClockDrift  estimated receiver clock drift expressed in meters per
     *                            second (m/s).
     * @param covariance          estimated Kalman filter error covariance .
     * @throws IllegalArgumentException if provided covariance matrix is not 17x17.
     */
    public INSTightlyCoupledKalmanState(
            final ECEFFrame frame,
            final double accelerationBiasX,
            final double accelerationBiasY,
            final double accelerationBiasZ,
            final double gyroBiasX,
            final double gyroBiasY,
            final double gyroBiasZ,
            final double receiverClockOffset,
            final double receiverClockDrift,
<span class="fc" id="L423">            final Matrix covariance) {</span>
<span class="fc" id="L424">        setFrame(frame);</span>
<span class="fc" id="L425">        setAccelerationBiasCoordinates(accelerationBiasX, accelerationBiasY, accelerationBiasZ);</span>
<span class="fc" id="L426">        setGyroBiasCoordinates(gyroBiasX, gyroBiasY, gyroBiasZ);</span>
<span class="fc" id="L427">        setReceiverClockOffset(receiverClockOffset);</span>
<span class="fc" id="L428">        setReceiverClockDrift(receiverClockDrift);</span>
<span class="fc" id="L429">        setCovariance(covariance);</span>
<span class="fc" id="L430">    }</span>

    /**
     * Constructor.
     *
     * @param c                   body to ECEF coordinate transformation.
     * @param vx                  estimated ECEF user velocity resolved around x axis.
     * @param vy                  estimated ECEF user velocity resolved around y axis.
     * @param vz                  estimated ECEF user velocity resolved around z axis.
     * @param x                   x coordinate of estimated ECEF user position.
     * @param y                   y coordinate of estimated ECEF user position.
     * @param z                   z coordinate of estimated ECEF user position.
     * @param accelerationBiasX   estimated accelerometer bias resolved around x axis.
     * @param accelerationBiasY   estimated accelerometer bias resolved around y axis.
     * @param accelerationBiasZ   estimated accelerometer bias resolved around z axis.
     * @param gyroBiasX           estimated gyroscope bias resolved around x axis.
     * @param gyroBiasY           estimated gyroscope bias resolved around y axis.
     * @param gyroBiasZ           estimated gyroscope bias resolved around z axis.
     * @param receiverClockOffset estimated receiver clock offset.
     * @param receiverClockDrift  estimated receiver clock drift.
     * @param covariance          estimated Kalman filter error covariance matrix.
     * @throws IllegalArgumentException if provided covariance matrix is not 17x17.
     */
    public INSTightlyCoupledKalmanState(
            final CoordinateTransformation c,
            final Speed vx, final Speed vy, final Speed vz,
            final Distance x, final Distance y, final Distance z,
            final Acceleration accelerationBiasX,
            final Acceleration accelerationBiasY,
            final Acceleration accelerationBiasZ,
            final AngularSpeed gyroBiasX,
            final AngularSpeed gyroBiasY,
            final AngularSpeed gyroBiasZ,
            final Distance receiverClockOffset,
            final Speed receiverClockDrift,
<span class="fc" id="L465">            final Matrix covariance) {</span>
<span class="fc" id="L466">        setC(c);</span>
<span class="fc" id="L467">        setVelocityCoordinates(vx, vy, vz);</span>
<span class="fc" id="L468">        setPositionCoordinates(x, y, z);</span>
<span class="fc" id="L469">        setAccelerationBiasCoordinates(accelerationBiasX, accelerationBiasY, accelerationBiasZ);</span>
<span class="fc" id="L470">        setGyroBiasCoordinates(gyroBiasX, gyroBiasY, gyroBiasZ);</span>
<span class="fc" id="L471">        setReceiverClockOffset(receiverClockOffset);</span>
<span class="fc" id="L472">        setReceiverClockDrift(receiverClockDrift);</span>
<span class="fc" id="L473">        setCovariance(covariance);</span>
<span class="fc" id="L474">    }</span>

    /**
     * Constructor.
     *
     * @param c                   body to ECEF coordinate transformation.
     * @param vx                  estimated ECEF user velocity resolved around x axis.
     * @param vy                  estimated ECEF user velocity resolved around y axis.
     * @param vz                  estimated ECEF user velocity resolved around z axis.
     * @param position            estimated ECEF user position expressed in meters (m).
     * @param accelerationBiasX   estimated accelerometer bias resolved around x axis.
     * @param accelerationBiasY   estimated accelerometer bias resolved around y axis.
     * @param accelerationBiasZ   estimated accelerometer bias resolved around z axis.
     * @param gyroBiasX           estimated gyroscope bias resolved around x axis.
     * @param gyroBiasY           estimated gyroscope bias resolved around y axis.
     * @param gyroBiasZ           estimated gyroscope bias resolved around z axis.
     * @param receiverClockOffset estimated receiver clock offset.
     * @param receiverClockDrift  estimated receiver clock drift.
     * @param covariance          estimated Kalman filter error covariance matrix.
     * @throws IllegalArgumentException if provided covariance matrix is not 17x17.
     */
    public INSTightlyCoupledKalmanState(
            final CoordinateTransformation c,
            final Speed vx, final Speed vy, final Speed vz,
            final Point3D position,
            final Acceleration accelerationBiasX,
            final Acceleration accelerationBiasY,
            final Acceleration accelerationBiasZ,
            final AngularSpeed gyroBiasX,
            final AngularSpeed gyroBiasY,
            final AngularSpeed gyroBiasZ,
            final Distance receiverClockOffset,
            final Speed receiverClockDrift,
<span class="fc" id="L507">            final Matrix covariance) {</span>
<span class="fc" id="L508">        setC(c);</span>
<span class="fc" id="L509">        setVelocityCoordinates(vx, vy, vz);</span>
<span class="fc" id="L510">        setPosition(position);</span>
<span class="fc" id="L511">        setAccelerationBiasCoordinates(accelerationBiasX, accelerationBiasY, accelerationBiasZ);</span>
<span class="fc" id="L512">        setGyroBiasCoordinates(gyroBiasX, gyroBiasY, gyroBiasZ);</span>
<span class="fc" id="L513">        setReceiverClockOffset(receiverClockOffset);</span>
<span class="fc" id="L514">        setReceiverClockDrift(receiverClockDrift);</span>
<span class="fc" id="L515">        setCovariance(covariance);</span>
<span class="fc" id="L516">    }</span>

    /**
     * Constructor.
     *
     * @param c                   body to ECEF coordinate transformation.
     * @param velocity            estimated ECEF user velocity.
     * @param position            estimated ECEF user position.
     * @param accelerationBiasX   estimated accelerometer bias resolved around x axis.
     * @param accelerationBiasY   estimated accelerometer bias resolved around y axis.
     * @param accelerationBiasZ   estimated accelerometer bias resolved around z axis.
     * @param gyroBiasX           estimated gyroscope bias resolved around x axis.
     * @param gyroBiasY           estimated gyroscope bias resolved around y axis.
     * @param gyroBiasZ           estimated gyroscope bias resolved around z axis.
     * @param receiverClockOffset estimated receiver clock offset.
     * @param receiverClockDrift  estimated receiver clock drift.
     * @param covariance          estimated Kalman filter error covariance matrix.
     * @throws IllegalArgumentException if provided covariance matrix is not 17x17.
     */
    public INSTightlyCoupledKalmanState(
            final CoordinateTransformation c,
            final ECEFVelocity velocity,
            final ECEFPosition position,
            final Acceleration accelerationBiasX,
            final Acceleration accelerationBiasY,
            final Acceleration accelerationBiasZ,
            final AngularSpeed gyroBiasX,
            final AngularSpeed gyroBiasY,
            final AngularSpeed gyroBiasZ,
            final Distance receiverClockOffset,
            final Speed receiverClockDrift,
<span class="fc" id="L547">            final Matrix covariance) {</span>
<span class="fc" id="L548">        setC(c);</span>
<span class="fc" id="L549">        setEcefVelocity(velocity);</span>
<span class="fc" id="L550">        setEcefPosition(position);</span>
<span class="fc" id="L551">        setAccelerationBiasCoordinates(accelerationBiasX, accelerationBiasY, accelerationBiasZ);</span>
<span class="fc" id="L552">        setGyroBiasCoordinates(gyroBiasX, gyroBiasY, gyroBiasZ);</span>
<span class="fc" id="L553">        setReceiverClockOffset(receiverClockOffset);</span>
<span class="fc" id="L554">        setReceiverClockDrift(receiverClockDrift);</span>
<span class="fc" id="L555">        setCovariance(covariance);</span>
<span class="fc" id="L556">    }</span>

    /**
     * Constructor.
     *
     * @param c                   body to ECEF coordinate transformation.
     * @param positionAndVelocity estimated ECEF user position and velocity.
     * @param accelerationBiasX   estimated accelerometer bias resolved around x axis.
     * @param accelerationBiasY   estimated accelerometer bias resolved around y axis.
     * @param accelerationBiasZ   estimated accelerometer bias resolved around z axis.
     * @param gyroBiasX           estimated gyroscope bias resolved around x axis.
     * @param gyroBiasY           estimated gyroscope bias resolved around y axis.
     * @param gyroBiasZ           estimated gyroscope bias resolved around z axis.
     * @param receiverClockOffset estimated receiver clock offset.
     * @param receiverClockDrift  estimated receiver clock drift.
     * @param covariance          estimated Kalman filter error covariance matrix.
     * @throws IllegalArgumentException if provided covariance matrix is not 17x17.
     */
    public INSTightlyCoupledKalmanState(
            final CoordinateTransformation c,
            final ECEFPositionAndVelocity positionAndVelocity,
            final Acceleration accelerationBiasX,
            final Acceleration accelerationBiasY,
            final Acceleration accelerationBiasZ,
            final AngularSpeed gyroBiasX,
            final AngularSpeed gyroBiasY,
            final AngularSpeed gyroBiasZ,
            final Distance receiverClockOffset,
            final Speed receiverClockDrift,
<span class="fc" id="L585">            final Matrix covariance) {</span>
<span class="fc" id="L586">        setC(c);</span>
<span class="fc" id="L587">        setPositionAndVelocity(positionAndVelocity);</span>
<span class="fc" id="L588">        setAccelerationBiasCoordinates(accelerationBiasX, accelerationBiasY, accelerationBiasZ);</span>
<span class="fc" id="L589">        setGyroBiasCoordinates(gyroBiasX, gyroBiasY, gyroBiasZ);</span>
<span class="fc" id="L590">        setReceiverClockOffset(receiverClockOffset);</span>
<span class="fc" id="L591">        setReceiverClockDrift(receiverClockDrift);</span>
<span class="fc" id="L592">        setCovariance(covariance);</span>
<span class="fc" id="L593">    }</span>

    /**
     * Constructor.
     *
     * @param frame               estimated user ECEF frame.
     * @param accelerationBiasX   estimated accelerometer bias resolved around x axis.
     * @param accelerationBiasY   estimated accelerometer bias resolved around y axis.
     * @param accelerationBiasZ   estimated accelerometer bias resolved around z axis.
     * @param gyroBiasX           estimated gyroscope bias resolved around x axis.
     * @param gyroBiasY           estimated gyroscope bias resolved around y axis.
     * @param gyroBiasZ           estimated gyroscope bias resolved around z axis.
     * @param receiverClockOffset estimated receiver clock offset.
     * @param receiverClockDrift  estimated receiver clock drift.
     * @param covariance          estimated Kalman filter error covariance matrix.
     * @throws IllegalArgumentException if provided covariance matrix is not 17x17.
     */
    public INSTightlyCoupledKalmanState(
            final ECEFFrame frame,
            final Acceleration accelerationBiasX,
            final Acceleration accelerationBiasY,
            final Acceleration accelerationBiasZ,
            final AngularSpeed gyroBiasX,
            final AngularSpeed gyroBiasY,
            final AngularSpeed gyroBiasZ,
            final Distance receiverClockOffset,
            final Speed receiverClockDrift,
<span class="fc" id="L620">            final Matrix covariance) {</span>
<span class="fc" id="L621">        setFrame(frame);</span>
<span class="fc" id="L622">        setAccelerationBiasCoordinates(accelerationBiasX, accelerationBiasY, accelerationBiasZ);</span>
<span class="fc" id="L623">        setGyroBiasCoordinates(gyroBiasX, gyroBiasY, gyroBiasZ);</span>
<span class="fc" id="L624">        setReceiverClockOffset(receiverClockOffset);</span>
<span class="fc" id="L625">        setReceiverClockDrift(receiverClockDrift);</span>
<span class="fc" id="L626">        setCovariance(covariance);</span>
<span class="fc" id="L627">    }</span>

    /**
     * Constructor.
     *
     * @param bodyToEcefCoordinateTransformationMatrix estimated body to ECEF coordinate transformation matrix.
     * @param vx                                       estimated ECEF user velocity resolved around x axis.
     * @param vy                                       estimated ECEF user velocity resolved around y axis.
     * @param vz                                       estimated ECEF user velocity resolved around z axis.
     * @param x                                        x coordinate of estimated ECEF user position.
     * @param y                                        y coordinate of estimated ECEF user position.
     * @param z                                        z coordinate of estimated ECEF user position.
     * @param accelerationBiasX                        estimated accelerometer bias resolved around x axis and
     *                                                 expressed in meters per squared second (m/s^2).
     * @param accelerationBiasY                        estimated accelerometer bias resolved around y axis and
     *                                                 expressed in meters per squared second (m/s^2).
     * @param accelerationBiasZ                        estimated accelerometer bias resolved around z axis and
     *                                                 expressed in meters per squared second (m/s^2).
     * @param gyroBiasX                                estimated gyroscope bias resolved around x axis and
     *                                                 expressed in radians per second (rad/s).
     * @param gyroBiasY                                estimated gyroscope bias resolved around y axis and
     *                                                 expressed in radians per second (rad/s).
     * @param gyroBiasZ                                estimated gyroscope bias resolved around z axis and
     *                                                 expressed in radians per second (rad/s).
     * @param receiverClockOffset                      estimated receiver clock offset expressed in meters (m).
     * @param receiverClockDrift                       estimated receiver clock drift expressed in meters per
     *                                                 second (m/s).
     * @param covariance                               estimated Kalman filter error covariance matrix.
     * @throws IllegalArgumentException if provided body to ECEF coordinate transformation matrix is not 3x3
     *                                  or if provided covariance matrix is not 17x17.
     */
    public INSTightlyCoupledKalmanState(
            final Matrix bodyToEcefCoordinateTransformationMatrix,
            final Speed vx, final Speed vy, final Speed vz,
            final Distance x, final Distance y, final Distance z,
            final double accelerationBiasX,
            final double accelerationBiasY,
            final double accelerationBiasZ,
            final double gyroBiasX,
            final double gyroBiasY,
            final double gyroBiasZ,
            final double receiverClockOffset,
            final double receiverClockDrift,
<span class="fc" id="L670">            final Matrix covariance) {</span>
<span class="fc" id="L671">        setBodyToEcefCoordinateTransformationMatrix(bodyToEcefCoordinateTransformationMatrix);</span>
<span class="fc" id="L672">        setVelocityCoordinates(vx, vy, vz);</span>
<span class="fc" id="L673">        setPositionCoordinates(x, y, z);</span>
<span class="fc" id="L674">        setAccelerationBiasCoordinates(accelerationBiasX, accelerationBiasY, accelerationBiasZ);</span>
<span class="fc" id="L675">        setGyroBiasCoordinates(gyroBiasX, gyroBiasY, gyroBiasZ);</span>
<span class="fc" id="L676">        setReceiverClockOffset(receiverClockOffset);</span>
<span class="fc" id="L677">        setReceiverClockDrift(receiverClockDrift);</span>
<span class="fc" id="L678">        setCovariance(covariance);</span>
<span class="fc" id="L679">    }</span>

    /**
     * Constructor.
     *
     * @param bodyToEcefCoordinateTransformationMatrix estimated body to ECEF coordinate transformation matrix.
     * @param vx                                       estimated ECEF user velocity resolved around x axis.
     * @param vy                                       estimated ECEF user velocity resolved around y axis.
     * @param vz                                       estimated ECEF user velocity resolved around z axis.
     * @param position                                 estimated ECEF user position.
     * @param accelerationBiasX                        estimated accelerometer bias resolved around x axis and
     *                                                 expressed in meters per squared second (m/s^2).
     * @param accelerationBiasY                        estimated accelerometer bias resolved around y axis and
     *                                                 expressed in meters per squared second (m/s^2).
     * @param accelerationBiasZ                        estimated accelerometer bias resolved around z axis and
     *                                                 expressed in meters per squared second (m/s^2).
     * @param gyroBiasX                                estimated gyroscope bias resolved around x axis and
     *                                                 expressed in radians per second (rad/s).
     * @param gyroBiasY                                estimated gyroscope bias resolved around y axis and
     *                                                 expressed in radians per second (rad/s).
     * @param gyroBiasZ                                estimated gyroscope bias resolved around z axis and
     *                                                 expressed in radians per second (rad/s).
     * @param receiverClockOffset                      estimated receiver clock offset expressed in meters (m).
     * @param receiverClockDrift                       estimated receiver clock drift expressed in meters per
     *                                                 second (m/s).
     * @param covariance                               estimated Kalman filter error covariance matrix.
     * @throws IllegalArgumentException if provided body to ECEF coordinate transformation matrix is not 3x3
     *                                  or if provided covariance matrix is not 17x17.
     */
    public INSTightlyCoupledKalmanState(
            final Matrix bodyToEcefCoordinateTransformationMatrix,
            final Speed vx, final Speed vy, final Speed vz,
            final Point3D position,
            final double accelerationBiasX,
            final double accelerationBiasY,
            final double accelerationBiasZ,
            final double gyroBiasX,
            final double gyroBiasY,
            final double gyroBiasZ,
            final double receiverClockOffset,
            final double receiverClockDrift,
<span class="fc" id="L720">            final Matrix covariance) {</span>
<span class="fc" id="L721">        setBodyToEcefCoordinateTransformationMatrix(bodyToEcefCoordinateTransformationMatrix);</span>
<span class="fc" id="L722">        setVelocityCoordinates(vx, vy, vz);</span>
<span class="fc" id="L723">        setPosition(position);</span>
<span class="fc" id="L724">        setAccelerationBiasCoordinates(accelerationBiasX, accelerationBiasY, accelerationBiasZ);</span>
<span class="fc" id="L725">        setGyroBiasCoordinates(gyroBiasX, gyroBiasY, gyroBiasZ);</span>
<span class="fc" id="L726">        setReceiverClockOffset(receiverClockOffset);</span>
<span class="fc" id="L727">        setReceiverClockDrift(receiverClockDrift);</span>
<span class="fc" id="L728">        setCovariance(covariance);</span>
<span class="fc" id="L729">    }</span>

    /**
     * Constructor.
     *
     * @param bodyToEcefCoordinateTransformationMatrix estimated body to ECEF coordinate transformation matrix.
     * @param velocity                                 estimated ECEF user velocity.
     * @param position                                 estimated ECEF user position.
     * @param accelerationBiasX                        estimated accelerometer bias resolved around x axis and
     *                                                 expressed in meters per squared second (m/s^2).
     * @param accelerationBiasY                        estimated accelerometer bias resolved around y axis and
     *                                                 expressed in meters per squared second (m/s^2).
     * @param accelerationBiasZ                        estimated accelerometer bias resolved around z axis and
     *                                                 expressed in meters per squared second (m/s^2).
     * @param gyroBiasX                                estimated gyroscope bias resolved around x axis and
     *                                                 expressed in radians per second (rad/s).
     * @param gyroBiasY                                estimated gyroscope bias resolved around y axis and
     *                                                 expressed in radians per second (rad/s).
     * @param gyroBiasZ                                estimated gyroscope bias resolved around z axis and
     *                                                 expressed in radians per second (rad/s).
     * @param receiverClockOffset                      estimated receiver clock offset expressed in meters (m).
     * @param receiverClockDrift                       estimated receiver clock drift expressed in meters per
     *                                                 second (m/s).
     * @param covariance                               estimated Kalman filter error covariance matrix.
     * @throws IllegalArgumentException if provided body to ECEF coordinate transformation matrix is not 3x3
     *                                  or if provided covariance matrix is not 17x17.
     */
    public INSTightlyCoupledKalmanState(
            final Matrix bodyToEcefCoordinateTransformationMatrix,
            final ECEFVelocity velocity,
            final ECEFPosition position,
            final double accelerationBiasX,
            final double accelerationBiasY,
            final double accelerationBiasZ,
            final double gyroBiasX,
            final double gyroBiasY,
            final double gyroBiasZ,
            final double receiverClockOffset,
            final double receiverClockDrift,
<span class="fc" id="L768">            final Matrix covariance) {</span>
<span class="fc" id="L769">        setBodyToEcefCoordinateTransformationMatrix(bodyToEcefCoordinateTransformationMatrix);</span>
<span class="fc" id="L770">        setEcefVelocity(velocity);</span>
<span class="fc" id="L771">        setEcefPosition(position);</span>
<span class="fc" id="L772">        setAccelerationBiasCoordinates(accelerationBiasX, accelerationBiasY, accelerationBiasZ);</span>
<span class="fc" id="L773">        setGyroBiasCoordinates(gyroBiasX, gyroBiasY, gyroBiasZ);</span>
<span class="fc" id="L774">        setReceiverClockOffset(receiverClockOffset);</span>
<span class="fc" id="L775">        setReceiverClockDrift(receiverClockDrift);</span>
<span class="fc" id="L776">        setCovariance(covariance);</span>
<span class="fc" id="L777">    }</span>

    /**
     * Constructor.
     *
     * @param bodyToEcefCoordinateTransformationMatrix estimated body to ECEF coordinate transformation matrix.
     * @param positionAndVelocity                      estimated ECEF user position and velocity.
     * @param accelerationBiasX                        estimated accelerometer bias resolved around x axis and
     *                                                 expressed in meters per squared second (m/s^2).
     * @param accelerationBiasY                        estimated accelerometer bias resolved around y axis and
     *                                                 expressed in meters per squared second (m/s^2).
     * @param accelerationBiasZ                        estimated accelerometer bias resolved around z axis and
     *                                                 expressed in meters per squared second (m/s^2).
     * @param gyroBiasX                                estimated gyroscope bias resolved around x axis and
     *                                                 expressed in radians per second (rad/s).
     * @param gyroBiasY                                estimated gyroscope bias resolved around y axis and
     *                                                 expressed in radians per second (rad/s).
     * @param gyroBiasZ                                estimated gyroscope bias resolved around z axis and
     *                                                 expressed in radians per second (rad/s).
     * @param receiverClockOffset                      estimated receiver clock offset expressed in meters (m).
     * @param receiverClockDrift                       estimated receiver clock drift expressed in meters per
     *                                                 second (m/s).
     * @param covariance                               estimated Kalman filter error covariance matrix.
     * @throws IllegalArgumentException if provided body to ECEF coordinate transformation matrix is not 3x3
     *                                  or if provided covariance matrix is not 17x17.
     */
    public INSTightlyCoupledKalmanState(
            final Matrix bodyToEcefCoordinateTransformationMatrix,
            final ECEFPositionAndVelocity positionAndVelocity,
            final double accelerationBiasX,
            final double accelerationBiasY,
            final double accelerationBiasZ,
            final double gyroBiasX,
            final double gyroBiasY,
            final double gyroBiasZ,
            final double receiverClockOffset,
            final double receiverClockDrift,
<span class="fc" id="L814">            final Matrix covariance) {</span>
<span class="fc" id="L815">        setBodyToEcefCoordinateTransformationMatrix(bodyToEcefCoordinateTransformationMatrix);</span>
<span class="fc" id="L816">        setPositionAndVelocity(positionAndVelocity);</span>
<span class="fc" id="L817">        setAccelerationBiasCoordinates(accelerationBiasX, accelerationBiasY, accelerationBiasZ);</span>
<span class="fc" id="L818">        setGyroBiasCoordinates(gyroBiasX, gyroBiasY, gyroBiasZ);</span>
<span class="fc" id="L819">        setReceiverClockOffset(receiverClockOffset);</span>
<span class="fc" id="L820">        setReceiverClockDrift(receiverClockDrift);</span>
<span class="fc" id="L821">        setCovariance(covariance);</span>
<span class="fc" id="L822">    }</span>

    /**
     * Constructor.
     *
     * @param bodyToEcefCoordinateTransformationMatrix estimated body to ECEF coordinate transformation matrix.
     * @param vx                                       estimated ECEF user velocity resolved around x axis.
     * @param vy                                       estimated ECEF user velocity resolved around y axis.
     * @param vz                                       estimated ECEF user velocity resolved around z axis.
     * @param x                                        x coordinate of estimated ECEF user position.
     * @param y                                        y coordinate of estimated ECEF user position.
     * @param z                                        z coordinate of estimated ECEF user position.
     * @param accelerationBiasX                        estimated accelerometer bias resolved around x axis.
     * @param accelerationBiasY                        estimated accelerometer bias resolved around y axis.
     * @param accelerationBiasZ                        estimated accelerometer bias resolved around z axis.
     * @param gyroBiasX                                estimated gyroscope bias resolved around x axis.
     * @param gyroBiasY                                estimated gyroscope bias resolved around y axis.
     * @param gyroBiasZ                                estimated gyroscope bias resolved around z axis.
     * @param receiverClockOffset                      estimated receiver clock offset.
     * @param receiverClockDrift                       estimated receiver clock drift.
     * @param covariance                               estimated Kalman filter error covariance matrix.
     * @throws IllegalArgumentException if provided body to ECEF coordinate transformation matrix is not 3x3
     *                                  or if provided covariance matrix is not 17x17.
     */
    public INSTightlyCoupledKalmanState(
            final Matrix bodyToEcefCoordinateTransformationMatrix,
            final Speed vx, final Speed vy, final Speed vz,
            final Distance x, final Distance y, final Distance z,
            final Acceleration accelerationBiasX,
            final Acceleration accelerationBiasY,
            final Acceleration accelerationBiasZ,
            final AngularSpeed gyroBiasX,
            final AngularSpeed gyroBiasY,
            final AngularSpeed gyroBiasZ,
            final Distance receiverClockOffset,
            final Speed receiverClockDrift,
<span class="fc" id="L858">            final Matrix covariance) {</span>
<span class="fc" id="L859">        setBodyToEcefCoordinateTransformationMatrix(bodyToEcefCoordinateTransformationMatrix);</span>
<span class="fc" id="L860">        setVelocityCoordinates(vx, vy, vz);</span>
<span class="fc" id="L861">        setPositionCoordinates(x, y, z);</span>
<span class="fc" id="L862">        setAccelerationBiasCoordinates(accelerationBiasX, accelerationBiasY, accelerationBiasZ);</span>
<span class="fc" id="L863">        setGyroBiasCoordinates(gyroBiasX, gyroBiasY, gyroBiasZ);</span>
<span class="fc" id="L864">        setReceiverClockOffset(receiverClockOffset);</span>
<span class="fc" id="L865">        setReceiverClockDrift(receiverClockDrift);</span>
<span class="fc" id="L866">        setCovariance(covariance);</span>
<span class="fc" id="L867">    }</span>

    /**
     * Constructor.
     *
     * @param bodyToEcefCoordinateTransformationMatrix estimated body to ECEF coordinate transformation matrix.
     * @param vx                                       estimated ECEF user velocity resolved around x axis.
     * @param vy                                       estimated ECEF user velocity resolved around y axis.
     * @param vz                                       estimated ECEF user velocity resolved around z axis.
     * @param position                                 estimated ECEF user position expressed in meters (m).
     * @param accelerationBiasX                        estimated accelerometer bias resolved around x axis.
     * @param accelerationBiasY                        estimated accelerometer bias resolved around y axis.
     * @param accelerationBiasZ                        estimated accelerometer bias resolved around z axis.
     * @param gyroBiasX                                estimated gyroscope bias resolved around x axis.
     * @param gyroBiasY                                estimated gyroscope bias resolved around y axis.
     * @param gyroBiasZ                                estimated gyroscope bias resolved around z axis.
     * @param receiverClockOffset                      estimated receiver clock offset.
     * @param receiverClockDrift                       estimated receiver clock drift.
     * @param covariance                               estimated Kalman filter error covariance matrix.
     * @throws IllegalArgumentException if provided body to ECEF coordinate transformation matrix is not 3x3
     *                                  or if provided covariance matrix is not 17x17.
     */
    public INSTightlyCoupledKalmanState(
            final Matrix bodyToEcefCoordinateTransformationMatrix,
            final Speed vx, final Speed vy, final Speed vz,
            final Point3D position,
            final Acceleration accelerationBiasX,
            final Acceleration accelerationBiasY,
            final Acceleration accelerationBiasZ,
            final AngularSpeed gyroBiasX,
            final AngularSpeed gyroBiasY,
            final AngularSpeed gyroBiasZ,
            final Distance receiverClockOffset,
            final Speed receiverClockDrift,
<span class="fc" id="L901">            final Matrix covariance) {</span>
<span class="fc" id="L902">        setBodyToEcefCoordinateTransformationMatrix(bodyToEcefCoordinateTransformationMatrix);</span>
<span class="fc" id="L903">        setVelocityCoordinates(vx, vy, vz);</span>
<span class="fc" id="L904">        setPosition(position);</span>
<span class="fc" id="L905">        setAccelerationBiasCoordinates(accelerationBiasX, accelerationBiasY, accelerationBiasZ);</span>
<span class="fc" id="L906">        setGyroBiasCoordinates(gyroBiasX, gyroBiasY, gyroBiasZ);</span>
<span class="fc" id="L907">        setReceiverClockOffset(receiverClockOffset);</span>
<span class="fc" id="L908">        setReceiverClockDrift(receiverClockDrift);</span>
<span class="fc" id="L909">        setCovariance(covariance);</span>
<span class="fc" id="L910">    }</span>

    /**
     * Constructor.
     *
     * @param bodyToEcefCoordinateTransformationMatrix estimated body to ECEF coordinate transformation matrix.
     * @param velocity                                 estimated ECEF user velocity.
     * @param position                                 estimated ECEF user position.
     * @param accelerationBiasX                        estimated accelerometer bias resolved around x axis.
     * @param accelerationBiasY                        estimated accelerometer bias resolved around y axis.
     * @param accelerationBiasZ                        estimated accelerometer bias resolved around z axis.
     * @param gyroBiasX                                estimated gyroscope bias resolved around x axis.
     * @param gyroBiasY                                estimated gyroscope bias resolved around y axis.
     * @param gyroBiasZ                                estimated gyroscope bias resolved around z axis.
     * @param receiverClockOffset                      estimated receiver clock offset.
     * @param receiverClockDrift                       estimated receiver clock drift.
     * @param covariance                               estimated Kalman filter error covariance matrix.
     * @throws IllegalArgumentException if provided body to ECEF coordinate transformation matrix is not 3x3
     *                                  or if provided covariance matrix is not 17x17.
     */
    public INSTightlyCoupledKalmanState(
            final Matrix bodyToEcefCoordinateTransformationMatrix,
            final ECEFVelocity velocity,
            final ECEFPosition position,
            final Acceleration accelerationBiasX,
            final Acceleration accelerationBiasY,
            final Acceleration accelerationBiasZ,
            final AngularSpeed gyroBiasX,
            final AngularSpeed gyroBiasY,
            final AngularSpeed gyroBiasZ,
            final Distance receiverClockOffset,
            final Speed receiverClockDrift,
<span class="fc" id="L942">            final Matrix covariance) {</span>
<span class="fc" id="L943">        setBodyToEcefCoordinateTransformationMatrix(bodyToEcefCoordinateTransformationMatrix);</span>
<span class="fc" id="L944">        setEcefVelocity(velocity);</span>
<span class="fc" id="L945">        setEcefPosition(position);</span>
<span class="fc" id="L946">        setAccelerationBiasCoordinates(accelerationBiasX, accelerationBiasY, accelerationBiasZ);</span>
<span class="fc" id="L947">        setGyroBiasCoordinates(gyroBiasX, gyroBiasY, gyroBiasZ);</span>
<span class="fc" id="L948">        setReceiverClockOffset(receiverClockOffset);</span>
<span class="fc" id="L949">        setReceiverClockDrift(receiverClockDrift);</span>
<span class="fc" id="L950">        setCovariance(covariance);</span>
<span class="fc" id="L951">    }</span>

    /**
     * Constructor.
     *
     * @param bodyToEcefCoordinateTransformationMatrix estimated body to ECEF coordinate transformation matrix.
     * @param positionAndVelocity                      estimated ECEF user position and velocity.
     * @param accelerationBiasX                        estimated accelerometer bias resolved around x axis.
     * @param accelerationBiasY                        estimated accelerometer bias resolved around y axis.
     * @param accelerationBiasZ                        estimated accelerometer bias resolved around z axis.
     * @param gyroBiasX                                estimated gyroscope bias resolved around x axis.
     * @param gyroBiasY                                estimated gyroscope bias resolved around y axis.
     * @param gyroBiasZ                                estimated gyroscope bias resolved around z axis.
     * @param receiverClockOffset                      estimated receiver clock offset.
     * @param receiverClockDrift                       estimated receiver clock drift.
     * @param covariance                               estimated Kalman filter error covariance matrix.
     * @throws IllegalArgumentException if provided body to ECEF coordinate transformation matrix is not 3x3
     *                                  or if provided covariance matrix is not 17x17.
     */
    public INSTightlyCoupledKalmanState(
            final Matrix bodyToEcefCoordinateTransformationMatrix,
            final ECEFPositionAndVelocity positionAndVelocity,
            final Acceleration accelerationBiasX,
            final Acceleration accelerationBiasY,
            final Acceleration accelerationBiasZ,
            final AngularSpeed gyroBiasX,
            final AngularSpeed gyroBiasY,
            final AngularSpeed gyroBiasZ,
            final Distance receiverClockOffset,
            final Speed receiverClockDrift,
<span class="fc" id="L981">            final Matrix covariance) {</span>
<span class="fc" id="L982">        setBodyToEcefCoordinateTransformationMatrix(bodyToEcefCoordinateTransformationMatrix);</span>
<span class="fc" id="L983">        setPositionAndVelocity(positionAndVelocity);</span>
<span class="fc" id="L984">        setAccelerationBiasCoordinates(accelerationBiasX, accelerationBiasY, accelerationBiasZ);</span>
<span class="fc" id="L985">        setGyroBiasCoordinates(gyroBiasX, gyroBiasY, gyroBiasZ);</span>
<span class="fc" id="L986">        setReceiverClockOffset(receiverClockOffset);</span>
<span class="fc" id="L987">        setReceiverClockDrift(receiverClockDrift);</span>
<span class="fc" id="L988">        setCovariance(covariance);</span>
<span class="fc" id="L989">    }</span>

    /**
     * Copy constructor.
     *
     * @param input input instance to copy data from.
     */
<span class="fc" id="L996">    public INSTightlyCoupledKalmanState(final INSTightlyCoupledKalmanState input) {</span>
<span class="fc" id="L997">        copyFrom(input);</span>
<span class="fc" id="L998">    }</span>

    /**
     * Gets estimated body to ECEF coordinate transformation matrix.
     *
     * @return estimated body to ECEF coordinate transformation matrix.
     */
    public Matrix getBodyToEcefCoordinateTransformationMatrix() {
<span class="fc" id="L1006">        return mBodyToEcefCoordinateTransformationMatrix;</span>
    }

    /**
     * Sets estimated body to ECEF coordinate transformation matrix.
     *
     * @param bodyToEcefCoordinateTransformationMatrix estimated body to ECEF coordinate
     *                                                 transformation matrix.
     * @throws IllegalArgumentException if provided matrix is not 3x3.
     */
    public void setBodyToEcefCoordinateTransformationMatrix(
            final Matrix bodyToEcefCoordinateTransformationMatrix) {
<span class="fc bfc" id="L1018" title="All 2 branches covered.">        if (bodyToEcefCoordinateTransformationMatrix.getRows() != CoordinateTransformation.ROWS ||</span>
<span class="fc bfc" id="L1019" title="All 2 branches covered.">                bodyToEcefCoordinateTransformationMatrix.getColumns() != CoordinateTransformation.COLS) {</span>
<span class="fc" id="L1020">            throw new IllegalArgumentException();</span>
        }
<span class="fc" id="L1022">        mBodyToEcefCoordinateTransformationMatrix =</span>
                bodyToEcefCoordinateTransformationMatrix;
<span class="fc" id="L1024">    }</span>

    /**
     * Gets estimated ECEF user velocity resolved around x axis and expressed in meters per second (m/s).
     *
     * @return estimated ECEF user velocity resolved around x axis and expressed in meters per second (m/s).
     */
    public double getVx() {
<span class="fc" id="L1032">        return mVx;</span>
    }

    /**
     * Sets estimated ECEF user velocity resolved around x axis and expressed in meters per second (m/s).
     *
     * @param vx estimated ECEF user velocity resolved around x axis and expressed in meters per second (m/s).
     */
    public void setVx(final double vx) {
<span class="fc" id="L1041">        mVx = vx;</span>
<span class="fc" id="L1042">    }</span>

    /**
     * Gets estimated ECEF user velocity resolved around y axis and expressed in meters per second (m/s).
     *
     * @return estimated ECEF user velocity resolved around y axis and expressed in meters per second (m/s).
     */
    public double getVy() {
<span class="fc" id="L1050">        return mVy;</span>
    }

    /**
     * Sets estimated ECEF user velocity resolved around y axis and expressed in meters per second (m/s).
     *
     * @param vy estimated ECEF user velocity resolved around y axis and expressed in meters per scond (m/s).
     */
    public void setVy(final double vy) {
<span class="fc" id="L1059">        mVy = vy;</span>
<span class="fc" id="L1060">    }</span>

    /**
     * Gets estimated ECEF user velocity resolved around z axis and expressed in meters per second (m/s).
     *
     * @return estimated ECEF user velocity resolved around z axis and expressed in meters per second (m/s).
     */
    public double getVz() {
<span class="fc" id="L1068">        return mVz;</span>
    }

    /**
     * Sets estimated ECEF user velocity resolved around z axis and expressed in meters per second (m/s).
     *
     * @param vz estimated ECEF user velocity resolved around z axis and expressed in meters per second (m/s).
     */
    public void setVz(final double vz) {
<span class="fc" id="L1077">        mVz = vz;</span>
<span class="fc" id="L1078">    }</span>

    /**
     * Sets estimated ECEF user velocity coordinates.
     *
     * @param vx estimated ECEF user velocity resolved around x axis and expressed in meters per second (m/s).
     * @param vy estimated ECEF user velocity resolved around y axis and expressed in meters per second (m/s).
     * @param vz estimated ECEF user velocity resolved around z axis and expressed in meters per second (m/s).
     */
    public void setVelocityCoordinates(
            final double vx, final double vy, final double vz) {
<span class="fc" id="L1089">        mVx = vx;</span>
<span class="fc" id="L1090">        mVy = vy;</span>
<span class="fc" id="L1091">        mVz = vz;</span>
<span class="fc" id="L1092">    }</span>

    /**
     * Gets x coordinate of estimated ECEF user position expressed in meters (m).
     *
     * @return x coordinate of estimated ECEF user position expressed in meters (m).
     */
    public double getX() {
<span class="fc" id="L1100">        return mX;</span>
    }

    /**
     * Sets x coordinate of estimated ECEF user position expressed in meters (m).
     *
     * @param x x coordinate of estimated ECEF user position expressed in meters (m).
     */
    public void setX(final double x) {
<span class="fc" id="L1109">        mX = x;</span>
<span class="fc" id="L1110">    }</span>

    /**
     * Gets y coordinate of estimated ECEF user position expressed in meters (m).
     *
     * @return y coordinate of estimated ECEF user position expressed in meters (m).
     */
    public double getY() {
<span class="fc" id="L1118">        return mY;</span>
    }

    /**
     * Sets y coordinate of estimated ECEF user position expressed in meters (m).
     *
     * @param y y coordinate of estimated ECEF user position expressed in meters (m).
     */
    public void setY(final double y) {
<span class="fc" id="L1127">        mY = y;</span>
<span class="fc" id="L1128">    }</span>

    /**
     * Gets z coordinate of estimated ECEF user position expressed in meters (m).
     *
     * @return z coordinate of estimated ECEF user position expressed in meters (m).
     */
    public double getZ() {
<span class="fc" id="L1136">        return mZ;</span>
    }

    /**
     * Sets z coordinate of estimated ECEF user position expressed in meters (m).
     *
     * @param z z coordinate of estimated ECEF user position expressed in meters (m).
     */
    public void setZ(final double z) {
<span class="fc" id="L1145">        mZ = z;</span>
<span class="fc" id="L1146">    }</span>

    /**
     * Sets estimated ECEF user position coordinates.
     *
     * @param x x coordinate of estimated ECEF user position expressed in meters (m).
     * @param y y coordinate of estimated ECEF user position expressed in meters (m).
     * @param z z coordinate of estimated ECEF user position expressed in meters (m).
     */
    public void setPositionCoordinates(
            final double x, final double y, final double z) {
<span class="fc" id="L1157">        mX = x;</span>
<span class="fc" id="L1158">        mY = y;</span>
<span class="fc" id="L1159">        mZ = z;</span>
<span class="fc" id="L1160">    }</span>

    /**
     * Gets estimated accelerometer bias resolved around x axis and expressed in
     * meters per squared second (m/s^2).
     *
     * @return estimated accelerometer bias resolved around x axis and expressed in
     * meters per squared second (m/s^2).
     */
    public double getAccelerationBiasX() {
<span class="fc" id="L1170">        return mAccelerationBiasX;</span>
    }

    /**
     * Sets estimated accelerometer bias resolved around x axis and expressed in
     * meters per squared second (m/s^2).
     *
     * @param accelerationBiasX estimated accelerometer bias resolved around x axis and
     *                          expressed in meters per squared second (m/s^2).
     */
    public void setAccelerationBiasX(final double accelerationBiasX) {
<span class="fc" id="L1181">        mAccelerationBiasX = accelerationBiasX;</span>
<span class="fc" id="L1182">    }</span>

    /**
     * Gets estimated accelerometer bias resolved around y axis and expressed in
     * meters per squared second (m/s^2).
     *
     * @return estimated accelerometer bias resolved around y axis and expressed in
     * meters per squared second (m/s^2).
     */
    public double getAccelerationBiasY() {
<span class="fc" id="L1192">        return mAccelerationBiasY;</span>
    }

    /**
     * Sets estimated accelerometer bias resolved around y axis and expressed in
     * meters per squared second (m/s^2).
     *
     * @param accelerationBiasY estimated accelerometer bias resolved around y axis
     *                          and expressed in meters per squared second (m/s^2).
     */
    public void setAccelerationBiasY(final double accelerationBiasY) {
<span class="fc" id="L1203">        mAccelerationBiasY = accelerationBiasY;</span>
<span class="fc" id="L1204">    }</span>

    /**
     * Gets estimated accelerometer bias resolved around z axis and expressed in
     * meters per squared second (m/s^2).
     *
     * @return estimated accelerometer bias resolved around z axis and
     * expressed in meters per squared second (m/s^2).
     */
    public double getAccelerationBiasZ() {
<span class="fc" id="L1214">        return mAccelerationBiasZ;</span>
    }

    /**
     * Sets estimated accelerometer bias resolved around z axis and expressed in
     * meters per squared second (m/s^2).
     *
     * @param accelerationBiasZ estimated accelerometer bias resolved around z axis
     *                          and expressed in meters per squared second (m/s^2).
     */
    public void setAccelerationBiasZ(final double accelerationBiasZ) {
<span class="fc" id="L1225">        mAccelerationBiasZ = accelerationBiasZ;</span>
<span class="fc" id="L1226">    }</span>

    /**
     * Sets estimated accelerometer bias expressed in meters per squared second (m/s^2).
     *
     * @param accelerationBiasX estimated accelerometer bias resolved around x axis and
     *                          expressed in meters per squared second (m/s^2).
     * @param accelerationBiasY estimated accelerometer bias resolved around y axis and
     *                          expressed in meters per squared second (m/s^2).
     * @param accelerationBiasZ estimated accelerometer bias resolved around z axis and
     *                          expressed in meters per squared second (m/s^2).
     */
    public void setAccelerationBiasCoordinates(
            final double accelerationBiasX, final double accelerationBiasY,
            final double accelerationBiasZ) {
<span class="fc" id="L1241">        mAccelerationBiasX = accelerationBiasX;</span>
<span class="fc" id="L1242">        mAccelerationBiasY = accelerationBiasY;</span>
<span class="fc" id="L1243">        mAccelerationBiasZ = accelerationBiasZ;</span>
<span class="fc" id="L1244">    }</span>

    /**
     * Gets estimated gyroscope bias resolved around x axis and expressed in
     * radians per second (rad/s).
     *
     * @return estimated gyroscope bias resolved around x axis and expressed in
     * radians per second (rad/s).
     */
    public double getGyroBiasX() {
<span class="fc" id="L1254">        return mGyroBiasX;</span>
    }

    /**
     * Sets estimated gyroscope bias resolved around x axis and expressed in
     * radians per second (rad/s).
     *
     * @param gyroBiasX estimated gyroscope bias resolved around x axis and
     *                  expressed in radians per second (rad/s).
     */
    public void setGyroBiasX(final double gyroBiasX) {
<span class="fc" id="L1265">        mGyroBiasX = gyroBiasX;</span>
<span class="fc" id="L1266">    }</span>

    /**
     * Gets estimated gyroscope bias resolved around y axis and expressed in
     * radians per second (rad/s).
     *
     * @return estimated gyroscope bias resolved around y axis and expressed
     * in radians per second (rad/s).
     */
    public double getGyroBiasY() {
<span class="fc" id="L1276">        return mGyroBiasY;</span>
    }

    /**
     * Sets estimated gyroscope bias resolved around y axis and expressed in
     * radians per second (rad/s).
     *
     * @param gyroBiasY estimated gyroscope bias resolved around y axis and
     *                  expressed in radians per second (rad/s).
     */
    public void setGyroBiasY(final double gyroBiasY) {
<span class="fc" id="L1287">        mGyroBiasY = gyroBiasY;</span>
<span class="fc" id="L1288">    }</span>

    /**
     * Gets estimated gyroscope bias resolved around z axis and expressed in
     * radians per second (rad/s).
     *
     * @return estimated gyroscope bias resolved around z axis and expressed
     * in radians per second (rad/s).
     */
    public double getGyroBiasZ() {
<span class="fc" id="L1298">        return mGyroBiasZ;</span>
    }

    /**
     * Sets estimated gyroscope bias resolved around z axis and expressed in
     * radians per second (rad/s).
     *
     * @param gyroBiasZ estimated gyroscope bias resolved around z axis and
     *                  expressed in radians per second (rad/s).
     */
    public void setGyroBiasZ(final double gyroBiasZ) {
<span class="fc" id="L1309">        mGyroBiasZ = gyroBiasZ;</span>
<span class="fc" id="L1310">    }</span>

    /**
     * Sets estimated gyroscope bias coordinates expressed in radians
     * per second (rad/s).
     *
     * @param gyroBiasX estimated gyroscope bias resolved around x axis and
     *                  expressed in radians per second (rad/s).
     * @param gyroBiasY estimated gyroscope bias resolved around y axis and
     *                  expressed in radians per second (rad/s).
     * @param gyroBiasZ estimated gyroscope bias resolved around z axis and
     *                  expressed in radians per second (rad/s).
     */
    public void setGyroBiasCoordinates(
            final double gyroBiasX, final double gyroBiasY, final double gyroBiasZ) {
<span class="fc" id="L1325">        mGyroBiasX = gyroBiasX;</span>
<span class="fc" id="L1326">        mGyroBiasY = gyroBiasY;</span>
<span class="fc" id="L1327">        mGyroBiasZ = gyroBiasZ;</span>
<span class="fc" id="L1328">    }</span>

    /**
     * Gets estimated receiver clock offset expressed in meters (m).
     *
     * @return estimated receiver clock offset expressed in meters (m).
     */
    public double getReceiverClockOffset() {
<span class="fc" id="L1336">        return mReceiverClockOffset;</span>
    }

    /**
     * Sets estimated receiver clock offset expressed in meters (m).
     *
     * @param receiverClockOffset estimated receiver clock offset expressed
     *                            in meters (m).
     */
    public void setReceiverClockOffset(final double receiverClockOffset) {
<span class="fc" id="L1346">        mReceiverClockOffset = receiverClockOffset;</span>
<span class="fc" id="L1347">    }</span>

    /**
     * Gets estimated receiver clock drift expressed in meters per second (m/s).
     *
     * @return estimated receiver clock drift expressed in meters per second (m/s).
     */
    public double getReceiverClockDrift() {
<span class="fc" id="L1355">        return mReceiverClockDrift;</span>
    }

    /**
     * Sets estimated receiver clock drift expressed in meters per second (m/s).
     *
     * @param receiverClockDrift estimated receiver clock drift expressed in
     *                           meters per second (m/s).
     */
    public void setReceiverClockDrift(final double receiverClockDrift) {
<span class="fc" id="L1365">        mReceiverClockDrift = receiverClockDrift;</span>
<span class="fc" id="L1366">    }</span>

    /**
     * Gets Kalman filter error covariance matrix.
     * Notice that covariance is expressed in terms of ECEF coordinates.
     * If accuracy of position, attitude or velocity needs to be expressed in terms
     * of NED coordinates, their respective submatrices of this covariance matrix
     * must be rotated, taking into account the Jacobian of the matrix transformation
     * relating both coordinates, the covariance can be expressed following the law
     * of propagation of uncertainties (https://en.wikipedia.org/wiki/Propagation_of_uncertainty)
     * as: cov(f(x)) = J*cov(x)*J'.
     *
     * @param result instance where result data will be copied to.
     * @return true if result data has been copied, false otherwise.
     */
    public boolean getCovariance(final Matrix result) {
<span class="fc bfc" id="L1382" title="All 2 branches covered.">        if (mCovariance != null) {</span>
<span class="fc" id="L1383">            mCovariance.copyTo(result);</span>
<span class="fc" id="L1384">            return true;</span>
        } else {
<span class="fc" id="L1386">            return false;</span>
        }
    }

    /**
     * Gets Kalman filter error covariance matrix.
     * Notice that covariance is expressed in terms of ECEF coordinates.
     * If accuracy of position, attitude or velocity needs to be expressed in terms
     * of NED coordinates, their respective submatrices of this covariance matrix
     * must be rotated, taking into account the Jacobian of the matrix transformation
     * relating both coordinates, the covariance can be expressed following the law
     * of propagation of uncertainties (https://en.wikipedia.org/wiki/Propagation_of_uncertainty)
     * as: cov(f(x)) = J*cov(x)*J'.
     *
     * @return Kalman filter error covariance matrix.
     */
    public Matrix getCovariance() {
<span class="fc" id="L1403">        return mCovariance;</span>
    }

    /**
     * Sets Kalman filter error covariance matrix.
     *
     * @param covariance Kalman filter error covariance matrix to be set.
     * @throws IllegalArgumentException if provided covariance matrix is not 17x17.
     */
    public void setCovariance(final Matrix covariance) {
<span class="fc bfc" id="L1413" title="All 2 branches covered.">        if (covariance.getRows() != NUM_PARAMS ||</span>
<span class="pc bpc" id="L1414" title="1 of 2 branches missed.">                covariance.getColumns() != NUM_PARAMS) {</span>
<span class="fc" id="L1415">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L1418">        mCovariance = covariance;</span>
<span class="fc" id="L1419">    }</span>

    /**
     * Gets body to ECEF coordinate transformation.
     *
     * @return body to ECEF coordinate transformation.
     * @throws InvalidRotationMatrixException if current body to ECEF transformation matrix is
     *                                        not valid (is not a 3x3 orthonormal matrix).
     */
    public CoordinateTransformation getC() throws InvalidRotationMatrixException {
<span class="fc bfc" id="L1429" title="All 2 branches covered.">        return mBodyToEcefCoordinateTransformationMatrix != null ?</span>
<span class="fc" id="L1430">                new CoordinateTransformation(mBodyToEcefCoordinateTransformationMatrix,</span>
<span class="fc" id="L1431">                        FrameType.BODY_FRAME, FrameType.EARTH_CENTERED_EARTH_FIXED_FRAME) : null;</span>
    }

    /**
     * Gets body to ECEF coordinate transformation.
     *
     * @param threshold threshold to determine whether current body to ECEF transformation
     *                  matrix is valid or not (to check that matrix is 3x3 orthonormal).
     * @return body to ECEF coordinate transformation.
     * @throws InvalidRotationMatrixException if current body to ECEF transformation matrix
     *                                        is considered not valid (is not a 3x3 orthonormal matrix) with provided threshold.
     */
    public CoordinateTransformation getC(final double threshold) throws InvalidRotationMatrixException {
<span class="pc bpc" id="L1444" title="1 of 2 branches missed.">        return mBodyToEcefCoordinateTransformationMatrix != null ?</span>
<span class="nc" id="L1445">                new CoordinateTransformation(mBodyToEcefCoordinateTransformationMatrix,</span>
<span class="fc" id="L1446">                        FrameType.BODY_FRAME, FrameType.EARTH_CENTERED_EARTH_FIXED_FRAME, threshold) : null;</span>
    }

    /**
     * Gets body to ECEF coordinate transformation.
     *
     * @param result instance where body to ECEF coordinate transformation will be stored.
     * @return true if result instance was updated, false otherwise.
     * @throws InvalidRotationMatrixException if current body to ECEF transformation matrix
     *                                        is not valid (is not a 3x3 orthonormal matrix).
     */
    public boolean getC(final CoordinateTransformation result) throws InvalidRotationMatrixException {
<span class="fc bfc" id="L1458" title="All 2 branches covered.">        if (mBodyToEcefCoordinateTransformationMatrix != null) {</span>
<span class="fc" id="L1459">            result.setSourceType(FrameType.BODY_FRAME);</span>
<span class="fc" id="L1460">            result.setDestinationType(FrameType.EARTH_CENTERED_EARTH_FIXED_FRAME);</span>
<span class="fc" id="L1461">            result.setMatrix(mBodyToEcefCoordinateTransformationMatrix);</span>
<span class="fc" id="L1462">            return true;</span>
        } else {
<span class="fc" id="L1464">            return false;</span>
        }
    }

    /**
     * Gets body to ECEF coordinate transformation.
     *
     * @param result    instance where body to ECEF coordinate transformation will be stored.
     * @param threshold threshold to determine whether current body to ECEF transformation
     *                  matrix is valid or not (to check that matrix is 3x3 orthonormal).
     * @return true if result instance was updated, false otherwise.
     * @throws InvalidRotationMatrixException if current body to ECEF transformation matrix
     *                                        is not valid (is not a 3x3 orthonormal matrix) with provided threshold.
     */
    public boolean getC(final CoordinateTransformation result,
                        final double threshold) throws InvalidRotationMatrixException {
<span class="fc bfc" id="L1480" title="All 2 branches covered.">        if (mBodyToEcefCoordinateTransformationMatrix != null) {</span>
<span class="fc" id="L1481">            result.setSourceType(FrameType.BODY_FRAME);</span>
<span class="fc" id="L1482">            result.setDestinationType(FrameType.EARTH_CENTERED_EARTH_FIXED_FRAME);</span>
<span class="fc" id="L1483">            result.setMatrix(mBodyToEcefCoordinateTransformationMatrix, threshold);</span>
<span class="fc" id="L1484">            return true;</span>
        } else {
<span class="fc" id="L1486">            return false;</span>
        }
    }

    /**
     * Sets body to ECEF coordinate transformation.
     *
     * @param c body to ECEF coordinate transformation to be set.
     * @throws IllegalArgumentException if provided coordinate transformation is
     *                                  not null and is not a body to ECEF transformation.
     */
    public void setC(final CoordinateTransformation c) {
<span class="fc bfc" id="L1498" title="All 2 branches covered.">        if (c == null) {</span>
<span class="fc" id="L1499">            mBodyToEcefCoordinateTransformationMatrix = null;</span>

        } else {

<span class="fc bfc" id="L1503" title="All 2 branches covered.">            if (c.getSourceType() != FrameType.BODY_FRAME ||</span>
<span class="pc bpc" id="L1504" title="1 of 2 branches missed.">                    c.getDestinationType() != FrameType.EARTH_CENTERED_EARTH_FIXED_FRAME) {</span>
<span class="fc" id="L1505">                throw new IllegalArgumentException();</span>
            }

<span class="fc bfc" id="L1508" title="All 2 branches covered.">            if (mBodyToEcefCoordinateTransformationMatrix != null) {</span>
<span class="fc" id="L1509">                c.getMatrix(mBodyToEcefCoordinateTransformationMatrix);</span>
            } else {
<span class="fc" id="L1511">                mBodyToEcefCoordinateTransformationMatrix = c.getMatrix();</span>
            }
        }
<span class="fc" id="L1514">    }</span>

    /**
     * Gets estimated ECEF user velocity resolved around x axis.
     *
     * @param result instance where estimated ECEF user velocity resolved around x axis will be stored.
     */
    public void getSpeedX(final Speed result) {
<span class="fc" id="L1522">        result.setValue(mVx);</span>
<span class="fc" id="L1523">        result.setUnit(SpeedUnit.METERS_PER_SECOND);</span>
<span class="fc" id="L1524">    }</span>

    /**
     * Gets estimated ECEF user velocity resolved around x axis.
     *
     * @return estimated ECEF user velocity resolved around x axis.
     */
    public Speed getSpeedX() {
<span class="fc" id="L1532">        return new Speed(mVx, SpeedUnit.METERS_PER_SECOND);</span>
    }

    /**
     * Sets estimated ECEF user velocity resolved around x axis.
     *
     * @param vx estimated ECEF user velocity resolved around x axis.
     */
    public void setSpeedX(final Speed vx) {
<span class="fc" id="L1541">        mVx = SpeedConverter.convert(vx.getValue().doubleValue(),</span>
<span class="fc" id="L1542">                vx.getUnit(), SpeedUnit.METERS_PER_SECOND);</span>
<span class="fc" id="L1543">    }</span>

    /**
     * Gets estimated ECEF user velocity resolved around y axis.
     *
     * @param result instance where estimated ECEF user velocity resolved around y axis will be stored.
     */
    public void getSpeedY(final Speed result) {
<span class="fc" id="L1551">        result.setValue(mVy);</span>
<span class="fc" id="L1552">        result.setUnit(SpeedUnit.METERS_PER_SECOND);</span>
<span class="fc" id="L1553">    }</span>

    /**
     * Gets estimated ECEF user velocity resolved around y axis.
     *
     * @return estimated ECEF velocity resolved around y axis.
     */
    public Speed getSpeedY() {
<span class="fc" id="L1561">        return new Speed(mVy, SpeedUnit.METERS_PER_SECOND);</span>
    }

    /**
     * Sets estimated ECEF user velocity resolved around y axis.
     *
     * @param vy estimated ECEF user velocity resolved around y axis.
     */
    public void setSpeedY(final Speed vy) {
<span class="fc" id="L1570">        mVy = SpeedConverter.convert(vy.getValue().doubleValue(),</span>
<span class="fc" id="L1571">                vy.getUnit(), SpeedUnit.METERS_PER_SECOND);</span>
<span class="fc" id="L1572">    }</span>

    /**
     * Gets estimated ECEF user velocity resolved around z axis.
     *
     * @param result instance where estimated ECEF user velocity resolved around z axis will be stored.
     */
    public void getSpeedZ(final Speed result) {
<span class="fc" id="L1580">        result.setValue(mVz);</span>
<span class="fc" id="L1581">        result.setUnit(SpeedUnit.METERS_PER_SECOND);</span>
<span class="fc" id="L1582">    }</span>

    /**
     * Gets estimated ECEF user velocity resolved around z axis.
     *
     * @return estimated ECEF velocity resolved around z axis.
     */
    public Speed getSpeedZ() {
<span class="fc" id="L1590">        return new Speed(mVz, SpeedUnit.METERS_PER_SECOND);</span>
    }

    /**
     * Sets estimated ECEF user velocity resolved around z axis.
     *
     * @param vz estimated ECEF velocity resolved around z axis.
     */
    public void setSpeedZ(final Speed vz) {
<span class="fc" id="L1599">        mVz = SpeedConverter.convert(vz.getValue().doubleValue(),</span>
<span class="fc" id="L1600">                vz.getUnit(), SpeedUnit.METERS_PER_SECOND);</span>
<span class="fc" id="L1601">    }</span>

    /**
     * Sets estimated ECEF user velocity.
     *
     * @param vx estimated ECEF velocity resolved around x axis.
     * @param vy estimated ECEF velocity resolved around y axis.
     * @param vz estimated ECEF velocity resolved around z axis.
     */
    public void setVelocityCoordinates(
            final Speed vx, final Speed vy, final Speed vz) {
<span class="fc" id="L1612">        setSpeedX(vx);</span>
<span class="fc" id="L1613">        setSpeedY(vy);</span>
<span class="fc" id="L1614">        setSpeedZ(vz);</span>
<span class="fc" id="L1615">    }</span>

    /**
     * Gets estimated ECEF user velocity.
     *
     * @param result instance where estimated ECEF user velocity will be stored.
     */
    public void getEcefVelocity(final ECEFVelocity result) {
<span class="fc" id="L1623">        result.setCoordinates(mVx, mVy, mVz);</span>
<span class="fc" id="L1624">    }</span>

    /**
     * Gets estimated ECEF user velocity.
     *
     * @return estimated ECEF user velocity.
     */
    public ECEFVelocity getEcefVelocity() {
<span class="fc" id="L1632">        return new ECEFVelocity(mVx, mVy, mVz);</span>
    }

    /**
     * Sets estimated ECEF user velocity.
     *
     * @param ecefVelocity estimated ECEF user velocity.
     */
    public void setEcefVelocity(final ECEFVelocity ecefVelocity) {
<span class="fc" id="L1641">        mVx = ecefVelocity.getVx();</span>
<span class="fc" id="L1642">        mVy = ecefVelocity.getVy();</span>
<span class="fc" id="L1643">        mVz = ecefVelocity.getVz();</span>
<span class="fc" id="L1644">    }</span>

    /**
     * Gets x coordinate of estimated ECEF user position.
     *
     * @param result instance where x coordinate of estimated ECEF user position
     *               will be stored.
     */
    public void getDistanceX(final Distance result) {
<span class="fc" id="L1653">        result.setValue(mX);</span>
<span class="fc" id="L1654">        result.setUnit(DistanceUnit.METER);</span>
<span class="fc" id="L1655">    }</span>

    /**
     * Gets x coordinate of estimated ECEF user position.
     *
     * @return x coordinate of estimated ECEF user position.
     */
    public Distance getDistanceX() {
<span class="fc" id="L1663">        return new Distance(mX, DistanceUnit.METER);</span>
    }

    /**
     * Sets x coordinate of estimated ECEF user position.
     *
     * @param x x coordinate of estimated ECEF user position.
     */
    public void setDistanceX(final Distance x) {
<span class="fc" id="L1672">        mX = DistanceConverter.convert(x.getValue().doubleValue(),</span>
<span class="fc" id="L1673">                x.getUnit(), DistanceUnit.METER);</span>
<span class="fc" id="L1674">    }</span>

    /**
     * Gets y coordinate of estimated ECEF user position.
     *
     * @param result instance where y coordinate of estimated ECEF user position
     *               will be stored.
     */
    public void getDistanceY(final Distance result) {
<span class="fc" id="L1683">        result.setValue(mY);</span>
<span class="fc" id="L1684">        result.setUnit(DistanceUnit.METER);</span>
<span class="fc" id="L1685">    }</span>

    /**
     * Gets y coordinate of estimated ECEF user position.
     *
     * @return y coordinate of estimated ECEF user position.
     */
    public Distance getDistanceY() {
<span class="fc" id="L1693">        return new Distance(mY, DistanceUnit.METER);</span>
    }

    /**
     * Sets y coordinate of estimated ECEF user position.
     *
     * @param y y coordinate of estimated ECEF user position.
     */
    public void setDistanceY(final Distance y) {
<span class="fc" id="L1702">        mY = DistanceConverter.convert(y.getValue().doubleValue(),</span>
<span class="fc" id="L1703">                y.getUnit(), DistanceUnit.METER);</span>
<span class="fc" id="L1704">    }</span>

    /**
     * Gets z coordinate of estimated ECEF user position.
     *
     * @param result instance where z coordinate of estimated ECEF user position
     *               will be stored.
     */
    public void getDistanceZ(final Distance result) {
<span class="fc" id="L1713">        result.setValue(mZ);</span>
<span class="fc" id="L1714">        result.setUnit(DistanceUnit.METER);</span>
<span class="fc" id="L1715">    }</span>

    /**
     * Gets z coordinate of estimated ECEF user position.
     *
     * @return z coordinate of estimated ECEF user position.
     */
    public Distance getDistanceZ() {
<span class="fc" id="L1723">        return new Distance(mZ, DistanceUnit.METER);</span>
    }

    /**
     * Sets z coordinate of estimated ECEF user position.
     *
     * @param z z coordinate of estimated ECEF user position.
     */
    public void setDistanceZ(final Distance z) {
<span class="fc" id="L1732">        mZ = DistanceConverter.convert(z.getValue().doubleValue(),</span>
<span class="fc" id="L1733">                z.getUnit(), DistanceUnit.METER);</span>
<span class="fc" id="L1734">    }</span>

    /**
     * Sets coordinates of estimated ECEF user position.
     *
     * @param x x coordinate of estimated ECEF user position.
     * @param y y coordinate of estimated ECEF user position.
     * @param z z coordinate of estimated ECEF user position.
     */
    public void setPositionCoordinates(
            final Distance x, final Distance y, final Distance z) {
<span class="fc" id="L1745">        setDistanceX(x);</span>
<span class="fc" id="L1746">        setDistanceY(y);</span>
<span class="fc" id="L1747">        setDistanceZ(z);</span>
<span class="fc" id="L1748">    }</span>

    /**
     * Gets estimated ECEF user position expressed in meters (m).
     *
     * @param result instance where estimated ECEF user position expressed
     *               in meters (m) will be stored.
     */
    public void getPosition(final Point3D result) {
<span class="fc" id="L1757">        result.setInhomogeneousCoordinates(mX, mY, mZ);</span>
<span class="fc" id="L1758">    }</span>

    /**
     * Gets estimated ECEF user position expressed in meters (m).
     *
     * @return estimated ECEF user position expressed in meters (m).
     */
    public Point3D getPosition() {
<span class="fc" id="L1766">        return new InhomogeneousPoint3D(mX, mY, mZ);</span>
    }

    /**
     * Sets estimated ECEF user position expressed in meters (m).
     *
     * @param position estimated ECEF user position expressed in
     *                 meters (m).
     */
    public void setPosition(final Point3D position) {
<span class="fc" id="L1776">        mX = position.getInhomX();</span>
<span class="fc" id="L1777">        mY = position.getInhomY();</span>
<span class="fc" id="L1778">        mZ = position.getInhomZ();</span>
<span class="fc" id="L1779">    }</span>

    /**
     * Gets estimated ECEF user position.
     *
     * @param result instance where estimated ECEF user position
     *               will be stored.
     */
    public void getEcefPosition(final ECEFPosition result) {
<span class="fc" id="L1788">        result.setCoordinates(mX, mY, mZ);</span>
<span class="fc" id="L1789">    }</span>

    /**
     * Gets estimated ECEF user position.
     *
     * @return estimated ECEF user position.
     */
    public ECEFPosition getEcefPosition() {
<span class="fc" id="L1797">        return new ECEFPosition(mX, mY, mZ);</span>
    }

    /**
     * Sets estimated ECEF user position.
     *
     * @param ecefPosition estimated ECEF user position.
     */
    public void setEcefPosition(final ECEFPosition ecefPosition) {
<span class="fc" id="L1806">        mX = ecefPosition.getX();</span>
<span class="fc" id="L1807">        mY = ecefPosition.getY();</span>
<span class="fc" id="L1808">        mZ = ecefPosition.getZ();</span>
<span class="fc" id="L1809">    }</span>

    /**
     * Gets estimated ECEF user position and velocity.
     *
     * @param result instance where estimated ECEF user position and velocity
     *               will be stored.
     */
    public void getPositionAndVelocity(final ECEFPositionAndVelocity result) {
<span class="fc" id="L1818">        result.setPositionCoordinates(mX, mY, mZ);</span>
<span class="fc" id="L1819">        result.setVelocityCoordinates(mVx, mVy, mVz);</span>
<span class="fc" id="L1820">    }</span>

    /**
     * Gets estimated ECEF user position and velocity.
     *
     * @return estimated ECEF user position and velocity.
     */
    public ECEFPositionAndVelocity getPositionAndVelocity() {
<span class="fc" id="L1828">        return new ECEFPositionAndVelocity(mX, mY, mZ, mVx, mVy, mVz);</span>
    }

    /**
     * Sets estimated ECEF user position and velocity.
     *
     * @param positionAndVelocity estimated ECEF user position and velocity.
     */
    public void setPositionAndVelocity(final ECEFPositionAndVelocity positionAndVelocity) {
<span class="fc" id="L1837">        mX = positionAndVelocity.getX();</span>
<span class="fc" id="L1838">        mY = positionAndVelocity.getY();</span>
<span class="fc" id="L1839">        mZ = positionAndVelocity.getZ();</span>
<span class="fc" id="L1840">        mVx = positionAndVelocity.getVx();</span>
<span class="fc" id="L1841">        mVy = positionAndVelocity.getVy();</span>
<span class="fc" id="L1842">        mVz = positionAndVelocity.getVz();</span>
<span class="fc" id="L1843">    }</span>

    /**
     * Gets body to ECEF frame containing coordinate transformation, position and
     * velocity.
     *
     * @param result instance where body to ECEF frame will be stored.
     * @return true if result was updated, false otherwise.
     */
    public boolean getFrame(final ECEFFrame result) {
<span class="fc bfc" id="L1853" title="All 2 branches covered.">        if (mBodyToEcefCoordinateTransformationMatrix != null) {</span>
            try {
<span class="fc" id="L1855">                result.setCoordinateTransformation(getC());</span>
<span class="fc" id="L1856">            } catch (final InvalidSourceAndDestinationFrameTypeException</span>
                    | InvalidRotationMatrixException e) {
<span class="fc" id="L1858">                return false;</span>
<span class="fc" id="L1859">            }</span>
<span class="fc" id="L1860">            result.setCoordinates(mX, mY, mZ);</span>
<span class="fc" id="L1861">            result.setVelocityCoordinates(mVx, mVy, mVz);</span>
<span class="fc" id="L1862">            return true;</span>
        } else {
<span class="fc" id="L1864">            return false;</span>
        }
    }

    /**
     * Gets body to ECEF frame containing coordinate transformation, position and
     * velocity.
     *
     * @return body to ECEF frame.
     */
    public ECEFFrame getFrame() {
<span class="fc bfc" id="L1875" title="All 2 branches covered.">        if (mBodyToEcefCoordinateTransformationMatrix != null) {</span>
            try {
<span class="fc" id="L1877">                return new ECEFFrame(mX, mY, mZ, mVx, mVy, mVz, getC());</span>
<span class="fc" id="L1878">            } catch (final InvalidSourceAndDestinationFrameTypeException</span>
                    | InvalidRotationMatrixException e) {
<span class="fc" id="L1880">                return null;</span>
            }
        } else {
<span class="fc" id="L1883">            return null;</span>
        }
    }

    /**
     * Sets body to ECEF frame containing coordinate transformation, position and
     * velocity.
     *
     * @param frame body to ECEF frame to be set.
     */
    public void setFrame(final ECEFFrame frame) {
<span class="fc" id="L1894">        mX = frame.getX();</span>
<span class="fc" id="L1895">        mY = frame.getY();</span>
<span class="fc" id="L1896">        mZ = frame.getZ();</span>

<span class="fc" id="L1898">        mVx = frame.getVx();</span>
<span class="fc" id="L1899">        mVy = frame.getVy();</span>
<span class="fc" id="L1900">        mVz = frame.getVz();</span>

<span class="fc bfc" id="L1902" title="All 2 branches covered.">        if (mBodyToEcefCoordinateTransformationMatrix != null) {</span>
<span class="fc" id="L1903">            frame.getCoordinateTransformationMatrix(mBodyToEcefCoordinateTransformationMatrix);</span>
        } else {
<span class="fc" id="L1905">            mBodyToEcefCoordinateTransformationMatrix = frame.getCoordinateTransformationMatrix();</span>
        }
<span class="fc" id="L1907">    }</span>

    /**
     * Gets estimated accelerometer bias resolved around x axis.
     *
     * @param result instance where estimated accelerometer bias resolved around
     *               x axis will be stored.
     */
    public void getAccelerationBiasXAsAcceleration(final Acceleration result) {
<span class="fc" id="L1916">        result.setValue(mAccelerationBiasX);</span>
<span class="fc" id="L1917">        result.setUnit(AccelerationUnit.METERS_PER_SQUARED_SECOND);</span>
<span class="fc" id="L1918">    }</span>

    /**
     * Gets estimated accelerometer bias resolved around x axis.
     *
     * @return estimated accelerometer bias resolved around x axis.
     */
    public Acceleration getAccelerationBiasXAsAcceleration() {
<span class="fc" id="L1926">        return new Acceleration(mAccelerationBiasX,</span>
                AccelerationUnit.METERS_PER_SQUARED_SECOND);
    }

    /**
     * Sets estimated accelerometer bias resolved around x axis.
     *
     * @param accelerationBiasX estimated accelerometer bias resolved
     *                          around x axis.
     */
    public void setAccelerationBiasX(final Acceleration accelerationBiasX) {
<span class="fc" id="L1937">        mAccelerationBiasX = AccelerationConverter.convert(</span>
<span class="fc" id="L1938">                accelerationBiasX.getValue().doubleValue(),</span>
<span class="fc" id="L1939">                accelerationBiasX.getUnit(),</span>
                AccelerationUnit.METERS_PER_SQUARED_SECOND);
<span class="fc" id="L1941">    }</span>

    /**
     * Gets estimated accelerometer bias resolved around y axis.
     *
     * @param result instance where estimated accelerometer bias resolved around
     *               y axis will be stored.
     */
    public void getAccelerationBiasYAsAcceleration(final Acceleration result) {
<span class="fc" id="L1950">        result.setValue(mAccelerationBiasY);</span>
<span class="fc" id="L1951">        result.setUnit(AccelerationUnit.METERS_PER_SQUARED_SECOND);</span>
<span class="fc" id="L1952">    }</span>

    /**
     * Gets estimated accelerometer bias resolved around y axis.
     *
     * @return estimated accelerometer bias resolved around y axis.
     */
    public Acceleration getAccelerationBiasYAsAcceleration() {
<span class="fc" id="L1960">        return new Acceleration(mAccelerationBiasY,</span>
                AccelerationUnit.METERS_PER_SQUARED_SECOND);
    }

    /**
     * Sets estimated accelerometer bias resolved around y axis.
     *
     * @param accelerationBiasY estimated accelerometer bias resolved
     *                          around y axis.
     */
    public void setAccelerationBiasY(final Acceleration accelerationBiasY) {
<span class="fc" id="L1971">        mAccelerationBiasY = AccelerationConverter.convert(</span>
<span class="fc" id="L1972">                accelerationBiasY.getValue().doubleValue(),</span>
<span class="fc" id="L1973">                accelerationBiasY.getUnit(),</span>
                AccelerationUnit.METERS_PER_SQUARED_SECOND);
<span class="fc" id="L1975">    }</span>

    /**
     * Gets estimated accelerometer bias resolved around z axis.
     *
     * @param result instance where estimated accelerometer bias resolved around
     *               z axis will be stored.
     */
    public void getAccelerationBiasZAsAcceleration(final Acceleration result) {
<span class="fc" id="L1984">        result.setValue(mAccelerationBiasZ);</span>
<span class="fc" id="L1985">        result.setUnit(AccelerationUnit.METERS_PER_SQUARED_SECOND);</span>
<span class="fc" id="L1986">    }</span>

    /**
     * Gets estimated accelerometer bias resolved around z axis.
     *
     * @return estimated accelerometer bias resolved around z axis.
     */
    public Acceleration getAccelerationBiasZAsAcceleration() {
<span class="fc" id="L1994">        return new Acceleration(mAccelerationBiasZ,</span>
                AccelerationUnit.METERS_PER_SQUARED_SECOND);
    }

    /**
     * Sets estimated accelerometer bias resolved around z axis.
     *
     * @param accelerationBiasZ estimated accelerometer bias resolved
     *                          around z axis.
     */
    public void setAccelerationBiasZ(final Acceleration accelerationBiasZ) {
<span class="fc" id="L2005">        mAccelerationBiasZ = AccelerationConverter.convert(</span>
<span class="fc" id="L2006">                accelerationBiasZ.getValue().doubleValue(),</span>
<span class="fc" id="L2007">                accelerationBiasZ.getUnit(),</span>
                AccelerationUnit.METERS_PER_SQUARED_SECOND);
<span class="fc" id="L2009">    }</span>

    /**
     * Sets estimated accelerometer bias coordinates.
     *
     * @param accelerationBiasX estimated accelerometer bias resolved around x axis.
     * @param accelerationBiasY estimated accelerometer bias resolved around y axis.
     * @param accelerationBiasZ estimated accelerometer bias resolved around z axis.
     */
    public void setAccelerationBiasCoordinates(
            final Acceleration accelerationBiasX, final Acceleration accelerationBiasY,
            final Acceleration accelerationBiasZ) {
<span class="fc" id="L2021">        setAccelerationBiasX(accelerationBiasX);</span>
<span class="fc" id="L2022">        setAccelerationBiasY(accelerationBiasY);</span>
<span class="fc" id="L2023">        setAccelerationBiasZ(accelerationBiasZ);</span>
<span class="fc" id="L2024">    }</span>

    /**
     * Gets estimated gyroscope bias resolved around x axis.
     *
     * @param result instance where estimated gyroscope bias resolved around x axis will
     *               be stored.
     */
    public void getAngularSpeedGyroBiasX(final AngularSpeed result) {
<span class="fc" id="L2033">        result.setValue(mGyroBiasX);</span>
<span class="fc" id="L2034">        result.setUnit(AngularSpeedUnit.RADIANS_PER_SECOND);</span>
<span class="fc" id="L2035">    }</span>

    /**
     * Gets estimated gyroscope bias resolved around x axis.
     *
     * @return estimated gyroscope bias resolved around x axis.
     */
    public AngularSpeed getAngularSpeedGyroBiasX() {
<span class="fc" id="L2043">        return new AngularSpeed(mGyroBiasX, AngularSpeedUnit.RADIANS_PER_SECOND);</span>
    }

    /**
     * Sets estimated gyroscope bias resolved around x axis.
     *
     * @param gyroBiasX estimated gyroscope bias resolved around x axis.
     */
    public void setGyroBiasX(final AngularSpeed gyroBiasX) {
<span class="fc" id="L2052">        mGyroBiasX = AngularSpeedConverter.convert(</span>
<span class="fc" id="L2053">                gyroBiasX.getValue().doubleValue(),</span>
<span class="fc" id="L2054">                gyroBiasX.getUnit(), AngularSpeedUnit.RADIANS_PER_SECOND);</span>
<span class="fc" id="L2055">    }</span>

    /**
     * Gets estimated gyroscope bias resolved around y axis.
     *
     * @param result instance where estimated gyroscope bias resolved around y axis will
     *               be stored.
     */
    public void getAngularSpeedGyroBiasY(final AngularSpeed result) {
<span class="fc" id="L2064">        result.setValue(mGyroBiasY);</span>
<span class="fc" id="L2065">        result.setUnit(AngularSpeedUnit.RADIANS_PER_SECOND);</span>
<span class="fc" id="L2066">    }</span>

    /**
     * Gets estimated gyroscope bias resolved around y axis.
     *
     * @return estimated gyroscope bias resolved around y axis.
     */
    public AngularSpeed getAngularSpeedGyroBiasY() {
<span class="fc" id="L2074">        return new AngularSpeed(mGyroBiasY, AngularSpeedUnit.RADIANS_PER_SECOND);</span>
    }

    /**
     * Sets estimated gyroscope bias resolved around y axis.
     *
     * @param gyroBiasY estimated gyroscope bias resolved around y axis.
     */
    public void setGyroBiasY(final AngularSpeed gyroBiasY) {
<span class="fc" id="L2083">        mGyroBiasY = AngularSpeedConverter.convert(</span>
<span class="fc" id="L2084">                gyroBiasY.getValue().doubleValue(),</span>
<span class="fc" id="L2085">                gyroBiasY.getUnit(), AngularSpeedUnit.RADIANS_PER_SECOND);</span>
<span class="fc" id="L2086">    }</span>

    /**
     * Gets estimated gyroscope bias resolved around z axis.
     *
     * @param result instance where estimated gyroscope bias resolved around z axis will
     *               be stored.
     */
    public void getAngularSpeedGyroBiasZ(final AngularSpeed result) {
<span class="fc" id="L2095">        result.setValue(mGyroBiasZ);</span>
<span class="fc" id="L2096">        result.setUnit(AngularSpeedUnit.RADIANS_PER_SECOND);</span>
<span class="fc" id="L2097">    }</span>

    /**
     * Gets estimated gyroscope bias resolved around z axis.
     *
     * @return estimated gyroscope bias resolved around z axis.
     */
    public AngularSpeed getAngularSpeedGyroBiasZ() {
<span class="fc" id="L2105">        return new AngularSpeed(mGyroBiasZ, AngularSpeedUnit.RADIANS_PER_SECOND);</span>
    }

    /**
     * Sets estimated gyroscope bias resolved around z axis.
     *
     * @param gyroBiasZ estimated gyroscope bias resolved around z axis.
     */
    public void setGyroBiasZ(final AngularSpeed gyroBiasZ) {
<span class="fc" id="L2114">        mGyroBiasZ = AngularSpeedConverter.convert(</span>
<span class="fc" id="L2115">                gyroBiasZ.getValue().doubleValue(),</span>
<span class="fc" id="L2116">                gyroBiasZ.getUnit(), AngularSpeedUnit.RADIANS_PER_SECOND);</span>
<span class="fc" id="L2117">    }</span>

    /**
     * Sets estimated gyroscope bias coordinates.
     *
     * @param gyroBiasX estimated gyroscope bias resolved around x axis.
     * @param gyroBiasY estimated gyroscope bias resolved around y axis.
     * @param gyroBiasZ estimated gyroscope bias resolved around z axis.
     */
    public void setGyroBiasCoordinates(
            final AngularSpeed gyroBiasX, final AngularSpeed gyroBiasY,
            final AngularSpeed gyroBiasZ) {
<span class="fc" id="L2129">        setGyroBiasX(gyroBiasX);</span>
<span class="fc" id="L2130">        setGyroBiasY(gyroBiasY);</span>
<span class="fc" id="L2131">        setGyroBiasZ(gyroBiasZ);</span>
<span class="fc" id="L2132">    }</span>

    /**
     * Gets estimated receiver clock offset.
     *
     * @param result instance where estimated receiver clock offset will be stored.
     */
    public void getReceiverClockOffsetAsDistance(final Distance result) {
<span class="fc" id="L2140">        result.setValue(mReceiverClockOffset);</span>
<span class="fc" id="L2141">        result.setUnit(DistanceUnit.METER);</span>
<span class="fc" id="L2142">    }</span>

    /**
     * Gets estimated receiver clock offset.
     *
     * @return estimated receiver clock offset.
     */
    public Distance getReceiverClockOffsetAsDistance() {
<span class="fc" id="L2150">        return new Distance(mReceiverClockOffset, DistanceUnit.METER);</span>
    }

    /**
     * Sets estimated receiver clock offset.
     *
     * @param receiverClockOffset estimated receiver clock offset.
     */
    public void setReceiverClockOffset(final Distance receiverClockOffset) {
<span class="fc" id="L2159">        mReceiverClockOffset = DistanceConverter.convert(</span>
<span class="fc" id="L2160">                receiverClockOffset.getValue().doubleValue(),</span>
<span class="fc" id="L2161">                receiverClockOffset.getUnit(), DistanceUnit.METER);</span>
<span class="fc" id="L2162">    }</span>

    /**
     * Gets estimated receiver clock drift.
     *
     * @param result instance where estimated receiver clock drift will be stored.
     */
    public void getReceiverClockDriftAsSpeed(final Speed result) {
<span class="fc" id="L2170">        result.setValue(mReceiverClockDrift);</span>
<span class="fc" id="L2171">        result.setUnit(SpeedUnit.METERS_PER_SECOND);</span>
<span class="fc" id="L2172">    }</span>

    /**
     * Gets estimated receiver clock drift.
     *
     * @return estimated receiver clock drift.
     */
    public Speed getReceiverClockDriftAsSpeed() {
<span class="fc" id="L2180">        return new Speed(mReceiverClockDrift, SpeedUnit.METERS_PER_SECOND);</span>
    }

    /**
     * Sets estimated receiver clock drift.
     *
     * @param receiverClockDrift estimated receiver clock drift.
     */
    public void setReceiverClockDrift(final Speed receiverClockDrift) {
<span class="fc" id="L2189">        mReceiverClockDrift = SpeedConverter.convert(</span>
<span class="fc" id="L2190">                receiverClockDrift.getValue().doubleValue(),</span>
<span class="fc" id="L2191">                receiverClockDrift.getUnit(), SpeedUnit.METERS_PER_SECOND);</span>
<span class="fc" id="L2192">    }</span>

    /**
     * Gets GNSS estimation from data contained into this instance.
     *
     * @param result instance where GNSS estimation data will be stored.
     */
    public void getGNSSEstimation(final GNSSEstimation result) {
<span class="fc" id="L2200">        result.setPositionCoordinates(mX, mY, mZ);</span>
<span class="fc" id="L2201">        result.setVelocityCoordinates(mVx, mVy, mVz);</span>
<span class="fc" id="L2202">        result.setClockOffset(mReceiverClockOffset);</span>
<span class="fc" id="L2203">        result.setClockDrift(mReceiverClockDrift);</span>
<span class="fc" id="L2204">    }</span>

    /**
     * Gets GNSS estimation from data contained into this instance.
     *
     * @return a new GNSS estimation instance.
     */
    public GNSSEstimation getGNSSEstimation() {
<span class="fc" id="L2212">        return new GNSSEstimation(mX, mY, mZ, mVx, mVy, mVz, mReceiverClockOffset,</span>
                mReceiverClockDrift);
    }

    /**
     * Sets GNSS estimation data into this instance.
     *
     * @param gnssEstimation GNSS estimation data to be set.
     */
    public void setGNSSEstimation(final GNSSEstimation gnssEstimation) {
<span class="fc" id="L2222">        mX = gnssEstimation.getX();</span>
<span class="fc" id="L2223">        mY = gnssEstimation.getY();</span>
<span class="fc" id="L2224">        mZ = gnssEstimation.getZ();</span>

<span class="fc" id="L2226">        mVx = gnssEstimation.getVx();</span>
<span class="fc" id="L2227">        mVy = gnssEstimation.getVy();</span>
<span class="fc" id="L2228">        mVz = gnssEstimation.getVz();</span>

<span class="fc" id="L2230">        mReceiverClockOffset = gnssEstimation.getClockOffset();</span>
<span class="fc" id="L2231">        mReceiverClockDrift = gnssEstimation.getClockDrift();</span>
<span class="fc" id="L2232">    }</span>

    /**
     * Copies this instance data into provided instance.
     *
     * @param output destination instance where data will be copied to.
     */
    public void copyTo(final INSTightlyCoupledKalmanState output) {
<span class="fc" id="L2240">        output.copyFrom(this);</span>
<span class="fc" id="L2241">    }</span>

    /**
     * Copies data of provided instance into this instance.
     *
     * @param input instance to copy data from.
     */
    public void copyFrom(final INSTightlyCoupledKalmanState input) {
        // copy coordinate transformation matrix
<span class="fc bfc" id="L2250" title="All 2 branches covered.">        if (input.mBodyToEcefCoordinateTransformationMatrix == null) {</span>
<span class="fc" id="L2251">            mBodyToEcefCoordinateTransformationMatrix = null;</span>
        } else {
<span class="fc bfc" id="L2253" title="All 2 branches covered.">            if (mBodyToEcefCoordinateTransformationMatrix == null) {</span>
<span class="fc" id="L2254">                mBodyToEcefCoordinateTransformationMatrix =</span>
                        new Matrix(input.mBodyToEcefCoordinateTransformationMatrix);
            } else {
<span class="fc" id="L2257">                mBodyToEcefCoordinateTransformationMatrix.copyFrom(</span>
                        input.mBodyToEcefCoordinateTransformationMatrix);
            }
        }

<span class="fc" id="L2262">        mVx = input.mVx;</span>
<span class="fc" id="L2263">        mVy = input.mVy;</span>
<span class="fc" id="L2264">        mVz = input.mVz;</span>

<span class="fc" id="L2266">        mX = input.mX;</span>
<span class="fc" id="L2267">        mY = input.mY;</span>
<span class="fc" id="L2268">        mZ = input.mZ;</span>

<span class="fc" id="L2270">        mAccelerationBiasX = input.mAccelerationBiasX;</span>
<span class="fc" id="L2271">        mAccelerationBiasY = input.mAccelerationBiasY;</span>
<span class="fc" id="L2272">        mAccelerationBiasZ = input.mAccelerationBiasZ;</span>

<span class="fc" id="L2274">        mGyroBiasX = input.mGyroBiasX;</span>
<span class="fc" id="L2275">        mGyroBiasY = input.mGyroBiasY;</span>
<span class="fc" id="L2276">        mGyroBiasZ = input.mGyroBiasZ;</span>

<span class="fc" id="L2278">        mReceiverClockOffset = input.mReceiverClockOffset;</span>
<span class="fc" id="L2279">        mReceiverClockDrift = input.mReceiverClockDrift;</span>

        // copy covariance
<span class="fc bfc" id="L2282" title="All 2 branches covered.">        if (input.mCovariance == null) {</span>
<span class="fc" id="L2283">            mCovariance = null;</span>
        } else {
<span class="fc bfc" id="L2285" title="All 2 branches covered.">            if (mCovariance == null) {</span>
<span class="fc" id="L2286">                mCovariance = new Matrix(input.mCovariance);</span>
            } else {
<span class="fc" id="L2288">                mCovariance.copyFrom(input.mCovariance);</span>
            }
        }
<span class="fc" id="L2291">    }</span>

    /**
     * Computes and returns hash code for this instance. Hash codes are almost unique
     * values that are useful for fast classification and storage of objects in collections.
     *
     * @return Hash code.
     */
    @Override
    public int hashCode() {
<span class="fc" id="L2301">        return Objects.hash(mBodyToEcefCoordinateTransformationMatrix,</span>
<span class="fc" id="L2302">                mVx, mVy, mVz, mX, mY, mZ,</span>
<span class="fc" id="L2303">                mAccelerationBiasX, mAccelerationBiasY, mAccelerationBiasZ,</span>
<span class="fc" id="L2304">                mGyroBiasX, mGyroBiasY, mGyroBiasZ,</span>
<span class="fc" id="L2305">                mReceiverClockOffset, mReceiverClockDrift, mCovariance);</span>
    }

    /**
     * Checks if provided object is a INSTightlyCoupledKalmanState having exactly the same
     * contents as this instance.
     *
     * @param obj Object to be compared.
     * @return true if both objects are considered to be equal, false otherwise.
     */
    @Override
    public boolean equals(final Object obj) {
<span class="fc bfc" id="L2317" title="All 2 branches covered.">        if (this == obj) {</span>
<span class="fc" id="L2318">            return true;</span>
        }
<span class="fc bfc" id="L2320" title="All 4 branches covered.">        if (obj == null || getClass() != obj.getClass()) {</span>
<span class="fc" id="L2321">            return false;</span>
        }
<span class="fc" id="L2323">        final INSTightlyCoupledKalmanState other = (INSTightlyCoupledKalmanState) obj;</span>
<span class="fc" id="L2324">        return equals(other);</span>
    }

    /**
     * Checks if provided instance has exactly the same contents as this instance.
     *
     * @param other instance to be compared.
     * @return true if both instances are considered to be equal, false otherwise.
     */
    public boolean equals(final INSTightlyCoupledKalmanState other) {
<span class="fc" id="L2334">        return equals(other, 0.0);</span>
    }

    /**
     * Checks if provided instance has contents similar to this instance up to provided
     * threshold value.
     *
     * @param other     instance to be compared.
     * @param threshold maximum difference allowed for values.
     * @return true if both instances are considered to be equal (up to provided threshold),
     * false otherwise.
     */
    public boolean equals(final INSTightlyCoupledKalmanState other,
                          final double threshold) {
<span class="fc bfc" id="L2348" title="All 2 branches covered.">        if (other == null) {</span>
<span class="fc" id="L2349">            return false;</span>
        }

<span class="fc bfc" id="L2352" title="All 2 branches covered.">        return Math.abs(mVx - other.mVx) &lt;= threshold</span>
<span class="pc bpc" id="L2353" title="1 of 2 branches missed.">                &amp;&amp; Math.abs(mVy - other.mVy) &lt;= threshold</span>
<span class="pc bpc" id="L2354" title="1 of 2 branches missed.">                &amp;&amp; Math.abs(mVz - other.mVz) &lt;= threshold</span>
<span class="pc bpc" id="L2355" title="1 of 2 branches missed.">                &amp;&amp; Math.abs(mX - other.mX) &lt;= threshold</span>
<span class="pc bpc" id="L2356" title="1 of 2 branches missed.">                &amp;&amp; Math.abs(mY - other.mY) &lt;= threshold</span>
<span class="pc bpc" id="L2357" title="1 of 2 branches missed.">                &amp;&amp; Math.abs(mZ - other.mZ) &lt;= threshold</span>
<span class="pc bpc" id="L2358" title="1 of 2 branches missed.">                &amp;&amp; Math.abs(mAccelerationBiasX - other.mAccelerationBiasX) &lt;= threshold</span>
<span class="pc bpc" id="L2359" title="1 of 2 branches missed.">                &amp;&amp; Math.abs(mAccelerationBiasY - other.mAccelerationBiasY) &lt;= threshold</span>
<span class="pc bpc" id="L2360" title="1 of 2 branches missed.">                &amp;&amp; Math.abs(mAccelerationBiasZ - other.mAccelerationBiasZ) &lt;= threshold</span>
<span class="pc bpc" id="L2361" title="1 of 2 branches missed.">                &amp;&amp; Math.abs(mGyroBiasX - other.mGyroBiasX) &lt;= threshold</span>
<span class="pc bpc" id="L2362" title="1 of 2 branches missed.">                &amp;&amp; Math.abs(mGyroBiasY - other.mGyroBiasY) &lt;= threshold</span>
<span class="pc bpc" id="L2363" title="1 of 2 branches missed.">                &amp;&amp; Math.abs(mGyroBiasZ - other.mGyroBiasZ) &lt;= threshold</span>
<span class="pc bpc" id="L2364" title="1 of 2 branches missed.">                &amp;&amp; Math.abs(mReceiverClockOffset - other.mReceiverClockOffset) &lt;= threshold</span>
<span class="pc bpc" id="L2365" title="2 of 4 branches missed.">                &amp;&amp; Math.abs(mReceiverClockDrift - other.mReceiverClockDrift) &lt;= threshold</span>
                &amp;&amp; other.mBodyToEcefCoordinateTransformationMatrix != null &amp;&amp;
<span class="pc bpc" id="L2367" title="2 of 4 branches missed.">                other.mBodyToEcefCoordinateTransformationMatrix.equals(mBodyToEcefCoordinateTransformationMatrix,</span>
                        threshold)
<span class="pc bpc" id="L2369" title="1 of 2 branches missed.">                &amp;&amp; other.mCovariance != null &amp;&amp; other.mCovariance.equals(mCovariance, threshold);</span>
    }

    /**
     * Makes a copy of this instance.
     *
     * @return a copy of this instance.
     * @throws CloneNotSupportedException if clone fails for some reason.
     */
    @Override
    protected Object clone() throws CloneNotSupportedException {
<span class="fc" id="L2380">        final INSTightlyCoupledKalmanState result =</span>
<span class="fc" id="L2381">                (INSTightlyCoupledKalmanState) super.clone();</span>
<span class="fc" id="L2382">        copyTo(result);</span>
<span class="fc" id="L2383">        return result;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>