<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>INSGNSSLooselyCoupledKalmanFilteredEstimator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.irurueta:irurueta-navigation</a> &gt; <a href="index.source.html" class="el_package">com.irurueta.navigation.inertial</a> &gt; <span class="el_source">INSGNSSLooselyCoupledKalmanFilteredEstimator.java</span></div><h1>INSGNSSLooselyCoupledKalmanFilteredEstimator.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2020 Alberto Irurueta Carro (alberto@irurueta.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.irurueta.navigation.inertial;

import com.irurueta.navigation.LockedException;
import com.irurueta.navigation.NotReadyException;
import com.irurueta.navigation.frames.CoordinateTransformation;
import com.irurueta.navigation.frames.ECEFFrame;
import com.irurueta.navigation.frames.InvalidSourceAndDestinationFrameTypeException;
import com.irurueta.navigation.geodesic.Constants;
import com.irurueta.navigation.gnss.GNSSEstimation;
import com.irurueta.navigation.gnss.GNSSException;
import com.irurueta.navigation.gnss.GNSSLeastSquaresPositionAndVelocityEstimator;
import com.irurueta.navigation.gnss.GNSSMeasurement;
import com.irurueta.units.Time;
import com.irurueta.units.TimeConverter;
import com.irurueta.units.TimeUnit;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;

/**
 * Calculates position, velocity, attitude and IMU biases using a GNSS unweighted
 * iterated least squares estimator along with an INS loosely coupled Kalman filter
 * to take into account intertial measurements to smooth results.
 * This implementation is based on the equations defined in &quot;Principles of GNSS, Inertial, and Multisensor
 * Integrated Navigation Systems, Second Edition&quot; and on the companion software available at:
 * https://github.com/ymjdz/MATLAB-Codes/blob/master/Loosely_coupled_INS_GNSS.m
 */
public class INSGNSSLooselyCoupledKalmanFilteredEstimator {

    /**
     * Internal estimator to compute least squares solution for GNSS measurements.
     */
<span class="fc" id="L49">    private final GNSSLeastSquaresPositionAndVelocityEstimator mLsEstimator</span>
            = new GNSSLeastSquaresPositionAndVelocityEstimator();

    /**
     * Internal INS estimator to update kinematic measures and propagate
     * estimated state.
     */
<span class="fc" id="L56">    private final INSLooselyCoupledKalmanFilteredEstimator mInsEstimator =</span>
            new INSLooselyCoupledKalmanFilteredEstimator(
<span class="fc" id="L58">                    new INSLooselyCoupledKalmanFilteredEstimatorListener() {</span>
                        @Override
                        public void onUpdateStart(
                                final INSLooselyCoupledKalmanFilteredEstimator estimator) {
<span class="pc bpc" id="L62" title="1 of 2 branches missed.">                            if (mListener != null) {</span>
<span class="fc" id="L63">                                mListener.onUpdateBodyKinematicsStart(</span>
                                        INSGNSSLooselyCoupledKalmanFilteredEstimator.this);
                            }
<span class="fc" id="L66">                        }</span>

                        @Override
                        public void onUpdateEnd(
                                final INSLooselyCoupledKalmanFilteredEstimator estimator) {
<span class="pc bpc" id="L71" title="1 of 2 branches missed.">                            if (mListener != null) {</span>
<span class="fc" id="L72">                                mListener.onUpdateBodyKinematicsEnd(</span>
                                        INSGNSSLooselyCoupledKalmanFilteredEstimator.this);
                            }
<span class="fc" id="L75">                        }</span>

                        @Override
                        public void onPropagateStart(
                                final INSLooselyCoupledKalmanFilteredEstimator estimator) {
<span class="pc bpc" id="L80" title="1 of 2 branches missed.">                            if (mListener != null) {</span>
<span class="fc" id="L81">                                mListener.onPropagateStart(</span>
                                        INSGNSSLooselyCoupledKalmanFilteredEstimator.this);
                            }
<span class="fc" id="L84">                        }</span>

                        @Override
                        public void onPropagateEnd(
                                final INSLooselyCoupledKalmanFilteredEstimator estimator) {
<span class="pc bpc" id="L89" title="1 of 2 branches missed.">                            if (mListener != null) {</span>
<span class="fc" id="L90">                                mListener.onPropagateEnd(</span>
                                        INSGNSSLooselyCoupledKalmanFilteredEstimator.this);
                            }
<span class="fc" id="L93">                        }</span>

                        @Override
                        public void onReset(
                                final INSLooselyCoupledKalmanFilteredEstimator estimator) {
<span class="fc" id="L98">                        }</span>
                    });

    /**
     * Listener to notify events raised by this instance.
     */
    private INSGNSSLooselyCoupledKalmanFilteredEstimatorListener mListener;

    /**
     * GNSS measurements of a collection of satellites.
     */
    private Collection&lt;GNSSMeasurement&gt; mMeasurements;

    /**
     * Last provided user kinematics containing applied specific force
     * and angular rates resolved in body axes.
     */
    private BodyKinematics mKinematics;

    /**
     * Contains last provided user kinematics minus currently estimated bias
     * for acceleration and angular rate values.
     */
    private BodyKinematics mCorrectedKinematics;

    /**
     * Internally keeps user position, velocity and attitude.
     */
    private ECEFFrame mFrame;

    /**
     * Current Kalman filter state containing current INS estimation along with
     * Kalman filter covariance error matrix.
     */
    private INSLooselyCoupledKalmanState mState;

    /**
     * Current estimation containing user ECEF position, user ECEF velocity, clock offset
     * and clock drift.
     */
    private GNSSEstimation mEstimation;

    /**
     * Indicates whether this estimator is running or not.
     */
    private boolean mRunning;

    /**
     * Constructor.
     */
<span class="fc" id="L148">    public INSGNSSLooselyCoupledKalmanFilteredEstimator() {</span>
<span class="fc" id="L149">    }</span>

    /**
     * Constructor.
     *
     * @param config INS Kalman filter configuration parameters (usually obtained
     *               through calibration).
     */
    public INSGNSSLooselyCoupledKalmanFilteredEstimator(
<span class="fc" id="L158">            final INSLooselyCoupledKalmanConfig config) {</span>
        try {
<span class="fc" id="L160">            mInsEstimator.setConfig(config);</span>
<span class="nc" id="L161">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L163">        }</span>
<span class="fc" id="L164">    }</span>

    /**
     * Constructor.
     *
     * @param epochInterval minimum epoch interval expressed in seconds (s) between
     *                      consecutive propagations or measurements.
     * @throws IllegalArgumentException if provided epoch interval is negative.
     */
    public INSGNSSLooselyCoupledKalmanFilteredEstimator(
<span class="fc" id="L174">            final double epochInterval) {</span>
        try {
<span class="fc" id="L176">            mInsEstimator.setEpochInterval(epochInterval);</span>
<span class="nc" id="L177">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L179">        }</span>
<span class="fc" id="L180">    }</span>

    /**
     * Constructor.
     *
     * @param listener listener to notify events raised by this instance.
     */
    public INSGNSSLooselyCoupledKalmanFilteredEstimator(
<span class="fc" id="L188">            final INSGNSSLooselyCoupledKalmanFilteredEstimatorListener listener) {</span>
<span class="fc" id="L189">        mListener = listener;</span>
<span class="fc" id="L190">    }</span>

    /**
     * Constructor.
     *
     * @param config        INS loosely coupled Kalman filter configuration parameters
     *                      (usually obtained through calibration).
     * @param epochInterval minimum epoch interval expressed in seconds (s) between
     *                      consecutive propagations or measurements.
     * @throws IllegalArgumentException if provided epoch interval is negative.
     */
    public INSGNSSLooselyCoupledKalmanFilteredEstimator(
            final INSLooselyCoupledKalmanConfig config, final double epochInterval) {
<span class="fc" id="L203">        this(epochInterval);</span>
        try {
<span class="fc" id="L205">            mInsEstimator.setConfig(config);</span>
<span class="nc" id="L206">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L208">        }</span>
<span class="fc" id="L209">    }</span>

    /**
     * Constructor.
     *
     * @param config   INS loosely coupled Kalman filter configuration parameters
     *                 (usually obtained through calibration).
     * @param listener listener to notify events raised by this instance.
     */
    public INSGNSSLooselyCoupledKalmanFilteredEstimator(
            final INSLooselyCoupledKalmanConfig config,
            final INSGNSSLooselyCoupledKalmanFilteredEstimatorListener listener) {
<span class="fc" id="L221">        this(config);</span>
<span class="fc" id="L222">        mListener = listener;</span>
<span class="fc" id="L223">    }</span>

    /**
     * Constructor.
     *
     * @param epochInterval minimum epoch interval expressed in seconds (s) between
     *                      consecutive propagations or measurements.
     * @param listener      listener to notify events raised by this instance.
     * @throws IllegalArgumentException if provided epoch interval is negative.
     */
    public INSGNSSLooselyCoupledKalmanFilteredEstimator(
            final double epochInterval,
            final INSGNSSLooselyCoupledKalmanFilteredEstimatorListener listener) {
<span class="fc" id="L236">        this(epochInterval);</span>
<span class="fc" id="L237">        mListener = listener;</span>
<span class="fc" id="L238">    }</span>

    /**
     * Constructor.
     *
     * @param config        INS loosely coupled Kalman filter configuration parameters
     *                      (usually obtained through calibration).
     * @param epochInterval minimum epoch interval expressed in seconds (s) between
     *                      consecutive propagations or measurements.
     * @param listener      listener to notify events raised by this instance.
     * @throws IllegalArgumentException if provided epoch interval is negative.
     */
    public INSGNSSLooselyCoupledKalmanFilteredEstimator(
            final INSLooselyCoupledKalmanConfig config, final double epochInterval,
            final INSGNSSLooselyCoupledKalmanFilteredEstimatorListener listener) {
<span class="fc" id="L253">        this(config, epochInterval);</span>
<span class="fc" id="L254">        mListener = listener;</span>
<span class="fc" id="L255">    }</span>

    /**
     * Constructor.
     *
     * @param epochInterval minimum epoch interval between consecutive
     *                      propagations or measurements.
     * @throws IllegalArgumentException if provided epoch interval is negative.
     */
    public INSGNSSLooselyCoupledKalmanFilteredEstimator(final Time epochInterval) {
<span class="fc" id="L265">        this(TimeConverter.convert(epochInterval.getValue().doubleValue(),</span>
<span class="fc" id="L266">                epochInterval.getUnit(), TimeUnit.SECOND));</span>
<span class="fc" id="L267">    }</span>

    /**
     * Constructor.
     *
     * @param config        INS loosely coupled Kalman filter configuration parameters
     *                      (usually obtained through calibration).
     * @param epochInterval minimum epoch interval between consecutive propagations
     *                      or measurements.
     * @throws IllegalArgumentException if provided epoch interval is negative.
     */
    public INSGNSSLooselyCoupledKalmanFilteredEstimator(
            final INSLooselyCoupledKalmanConfig config, final Time epochInterval) {
<span class="fc" id="L280">        this(config, TimeConverter.convert(epochInterval.getValue().doubleValue(),</span>
<span class="fc" id="L281">                epochInterval.getUnit(), TimeUnit.SECOND));</span>
<span class="fc" id="L282">    }</span>

    /**
     * Constructor.
     *
     * @param epochInterval minimum epoch interval between consecutive
     *                      propagations or measurements.
     * @param listener      listener to notify events raised by this instance.
     * @throws IllegalArgumentException if provided epoch interval is negative.
     */
    public INSGNSSLooselyCoupledKalmanFilteredEstimator(
            final Time epochInterval,
            final INSGNSSLooselyCoupledKalmanFilteredEstimatorListener listener) {
<span class="fc" id="L295">        this(epochInterval);</span>
<span class="fc" id="L296">        mListener = listener;</span>
<span class="fc" id="L297">    }</span>

    /**
     * Constructor.
     *
     * @param config        INS loosely coupled Kalman filter configuration parameters
     *                      (usually obtained through calibration).
     * @param epochInterval minimum epoch interval between consecutive
     *                      propagations or measurements.
     * @param listener      listener to notify events raised by this instance.
     * @throws IllegalArgumentException if provided epoch interval is negative.
     */
    public INSGNSSLooselyCoupledKalmanFilteredEstimator(
            final INSLooselyCoupledKalmanConfig config, final Time epochInterval,
            final INSGNSSLooselyCoupledKalmanFilteredEstimatorListener listener) {
<span class="fc" id="L312">        this(config, epochInterval);</span>
<span class="fc" id="L313">        mListener = listener;</span>
<span class="fc" id="L314">    }</span>

    /**
     * Constructor.
     *
     * @param c body-to-ECEF coordinate transformation defining the initial body
     *          attitude.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not valid.
     */
    public INSGNSSLooselyCoupledKalmanFilteredEstimator(final CoordinateTransformation c)
            throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L326">        this();</span>
        try {
<span class="fc" id="L328">            setCoordinateTransformation(c);</span>
<span class="nc" id="L329">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L331">        }</span>
<span class="fc" id="L332">    }</span>

    /**
     * Constructor.
     *
     * @param config INS loosely Kalman filter configuration parameters (usually obtained
     *               through calibration).
     * @param c      body-to-ECEF coordinate transformation defining the initial body
     *               attitude.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not valid.
     */
    public INSGNSSLooselyCoupledKalmanFilteredEstimator(
            final INSLooselyCoupledKalmanConfig config,
            final CoordinateTransformation c)
            throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L348">        this(c);</span>
        try {
<span class="fc" id="L350">            mInsEstimator.setConfig(config);</span>
<span class="nc" id="L351">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L353">        }</span>
<span class="fc" id="L354">    }</span>

    /**
     * Constructor.
     *
     * @param epochInterval minimum epoch interval expressed in seconds (s) between
     *                      consecutive propagations or measurements.
     * @param c             body-to-ECEF coordinate transformation defining the initial body
     *                      attitude.
     * @throws IllegalArgumentException                      if provided epoch interval
     *                                                       is negative.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not valid.
     */
    public INSGNSSLooselyCoupledKalmanFilteredEstimator(
            final double epochInterval, final CoordinateTransformation c)
            throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L371">        this(epochInterval);</span>
        try {
<span class="fc" id="L373">            setCoordinateTransformation(c);</span>
<span class="nc" id="L374">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L376">        }</span>
<span class="fc" id="L377">    }</span>

    /**
     * Constructor.
     *
     * @param c        body-to-ECEF coordinate transformation defining the initial body
     *                 attitude.
     * @param listener listener to notify events raised by this instance.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not valid.
     */
    public INSGNSSLooselyCoupledKalmanFilteredEstimator(
            final CoordinateTransformation c,
            final INSGNSSLooselyCoupledKalmanFilteredEstimatorListener listener)
            throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L392">        this(c);</span>
<span class="fc" id="L393">        mListener = listener;</span>
<span class="fc" id="L394">    }</span>

    /**
     * Constructor.
     *
     * @param config        INS loosely coupled Kalman filter configuration
     *                      parameters (usually obtained through calibration).
     * @param epochInterval minimum epoch interval expressed in seconds (s) between
     *                      consecutive propagations or measurements.
     * @param c             body-to-ECEF coordinate transformation defining the initial body
     *                      attitude.
     * @throws IllegalArgumentException                      if provided epoch interval
     *                                                       is negative.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not valid.
     */
    public INSGNSSLooselyCoupledKalmanFilteredEstimator(
            final INSLooselyCoupledKalmanConfig config, final double epochInterval,
            final CoordinateTransformation c)
            throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L414">        this(config, epochInterval);</span>
        try {
<span class="fc" id="L416">            setCoordinateTransformation(c);</span>
<span class="nc" id="L417">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L419">        }</span>
<span class="fc" id="L420">    }</span>

    /**
     * Constructor.
     *
     * @param config   INS loosely coupled Kalman filter configuration parameters
     *                 (usually obtained through calibration).
     * @param c        body-to-ECEF coordinate transformation defining the initial body
     *                 attitude.
     * @param listener listener to notify events raised by this instance.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not valid.
     */
    public INSGNSSLooselyCoupledKalmanFilteredEstimator(
            final INSLooselyCoupledKalmanConfig config,
            final CoordinateTransformation c,
            final INSGNSSLooselyCoupledKalmanFilteredEstimatorListener listener)
            throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L438">        this(config, listener);</span>
        try {
<span class="fc" id="L440">            setCoordinateTransformation(c);</span>
<span class="nc" id="L441">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L443">        }</span>
<span class="fc" id="L444">    }</span>

    /**
     * Constructor.
     *
     * @param epochInterval minimum epoch interval expressed in seconds (s) between
     *                      consecutive propagations or measurements.
     * @param c             body-to-ECEF coordinate transformation defining the initial
     *                      body attitude.
     * @param listener      listener to notify events raised by this instance.
     * @throws IllegalArgumentException                      if provided epoch interval
     *                                                       is negative.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not valid.
     */
    public INSGNSSLooselyCoupledKalmanFilteredEstimator(
            final double epochInterval,
            final CoordinateTransformation c,
            final INSGNSSLooselyCoupledKalmanFilteredEstimatorListener listener)
            throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L464">        this(epochInterval, listener);</span>
        try {
<span class="fc" id="L466">            setCoordinateTransformation(c);</span>
<span class="nc" id="L467">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L469">        }</span>
<span class="fc" id="L470">    }</span>

    /**
     * Constructor.
     *
     * @param config        INS loosely coupled Kalman filter configuration
     *                      parameters (usually obtained through calibration).
     * @param epochInterval minimum epoch interval expressed in seconds (s) between
     *                      consecutive propagations or measurements.
     * @param c             body-to-ECEF coordinate transformation defining the initial
     *                      body attitude.
     * @param listener      listener to notify events raised by this instance.
     * @throws IllegalArgumentException                      if provided epoch interval
     *                                                       is negative.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not valid.
     */
    public INSGNSSLooselyCoupledKalmanFilteredEstimator(
            final INSLooselyCoupledKalmanConfig config, final double epochInterval,
            final CoordinateTransformation c,
            final INSGNSSLooselyCoupledKalmanFilteredEstimatorListener listener)
            throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L492">        this(config, epochInterval, listener);</span>
        try {
<span class="fc" id="L494">            setCoordinateTransformation(c);</span>
<span class="nc" id="L495">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L497">        }</span>
<span class="fc" id="L498">    }</span>

    /**
     * Constructor.
     *
     * @param epochInterval minimum epoch interval between consecutive propagations
     *                      or measurements.
     * @param c             body-to-ECEF coordinate transformation defining the initial
     *                      body attitude.
     * @throws IllegalArgumentException                      if provided epoch interval
     *                                                       is negative.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not valid.
     */
    public INSGNSSLooselyCoupledKalmanFilteredEstimator(
            final Time epochInterval, final CoordinateTransformation c)
            throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L515">        this(epochInterval);</span>
        try {
<span class="fc" id="L517">            setCoordinateTransformation(c);</span>
<span class="nc" id="L518">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L520">        }</span>
<span class="fc" id="L521">    }</span>

    /**
     * Constructor.
     *
     * @param config        INS loosely coupled Kalman filter configuration
     *                      parameters (usually obtained through calibration).
     * @param epochInterval minimum epoch interval between consecutive
     *                      propagations or measurements.
     * @param c             body-to-ECEF coordinate transformation defining the
     *                      initial body attitude.
     * @throws IllegalArgumentException                      if provided epoch interval
     *                                                       is negative.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not valid.
     */
    public INSGNSSLooselyCoupledKalmanFilteredEstimator(
            final INSLooselyCoupledKalmanConfig config, final Time epochInterval,
            final CoordinateTransformation c)
            throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L541">        this(config, epochInterval);</span>
        try {
<span class="fc" id="L543">            setCoordinateTransformation(c);</span>
<span class="nc" id="L544">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L546">        }</span>
<span class="fc" id="L547">    }</span>

    /**
     * Constructor.
     *
     * @param epochInterval minimum epoch interval between consecutive propagations
     *                      or measurements.
     * @param c             body-to-ECEF coordinate transformation defining the initial
     *                      body attitude.
     * @param listener      listener to notify events raised by this instance.
     * @throws IllegalArgumentException                      if provided epoch interval
     *                                                       is negative.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not valid.
     */
    public INSGNSSLooselyCoupledKalmanFilteredEstimator(
            final Time epochInterval,
            final CoordinateTransformation c,
            final INSGNSSLooselyCoupledKalmanFilteredEstimatorListener listener)
            throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L567">        this(epochInterval, listener);</span>
        try {
<span class="fc" id="L569">            setCoordinateTransformation(c);</span>
<span class="nc" id="L570">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L572">        }</span>
<span class="fc" id="L573">    }</span>

    /**
     * Constructor.
     *
     * @param config        INS loosely coupled Kalman filter configuration parameters
     *                      (usually obtained through calibration).
     * @param epochInterval minimum epoch interval between consecutive
     *                      propagations or measurements.
     * @param c             body-to-ECEF coordinate transformation defining the initial
     *                      body attitude.
     * @param listener      listener to notify events raised by this instance.
     * @throws IllegalArgumentException                      if provided epoch interval
     *                                                       is negative.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not valid.
     */
    public INSGNSSLooselyCoupledKalmanFilteredEstimator(
            final INSLooselyCoupledKalmanConfig config, final Time epochInterval,
            final CoordinateTransformation c,
            final INSGNSSLooselyCoupledKalmanFilteredEstimatorListener listener)
            throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L595">        this(config, epochInterval, listener);</span>
        try {
<span class="fc" id="L597">            setCoordinateTransformation(c);</span>
<span class="nc" id="L598">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L600">        }</span>
<span class="fc" id="L601">    }</span>

    /**
     * Constructor.
     *
     * @param initialConfig initial INS loosely coupled Kalman configuration to
     *                      set proper initial covariance during filter initialization.
     */
    public INSGNSSLooselyCoupledKalmanFilteredEstimator(
            final INSLooselyCoupledKalmanInitializerConfig initialConfig) {
<span class="fc" id="L611">        this();</span>
        try {
<span class="fc" id="L613">            setInitialConfig(initialConfig);</span>
<span class="nc" id="L614">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L616">        }</span>
<span class="fc" id="L617">    }</span>

    /**
     * Constructor.
     *
     * @param config        INS loosely Kalman filter configuration parameters
     *                      (usually obtained through calibration).
     * @param initialConfig initial INS loosely coupled Kalman configuration to
     *                      set proper initial covariance during filter initialization.
     */
    public INSGNSSLooselyCoupledKalmanFilteredEstimator(
            final INSLooselyCoupledKalmanConfig config,
            final INSLooselyCoupledKalmanInitializerConfig initialConfig) {
<span class="fc" id="L630">        this(config);</span>
        try {
<span class="fc" id="L632">            setInitialConfig(initialConfig);</span>
<span class="nc" id="L633">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L635">        }</span>
<span class="fc" id="L636">    }</span>

    /**
     * Constructor.
     *
     * @param epochInterval minimum epoch interval expressed in seconds (s) between
     *                      consecutive propagations or measurements.
     * @param initialConfig initial INS loosely coupled Kalman configuration to
     *                      set proper initial covariance during filter initialization.
     * @throws IllegalArgumentException if provided epoch interval is negative.
     */
    public INSGNSSLooselyCoupledKalmanFilteredEstimator(
            final double epochInterval,
            final INSLooselyCoupledKalmanInitializerConfig initialConfig) {
<span class="fc" id="L650">        this(epochInterval);</span>
        try {
<span class="fc" id="L652">            setInitialConfig(initialConfig);</span>
<span class="nc" id="L653">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L655">        }</span>
<span class="fc" id="L656">    }</span>

    /**
     * Constructor.
     *
     * @param initialConfig initial INS loosely coupled Kalman configuration to
     *                      set proper initial covariance during filter initialization.
     * @param listener      listener to notify events raised by this instance.
     */
    public INSGNSSLooselyCoupledKalmanFilteredEstimator(
            final INSLooselyCoupledKalmanInitializerConfig initialConfig,
            final INSGNSSLooselyCoupledKalmanFilteredEstimatorListener listener) {
<span class="fc" id="L668">        this(initialConfig);</span>
<span class="fc" id="L669">        mListener = listener;</span>
<span class="fc" id="L670">    }</span>

    /**
     * Constructor.
     *
     * @param config        INS loosely coupled Kalman filter configuration parameters
     *                      (usually obtained through calibration).
     * @param epochInterval minimum epoch interval expressed in seconds (s) between
     *                      consecutive propagations or measurements.
     * @param initialConfig initial INS loosely coupled Kalman configuration to
     *                      set proper initial covariance during filter initialization.
     * @throws IllegalArgumentException if provided epoch interval is negative.
     */
    public INSGNSSLooselyCoupledKalmanFilteredEstimator(
            final INSLooselyCoupledKalmanConfig config, final double epochInterval,
            final INSLooselyCoupledKalmanInitializerConfig initialConfig) {
<span class="fc" id="L686">        this(config, epochInterval);</span>
        try {
<span class="fc" id="L688">            setInitialConfig(initialConfig);</span>
<span class="nc" id="L689">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L691">        }</span>
<span class="fc" id="L692">    }</span>

    /**
     * Constructor.
     *
     * @param config        INS loosely coupled Kalman filter configuration parameters
     *                      (usually obtained through calibration).
     * @param initialConfig initial INS loosely coupled Kalman configuration to
     *                      set proper initial covariance during filter initialization.
     * @param listener      listener to notify events raised by this instance.
     */
    public INSGNSSLooselyCoupledKalmanFilteredEstimator(
            final INSLooselyCoupledKalmanConfig config,
            final INSLooselyCoupledKalmanInitializerConfig initialConfig,
            final INSGNSSLooselyCoupledKalmanFilteredEstimatorListener listener) {
<span class="fc" id="L707">        this(config, listener);</span>
        try {
<span class="fc" id="L709">            setInitialConfig(initialConfig);</span>
<span class="nc" id="L710">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L712">        }</span>
<span class="fc" id="L713">    }</span>

    /**
     * Constructor.
     *
     * @param epochInterval minimum epoch interval expressed in seconds (s) between
     *                      consecutive propagations or measurements.
     * @param initialConfig initial INS loosely coupled Kalman configuration to
     *                      set proper initial covariance during filter initialization.
     * @param listener      listener to notify events raised by this instance.
     * @throws IllegalArgumentException if provided epoch interval is negative.
     */
    public INSGNSSLooselyCoupledKalmanFilteredEstimator(
            final double epochInterval,
            final INSLooselyCoupledKalmanInitializerConfig initialConfig,
            final INSGNSSLooselyCoupledKalmanFilteredEstimatorListener listener) {
<span class="fc" id="L729">        this(epochInterval, listener);</span>
        try {
<span class="fc" id="L731">            setInitialConfig(initialConfig);</span>
<span class="nc" id="L732">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L734">        }</span>
<span class="fc" id="L735">    }</span>

    /**
     * Constructor.
     *
     * @param config        INS loosely coupled Kalman filter configuration parameters
     *                      (usually obtained through calibration).
     * @param epochInterval minimum epoch interval expressed in seconds (s) between
     *                      consecutive propagations or measurements.
     * @param initialConfig initial INS loosely coupled Kalman configuration to
     *                      set proper initial covariance during filter initialization.
     * @param listener      listener to notify events raised by this instance.
     * @throws IllegalArgumentException if provided epoch interval is negative.
     */
    public INSGNSSLooselyCoupledKalmanFilteredEstimator(
            final INSLooselyCoupledKalmanConfig config, final double epochInterval,
            final INSLooselyCoupledKalmanInitializerConfig initialConfig,
            final INSGNSSLooselyCoupledKalmanFilteredEstimatorListener listener) {
<span class="fc" id="L753">        this(config, epochInterval, listener);</span>
        try {
<span class="fc" id="L755">            setInitialConfig(initialConfig);</span>
<span class="nc" id="L756">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L758">        }</span>
<span class="fc" id="L759">    }</span>

    /**
     * Constructor.
     *
     * @param epochInterval minimum epoch interval between consecutive propagations
     *                      or measurements.
     * @param initialConfig initial INS loosely coupled Kalman configuration to set
     *                      proper initial covariance during filter initialization.
     * @throws IllegalArgumentException if provided epoch interval is negative.
     */
    public INSGNSSLooselyCoupledKalmanFilteredEstimator(
            final Time epochInterval,
            final INSLooselyCoupledKalmanInitializerConfig initialConfig) {
<span class="fc" id="L773">        this(epochInterval);</span>
        try {
<span class="fc" id="L775">            setInitialConfig(initialConfig);</span>
<span class="nc" id="L776">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L778">        }</span>
<span class="fc" id="L779">    }</span>

    /**
     * Constructor.
     *
     * @param config        INS loosely coupled Kalman filter configuration parameters
     *                      (usually obtained through calibration).
     * @param epochInterval minimum epoch interval between consecutive propagations
     *                      or measurements.
     * @param initialConfig initial INS loosely coupled Kalman configuration to
     *                      set proper initial covariance during filter initialization.
     * @throws IllegalArgumentException if provided epoch interval is negative.
     */
    public INSGNSSLooselyCoupledKalmanFilteredEstimator(
            final INSLooselyCoupledKalmanConfig config, final Time epochInterval,
            final INSLooselyCoupledKalmanInitializerConfig initialConfig) {
<span class="fc" id="L795">        this(config, epochInterval);</span>
        try {
<span class="fc" id="L797">            setInitialConfig(initialConfig);</span>
<span class="nc" id="L798">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L800">        }</span>
<span class="fc" id="L801">    }</span>

    /**
     * Constructor.
     *
     * @param epochInterval minimum epoch interval between consecutive propagations
     *                      or measurements.
     * @param initialConfig initial INS loosely coupled Kalman configuration to
     *                      set proper initial covariance during filter initialization.
     * @param listener      listener to notify events raised by this instance.
     * @throws IllegalArgumentException if provided epoch interval is negative.
     */
    public INSGNSSLooselyCoupledKalmanFilteredEstimator(
            final Time epochInterval,
            final INSLooselyCoupledKalmanInitializerConfig initialConfig,
            final INSGNSSLooselyCoupledKalmanFilteredEstimatorListener listener) {
<span class="fc" id="L817">        this(epochInterval, listener);</span>
        try {
<span class="fc" id="L819">            setInitialConfig(initialConfig);</span>
<span class="nc" id="L820">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L822">        }</span>
<span class="fc" id="L823">    }</span>

    /**
     * Constructor.
     *
     * @param config        INS loosely coupled Kalman filter configuration parameters
     *                      (usually obtained through calibration).
     * @param epochInterval minimum epoch interval between consecutive propagations
     *                      or measurements.
     * @param initialConfig initial INS loosely coupled Kalman configuration to set
     *                      proper initial covariance during filter initialization.
     * @param listener      listener to notify events raised by this instance.
     * @throws IllegalArgumentException if provided epoch interval is negative.
     */
    public INSGNSSLooselyCoupledKalmanFilteredEstimator(
            final INSLooselyCoupledKalmanConfig config, final Time epochInterval,
            final INSLooselyCoupledKalmanInitializerConfig initialConfig,
            final INSGNSSLooselyCoupledKalmanFilteredEstimatorListener listener) {
<span class="fc" id="L841">        this(config, epochInterval, listener);</span>
        try {
<span class="fc" id="L843">            setInitialConfig(initialConfig);</span>
<span class="nc" id="L844">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L846">        }</span>
<span class="fc" id="L847">    }</span>

    /**
     * Constructor.
     *
     * @param initialConfig initial INS loosely coupled Kalman configuration to
     *                      set proper initial covariance during filter initialization.
     * @param c             body-to-ECEF coordinate transformation defining the initial body
     *                      attitude.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not valid.
     */
    public INSGNSSLooselyCoupledKalmanFilteredEstimator(
            final INSLooselyCoupledKalmanInitializerConfig initialConfig,
            final CoordinateTransformation c)
            throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L863">        this(c);</span>
        try {
<span class="fc" id="L865">            setInitialConfig(initialConfig);</span>
<span class="nc" id="L866">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L868">        }</span>
<span class="fc" id="L869">    }</span>

    /**
     * Constructor.
     *
     * @param config        INS loosely Kalman filter configuration parameters (usually
     *                      obtained through calibration).
     * @param initialConfig initial INS loosely coupled Kalman configuration to set
     *                      proper initial covariance during filter initialization.
     * @param c             body-to-ECEF coordinate transformation defining the initial
     *                      body attitude.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not valid.
     */
    public INSGNSSLooselyCoupledKalmanFilteredEstimator(
            final INSLooselyCoupledKalmanConfig config,
            final INSLooselyCoupledKalmanInitializerConfig initialConfig,
            final CoordinateTransformation c)
            throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L888">        this(config, c);</span>
        try {
<span class="fc" id="L890">            setInitialConfig(initialConfig);</span>
<span class="nc" id="L891">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L893">        }</span>
<span class="fc" id="L894">    }</span>

    /**
     * Constructor.
     *
     * @param epochInterval minimum epoch interval expressed in seconds (s) between
     *                      consecutive propagations or measurements.
     * @param initialConfig initial INS loosely coupled Kalman configuration to
     *                      set proper initial covariance during filter initialization.
     * @param c             body-to-ECEF coordinate transformation defining the initial
     *                      body attitude.
     * @throws IllegalArgumentException                      if provided epoch interval
     *                                                       is negative.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not valid.
     */
    public INSGNSSLooselyCoupledKalmanFilteredEstimator(
            final double epochInterval,
            final INSLooselyCoupledKalmanInitializerConfig initialConfig,
            final CoordinateTransformation c)
            throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L915">        this(epochInterval, c);</span>
        try {
<span class="fc" id="L917">            setInitialConfig(initialConfig);</span>
<span class="nc" id="L918">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L920">        }</span>
<span class="fc" id="L921">    }</span>

    /**
     * Constructor.
     *
     * @param initialConfig initial INS loosely coupled Kalman configuration to
     *                      set proper initial covariance during filter initialization.
     * @param c             body-to-ECEF coordinate transformation defining the initial
     *                      body attitude.
     * @param listener      listener to notify events raised by this instance.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not valid.
     */
    public INSGNSSLooselyCoupledKalmanFilteredEstimator(
            final INSLooselyCoupledKalmanInitializerConfig initialConfig,
            final CoordinateTransformation c,
            final INSGNSSLooselyCoupledKalmanFilteredEstimatorListener listener)
            throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L939">        this(c, listener);</span>
        try {
<span class="fc" id="L941">            setInitialConfig(initialConfig);</span>
<span class="nc" id="L942">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L944">        }</span>
<span class="fc" id="L945">    }</span>

    /**
     * Constructor.
     *
     * @param config        INS loosely coupled Kalman filter configuration parameters
     *                      (usually obtained through calibration).
     * @param epochInterval minimum epoch interval expressed in seconds (s) between
     *                      consecutive propagations or measurements.
     * @param initialConfig initial INS loosely coupled Kalman configuration to set
     *                      proper initial covariance during filter initialization.
     * @param c             body-to-ECEF coordinate transformation defining the initial
     *                      body attitude.
     * @throws IllegalArgumentException                      if provided epoch interval
     *                                                       is negative.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not valid.
     */
    public INSGNSSLooselyCoupledKalmanFilteredEstimator(
            final INSLooselyCoupledKalmanConfig config, final double epochInterval,
            final INSLooselyCoupledKalmanInitializerConfig initialConfig,
            final CoordinateTransformation c)
            throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L968">        this(config, epochInterval, c);</span>
        try {
<span class="fc" id="L970">            setInitialConfig(initialConfig);</span>
<span class="nc" id="L971">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L973">        }</span>
<span class="fc" id="L974">    }</span>

    /**
     * Constructor.
     *
     * @param config        INS loosely coupled Kalman filter configuration parameters
     *                      (usually obtained through calibration).
     * @param initialConfig initial INS loosely coupled Kalman configuration to
     *                      set proper initial covariance during filter initialization.
     * @param c             body-to-ECEF coordinate transformation defining the initial
     *                      body attitude.
     * @param listener      listener to notify events raised by this instance.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not valid.
     */
    public INSGNSSLooselyCoupledKalmanFilteredEstimator(
            final INSLooselyCoupledKalmanConfig config,
            final INSLooselyCoupledKalmanInitializerConfig initialConfig,
            final CoordinateTransformation c,
            final INSGNSSLooselyCoupledKalmanFilteredEstimatorListener listener)
            throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L995">        this(config, c, listener);</span>
        try {
<span class="fc" id="L997">            setInitialConfig(initialConfig);</span>
<span class="nc" id="L998">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L1000">        }</span>
<span class="fc" id="L1001">    }</span>

    /**
     * Constructor.
     *
     * @param epochInterval minimum epoch interval expressed in seconds (s) between
     *                      consecutive propagations or measurements.
     * @param initialConfig initial INS loosely coupled Kalman configuration to
     *                      set proper initial covariance during filter initialization.
     * @param c             body-to-ECEF coordinate transformation defining the initial
     *                      body attitude.
     * @param listener      listener to notify events raised by this instance.
     * @throws IllegalArgumentException                      if provided epoch interval
     *                                                       is negative.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not valid.
     */
    public INSGNSSLooselyCoupledKalmanFilteredEstimator(
            final double epochInterval,
            final INSLooselyCoupledKalmanInitializerConfig initialConfig,
            final CoordinateTransformation c,
            final INSGNSSLooselyCoupledKalmanFilteredEstimatorListener listener)
            throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L1024">        this(epochInterval, c, listener);</span>
        try {
<span class="fc" id="L1026">            setInitialConfig(initialConfig);</span>
<span class="nc" id="L1027">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L1029">        }</span>
<span class="fc" id="L1030">    }</span>

    /**
     * Constructor.
     *
     * @param config        INS loosely coupled Kalman filter configuration parameters
     *                      (usually obtained through calibration).
     * @param epochInterval minimum epoch interval expressed in seconds (s) between
     *                      consecutive propagations or measurements.
     * @param initialConfig initial INS loosely coupled Kalman configuration to
     *                      set proper initial covariance during filter initialization.
     * @param c             body-to-ECEF coordinate transformation defining the initial
     *                      body attitude.
     * @param listener      listener to notify events raised by this instance.
     * @throws IllegalArgumentException                      if provided epoch interval
     *                                                       is negative.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not valid.
     */
    public INSGNSSLooselyCoupledKalmanFilteredEstimator(
            final INSLooselyCoupledKalmanConfig config, final double epochInterval,
            final INSLooselyCoupledKalmanInitializerConfig initialConfig,
            final CoordinateTransformation c,
            final INSGNSSLooselyCoupledKalmanFilteredEstimatorListener listener)
            throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L1055">        this(config, epochInterval, c, listener);</span>
        try {
<span class="fc" id="L1057">            setInitialConfig(initialConfig);</span>
<span class="nc" id="L1058">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L1060">        }</span>
<span class="fc" id="L1061">    }</span>

    /**
     * Constructor.
     *
     * @param epochInterval minimum epoch interval between consecutive propagations
     *                      or measurements.
     * @param initialConfig initial INS loosely coupled Kalman configuration to
     *                      set proper initial covariance during filter initialization.
     * @param c             body-to-ECEF coordinate transformation defining the initial
     *                      body attitude.
     * @throws IllegalArgumentException                      if provided epoch interval
     *                                                       is negative.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not valid.
     */
    public INSGNSSLooselyCoupledKalmanFilteredEstimator(
            final Time epochInterval,
            final INSLooselyCoupledKalmanInitializerConfig initialConfig,
            final CoordinateTransformation c)
            throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L1082">        this(epochInterval, c);</span>
        try {
<span class="fc" id="L1084">            setInitialConfig(initialConfig);</span>
<span class="nc" id="L1085">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L1087">        }</span>
<span class="fc" id="L1088">    }</span>

    /**
     * Constructor.
     *
     * @param config        INS loosely coupled Kalman filter configuration parameters
     *                      (usually obtained through calibration).
     * @param epochInterval minimum epoch interval between consecutive propagations
     *                      or measurements.
     * @param initialConfig initial INS loosely coupled Kalman configuration to set
     *                      proper initial covariance during filter initialization.
     * @param c             body-to-ECEF coordinate transformation defining the initial
     *                      body attitude.
     * @throws IllegalArgumentException                      if provided epoch interval
     *                                                       is negative.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not valid.
     */
    public INSGNSSLooselyCoupledKalmanFilteredEstimator(
            final INSLooselyCoupledKalmanConfig config, final Time epochInterval,
            final INSLooselyCoupledKalmanInitializerConfig initialConfig,
            final CoordinateTransformation c)
            throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L1111">        this(config, epochInterval, c);</span>
        try {
<span class="fc" id="L1113">            setInitialConfig(initialConfig);</span>
<span class="nc" id="L1114">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L1116">        }</span>
<span class="fc" id="L1117">    }</span>

    /**
     * Constructor.
     *
     * @param epochInterval minimum epoch interval between consecutive
     *                      propagations or measurements.
     * @param initialConfig initial INS loosely coupled Kalman configuration to
     *                      set proper initial covariance during filter initialization.
     * @param c             body-to-ECEF coordinate transformation defining the initial
     *                      body attitude.
     * @param listener      listener to notify events raised by this instance.
     * @throws IllegalArgumentException                      if provided epoch interval
     *                                                       is negative.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not valid.
     */
    public INSGNSSLooselyCoupledKalmanFilteredEstimator(
            final Time epochInterval,
            final INSLooselyCoupledKalmanInitializerConfig initialConfig,
            final CoordinateTransformation c,
            final INSGNSSLooselyCoupledKalmanFilteredEstimatorListener listener)
            throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L1140">        this(epochInterval, c, listener);</span>
        try {
<span class="fc" id="L1142">            setInitialConfig(initialConfig);</span>
<span class="nc" id="L1143">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L1145">        }</span>
<span class="fc" id="L1146">    }</span>

    /**
     * Constructor.
     *
     * @param config        INS loosely coupled Kalman filter configuration parameters
     *                      (usually obtained through calibration).
     * @param epochInterval minimum epoch interval between consecutive propagations
     *                      or measurements.
     * @param initialConfig initial INS loosely coupled Kalman configuration to set
     *                      proper initial covariance during filter initialization.
     * @param c             body-to-ECEF coordinate transformation defining the initial
     *                      body attitude.
     * @param listener      listener to notify events raised by this instance.
     * @throws IllegalArgumentException                      if provided epoch interval
     *                                                       is negative.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not valid.
     */
    public INSGNSSLooselyCoupledKalmanFilteredEstimator(
            final INSLooselyCoupledKalmanConfig config, final Time epochInterval,
            final INSLooselyCoupledKalmanInitializerConfig initialConfig,
            final CoordinateTransformation c,
            final INSGNSSLooselyCoupledKalmanFilteredEstimatorListener listener)
            throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L1171">        this(config, epochInterval, c, listener);</span>
        try {
<span class="fc" id="L1173">            setInitialConfig(initialConfig);</span>
<span class="nc" id="L1174">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L1176">        }</span>
<span class="fc" id="L1177">    }</span>

    /**
     * Gets listener to notify events raised by this instance.
     *
     * @return listener to notify events raised by this instance.
     */
    public INSGNSSLooselyCoupledKalmanFilteredEstimatorListener getListener() {
<span class="fc" id="L1185">        return mListener;</span>
    }

    /**
     * Sets listener to notify events raised by this instance.
     *
     * @param listener listener to notify events raised by this instance.
     * @throws LockedException if this estimator is already running.
     */
    public void setListener(
            final INSGNSSLooselyCoupledKalmanFilteredEstimatorListener listener)
            throws LockedException {
<span class="fc bfc" id="L1197" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L1198">            throw new LockedException();</span>
        }

<span class="fc" id="L1201">        mListener = listener;</span>
<span class="fc" id="L1202">    }</span>

    /**
     * Gets minimum epoch interval expressed in seconds (s) between consecutive
     * propagations or measurements expressed in seconds.
     * Attempting to propagate results using Kalman filter or updating measurements
     * when intervals are less than this value, will be ignored.
     *
     * @return minimum epoch interval between consecutive propagations or
     * measurements.
     */
    public double getEpochInterval() {
<span class="fc" id="L1214">        return mInsEstimator.getEpochInterval();</span>
    }

    /**
     * Sets minimum epoch interval expressed in seconds (s) between consecutive
     * propagations or measurements expressed in seconds.
     * Attempting to propagate results using Kalman filter or updating measurements
     * when intervals are less than this value, will be ignored.
     *
     * @param epochInterval minimum epoch interval expressed in seconds (s) between
     *                      consecutive propagations or measurements.
     * @throws LockedException          if this estimator is already running.
     * @throws IllegalArgumentException if provided epoch interval is negative.
     */
    public void setEpochInterval(final double epochInterval) throws LockedException {
<span class="fc bfc" id="L1229" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L1230">            throw new LockedException();</span>
        }

<span class="fc" id="L1233">        mInsEstimator.setEpochInterval(epochInterval);</span>
<span class="fc" id="L1234">    }</span>

    /**
     * Gets minimum epoch interval between consecutive propagations or measurements.
     * Attempting to propagate results using Kalman filter or updating measurements
     * when intervals are less than this value, will be ignored.
     *
     * @param result instance where minimum epoch interval will be stored.
     */
    public void getEpochIntervalAsTime(final Time result) {
<span class="fc" id="L1244">        mInsEstimator.getEpochIntervalAsTime(result);</span>
<span class="fc" id="L1245">    }</span>

    /**
     * Gets minimum epoch interval between consecutive propagations or measurements.
     * Attempting to propagate results using Kalman filter or updating measurements
     * when intervals are less than this value, will be ignored.
     *
     * @return minimum epoch interval.
     */
    public Time getEpochIntervalAsTime() {
<span class="fc" id="L1255">        return mInsEstimator.getEpochIntervalAsTime();</span>
    }

    /**
     * Sets minimum epoch interval between consecutive propagations or measurements.
     * Attempting to propagate results using Kalman filter or updating measurements
     * when intervals are less than this value, will be ignored.
     *
     * @param epochInterval minimum epoch interval.
     * @throws LockedException          if this estimator is already running.
     * @throws IllegalArgumentException if provided epoch interval is negative.
     */
    public void setEpochInterval(final Time epochInterval) throws LockedException {
<span class="fc bfc" id="L1268" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L1269">            throw new LockedException();</span>
        }

<span class="fc" id="L1272">        mInsEstimator.setEpochInterval(epochInterval);</span>
<span class="fc" id="L1273">    }</span>

    /**
     * Gets INS loosely coupled Kalman configuration parameters (usually
     * obtained through calibration).
     *
     * @param result instance where INS loosely coupled Kalman configuration
     *               parameters will be stored.
     * @return true if result instance is updated, false otherwise.
     */
    public boolean getConfig(final INSLooselyCoupledKalmanConfig result) {
<span class="fc" id="L1284">        return mInsEstimator.getConfig(result);</span>
    }

    /**
     * Gets INS loosely coupled Kalman configuration parameters (usually obtained
     * through calibration).
     *
     * @return INS loosely coupled Kalman configuration parameters.
     */
    public INSLooselyCoupledKalmanConfig getConfig() {
<span class="fc" id="L1294">        return mInsEstimator.getConfig();</span>
    }

    /**
     * Sets INS loosely coupled Kalman configuration parameters (usually obtained
     * through calibration).
     *
     * @param config INS loosely coupled Kalman configuration parameters to be
     *               set.
     * @throws LockedException if this estimator is already runnign.
     */
    public void setConfig(final INSLooselyCoupledKalmanConfig config)
            throws LockedException {
<span class="fc bfc" id="L1307" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L1308">            throw new LockedException();</span>
        }

<span class="fc" id="L1311">        mInsEstimator.setConfig(config);</span>
<span class="fc" id="L1312">    }</span>

    /**
     * Gets body-to-ECEF coordinate transformation defining the body attitude.
     * This can be used to set the initial body attitude before starting the
     * estimator, or to update body attitude between INS/GNSS measurement updates.
     *
     * @return body-to-ECEF coordinate transformation.
     */
    public CoordinateTransformation getCoordinateTransformation() {
<span class="fc bfc" id="L1322" title="All 2 branches covered.">        return mFrame != null ? mFrame.getCoordinateTransformation() : null;</span>
    }

    /**
     * Gets body-to-ECEF coordinate transformation defining the body attitude.
     * This can be used to set the initial body attitude before starting the
     * estimator, or to update body attitude between INS/GNSS measurement updates.
     *
     * @param result instance where body-to-ECEF data will be stored.
     * @return true if result instance was updated, false otherwise.
     */
    public boolean getCoordinateTransformation(final CoordinateTransformation result) {
<span class="fc bfc" id="L1334" title="All 2 branches covered.">        if (mFrame != null) {</span>
<span class="fc" id="L1335">            mFrame.getCoordinateTransformation(result);</span>
<span class="fc" id="L1336">            return true;</span>
        } else {
<span class="fc" id="L1338">            return false;</span>
        }
    }

    /**
     * Sets body-to-ECEF coordinate transformation defining the body attitude.
     * This can be used to set the initial body attitude before starting the
     * estimator, or to update body attitude between INS/GNSS measurement updates.
     *
     * @param c body-to-ECEF coordinate transformation to be set.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not valid (is not a
     *                                                       body-to-ECEF transformation).
     * @throws LockedException                               if this estimator is already running.
     */
    public void setCoordinateTransformation(final CoordinateTransformation c)
            throws InvalidSourceAndDestinationFrameTypeException, LockedException {
<span class="fc bfc" id="L1355" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L1356">            throw new LockedException();</span>
        }

<span class="fc" id="L1359">        initFrame();</span>
<span class="fc" id="L1360">        mFrame.setCoordinateTransformation(c);</span>
<span class="fc" id="L1361">        mInsEstimator.setFrame(mFrame);</span>
<span class="fc" id="L1362">    }</span>

    /**
     * Gets initial INS loosely coupled Kalman configuration to set a proper
     * initial covariance matrix during the first Kalman filter propagation.
     * Once this estimator is initialized, covariance will be updated with new provided
     * GNSS and INS measurements until convergence is reached.
     *
     * @param result instance where configuration data will be stored.
     * @return true if result instance was updated, false otherwise.
     */
    public boolean getInitialConfig(
            final INSLooselyCoupledKalmanInitializerConfig result) {
<span class="fc" id="L1375">        return mInsEstimator.getInitialConfig(result);</span>
    }

    /**
     * Gets initial INS loosely coupled Kalman configuration te set a proper
     * initial covariance matrix during the first Kalman filter propagation.
     * Once this estimator is initialized, covariance will be updated with new provided
     * GNSS and INS measurements until convergence is reached.
     *
     * @return initial INS loosely coupled Kalman configuration.
     */
    public INSLooselyCoupledKalmanInitializerConfig getInitialConfig() {
<span class="fc" id="L1387">        return mInsEstimator.getInitialConfig();</span>
    }

    /**
     * Sets initial INS loosely coupled Kalman configuration to set a proper
     * initial covariance matrix during the first Kalman filter propagation.
     * Once this estimator is initialized, covariance will be updated with new provided
     * GNSS and INS measurements until convergence is reached.
     *
     * @param initialConfig initial configuration to be set.
     * @throws LockedException if this estimator is already runnign.
     */
    public void setInitialConfig(
            final INSLooselyCoupledKalmanInitializerConfig initialConfig)
            throws LockedException {
<span class="fc bfc" id="L1402" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L1403">            throw new LockedException();</span>
        }

<span class="fc" id="L1406">        mInsEstimator.setInitialConfig(initialConfig);</span>
<span class="fc" id="L1407">    }</span>

    /**
     * Gets last updated GNSS measurements of a collection of satellites.
     *
     * @return last updated GNSS measurements of a collection of satellites.
     */
    public Collection&lt;GNSSMeasurement&gt; getMeasurements() {
<span class="fc bfc" id="L1415" title="All 2 branches covered.">        if (mMeasurements == null) {</span>
<span class="fc" id="L1416">            return null;</span>
        }

<span class="fc" id="L1419">        final List&lt;GNSSMeasurement&gt; result = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L1420" title="All 2 branches covered.">        for (GNSSMeasurement measurement : mMeasurements) {</span>
<span class="fc" id="L1421">            result.add(new GNSSMeasurement(measurement));</span>
<span class="fc" id="L1422">        }</span>
<span class="fc" id="L1423">        return result;</span>
    }

    /**
     * Gets last provided user kinematics containing applied specific force and
     * angular rates resolved in body axes.
     *
     * @return last provided user kinematics.
     */
    public BodyKinematics getKinematics() {
<span class="fc" id="L1433">        final BodyKinematics result = mInsEstimator.getKinematics();</span>
<span class="fc bfc" id="L1434" title="All 2 branches covered.">        if (result != null) {</span>
<span class="fc" id="L1435">            return result;</span>
        } else {
<span class="pc bpc" id="L1437" title="1 of 2 branches missed.">            if (mKinematics != null) {</span>
<span class="nc" id="L1438">                return new BodyKinematics(mKinematics);</span>
            } else {
<span class="fc" id="L1440">                return null;</span>
            }
        }
    }

    /**
     * Gets last provided user kinematics containing applied specific force and
     * angular rates resolved in body axes.
     *
     * @param result instance where last provided body kinematics will be stored.
     * @return true if provided result instance was updated, false otherwise.
     */
    public boolean getKinematics(final BodyKinematics result) {
<span class="fc bfc" id="L1453" title="All 2 branches covered.">        if (!mInsEstimator.getKinematics(result)) {</span>
<span class="pc bpc" id="L1454" title="1 of 2 branches missed.">            if (mKinematics != null) {</span>
<span class="nc" id="L1455">                result.copyFrom(mKinematics);</span>
<span class="nc" id="L1456">                return true;</span>
            } else {
<span class="fc" id="L1458">                return false;</span>
            }
        } else {
<span class="fc" id="L1461">            return true;</span>
        }
    }

    /**
     * Gets corrected kinematics which are the last provided user kinematics after
     * removal of the biases estimated by the Kalman filter.
     *
     * @return corrected kinematics.
     * @see #getKinematics()
     */
    public BodyKinematics getCorrectedKinematics() {
<span class="fc" id="L1473">        final BodyKinematics result = mInsEstimator.getCorrectedKinematics();</span>
<span class="fc bfc" id="L1474" title="All 2 branches covered.">        if (result != null) {</span>
<span class="fc" id="L1475">            return result;</span>
        } else {
<span class="pc bpc" id="L1477" title="1 of 2 branches missed.">            if (mCorrectedKinematics != null) {</span>
<span class="nc" id="L1478">                return new BodyKinematics(mCorrectedKinematics);</span>
            } else {
<span class="fc" id="L1480">                return null;</span>
            }
        }
    }

    /**
     * Gets corrected kinematics which are the last provided user kinematics after
     * removal of the biases estimated by the Kalman filter.
     *
     * @param result instance where corrected body kinematics will be stored.
     * @return true if provided result instance was updated, false otherwise.
     */
    public boolean getCorrectedKinematics(final BodyKinematics result) {
<span class="fc bfc" id="L1493" title="All 2 branches covered.">        if (!mInsEstimator.getCorrectedKinematics(result)) {</span>
<span class="pc bpc" id="L1494" title="1 of 2 branches missed.">            if (mCorrectedKinematics != null) {</span>
<span class="nc" id="L1495">                result.copyFrom(mCorrectedKinematics);</span>
<span class="nc" id="L1496">                return true;</span>
            } else {
<span class="fc" id="L1498">                return false;</span>
            }
        } else {
<span class="fc" id="L1501">            return true;</span>
        }
    }

    /**
     * Gets current estimation containing user ECEF position, user ECEF velocity,
     * clock offset and clock drift.
     *
     * @return current estimation containing user ECEF position, user ECEF velocity,
     * clock offset and clock drift.
     */
    public GNSSEstimation getEstimation() {
<span class="fc bfc" id="L1513" title="All 2 branches covered.">        return mEstimation != null ? new GNSSEstimation(mEstimation) : null;</span>
    }

    /**
     * Gets current estimation containing user ECEF position, user ECEF velocity,
     * clock offset and clock drift.
     * This method does not update result instance if no estimation is available.
     *
     * @param result instance where estimation will be stored.
     * @return true if result estimation was updated, false otherwise.
     */
    public boolean getEstimation(final GNSSEstimation result) {
<span class="fc bfc" id="L1525" title="All 2 branches covered.">        if (mEstimation != null) {</span>
<span class="fc" id="L1526">            result.copyFrom(mEstimation);</span>
<span class="fc" id="L1527">            return true;</span>
        } else {
<span class="fc" id="L1529">            return false;</span>
        }
    }

    /**
     * Gets current Kalman filter state containing current user position,
     * velocity, attitude and IMU biases along with Kalman filter
     * covariance error matrix.
     *
     * @return current Kalman filter state.
     */
    public INSLooselyCoupledKalmanState getState() {
<span class="fc bfc" id="L1541" title="All 2 branches covered.">        return mState != null ? new INSLooselyCoupledKalmanState(mState) : null;</span>
    }

    /**
     * Gets current Kalman filter state containing current user position,
     * velocity, attitude and IMU biases along with Kalman filter
     * covariance error matrix.
     *
     * @param result instance where state will be stored.
     * @return true if result state was updated, false otherwise.
     */
    public boolean getState(final INSLooselyCoupledKalmanState result) {
<span class="fc bfc" id="L1553" title="All 2 branches covered.">        if (mState != null) {</span>
<span class="fc" id="L1554">            result.copyFrom(mState);</span>
<span class="fc" id="L1555">            return true;</span>
        } else {
<span class="fc" id="L1557">            return false;</span>
        }
    }

    /**
     * Gets timestamp expressed in seconds since epoch time when Kalman filter state
     * was last propagated.
     *
     * @return timestamp expressed in seconds since epoch time when Kalman filter
     * state was last propagated.
     */
    public Double getLastStateTimestamp() {
<span class="fc" id="L1569">        return mInsEstimator.getLastStateTimestamp();</span>
    }

    /**
     * Gets timestamp since epoch time when Kalman filter state was las propagated.
     *
     * @param result instance where timestamp since epoch tiem when Kalman filter
     *               state was last propagated will be stored.
     * @return true if result instance is updated, false otherwise.
     */
    public boolean getLastStateTimestampAsTime(final Time result) {
<span class="fc" id="L1580">        return mInsEstimator.getLastStateTimestampAsTime(result);</span>
    }

    /**
     * Gets timestamp since epoch time when Kalman filter state was last propagated.
     *
     * @return timestamp since epoch time when Kalman fitler state was last
     * propagated.
     */
    public Time getLastStateTimestampAsTime() {
<span class="fc" id="L1590">        return mInsEstimator.getLastStateTimestampAsTime();</span>
    }

    /**
     * Indicates whether this estimator is running or not.
     *
     * @return true if this estimator is running, false otherwise.
     */
    public boolean isRunning() {
<span class="pc bpc" id="L1599" title="1 of 4 branches missed.">        return mRunning || mInsEstimator.isRunning();</span>
    }

    /**
     * Indicates whether provided measurements are ready to be
     * used for an update.
     *
     * @param measurements measurements to be checked.
     * @return true if estimator is ready, false otherwise.
     */
    public static boolean isUpdateMeasurementsReady(
            final Collection&lt;GNSSMeasurement&gt; measurements) {
<span class="fc" id="L1611">        return GNSSLeastSquaresPositionAndVelocityEstimator</span>
<span class="fc" id="L1612">                .isValidMeasurements(measurements);</span>
    }

    /**
     * Updates GNSS measurements of this estimator when new satellite measurements
     * are available.
     * Calls to this method will be ignored if interval between provided timestamp
     * and last timestamp when Kalman filter was updated is less than epoch interval.
     *
     * @param measurements GNSS measurements to be updated.
     * @param timestamp    timestamp since epoch time when GNSS measurements were
     *                     updated.
     * @return true if measurements were updated, false otherwise.
     * @throws LockedException   if this estimator is already running.
     * @throws NotReadyException if estimator is not ready for measurements updates.
     * @throws INSGNSSException  if estimation fails due to numerical instabilities.
     */
    public boolean updateMeasurements(
            final Collection&lt;GNSSMeasurement&gt; measurements, final Time timestamp)
            throws LockedException, NotReadyException, INSGNSSException {
<span class="fc" id="L1632">        return updateMeasurements(measurements, TimeConverter.convert(</span>
<span class="fc" id="L1633">                timestamp.getValue().doubleValue(), timestamp.getUnit(),</span>
                TimeUnit.SECOND));
    }

    /**
     * Updates GNSS measurements of this estimator when new satellite measurements
     * are available.
     * Call to this method will be ignored if interval between provided timestamp
     * and last timestamp when Kalman filter was updated is less than epoch interval.
     *
     * @param measurements GNSS measurements to be updated.
     * @param timestamp    timestamp expressed in seconds since epoch time when
     *                     GNSS measurements were updated.
     * @return true if measurements were updated, false otherwise.
     * @throws LockedException   if this estimator is already running.
     * @throws NotReadyException if estimator is not ready for measurements updates.
     * @throws INSGNSSException  if estimation fails due to numerical instabilities.
     */
    public boolean updateMeasurements(
            final Collection&lt;GNSSMeasurement&gt; measurements, final double timestamp)
            throws LockedException, NotReadyException, INSGNSSException {

<span class="fc bfc" id="L1655" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L1656">            throw new LockedException();</span>
        }

<span class="fc bfc" id="L1659" title="All 2 branches covered.">        if (!isUpdateMeasurementsReady(measurements)) {</span>
<span class="fc" id="L1660">            throw new NotReadyException();</span>
        }

<span class="fc" id="L1663">        final Double lastStateTimestamp = mInsEstimator.getLastStateTimestamp();</span>
<span class="fc bfc" id="L1664" title="All 2 branches covered.">        if (lastStateTimestamp != null &amp;&amp;</span>
<span class="fc bfc" id="L1665" title="All 2 branches covered.">                timestamp - lastStateTimestamp &lt;= mInsEstimator.getEpochInterval()) {</span>
<span class="fc" id="L1666">            return false;</span>
        }

        try {
<span class="fc" id="L1670">            mRunning = true;</span>

<span class="pc bpc" id="L1672" title="1 of 2 branches missed.">            if (mListener != null) {</span>
<span class="fc" id="L1673">                mListener.onUpdateGNSSMeasurementsStart(this);</span>
            }

<span class="fc" id="L1676">            mMeasurements = new ArrayList&lt;&gt;(measurements);</span>

<span class="fc" id="L1678">            mLsEstimator.setMeasurements(mMeasurements);</span>
<span class="fc" id="L1679">            mLsEstimator.setPriorPositionAndVelocityFromEstimation(mEstimation);</span>
<span class="pc bpc" id="L1680" title="1 of 2 branches missed.">            if (mEstimation != null) {</span>
<span class="nc" id="L1681">                mLsEstimator.estimate(mEstimation);</span>
            } else {
<span class="fc" id="L1683">                mEstimation = mLsEstimator.estimate();</span>
            }

<span class="pc bpc" id="L1686" title="1 of 2 branches missed.">            if (mListener != null) {</span>
<span class="fc" id="L1687">                mListener.onUpdateGNSSMeasurementsEnd(this);</span>
            }
<span class="nc" id="L1689">        } catch (final GNSSException e) {</span>
<span class="nc" id="L1690">            throw new INSGNSSException(e);</span>
        } finally {
<span class="fc" id="L1692">            mRunning = false;</span>
        }

<span class="fc bfc" id="L1695" title="All 2 branches covered.">        if (mKinematics == null) {</span>
<span class="fc" id="L1696">            mKinematics = mInsEstimator.getKinematics();</span>
        } else {
<span class="fc" id="L1698">            mInsEstimator.getKinematics(mKinematics);</span>
        }

<span class="fc" id="L1701">        updateBodyKinematics(mKinematics, timestamp);</span>

<span class="fc" id="L1703">        return true;</span>
    }

    /**
     * Updates specific force and angular rate applied to the user's
     * body expressed in coordinates resolved along body-frame axes.
     *
     * @param kinematics kinematics applied to body (specific force and angular rate)
     *                   during last period of time. These measures are obtained from
     *                   an inertial unit (IMU).
     * @param timestamp  timestamp since epoch time when specific force and
     *                   angular rate values were updated.
     * @return true if body kinematics values were updated, false otherwise.
     * @throws LockedException  if this estimator is already running.
     * @throws INSGNSSException if estimation fails due to numerical instabilities.
     */
    public boolean updateBodyKinematics(
            final BodyKinematics kinematics, final Time timestamp)
            throws LockedException, INSGNSSException {
<span class="fc" id="L1722">        return updateBodyKinematics(kinematics, TimeConverter.convert(</span>
<span class="fc" id="L1723">                timestamp.getValue().doubleValue(), timestamp.getUnit(),</span>
                TimeUnit.SECOND));
    }

    /**
     * Updates specific force and angular rate applied to the user's
     * body expressed in coordinates resolved along body-frame axes.
     *
     * @param kinematics kinematics applied to body (specific force and angular rate)
     *                   during last period of time. These measures are obtained from
     *                   an intertial unit (IMU).
     * @param timestamp  timestamp expressed in seconds since epoch time when specific
     *                   force and angular rate values were updated.
     * @return true if body kinematics values were updated, false otherwise.
     * @throws LockedException  if this estimator is already running.
     * @throws INSGNSSException if estimation fails due to numerical instabilities.
     */
    public boolean updateBodyKinematics(
            final BodyKinematics kinematics, final double timestamp)
            throws LockedException, INSGNSSException {

<span class="fc bfc" id="L1744" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L1745">            throw new LockedException();</span>
        }

        try {
<span class="fc" id="L1749">            mRunning = true;</span>

<span class="fc" id="L1751">            initFrame();</span>
<span class="fc bfc" id="L1752" title="All 2 branches covered.">            if (mEstimation != null) {</span>
<span class="fc" id="L1753">                mFrame.setCoordinates(</span>
<span class="fc" id="L1754">                        mEstimation.getX(), mEstimation.getY(), mEstimation.getZ());</span>
<span class="fc" id="L1755">                mFrame.setVelocityCoordinates(</span>
<span class="fc" id="L1756">                        mEstimation.getVx(), mEstimation.getVy(), mEstimation.getVz());</span>
            }
<span class="fc" id="L1758">            mInsEstimator.setFrame(mFrame);</span>

<span class="fc" id="L1760">            boolean result = false;</span>
<span class="pc bpc" id="L1761" title="1 of 2 branches missed.">            if (mInsEstimator.isUpdateReady() &amp;&amp;</span>
<span class="fc bfc" id="L1762" title="All 2 branches covered.">                    (result = mInsEstimator.update(kinematics, timestamp))) {</span>
<span class="fc bfc" id="L1763" title="All 2 branches covered.">                if (mKinematics == null) {</span>
<span class="fc" id="L1764">                    mKinematics = mInsEstimator.getKinematics();</span>
                } else {
<span class="fc" id="L1766">                    mInsEstimator.getKinematics(mKinematics);</span>
                }

<span class="fc bfc" id="L1769" title="All 2 branches covered.">                if (mEstimation != null) {</span>
<span class="fc" id="L1770">                    initState();</span>
<span class="fc" id="L1771">                    mInsEstimator.getState(mState);</span>
                }
            } else {
<span class="fc" id="L1774">                mKinematics = kinematics;</span>
            }

<span class="fc bfc" id="L1777" title="All 2 branches covered.">            if (kinematics != null) {</span>
<span class="fc" id="L1778">                correctKinematics(kinematics);</span>
            }

<span class="fc" id="L1781">            return result;</span>

<span class="nc" id="L1783">        } catch (final INSException | NotReadyException e) {</span>
<span class="nc" id="L1784">            throw new INSGNSSException(e);</span>
        } finally {
<span class="fc" id="L1786">            mRunning = false;</span>
        }
    }

    /**
     * Indicates whether this estimator is ready for state propagations.
     *
     * @return true if estimator is ready, false otherwise.
     */
    public boolean isPropagateReady() {
<span class="fc bfc" id="L1796" title="All 4 branches covered.">        return mInsEstimator.isPropagateReady() &amp;&amp; mEstimation != null;</span>
    }

    /**
     * Propagates Kalman filter state held by this estimator at provided
     * timestamp.
     * Call to this method will be ignored if interval between provided timestamp
     * and last timestamp when Kalman filter was updated is less than epoch interval.
     *
     * @param timestamp timestamp since epoch to propagate state.
     * @return true if state was propagated, false otherwise.
     * @throws LockedException  if this estimator is already running.
     * @throws INSGNSSException if estimation fails due to numerical instabilities.
     */
    public boolean propagate(final Time timestamp) throws LockedException,
            INSGNSSException {
<span class="fc" id="L1812">        return propagate(TimeConverter.convert(timestamp.getValue().doubleValue(),</span>
<span class="fc" id="L1813">                timestamp.getUnit(), TimeUnit.SECOND));</span>
    }

    /**
     * Propagates Kalman filter state held by this estimator at provided
     * timestamp.
     * Call to this method will be ignored if interval between provided timestamp
     * and last timestamp when Kalman filter was updated is less than epoch interval.
     *
     * @param timestamp timestamp expressed in seconds since epoch to propagate state.
     * @return true if state was propagated, false otherwise.
     * @throws LockedException  if this estimator is already running.
     * @throws INSGNSSException if estimation fails due to numerical instabilities.
     */
    public boolean propagate(final double timestamp) throws LockedException,
            INSGNSSException {

<span class="fc bfc" id="L1830" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L1831">            throw new LockedException();</span>
        }

<span class="fc bfc" id="L1834" title="All 2 branches covered.">        if (!isPropagateReady()) {</span>
<span class="fc" id="L1835">            return false;</span>
        }

        try {
<span class="fc" id="L1839">            mRunning = true;</span>

<span class="pc bpc" id="L1841" title="1 of 2 branches missed.">            if (initFrame()) {</span>
<span class="nc" id="L1842">                mFrame.setCoordinates(</span>
<span class="nc" id="L1843">                        mEstimation.getX(), mEstimation.getY(), mEstimation.getZ());</span>
<span class="nc" id="L1844">                mFrame.setVelocityCoordinates(</span>
<span class="nc" id="L1845">                        mEstimation.getVx(), mEstimation.getVy(), mEstimation.getVz());</span>
<span class="nc" id="L1846">                mInsEstimator.setFrame(mFrame);</span>
            }

<span class="fc" id="L1849">            boolean result = mInsEstimator.propagate(timestamp);</span>
<span class="fc bfc" id="L1850" title="All 2 branches covered.">            if (result) {</span>
<span class="fc" id="L1851">                mInsEstimator.getFrame(mFrame);</span>
<span class="fc" id="L1852">                mEstimation.setPositionCoordinates(</span>
<span class="fc" id="L1853">                        mFrame.getX(), mFrame.getY(), mFrame.getZ());</span>
<span class="fc" id="L1854">                mEstimation.setVelocityCoordinates(</span>
<span class="fc" id="L1855">                        mFrame.getVx(), mFrame.getVy(), mFrame.getVz());</span>

<span class="pc bpc" id="L1857" title="1 of 2 branches missed.">                if (mEstimation != null) {</span>
<span class="fc" id="L1858">                    initState();</span>
<span class="fc" id="L1859">                    mInsEstimator.getState(mState);</span>
                }
            }

<span class="fc" id="L1863">            return result;</span>

<span class="nc" id="L1865">        } catch (final INSException | NotReadyException e) {</span>
<span class="nc" id="L1866">            throw new INSGNSSException(e);</span>
        } finally {
<span class="fc" id="L1868">            mRunning = false;</span>
        }
    }

    /**
     * Resets this estimator.
     *
     * @throws LockedException if this estimator is already running.
     */
    public void reset() throws LockedException {
<span class="fc bfc" id="L1878" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L1879">            throw new LockedException();</span>
        }

<span class="fc" id="L1882">        mRunning = true;</span>
<span class="fc" id="L1883">        mMeasurements = null;</span>
<span class="fc" id="L1884">        mEstimation = null;</span>
<span class="fc" id="L1885">        mState = null;</span>
<span class="fc" id="L1886">        mKinematics = null;</span>
<span class="fc" id="L1887">        mCorrectedKinematics = null;</span>
<span class="fc" id="L1888">        mFrame = null;</span>

<span class="fc" id="L1890">        mInsEstimator.reset();</span>

<span class="pc bpc" id="L1892" title="1 of 2 branches missed.">        if (mListener != null) {</span>
<span class="fc" id="L1893">            mListener.onReset(this);</span>
        }

<span class="fc" id="L1896">        mRunning = false;</span>
<span class="fc" id="L1897">    }</span>

    /**
     * Initializes current ECEF frame containing user position, velocity and
     * orientation expressed an resolved in ECEF coordinates.
     * This method makes no action if an initial frame already exists.
     *
     * @return true if frame was initialized, false otherwise.
     */
    private boolean initFrame() {
<span class="fc bfc" id="L1907" title="All 2 branches covered.">        if (mFrame == null) {</span>
<span class="fc" id="L1908">            mFrame = new ECEFFrame();</span>
<span class="fc" id="L1909">            mFrame.setCoordinates(</span>
                    Constants.EARTH_EQUATORIAL_RADIUS_WGS84, 0.0, 0.0);
<span class="fc" id="L1911">            return true;</span>
        } else {
<span class="fc" id="L1913">            return false;</span>
        }
    }

    /**
     * Initializes state.
     */
    private void initState() {
<span class="fc bfc" id="L1921" title="All 2 branches covered.">        if (mState == null) {</span>
<span class="fc" id="L1922">            mState = new INSLooselyCoupledKalmanState();</span>
        }
<span class="fc" id="L1924">    }</span>

    /**
     * Corrects provided kinematics by taking into account currently estimated
     * specific force and angular rate biases.
     * This method stores the result into the variable member containing corrected
     * kinematics values.
     *
     * @param kinematics kinematics instance to be corrected.
     */
    private void correctKinematics(final BodyKinematics kinematics) {
<span class="fc bfc" id="L1935" title="All 2 branches covered.">        if (mCorrectedKinematics == null) {</span>
<span class="fc" id="L1936">            mCorrectedKinematics = new BodyKinematics();</span>
        }

        final double accelBiasX;
        final double accelBiasY;
        final double accelBiasZ;
        final double gyroBiasX;
        final double gyroBiasY;
        final double gyroBiasZ;
<span class="fc bfc" id="L1945" title="All 2 branches covered.">        if (mState != null) {</span>
<span class="fc" id="L1946">            accelBiasX = getValueOrZero(mState.getAccelerationBiasX());</span>
<span class="fc" id="L1947">            accelBiasY = getValueOrZero(mState.getAccelerationBiasY());</span>
<span class="fc" id="L1948">            accelBiasZ = getValueOrZero(mState.getAccelerationBiasZ());</span>
<span class="fc" id="L1949">            gyroBiasX = getValueOrZero(mState.getGyroBiasX());</span>
<span class="fc" id="L1950">            gyroBiasY = getValueOrZero(mState.getGyroBiasY());</span>
<span class="fc" id="L1951">            gyroBiasZ = getValueOrZero(mState.getGyroBiasZ());</span>
        } else {
<span class="fc" id="L1953">            accelBiasX = 0.0;</span>
<span class="fc" id="L1954">            accelBiasY = 0.0;</span>
<span class="fc" id="L1955">            accelBiasZ = 0.0;</span>
<span class="fc" id="L1956">            gyroBiasX = 0.0;</span>
<span class="fc" id="L1957">            gyroBiasY = 0.0;</span>
<span class="fc" id="L1958">            gyroBiasZ = 0.0;</span>
        }

<span class="fc" id="L1961">        final double fx = kinematics.getFx();</span>
<span class="fc" id="L1962">        final double fy = kinematics.getFy();</span>
<span class="fc" id="L1963">        final double fz = kinematics.getFz();</span>
<span class="fc" id="L1964">        final double angularRateX = kinematics.getAngularRateX();</span>
<span class="fc" id="L1965">        final double angularRateY = kinematics.getAngularRateY();</span>
<span class="fc" id="L1966">        final double angularRateZ = kinematics.getAngularRateZ();</span>

<span class="fc" id="L1968">        mCorrectedKinematics.setSpecificForceCoordinates(</span>
                fx - accelBiasX, fy - accelBiasY, fz - accelBiasZ);
<span class="fc" id="L1970">        mCorrectedKinematics.setAngularRateCoordinates(</span>
                angularRateX - gyroBiasX,
                angularRateY - gyroBiasY,
                angularRateZ - gyroBiasZ);
<span class="fc" id="L1974">    }</span>

    /**
     * Returns provided value if not infinity and not NaN.
     *
     * @param value value to be returned.
     * @return value or 0.0.
     */
    private double getValueOrZero(final double value) {
<span class="pc bpc" id="L1983" title="2 of 4 branches missed.">        if (Double.isNaN(value) || Double.isInfinite(value)) {</span>
<span class="nc" id="L1984">            return 0.0;</span>
        } else {
<span class="fc" id="L1986">            return value;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>