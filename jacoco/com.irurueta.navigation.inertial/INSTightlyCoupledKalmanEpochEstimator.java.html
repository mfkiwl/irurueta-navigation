<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>INSTightlyCoupledKalmanEpochEstimator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.irurueta:irurueta-navigation</a> &gt; <a href="index.source.html" class="el_package">com.irurueta.navigation.inertial</a> &gt; <span class="el_source">INSTightlyCoupledKalmanEpochEstimator.java</span></div><h1>INSTightlyCoupledKalmanEpochEstimator.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2019 Alberto Irurueta Carro (alberto@irurueta.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.irurueta.navigation.inertial;

import com.irurueta.algebra.AlgebraException;
import com.irurueta.algebra.Matrix;
import com.irurueta.algebra.Utils;
import com.irurueta.navigation.frames.CoordinateTransformation;
import com.irurueta.navigation.frames.converters.ECEFtoNEDPositionVelocityConverter;
import com.irurueta.navigation.geodesic.Constants;
import com.irurueta.navigation.gnss.GNSSMeasurement;
import com.irurueta.navigation.inertial.estimators.ECEFGravityEstimator;
import com.irurueta.units.Angle;
import com.irurueta.units.AngleConverter;
import com.irurueta.units.AngleUnit;
import com.irurueta.units.Time;
import com.irurueta.units.TimeConverter;
import com.irurueta.units.TimeUnit;

import java.util.Collection;

/**
 * Implements one cycle of the tightly coupled INS/GNSS
 * Kalman filter plus closed-loop correction of all inertial states.
 * This implementation is based on the equations defined in &quot;Principles of GNSS, Inertial, and Multisensor
 * Integrated Navigation Systems, Second Edition&quot; and on the companion software available at:
 * https://github.com/ymjdz/MATLAB-Codes/blob/master/TC_KF_Epoch.m
 */
<span class="nc" id="L42">public class INSTightlyCoupledKalmanEpochEstimator {</span>

    /**
     * Speed of light in the vacuum expressed in meters per second (m/s).
     */
    public static final double SPEED_OF_LIGHT = Constants.SPEED_OF_LIGHT;

    /**
     * Earth rotation rate expressed in radians per second (rad/s).
     */
    public static final double EARTH_ROTATION_RATE = Constants.EARTH_ROTATION_RATE;

    /**
     * The equatorial radius of WGS84 ellipsoid (6378137 m) defining Earth's shape.
     */
    public static final double EARTH_EQUATORIAL_RADIUS_WGS84 = Constants.EARTH_EQUATORIAL_RADIUS_WGS84;

    /**
     * Earth eccentricity as defined on the WGS84 ellipsoid.
     */
    public static final double EARTH_ECCENTRICITY = Constants.EARTH_ECCENTRICITY;

    /**
     * Estimates the update of Kalman filter state and covariance matrix for a single
     * epoch.
     *
     * @param measurements        satellite measurements data.
     * @param propagationInterval propagation interval expressed in seconds (s).
     * @param previousState       previous Kalman filter state.
     * @param fx                  measured specific force resolved along body frame
     *                            x-axis and expressed in meters per squared
     *                            second (m/s^2).
     * @param fy                  measured specific force resolved along body frame
     *                            y-axis and expressed in meters per squared
     *                            second (m/s^2).
     * @param fz                  measured specific force resolved along body frame
     *                            z-axis and expressed in meters per squared
     *                            second (m/s^2).
     * @param previousLatitude    previous latitude solution expressed in radians (rad).
     * @param config              Tightly Coupled Kalman filter configuration.
     * @param result              instance where new state of Kalman filter will be
     *                            stored.
     * @throws AlgebraException if there are numerical instabilities.
     */
    public static void estimate(
            final Collection&lt;GNSSMeasurement&gt; measurements,
            final double propagationInterval,
            final INSTightlyCoupledKalmanState previousState,
            final double fx, final double fy, final double fz,
            final double previousLatitude,
            final INSTightlyCoupledKalmanConfig config,
            final INSTightlyCoupledKalmanState result) throws AlgebraException {

        // Skew symmetric matrix of Earth rate
<span class="fc" id="L96">        final Matrix omegaIe = Utils.skewMatrix(</span>
                new double[]{0.0, 0.0, EARTH_ROTATION_RATE});

        // SYSTEM PROPAGATION PHASE

        // 1. Determine transition matrix using (14.50) (first-order approx)
<span class="fc" id="L102">        final Matrix phiMatrix = Matrix.identity(</span>
                INSTightlyCoupledKalmanState.NUM_PARAMS,
                INSTightlyCoupledKalmanState.NUM_PARAMS);

<span class="fc" id="L106">        final Matrix tmp1 = omegaIe.multiplyByScalarAndReturnNew(</span>
                propagationInterval);
<span class="fc" id="L108">        final Matrix tmp2 = phiMatrix.getSubmatrix(0, 0,</span>
                2, 2);
<span class="fc" id="L110">        tmp2.subtract(tmp1);</span>

<span class="fc" id="L112">        phiMatrix.setSubmatrix(0, 0,</span>
                2, 2, tmp2);

<span class="fc" id="L115">        final Matrix estCbeOld = previousState</span>
<span class="fc" id="L116">                .getBodyToEcefCoordinateTransformationMatrix();</span>
<span class="fc" id="L117">        tmp1.copyFrom(estCbeOld);</span>
<span class="fc" id="L118">        tmp1.multiplyByScalar(propagationInterval);</span>

<span class="fc" id="L120">        phiMatrix.setSubmatrix(0, 12,</span>
                2, 14, tmp1);
<span class="fc" id="L122">        phiMatrix.setSubmatrix(3, 9,</span>
                5, 11, tmp1);

<span class="fc" id="L125">        final Matrix measFibb = new Matrix(BodyKinematics.COMPONENTS, 1);</span>
<span class="fc" id="L126">        measFibb.setElementAtIndex(0, fx);</span>
<span class="fc" id="L127">        measFibb.setElementAtIndex(1, fy);</span>
<span class="fc" id="L128">        measFibb.setElementAtIndex(2, fz);</span>

<span class="fc" id="L130">        estCbeOld.multiply(measFibb, tmp1);</span>

<span class="fc" id="L132">        Utils.skewMatrix(tmp1, tmp2);</span>
<span class="fc" id="L133">        tmp2.multiplyByScalar(-propagationInterval);</span>

<span class="fc" id="L135">        phiMatrix.setSubmatrix(3, 0,</span>
                5, 2, tmp2);

<span class="fc" id="L138">        phiMatrix.getSubmatrix(3, 3,</span>
                5, 5, tmp1);
<span class="fc" id="L140">        tmp2.copyFrom(omegaIe);</span>
<span class="fc" id="L141">        tmp2.multiplyByScalar(2.0 * propagationInterval);</span>
<span class="fc" id="L142">        tmp1.subtract(tmp2);</span>
<span class="fc" id="L143">        phiMatrix.setSubmatrix(3, 3,</span>
                5, 5, tmp1);

<span class="fc" id="L146">        final double sinPrevLat = Math.sin(previousLatitude);</span>
<span class="fc" id="L147">        final double cosPrevLat = Math.cos(previousLatitude);</span>
<span class="fc" id="L148">        final double sinPrevLat2 = sinPrevLat * sinPrevLat;</span>
<span class="fc" id="L149">        final double cosPrevLat2 = cosPrevLat * cosPrevLat;</span>

        // From (2.137)
<span class="fc" id="L152">        final double geocentricRadius = EARTH_EQUATORIAL_RADIUS_WGS84</span>
<span class="fc" id="L153">                / Math.sqrt(1.0 - Math.pow(EARTH_ECCENTRICITY * sinPrevLat, 2.0))</span>
<span class="fc" id="L154">                * Math.sqrt(cosPrevLat2</span>
<span class="fc" id="L155">                + Math.pow(1.0 - EARTH_ECCENTRICITY * EARTH_ECCENTRICITY, 2.0) * sinPrevLat2);</span>

<span class="fc" id="L157">        final double prevX = previousState.getX();</span>
<span class="fc" id="L158">        final double prevY = previousState.getY();</span>
<span class="fc" id="L159">        final double prevZ = previousState.getZ();</span>
<span class="fc" id="L160">        final ECEFGravity gravity = ECEFGravityEstimator.estimateGravityAndReturnNew(</span>
                prevX, prevY, prevZ);

<span class="fc" id="L163">        final double previousPositionNorm = Math.sqrt(prevX * prevX +</span>
                prevY * prevY + prevZ * prevZ);

<span class="fc" id="L166">        final Matrix estRebeOld = new Matrix(ECEFPosition.COMPONENTS, 1);</span>
<span class="fc" id="L167">        estRebeOld.setElementAtIndex(0, prevX);</span>
<span class="fc" id="L168">        estRebeOld.setElementAtIndex(1, prevY);</span>
<span class="fc" id="L169">        estRebeOld.setElementAtIndex(2, prevZ);</span>

<span class="fc" id="L171">        final Matrix g = gravity.asMatrix();</span>
<span class="fc" id="L172">        g.multiplyByScalar(-2.0 * propagationInterval / geocentricRadius);</span>

<span class="fc" id="L174">        final Matrix estRebeOldTrans = estRebeOld.transposeAndReturnNew();</span>
<span class="fc" id="L175">        estRebeOldTrans.multiplyByScalar(1.0 / previousPositionNorm);</span>

<span class="fc" id="L177">        g.multiply(estRebeOldTrans, tmp1);</span>

<span class="fc" id="L179">        phiMatrix.setSubmatrix(3, 6,</span>
                5, 8, tmp1);

<span class="fc bfc" id="L182" title="All 2 branches covered.">        for (int i = 0; i &lt; ECEFPosition.COMPONENTS; i++) {</span>
<span class="fc" id="L183">            phiMatrix.setElementAt(6 + i, 3 + i, propagationInterval);</span>
        }

<span class="fc" id="L186">        phiMatrix.setElementAt(15, 16, propagationInterval);</span>


        // 2. Determine approximate system noise covariance matrix using (14.82)
<span class="fc" id="L190">        final Matrix qPrimeMatrix = new Matrix(</span>
                INSTightlyCoupledKalmanState.NUM_PARAMS,
                INSTightlyCoupledKalmanState.NUM_PARAMS);

<span class="fc" id="L194">        final double gyroNoisePSD = config.getGyroNoisePSD();</span>
<span class="fc" id="L195">        final double gyroNoiseValue = gyroNoisePSD * propagationInterval;</span>
<span class="fc bfc" id="L196" title="All 2 branches covered.">        for (int i = 0; i &lt; 3; i++) {</span>
<span class="fc" id="L197">            qPrimeMatrix.setElementAt(i, i, gyroNoiseValue);</span>
        }

<span class="fc" id="L200">        final double accelNoisePSD = config.getAccelerometerNoisePSD();</span>
<span class="fc" id="L201">        final double accelNoiseValue = accelNoisePSD * propagationInterval;</span>
<span class="fc bfc" id="L202" title="All 2 branches covered.">        for (int i = 3; i &lt; 6; i++) {</span>
<span class="fc" id="L203">            qPrimeMatrix.setElementAt(i, i, accelNoiseValue);</span>
        }

<span class="fc" id="L206">        final double accelBiasPSD = config.getAccelerometerBiasPSD();</span>
<span class="fc" id="L207">        final double accelBiasValue = accelBiasPSD * propagationInterval;</span>
<span class="fc bfc" id="L208" title="All 2 branches covered.">        for (int i = 9; i &lt; 12; i++) {</span>
<span class="fc" id="L209">            qPrimeMatrix.setElementAt(i, i, accelBiasValue);</span>
        }

<span class="fc" id="L212">        final double gyroBiasPSD = config.getGyroBiasPSD();</span>
<span class="fc" id="L213">        final double gyroBiasValue = gyroBiasPSD * propagationInterval;</span>
<span class="fc bfc" id="L214" title="All 2 branches covered.">        for (int i = 12; i &lt; 15; i++) {</span>
<span class="fc" id="L215">            qPrimeMatrix.setElementAt(i, i, gyroBiasValue);</span>
        }

<span class="fc" id="L218">        final double clockPhasePSD = config.getClockPhasePSD();</span>
<span class="fc" id="L219">        final double clockPhaseValue = clockPhasePSD * propagationInterval;</span>
<span class="fc" id="L220">        qPrimeMatrix.setElementAt(15, 15, clockPhaseValue);</span>

<span class="fc" id="L222">        final double clockFreqPSD = config.getClockFrequencyPSD();</span>
<span class="fc" id="L223">        final double clockFreqValue = clockFreqPSD * propagationInterval;</span>
<span class="fc" id="L224">        qPrimeMatrix.setElementAt(16, 16, clockFreqValue);</span>


        // 3. Propagate state estimates using (3.14) noting that only the clock
        // states are non-zero due to closed-loop correction
<span class="fc" id="L229">        final double prevClockOffset = previousState.getReceiverClockOffset();</span>
<span class="fc" id="L230">        final double prevClockDrift = previousState.getReceiverClockDrift();</span>

<span class="fc" id="L232">        final Matrix xEstPropagated = new Matrix(INSTightlyCoupledKalmanState.NUM_PARAMS, 1);</span>
<span class="fc" id="L233">        xEstPropagated.setElementAtIndex(15, prevClockOffset</span>
                + prevClockDrift * propagationInterval);
<span class="fc" id="L235">        xEstPropagated.setElementAtIndex(16, prevClockDrift);</span>

        // 4. Propagate state estimation error covariance matrix using (3.46)
<span class="fc" id="L238">        final Matrix pMatrixOld = previousState.getCovariance();</span>

<span class="fc" id="L240">        qPrimeMatrix.multiplyByScalar(0.5);</span>

<span class="fc" id="L242">        final Matrix tmp3 = pMatrixOld.addAndReturnNew(qPrimeMatrix);</span>
<span class="fc" id="L243">        final Matrix pMatrixPropagated = phiMatrix.multiplyAndReturnNew(tmp3);</span>

<span class="fc" id="L245">        phiMatrix.transpose();</span>
<span class="fc" id="L246">        pMatrixPropagated.multiply(phiMatrix);</span>

<span class="fc" id="L248">        pMatrixPropagated.add(qPrimeMatrix);</span>


        // MEASUREMENT UPDATE PHASE

<span class="fc" id="L253">        final int numberOfMeasurements = measurements.size();</span>
<span class="fc" id="L254">        final Matrix uAseT = new Matrix(numberOfMeasurements, 3);</span>
<span class="fc" id="L255">        final Matrix predMeas = new Matrix(numberOfMeasurements, 2);</span>

<span class="fc" id="L257">        final Matrix cei = Matrix.identity(CoordinateTransformation.ROWS,</span>
                CoordinateTransformation.COLS);
<span class="fc" id="L259">        final Matrix satellitePosition = new Matrix(CoordinateTransformation.ROWS, 1);</span>
<span class="fc" id="L260">        final Matrix satelliteVelocity = new Matrix(CoordinateTransformation.ROWS, 1);</span>
<span class="fc" id="L261">        final Matrix deltaR = new Matrix(CoordinateTransformation.ROWS, 1);</span>
<span class="fc" id="L262">        final Matrix tmp1b = new Matrix(CoordinateTransformation.ROWS, 1);</span>
<span class="fc" id="L263">        final Matrix tmp2b = new Matrix(CoordinateTransformation.ROWS, 1);</span>
<span class="fc" id="L264">        final Matrix tmp3b = new Matrix(CoordinateTransformation.ROWS, 1);</span>
<span class="fc" id="L265">        final Matrix tmp4b = new Matrix(CoordinateTransformation.ROWS, 1);</span>
<span class="fc" id="L266">        final Matrix tmp5b = new Matrix(CoordinateTransformation.ROWS, 1);</span>
<span class="fc" id="L267">        final Matrix tmp6b = new Matrix(CoordinateTransformation.ROWS, 1);</span>
<span class="fc" id="L268">        final Matrix tmp7b = new Matrix(1, CoordinateTransformation.ROWS);</span>

<span class="fc" id="L270">        final double prevVx = previousState.getVx();</span>
<span class="fc" id="L271">        final double prevVy = previousState.getVy();</span>
<span class="fc" id="L272">        final double prevVz = previousState.getVz();</span>

<span class="fc" id="L274">        final Matrix estVebeOld = new Matrix(ECEFVelocity.COMPONENTS, 1);</span>
<span class="fc" id="L275">        estVebeOld.setElementAtIndex(0, prevVx);</span>
<span class="fc" id="L276">        estVebeOld.setElementAtIndex(1, prevVy);</span>
<span class="fc" id="L277">        estVebeOld.setElementAtIndex(2, prevVz);</span>

<span class="fc" id="L279">        int j = 0;</span>
<span class="fc bfc" id="L280" title="All 2 branches covered.">        for (final GNSSMeasurement measurement : measurements) {</span>
            // Predict approx range
<span class="fc" id="L282">            final double measX = measurement.getX();</span>
<span class="fc" id="L283">            final double measY = measurement.getY();</span>
<span class="fc" id="L284">            final double measZ = measurement.getZ();</span>

<span class="fc" id="L286">            final double deltaX = measX - prevX;</span>
<span class="fc" id="L287">            final double deltaY = measY - prevY;</span>
<span class="fc" id="L288">            final double deltaZ = measZ - prevZ;</span>
<span class="fc" id="L289">            final double approxRange = Math.sqrt(deltaX * deltaX + deltaY * deltaY + deltaZ * deltaZ);</span>

            // Calculate frame rotation during signal transit time using (8.36)
<span class="fc" id="L292">            final double ceiValue = EARTH_ROTATION_RATE * approxRange / SPEED_OF_LIGHT;</span>
<span class="fc" id="L293">            Matrix.identity(cei);</span>
<span class="fc" id="L294">            cei.setElementAt(0, 1, ceiValue);</span>
<span class="fc" id="L295">            cei.setElementAt(1, 0, -ceiValue);</span>

            // Predict pseudo-range using (9.165)
<span class="fc" id="L298">            satellitePosition.setElementAtIndex(0, measX);</span>
<span class="fc" id="L299">            satellitePosition.setElementAtIndex(1, measY);</span>
<span class="fc" id="L300">            satellitePosition.setElementAtIndex(2, measZ);</span>

<span class="fc" id="L302">            cei.multiply(satellitePosition, deltaR);</span>
<span class="fc bfc" id="L303" title="All 2 branches covered.">            for (int i = 0; i &lt; CoordinateTransformation.ROWS; i++) {</span>
<span class="fc" id="L304">                deltaR.setElementAtIndex(i, deltaR.getElementAtIndex(i)</span>
<span class="fc" id="L305">                        - estRebeOld.getElementAtIndex(i));</span>
            }
<span class="fc" id="L307">            final double range = Utils.normF(deltaR);</span>

<span class="fc" id="L309">            predMeas.setElementAt(j, 0, range</span>
<span class="fc" id="L310">                    + xEstPropagated.getElementAtIndex(15));</span>

            // Predict line of sight
<span class="fc bfc" id="L313" title="All 2 branches covered.">            for (int i = 0; i &lt; CoordinateTransformation.ROWS; i++) {</span>
<span class="fc" id="L314">                uAseT.setElementAt(j, i, deltaR.getElementAtIndex(i) / range);</span>
            }

            // Predict pseudo-range rae using (9.165)
<span class="fc" id="L318">            satelliteVelocity.setElementAtIndex(0, measurement.getVx());</span>
<span class="fc" id="L319">            satelliteVelocity.setElementAtIndex(1, measurement.getVy());</span>
<span class="fc" id="L320">            satelliteVelocity.setElementAtIndex(2, measurement.getVz());</span>

<span class="fc" id="L322">            omegaIe.multiply(satellitePosition, tmp1b);</span>
<span class="fc" id="L323">            satelliteVelocity.add(tmp1b, tmp2b);</span>
<span class="fc" id="L324">            cei.multiply(tmp2b, tmp3b);</span>

<span class="fc" id="L326">            omegaIe.multiply(estRebeOld, tmp4b);</span>
<span class="fc" id="L327">            estVebeOld.add(tmp4b, tmp6b);</span>

<span class="fc" id="L329">            tmp3b.subtract(tmp6b, tmp5b);</span>

<span class="fc" id="L331">            uAseT.getSubmatrix(j, 0, j, 2, tmp7b);</span>

<span class="fc" id="L333">            final double rangeRate = Utils.dotProduct(tmp7b, tmp5b);</span>

<span class="fc" id="L335">            predMeas.setElementAt(j, 1, rangeRate</span>
<span class="fc" id="L336">                    + xEstPropagated.getElementAtIndex(16));</span>

<span class="fc" id="L338">            j++;</span>
<span class="fc" id="L339">        }</span>

        // 5. Set-up measurement matrix using (14.126)
<span class="fc" id="L342">        final Matrix h = new Matrix(2 * numberOfMeasurements, INSTightlyCoupledKalmanState.NUM_PARAMS);</span>
<span class="fc bfc" id="L343" title="All 2 branches covered.">        for (int j1 = 0, j2 = numberOfMeasurements; j1 &lt; numberOfMeasurements; j1++, j2++) {</span>
<span class="fc bfc" id="L344" title="All 2 branches covered.">            for (int i1 = 0, i2 = 6, i3 = 3; i1 &lt; CoordinateTransformation.ROWS; i1++, i2++, i3++) {</span>
<span class="fc" id="L345">                final double value = uAseT.getElementAt(j1, i1);</span>

<span class="fc" id="L347">                h.setElementAt(j1, i2, value);</span>
<span class="fc" id="L348">                h.setElementAt(j2, i3, value);</span>
            }
<span class="fc" id="L350">            h.setElementAt(j1, 15, 1.0);</span>
<span class="fc" id="L351">            h.setElementAt(j2, 16, 1.0);</span>
        }

        // 6. Set-up measurement noise covariance matrix assuming all measurements are independent
        // and have equal variance for a given measurement type.
<span class="fc" id="L356">        final double pseudoRangeSD = config.getPseudoRangeSD();</span>
<span class="fc" id="L357">        final double pseudoRangeSD2 = pseudoRangeSD * pseudoRangeSD;</span>
<span class="fc" id="L358">        final double rangeRateSD = config.getRangeRateSD();</span>
<span class="fc" id="L359">        final double rangeRateSD2 = rangeRateSD * rangeRateSD;</span>
<span class="fc" id="L360">        final Matrix r = new Matrix(2 * numberOfMeasurements, 2 * numberOfMeasurements);</span>
<span class="fc bfc" id="L361" title="All 2 branches covered.">        for (int i1 = 0, i2 = numberOfMeasurements; i1 &lt; numberOfMeasurements; i1++, i2++) {</span>
<span class="fc" id="L362">            r.setElementAt(i1, i1, pseudoRangeSD2);</span>
<span class="fc" id="L363">            r.setElementAt(i2, i2, rangeRateSD2);</span>
        }

        // 7. Calculate Kalman gain using (3.21)
<span class="fc" id="L367">        final Matrix hTransposed = h.transposeAndReturnNew();</span>
<span class="fc" id="L368">        final Matrix tmp8b = h.multiplyAndReturnNew(</span>
<span class="fc" id="L369">                pMatrixPropagated.multiplyAndReturnNew(hTransposed));</span>
<span class="fc" id="L370">        tmp8b.add(r);</span>
<span class="fc" id="L371">        final Matrix tmp9b = Utils.inverse(tmp8b);</span>
<span class="fc" id="L372">        final Matrix k = pMatrixPropagated.multiplyAndReturnNew(hTransposed);</span>
<span class="fc" id="L373">        k.multiply(tmp9b);</span>

        // 8. Formulate measurement innovations using (14.119)
<span class="fc" id="L376">        final Matrix deltaZ = new Matrix(2 * numberOfMeasurements, 1);</span>
<span class="fc" id="L377">        int i1 = 0;</span>
<span class="fc" id="L378">        int i2 = numberOfMeasurements;</span>
<span class="fc bfc" id="L379" title="All 2 branches covered.">        for (final GNSSMeasurement measurement : measurements) {</span>
<span class="fc" id="L380">            deltaZ.setElementAtIndex(i1, measurement.getPseudoRange()</span>
<span class="fc" id="L381">                    - predMeas.getElementAt(i1, 0));</span>
<span class="fc" id="L382">            deltaZ.setElementAtIndex(i2, measurement.getPseudoRate()</span>
<span class="fc" id="L383">                    - predMeas.getElementAt(i1, 1));</span>

<span class="fc" id="L385">            i1++;</span>
<span class="fc" id="L386">            i2++;</span>
<span class="fc" id="L387">        }</span>

        // 9. Update state estimates using (3.24)
<span class="fc" id="L390">        xEstPropagated.add(k.multiplyAndReturnNew(deltaZ));</span>

        // xEstPropagated now contains updated state

        // 10. Update state estimation error covariance matrix using (3.25)
<span class="fc" id="L395">        Matrix updatedCovariance = result.getCovariance();</span>
<span class="pc bpc" id="L396" title="1 of 2 branches missed.">        if (updatedCovariance == null ||</span>
<span class="nc bnc" id="L397" title="All 2 branches missed.">                updatedCovariance.getRows() != INSTightlyCoupledKalmanState.NUM_PARAMS ||</span>
<span class="nc bnc" id="L398" title="All 2 branches missed.">                updatedCovariance.getColumns() != INSTightlyCoupledKalmanState.NUM_PARAMS) {</span>
<span class="fc" id="L399">            updatedCovariance = Matrix.identity(INSTightlyCoupledKalmanState.NUM_PARAMS,</span>
                    INSTightlyCoupledKalmanState.NUM_PARAMS);
        } else {
<span class="nc" id="L402">            Matrix.identity(updatedCovariance);</span>
        }
<span class="fc" id="L404">        k.multiply(h);</span>
<span class="fc" id="L405">        updatedCovariance.subtract(k);</span>
<span class="fc" id="L406">        updatedCovariance.multiply(pMatrixPropagated);</span>


        // CLOSED-LOOP CORRECTION

        // Correct attitude, velocity, and position using (14.7-9)

<span class="fc" id="L413">        Matrix estCbeNew = result.getBodyToEcefCoordinateTransformationMatrix();</span>
<span class="pc bpc" id="L414" title="1 of 2 branches missed.">        if (estCbeNew == null) {</span>
<span class="fc" id="L415">            estCbeNew = Matrix.identity(CoordinateTransformation.ROWS,</span>
                    CoordinateTransformation.COLS);
        } else {
<span class="nc" id="L418">            Matrix.identity(estCbeNew);</span>
        }

<span class="fc" id="L421">        xEstPropagated.getSubmatrix(0, 0,</span>
                2, 0, tmp1b);
<span class="fc" id="L423">        estCbeNew.subtract(Utils.skewMatrix(tmp1b));</span>
<span class="fc" id="L424">        estCbeNew.multiply(estCbeOld);</span>


<span class="fc" id="L427">        result.setBodyToEcefCoordinateTransformationMatrix(estCbeNew);</span>
<span class="fc" id="L428">        result.setVelocityCoordinates(</span>
<span class="fc" id="L429">                prevVx - xEstPropagated.getElementAtIndex(3),</span>
<span class="fc" id="L430">                prevVy - xEstPropagated.getElementAtIndex(4),</span>
<span class="fc" id="L431">                prevVz - xEstPropagated.getElementAtIndex(5));</span>
<span class="fc" id="L432">        result.setPositionCoordinates(</span>
<span class="fc" id="L433">                prevX - xEstPropagated.getElementAtIndex(6),</span>
<span class="fc" id="L434">                prevY - xEstPropagated.getElementAtIndex(7),</span>
<span class="fc" id="L435">                prevZ - xEstPropagated.getElementAtIndex(8));</span>
<span class="fc" id="L436">        result.setCovariance(updatedCovariance);</span>

        // Update IMU bias and GNSS receiver clock estimates
<span class="fc" id="L439">        final double prevAccelBiasX = previousState.getAccelerationBiasX();</span>
<span class="fc" id="L440">        final double prevAccelBiasY = previousState.getAccelerationBiasY();</span>
<span class="fc" id="L441">        final double prevAccelBiasZ = previousState.getAccelerationBiasZ();</span>
<span class="fc" id="L442">        final double prevGyroBiasX = previousState.getGyroBiasX();</span>
<span class="fc" id="L443">        final double prevGyroBiasY = previousState.getGyroBiasY();</span>
<span class="fc" id="L444">        final double prevGyroBiasZ = previousState.getGyroBiasZ();</span>

<span class="fc" id="L446">        result.setAccelerationBiasCoordinates(</span>
<span class="fc" id="L447">                prevAccelBiasX + xEstPropagated.getElementAtIndex(9),</span>
<span class="fc" id="L448">                prevAccelBiasY + xEstPropagated.getElementAtIndex(10),</span>
<span class="fc" id="L449">                prevAccelBiasZ + xEstPropagated.getElementAtIndex(11));</span>
<span class="fc" id="L450">        result.setGyroBiasCoordinates(</span>
<span class="fc" id="L451">                prevGyroBiasX + xEstPropagated.getElementAtIndex(12),</span>
<span class="fc" id="L452">                prevGyroBiasY + xEstPropagated.getElementAtIndex(13),</span>
<span class="fc" id="L453">                prevGyroBiasZ + xEstPropagated.getElementAtIndex(14));</span>

<span class="fc" id="L455">        result.setReceiverClockOffset(xEstPropagated.getElementAtIndex(15));</span>
<span class="fc" id="L456">        result.setReceiverClockDrift(xEstPropagated.getElementAtIndex(16));</span>
<span class="fc" id="L457">    }</span>

    /**
     * Estimates the update of Kalman filter state and covariance matrix for a single
     * epoch.
     *
     * @param measurements        satellite measurements data.
     * @param propagationInterval propagation interval expressed in seconds (s).
     * @param previousState       previous Kalman filter state.
     * @param fx                  measured specific force resolved along body frame
     *                            x-axis and expressed in meters per squared
     *                            second (m/s^2).
     * @param fy                  measured specific force resolved along body frame
     *                            y-axis and expressed in meters per squared
     *                            second (m/s^2).
     * @param fz                  measured specific force resolved along body frame
     *                            z-axis and expressed in meters per squared
     *                            second (m/s^2).
     * @param previousLatitude    previous latitude solution expressed in radians (rad).
     * @param config              Tightly Coupled Kalman filter configuration.
     * @return new state of Kalman filter.
     * @throws AlgebraException if there are numerical instabilities.
     */
    public static INSTightlyCoupledKalmanState estimate(
            final Collection&lt;GNSSMeasurement&gt; measurements,
            final double propagationInterval,
            final INSTightlyCoupledKalmanState previousState,
            final double fx, final double fy, final double fz,
            final double previousLatitude,
            final INSTightlyCoupledKalmanConfig config) throws AlgebraException {
<span class="fc" id="L487">        final INSTightlyCoupledKalmanState result = new INSTightlyCoupledKalmanState();</span>
<span class="fc" id="L488">        estimate(measurements, propagationInterval, previousState,</span>
                fx, fy, fz, previousLatitude, config, result);
<span class="fc" id="L490">        return result;</span>
    }

    /**
     * Estimates the update of Kalman filter state and covariance matrix for a single
     * epoch.
     *
     * @param measurements        satellite measurements data.
     * @param propagationInterval propagation interval.
     * @param previousState       previous Kalman filter state.
     * @param fx                  measured specific force resolved along body frame
     *                            x-axis and expressed in meters per squared
     *                            second (m/s^2).
     * @param fy                  measured specific force resolved along body frame
     *                            y-axis and expressed in meters per squared
     *                            second (m/s^2).
     * @param fz                  measured specific force resolved along body frame
     *                            z-axis and expressed in meters per squared
     *                            second (m/s^2).
     * @param previousLatitude    previous latitude solution expressed in radians (rad).
     * @param config              Tightly Coupled Kalman filter configuration.
     * @param result              instance where new state of Kalman filter will be
     *                            stored.
     * @throws AlgebraException if there are numerical instabilities.
     */
    public static void estimate(
            final Collection&lt;GNSSMeasurement&gt; measurements,
            final Time propagationInterval,
            final INSTightlyCoupledKalmanState previousState,
            final double fx, final double fy, final double fz,
            final double previousLatitude,
            final INSTightlyCoupledKalmanConfig config,
            final INSTightlyCoupledKalmanState result) throws AlgebraException {
<span class="fc" id="L523">        estimate(measurements, convertTime(propagationInterval),</span>
                previousState, fx, fy, fz, previousLatitude, config, result);
<span class="fc" id="L525">    }</span>

    /**
     * Estimates the update of Kalman filter state and covariance matrix for a single
     * epoch.
     *
     * @param measurements        satellite measurements data.
     * @param propagationInterval propagation interval.
     * @param previousState       previous Kalman filter state.
     * @param fx                  measured specific force resolved along body frame
     *                            x-axis and expressed in meters per squared
     *                            second (m/s^2).
     * @param fy                  measured specific force resolved along body frame
     *                            y-axis and expressed in meters per squared
     *                            second (m/s^2).
     * @param fz                  measured specific force resolved along body frame
     *                            z-axis and expressed in meters per squared
     *                            second (m/s^2).
     * @param previousLatitude    previous latitude solution expressed in radians (rad).
     * @param config              Tightly Coupled Kalman filter configuration.
     * @return new state of Kalman filter.
     * @throws AlgebraException if there are numerical instabilities.
     */
    public static INSTightlyCoupledKalmanState estimate(
            final Collection&lt;GNSSMeasurement&gt; measurements,
            final Time propagationInterval,
            final INSTightlyCoupledKalmanState previousState,
            final double fx, final double fy, final double fz,
            final double previousLatitude,
            final INSTightlyCoupledKalmanConfig config) throws AlgebraException {
<span class="fc" id="L555">        return estimate(measurements, convertTime(propagationInterval),</span>
                previousState, fx, fy, fz, previousLatitude, config);
    }

    /**
     * Estimates the update of Kalman filter state and covariance matrix for a single
     * epoch.
     *
     * @param measurements        satellite measurements data.
     * @param propagationInterval propagation interval expressed in seconds (s).
     * @param previousState       previous Kalman filter state.
     * @param fx                  measured specific force resolved along body frame
     *                            x-axis and expressed in meters per squared
     *                            second (m/s^2).
     * @param fy                  measured specific force resolved along body frame
     *                            y-axis and expressed in meters per squared
     *                            second (m/s^2).
     * @param fz                  measured specific force resolved along body frame
     *                            z-axis and expressed in meters per squared
     *                            second (m/s^2).
     * @param config              Tightly Coupled Kalman filter configuration.
     * @param result              instance where new state of Kalman filter will be
     *                            stored.
     * @throws AlgebraException if there are numerical instabilities.
     */
    public static void estimate(
            final Collection&lt;GNSSMeasurement&gt; measurements,
            final double propagationInterval,
            final INSTightlyCoupledKalmanState previousState,
            final double fx, final double fy, final double fz,
            final INSTightlyCoupledKalmanConfig config,
            final INSTightlyCoupledKalmanState result) throws AlgebraException {

<span class="fc" id="L588">        final NEDPosition prevNedPosition = new NEDPosition();</span>
<span class="fc" id="L589">        final NEDVelocity prevNedVelocity = new NEDVelocity();</span>
<span class="fc" id="L590">        ECEFtoNEDPositionVelocityConverter.convertECEFtoNED(</span>
<span class="fc" id="L591">                previousState.getX(), previousState.getY(), previousState.getZ(),</span>
<span class="fc" id="L592">                previousState.getVx(), previousState.getVy(), previousState.getVz(),</span>
                prevNedPosition, prevNedVelocity);

<span class="fc" id="L595">        final double previousLatitude = prevNedPosition.getLatitude();</span>

<span class="fc" id="L597">        estimate(measurements, propagationInterval, previousState,</span>
                fx, fy, fz, previousLatitude, config, result);
<span class="fc" id="L599">    }</span>

    /**
     * Estimates the update of Kalman filter state and covariance matrix for a single
     * epoch.
     *
     * @param measurements        satellite measurements data.
     * @param propagationInterval propagation interval expressed in seconds (s).
     * @param previousState       previous Kalman filter state.
     * @param fx                  measured specific force resolved along body frame
     *                            x-axis and expressed in meters per squared
     *                            second (m/s^2).
     * @param fy                  measured specific force resolved along body frame
     *                            y-axis and expressed in meters per squared
     *                            second (m/s^2).
     * @param fz                  measured specific force resolved along body frame
     *                            z-axis and expressed in meters per squared
     *                            second (m/s^2).
     * @param config              Tightly Coupled Kalman filter configuration.
     * @return new state of Kalman filter.
     * @throws AlgebraException if there are numerical instabilities.
     */
    public static INSTightlyCoupledKalmanState estimate(
            final Collection&lt;GNSSMeasurement&gt; measurements,
            final double propagationInterval,
            final INSTightlyCoupledKalmanState previousState,
            final double fx, final double fy, final double fz,
            final INSTightlyCoupledKalmanConfig config) throws AlgebraException {
<span class="fc" id="L627">        final INSTightlyCoupledKalmanState result = new INSTightlyCoupledKalmanState();</span>
<span class="fc" id="L628">        estimate(measurements, propagationInterval, previousState, fx, fy, fz,</span>
                config, result);
<span class="fc" id="L630">        return result;</span>
    }

    /**
     * Estimates the update of Kalman filter state and covariance matrix for a single
     * epoch.
     *
     * @param measurements        satellite measurements data.
     * @param propagationInterval propagation interval.
     * @param previousState       previous Kalman filter state.
     * @param fx                  measured specific force resolved along body frame
     *                            x-axis and expressed in meters per squared
     *                            second (m/s^2).
     * @param fy                  measured specific force resolved along body frame
     *                            y-axis and expressed in meters per squared
     *                            second (m/s^2).
     * @param fz                  measured specific force resolved along body frame
     *                            z-axis and expressed in meters per squared
     *                            second (m/s^2).
     * @param config              Tightly Coupled Kalman filter configuration.
     * @param result              instance where new state of Kalman filter will be
     *                            stored.
     * @throws AlgebraException if there are numerical instabilities.
     */
    public static void estimate(
            final Collection&lt;GNSSMeasurement&gt; measurements,
            final Time propagationInterval,
            final INSTightlyCoupledKalmanState previousState,
            final double fx, final double fy, final double fz,
            final INSTightlyCoupledKalmanConfig config,
            final INSTightlyCoupledKalmanState result) throws AlgebraException {
<span class="fc" id="L661">        estimate(measurements, convertTime(propagationInterval),</span>
                previousState, fx, fy, fz, config, result);
<span class="fc" id="L663">    }</span>

    /**
     * Estimates the update of Kalman filter state and covariance matrix for a single
     * epoch.
     *
     * @param measurements        satellite measurements data.
     * @param propagationInterval propagation interval.
     * @param previousState       previous Kalman filter state.
     * @param fx                  measured specific force resolved along body frame
     *                            x-axis and expressed in meters per squared
     *                            second (m/s^2).
     * @param fy                  measured specific force resolved along body frame
     *                            y-axis and expressed in meters per squared
     *                            second (m/s^2).
     * @param fz                  measured specific force resolved along body frame
     *                            second (m/s^2).
     * @param config              Tightly Coupled Kalman filter configuration.
     * @return new state of Kalman filter.
     * @throws AlgebraException if there are numerical instabilities.
     */
    public static INSTightlyCoupledKalmanState estimate(
            final Collection&lt;GNSSMeasurement&gt; measurements,
            final Time propagationInterval,
            final INSTightlyCoupledKalmanState previousState,
            final double fx, final double fy, final double fz,
            final INSTightlyCoupledKalmanConfig config) throws AlgebraException {
<span class="fc" id="L690">        return estimate(measurements, convertTime(propagationInterval),</span>
                previousState, fx, fy, fz, config);
    }

    /**
     * Estimates the update of Kalman filter state and covariance matrix for a single
     * epoch.
     *
     * @param measurements        satellite measurements data.
     * @param propagationInterval propagation interval expressed in seconds (s).
     * @param previousState       previous Kalman filter state.
     * @param bodyKinematics      body kinematics containing measured specific force
     *                            resolved along body frame axes.
     * @param previousLatitude    previous latitude solution expressed in radians (rad).
     * @param config              Tightly Coupled Kalman filter configuration.
     * @param result              instance where new state of Kalman filter will be
     *                            stored.
     * @throws AlgebraException if there are numerical instabilities.
     */
    public static void estimate(
            final Collection&lt;GNSSMeasurement&gt; measurements,
            final double propagationInterval,
            final INSTightlyCoupledKalmanState previousState,
            final BodyKinematics bodyKinematics,
            final double previousLatitude,
            final INSTightlyCoupledKalmanConfig config,
            final INSTightlyCoupledKalmanState result) throws AlgebraException {

<span class="fc" id="L718">        final double fx = bodyKinematics.getFx();</span>
<span class="fc" id="L719">        final double fy = bodyKinematics.getFy();</span>
<span class="fc" id="L720">        final double fz = bodyKinematics.getFz();</span>

<span class="fc" id="L722">        estimate(measurements, propagationInterval, previousState,</span>
                fx, fy, fz, previousLatitude, config, result);
<span class="fc" id="L724">    }</span>

    /**
     * Estimates the update of Kalman filter state and covariance matrix for a single
     * epoch.
     *
     * @param measurements        satellite measurements data.
     * @param propagationInterval propagation interval expressed in seconds (s).
     * @param previousState       previous Kalman filter state.
     * @param bodyKinematics      body kinematics containing measured specific force
     *                            resolved along body frame axes.
     * @param previousLatitude    previous latitude solution expressed in radians (rad).
     * @param config              Tightly Coupled Kalman filter configuration.
     * @return new state of Kalman filter.
     * @throws AlgebraException if there are numerical instabilities.
     */
    public static INSTightlyCoupledKalmanState estimate(
            final Collection&lt;GNSSMeasurement&gt; measurements,
            final double propagationInterval,
            final INSTightlyCoupledKalmanState previousState,
            final BodyKinematics bodyKinematics,
            final double previousLatitude,
            final INSTightlyCoupledKalmanConfig config) throws AlgebraException {
<span class="fc" id="L747">        final INSTightlyCoupledKalmanState result = new INSTightlyCoupledKalmanState();</span>
<span class="fc" id="L748">        estimate(measurements, propagationInterval, previousState,</span>
                bodyKinematics, previousLatitude, config, result);
<span class="fc" id="L750">        return result;</span>
    }

    /**
     * Estimates the update of Kalman filter state and covariance matrix for a single
     * epoch.
     *
     * @param measurements        satellite measurements data.
     * @param propagationInterval propagation interval.
     * @param previousState       previous Kalman filter state.
     * @param bodyKinematics      body kinematics containing measured specific force
     *                            resolved along body frame axes.
     * @param previousLatitude    previous latitude solution expressed in radians (rad).
     * @param config              Tightly Coupled Kalman filter configuration.
     * @param result              instance where new state of Kalman filter will be
     *                            stored.
     * @throws AlgebraException if there are numerical instabilities.
     */
    public static void estimate(
            final Collection&lt;GNSSMeasurement&gt; measurements,
            final Time propagationInterval,
            final INSTightlyCoupledKalmanState previousState,
            final BodyKinematics bodyKinematics,
            final double previousLatitude,
            final INSTightlyCoupledKalmanConfig config,
            final INSTightlyCoupledKalmanState result) throws AlgebraException {
<span class="fc" id="L776">        estimate(measurements, convertTime(propagationInterval),</span>
                previousState, bodyKinematics, previousLatitude, config, result);
<span class="fc" id="L778">    }</span>

    /**
     * Estimates the update of Kalman filter state and covariance matrix for a single
     * epoch.
     *
     * @param measurements        satellite measurements data.
     * @param propagationInterval propagation interval.
     * @param previousState       previous Kalman filter state.
     * @param bodyKinematics      body kinematics containing measured specific force
     *                            resolved along body frame axes.
     * @param previousLatitude    previous latitude solution expressed in radians (rad).
     * @param config              Tightly Coupled Kalman filter configuration.
     * @return new state of Kalman filter.
     * @throws AlgebraException if there are numerical instabilities.
     */
    public static INSTightlyCoupledKalmanState estimate(
            final Collection&lt;GNSSMeasurement&gt; measurements,
            final Time propagationInterval,
            final INSTightlyCoupledKalmanState previousState,
            final BodyKinematics bodyKinematics,
            final double previousLatitude,
            final INSTightlyCoupledKalmanConfig config) throws AlgebraException {
<span class="fc" id="L801">        return estimate(measurements, convertTime(propagationInterval),</span>
                previousState, bodyKinematics, previousLatitude, config);
    }

    /**
     * Estimates the update of Kalman filter state and covariance matrix for a single
     * epoch.
     *
     * @param measurements        satellite measurements data.
     * @param propagationInterval propagation interval expressed in seconds (s).
     * @param previousState       previous Kalman filter state.
     * @param bodyKinematics      body kinematics containing measured specific force
     *                            resolved along body frame axes.
     * @param config              Tightly Coupled Kalman filter configuration.
     * @param result              instance where new state of Kalman filter will be
     *                            stored.
     * @throws AlgebraException if there are numerical instabilities.
     */
    public static void estimate(
            final Collection&lt;GNSSMeasurement&gt; measurements,
            final double propagationInterval,
            final INSTightlyCoupledKalmanState previousState,
            final BodyKinematics bodyKinematics,
            final INSTightlyCoupledKalmanConfig config,
            final INSTightlyCoupledKalmanState result) throws AlgebraException {

<span class="fc" id="L827">        final double fx = bodyKinematics.getFx();</span>
<span class="fc" id="L828">        final double fy = bodyKinematics.getFy();</span>
<span class="fc" id="L829">        final double fz = bodyKinematics.getFz();</span>

<span class="fc" id="L831">        estimate(measurements, propagationInterval, previousState,</span>
                fx, fy, fz, config, result);
<span class="fc" id="L833">    }</span>

    /**
     * Estimates the update of Kalman filter state and covariance matrix for a single
     * epoch.
     *
     * @param measurements        satellite measurements data.
     * @param propagationInterval propagation interval expressed in seconds (s).
     * @param previousState       previous Kalman filter state.
     * @param bodyKinematics      body kinematics containing measured specific force
     *                            resolved along body frame axes.
     * @param config              Tightly Coupled Kalman filter configuration.
     * @return new state of Kalman filter.
     * @throws AlgebraException if there are numerical instabilities.
     */
    public static INSTightlyCoupledKalmanState estimate(
            final Collection&lt;GNSSMeasurement&gt; measurements,
            final double propagationInterval,
            final INSTightlyCoupledKalmanState previousState,
            final BodyKinematics bodyKinematics,
            final INSTightlyCoupledKalmanConfig config) throws AlgebraException {
<span class="fc" id="L854">        final INSTightlyCoupledKalmanState result = new INSTightlyCoupledKalmanState();</span>
<span class="fc" id="L855">        estimate(measurements, propagationInterval, previousState, bodyKinematics,</span>
                config, result);
<span class="fc" id="L857">        return result;</span>
    }

    /**
     * Estimates the update of Kalman filter state and covariance matrix for a single
     * epoch.
     *
     * @param measurements        satellite measurements data.
     * @param propagationInterval propagation interval.
     * @param previousState       previous Kalman filter state.
     * @param bodyKinematics      body kinematics containing measured specific force
     *                            resolved along body frame axes.
     * @param config              Tightly Coupled Kalman filter configuration.
     * @param result              instance where new state of Kalman filter will be
     *                            stored.
     * @throws AlgebraException if there are numerical instabilities.
     */
    public static void estimate(
            final Collection&lt;GNSSMeasurement&gt; measurements,
            final Time propagationInterval,
            final INSTightlyCoupledKalmanState previousState,
            final BodyKinematics bodyKinematics,
            final INSTightlyCoupledKalmanConfig config,
            final INSTightlyCoupledKalmanState result) throws AlgebraException {
<span class="fc" id="L881">        estimate(measurements, convertTime(propagationInterval), previousState,</span>
                bodyKinematics, config, result);
<span class="fc" id="L883">    }</span>

    /**
     * Estimates the update of Kalman filter state and covariance matrix for a single
     * epoch.
     *
     * @param measurements        satellite measurements data.
     * @param propagationInterval propagation interval expressed in seconds (s).
     * @param previousState       previous Kalman filter state.
     * @param bodyKinematics      body kinematics containing measured specific force
     *                            resolved along body frame axes.
     * @param config              Tightly Coupled Kalman filter configuration.
     * @return new state of Kalman filter.
     * @throws AlgebraException if there are numerical instabilities.
     */
    public static INSTightlyCoupledKalmanState estimate(
            final Collection&lt;GNSSMeasurement&gt; measurements,
            final Time propagationInterval,
            final INSTightlyCoupledKalmanState previousState,
            final BodyKinematics bodyKinematics,
            final INSTightlyCoupledKalmanConfig config) throws AlgebraException {
<span class="fc" id="L904">        return estimate(measurements, convertTime(propagationInterval),</span>
                previousState, bodyKinematics, config);
    }

    /**
     * Estimates the update of Kalman filter state and covariance matrix for a single
     * epoch.
     *
     * @param measurements        satellite measurements data.
     * @param propagationInterval propagation interval expressed in seconds (s).
     * @param previousState       previous Kalman filter state.
     * @param fx                  measured specific force resolved along body frame
     *                            x-axis and expressed in meters per squared
     *                            second (m/s^2).
     * @param fy                  measured specific force resolved along body frame
     *                            y-axis and expressed in meters per squared
     *                            second (m/s^2).
     * @param fz                  measured specific force resolved along body frame
     *                            z-axis and expressed in meters per squared
     *                            second (m/s^2).
     * @param previousLatitude    previous latitude solution.
     * @param config              Tightly Coupled Kalman filter configuration.
     * @param result              instance where new state of Kalman filter will be
     *                            stored.
     * @throws AlgebraException if there are numerical instabilities.
     */
    public static void estimate(
            final Collection&lt;GNSSMeasurement&gt; measurements,
            final double propagationInterval,
            final INSTightlyCoupledKalmanState previousState,
            final double fx, final double fy, final double fz,
            final Angle previousLatitude,
            final INSTightlyCoupledKalmanConfig config,
            final INSTightlyCoupledKalmanState result) throws AlgebraException {
<span class="fc" id="L938">        estimate(measurements, propagationInterval, previousState,</span>
<span class="fc" id="L939">                fx, fy, fz, convertAngle(previousLatitude), config, result);</span>
<span class="fc" id="L940">    }</span>

    /**
     * Estimates the update of Kalman filter state and covariance matrix for a single
     * epoch.
     *
     * @param measurements        satellite measurements data.
     * @param propagationInterval propagation interval expressed in seconds (s).
     * @param previousState       previous Kalman filter state.
     * @param fx                  measured specific force resolved along body frame
     *                            x-axis and expressed in meters per squared
     *                            second (m/s^2).
     * @param fy                  measured specific force resolved along body frame
     *                            y-axis and expressed in meters per squared
     *                            second (m/s^2).
     * @param fz                  measured specific force resolved along body frame
     *                            z-axis and expressed in meters per squared
     *                            second (m/s^2).
     * @param previousLatitude    previous latitude solution.
     * @param config              Tightly Coupled Kalman filter configuration.
     * @return new state of Kalman filter.
     * @throws AlgebraException if there are numerical instabilities.
     */
    public static INSTightlyCoupledKalmanState estimate(
            final Collection&lt;GNSSMeasurement&gt; measurements,
            final double propagationInterval,
            final INSTightlyCoupledKalmanState previousState,
            final double fx, final double fy, final double fz,
            final Angle previousLatitude,
            final INSTightlyCoupledKalmanConfig config) throws AlgebraException {
<span class="fc" id="L970">        return estimate(measurements, propagationInterval, previousState,</span>
<span class="fc" id="L971">                fx, fy, fz, convertAngle(previousLatitude), config);</span>
    }

    /**
     * Estimates the update of Kalman filter state and covariance matrix for a single
     * epoch.
     *
     * @param measurements        satellite measurements data.
     * @param propagationInterval propagation interval expressed in seconds (s).
     * @param previousState       previous Kalman filter state.
     * @param fx                  measured specific force resolved along body frame
     *                            x-axis and expressed in meters per squared
     *                            second (m/s^2).
     * @param fy                  measured specific force resolved along body frame
     *                            y-axis and expressed in meters per squared
     *                            second (m/s^2).
     * @param fz                  measured specific force resolved along body frame
     *                            z-axis and expressed in meters per squared
     *                            second (m/s^2).
     * @param previousLatitude    previous latitude solution.
     * @param config              Tightly Coupled Kalman filter configuration.
     * @param result              instance where new state of Kalman filter will be
     *                            stored.
     * @throws AlgebraException if there are numerical instabilities.
     */
    public static void estimate(
            final Collection&lt;GNSSMeasurement&gt; measurements,
            final Time propagationInterval,
            final INSTightlyCoupledKalmanState previousState,
            final double fx, final double fy, final double fz,
            final Angle previousLatitude,
            final INSTightlyCoupledKalmanConfig config,
            final INSTightlyCoupledKalmanState result) throws AlgebraException {
<span class="fc" id="L1004">        estimate(measurements, propagationInterval, previousState,</span>
<span class="fc" id="L1005">                fx, fy, fz, convertAngle(previousLatitude), config,</span>
                result);
<span class="fc" id="L1007">    }</span>

    /**
     * Estimates the update of Kalman filter state and covariance matrix for a single
     * epoch.
     *
     * @param measurements        satellite measurements data.
     * @param propagationInterval propagation interval expressed in seconds (s).
     * @param previousState       previous Kalman filter state.
     * @param fx                  measured specific force resolved along body frame
     *                            x-axis and expressed in meters per squared
     *                            second (m/s^2).
     * @param fy                  measured specific force resolved along body frame
     *                            y-axis and expressed in meters per squared
     *                            second (m/s^2).
     * @param fz                  measured specific force resolved along body frame
     *                            z-axis and expressed in meters per squared
     *                            second (m/s^2).
     * @param previousLatitude    previous latitude solution.
     * @param config              Tightly Coupled Kalman filter configuration.
     * @return new state of Kalman filter.
     * @throws AlgebraException if there are numerical instabilities.
     */
    public static INSTightlyCoupledKalmanState estimate(
            final Collection&lt;GNSSMeasurement&gt; measurements,
            final Time propagationInterval,
            final INSTightlyCoupledKalmanState previousState,
            final double fx, final double fy, final double fz,
            final Angle previousLatitude,
            final INSTightlyCoupledKalmanConfig config) throws AlgebraException {
<span class="fc" id="L1037">        return estimate(measurements, propagationInterval, previousState,</span>
<span class="fc" id="L1038">                fx, fy, fz, convertAngle(previousLatitude), config);</span>
    }

    /**
     * Estimates the update of Kalman filter state and covariance matrix for a single
     * epoch.
     *
     * @param measurements        satellite measurements data.
     * @param propagationInterval propagation interval expressed in seconds (s).
     * @param previousState       previous Kalman filter state.
     * @param bodyKinematics      body kinematics containing measured specific force
     *                            resolved along body frame axes.
     * @param previousLatitude    previous latitude solution.
     * @param config              Tightly Coupled Kalman filter configuration.
     * @param result              instance where new state of Kalman filter will be
     *                            stored.
     * @throws AlgebraException if there are numerical instabilities.
     */
    public static void estimate(
            final Collection&lt;GNSSMeasurement&gt; measurements,
            final double propagationInterval,
            final INSTightlyCoupledKalmanState previousState,
            final BodyKinematics bodyKinematics,
            final Angle previousLatitude,
            final INSTightlyCoupledKalmanConfig config,
            final INSTightlyCoupledKalmanState result) throws AlgebraException {
<span class="fc" id="L1064">        estimate(measurements, propagationInterval, previousState,</span>
<span class="fc" id="L1065">                bodyKinematics, convertAngle(previousLatitude), config, result);</span>
<span class="fc" id="L1066">    }</span>

    /**
     * Estimates the update of Kalman filter state and covariance matrix for a single
     * epoch.
     *
     * @param measurements        satellite measurements data.
     * @param propagationInterval propagation interval expressed in seconds (s).
     * @param previousState       previous Kalman filter state.
     * @param bodyKinematics      body kinematics containing measured specific force
     *                            resolved along body frame axes.
     * @param previousLatitude    previous latitude solution.
     * @param config              Tightly Coupled Kalman filter configuration.
     * @return new state of Kalman filter.
     * @throws AlgebraException if there are numerical instabilities.
     */
    public static INSTightlyCoupledKalmanState estimate(
            final Collection&lt;GNSSMeasurement&gt; measurements,
            final double propagationInterval,
            final INSTightlyCoupledKalmanState previousState,
            final BodyKinematics bodyKinematics,
            final Angle previousLatitude,
            final INSTightlyCoupledKalmanConfig config) throws AlgebraException {
<span class="fc" id="L1089">        return estimate(measurements, propagationInterval, previousState,</span>
<span class="fc" id="L1090">                bodyKinematics, convertAngle(previousLatitude), config);</span>
    }

    /**
     * Estimtes the update of Kalman filter state and covariance matrix for a single
     * epoch.
     *
     * @param measurements        satellite measurements data.
     * @param propagationInterval propagation interval.
     * @param previousState       previous Kalman filter state.
     * @param bodyKinematics      body kinematics containing measured specific force
     *                            resolved along body frame axes.
     * @param previousLatitude    previous latitude solution.
     * @param config              Tightly Coupled Kalman filter configuration.
     * @param result              instance where new state of Kalman filter will be
     *                            stored.
     * @throws AlgebraException if there are numerical instabilities.
     */
    public static void estimate(
            final Collection&lt;GNSSMeasurement&gt; measurements,
            final Time propagationInterval,
            final INSTightlyCoupledKalmanState previousState,
            final BodyKinematics bodyKinematics,
            final Angle previousLatitude,
            final INSTightlyCoupledKalmanConfig config,
            final INSTightlyCoupledKalmanState result) throws AlgebraException {
<span class="fc" id="L1116">        estimate(measurements, propagationInterval, previousState,</span>
<span class="fc" id="L1117">                bodyKinematics, convertAngle(previousLatitude), config, result);</span>
<span class="fc" id="L1118">    }</span>

    /**
     * Estimates the update of Kalman filter state and covariance matrix for a single
     * epoch.
     *
     * @param measurements        satellite measurements data.
     * @param propagationInterval propagation interval.
     * @param previousState       previous Kalman filter state.
     * @param bodyKinematics      body kinematics containing measured specific force
     *                            resolved along body frame axes.
     * @param previousLatitude    previous latitude solution.
     * @param config              Tightly Coupled Kalman filter configuration.
     * @return new state of Kalman filter.
     * @throws AlgebraException if there are numerical instabilities.
     */
    public static INSTightlyCoupledKalmanState estimate(
            final Collection&lt;GNSSMeasurement&gt; measurements,
            final Time propagationInterval,
            final INSTightlyCoupledKalmanState previousState,
            final BodyKinematics bodyKinematics,
            final Angle previousLatitude,
            final INSTightlyCoupledKalmanConfig config) throws AlgebraException {
<span class="fc" id="L1141">        return estimate(measurements, propagationInterval, previousState,</span>
<span class="fc" id="L1142">                bodyKinematics, convertAngle(previousLatitude), config);</span>
    }

    /**
     * Converts time instance into a value expressed in seconds.
     *
     * @param time time instance to be converted.
     * @return time value expressed in seconds.
     */
    private static double convertTime(final Time time) {
<span class="fc" id="L1152">        return TimeConverter.convert(time.getValue().doubleValue(),</span>
<span class="fc" id="L1153">                time.getUnit(), TimeUnit.SECOND);</span>
    }

    /**
     * Converts angle instance into a value expressed in radians.
     *
     * @param angle angle instance to be converted.
     * @return angle value expressed in radians.
     */
    private static double convertAngle(final Angle angle) {
<span class="fc" id="L1163">        return AngleConverter.convert(angle.getValue().doubleValue(),</span>
<span class="fc" id="L1164">                angle.getUnit(), AngleUnit.RADIANS);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>