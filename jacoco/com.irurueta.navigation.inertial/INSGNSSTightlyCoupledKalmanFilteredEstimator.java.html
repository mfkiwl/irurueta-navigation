<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>INSGNSSTightlyCoupledKalmanFilteredEstimator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.irurueta:irurueta-navigation</a> &gt; <a href="index.source.html" class="el_package">com.irurueta.navigation.inertial</a> &gt; <span class="el_source">INSGNSSTightlyCoupledKalmanFilteredEstimator.java</span></div><h1>INSGNSSTightlyCoupledKalmanFilteredEstimator.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2020 Alberto Irurueta Carro (alberto@irurueta.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.irurueta.navigation.inertial;

import com.irurueta.algebra.AlgebraException;
import com.irurueta.algebra.Matrix;
import com.irurueta.navigation.LockedException;
import com.irurueta.navigation.NotReadyException;
import com.irurueta.navigation.frames.CoordinateTransformation;
import com.irurueta.navigation.frames.ECEFFrame;
import com.irurueta.navigation.frames.InvalidSourceAndDestinationFrameTypeException;
import com.irurueta.navigation.gnss.GNSSEstimation;
import com.irurueta.navigation.gnss.GNSSException;
import com.irurueta.navigation.gnss.GNSSLeastSquaresPositionAndVelocityEstimator;
import com.irurueta.navigation.gnss.GNSSMeasurement;
import com.irurueta.navigation.inertial.navigators.ECEFInertialNavigator;
import com.irurueta.navigation.inertial.navigators.InertialNavigatorException;
import com.irurueta.units.Time;
import com.irurueta.units.TimeConverter;
import com.irurueta.units.TimeUnit;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;

/**
 * Calculates position, velocity, attitude, clock offset, clock drift and IMU biases
 * using a GNSS unweighted iterated least squares estimator along with an INS tightly
 * coupled Kalman filter to take into account inertial measurements to
 * smooth results.
 * This implementation is based on the equations defined in &quot;Principles of GNSS, Inertial, and Multisensor
 * Integrated Navigation Systems, Second Edition&quot; and on the companion software available at:
 * https://github.com/ymjdz/MATLAB-Codes/blob/master/Tightly_coupled_INS_GNSS.m
 */
public class INSGNSSTightlyCoupledKalmanFilteredEstimator {

    /**
     * Internal estimator to compute least squares solution for GNSS measurements.
     */
<span class="fc" id="L53">    private final GNSSLeastSquaresPositionAndVelocityEstimator mLsEstimator</span>
            = new GNSSLeastSquaresPositionAndVelocityEstimator();

    /**
     * Listener to notify events raised by this instance.
     */
    private INSGNSSTightlyCoupledKalmanFilteredEstimatorListener mListener;

    /**
     * Minimum epoch interval expressed in seconds (s) between consecutive
     * propagations or measurements.
     * Attempting to propagate results using Kalman filter or updating measurements
     * when intervals are less than this value, will be ignored.
     */
    private double mEpochInterval;

    /**
     * INS/GNSS tightly coupled Kalman filter configuration parameters (usually
     * obtained through calibration).
     */
    private INSTightlyCoupledKalmanConfig mConfig;

    /**
     * GNSS measurements of a collection of satellites.
     */
    private Collection&lt;GNSSMeasurement&gt; mMeasurements;

    /**
     * Last provided user kinematics containing applied specific force and
     * angular rates resolved in body axes.
     */
    private BodyKinematics mKinematics;

    /**
     * Contains last provided user kinematics minus currently estimated bias
     * for acceleration and angular rate values.
     */
    private BodyKinematics mCorrectedKinematics;

    /**
     * Internally keeps user position, velocity and attitude.
     */
    private ECEFFrame mFrame;

    /**
     * Configuration containing uncertainty measures to set initial covariance matrix
     * within estimated state.
     * Once this estimator is initialized, covariance will be updated with new provided
     * GNSS and INS measurements until convergence is reached.
     */
    private INSTightlyCoupledKalmanInitializerConfig mInitialConfig;

    /**
     * Current estimation containing user ECEF position, user ECEF velocity, clock offset
     * and clock drift.
     */
    private GNSSEstimation mEstimation;

    /**
     * Current Kalman filter state containing current INS/GNSS estimation along with
     * Kalman filter covariance error matrix.
     */
    private INSTightlyCoupledKalmanState mState;

    /**
     * Timestamp expressed in seconds since epoch time when Kalman filter state
     * was last propagated.
     */
    private Double mLastStateTimestamp;

    /**
     * Indicates whether this estimator is running or not.
     */
    private boolean mRunning;

    /**
     * Constructor.
     */
<span class="fc" id="L131">    public INSGNSSTightlyCoupledKalmanFilteredEstimator() {</span>
<span class="fc" id="L132">    }</span>

    /**
     * Constructor.
     *
     * @param config INS/GNSS Kalman filter configuration parameters (usually obtained
     *               through calibration).
     */
    public INSGNSSTightlyCoupledKalmanFilteredEstimator(
<span class="fc" id="L141">            final INSTightlyCoupledKalmanConfig config) {</span>
<span class="fc" id="L142">        mConfig = new INSTightlyCoupledKalmanConfig(config);</span>
<span class="fc" id="L143">    }</span>

    /**
     * Constructor.
     *
     * @param epochInterval minimum epoch interval expressed in seconds (s) between
     *                      consecutive propagations or measurements.
     * @throws IllegalArgumentException if provided epoch interval is negative.
     */
    public INSGNSSTightlyCoupledKalmanFilteredEstimator(
<span class="fc" id="L153">            final double epochInterval) {</span>
        try {
<span class="fc" id="L155">            setEpochInterval(epochInterval);</span>
<span class="nc" id="L156">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L158">        }</span>
<span class="fc" id="L159">    }</span>

    /**
     * Constructor.
     *
     * @param listener listener to notify events raised by this instance.
     */
    public INSGNSSTightlyCoupledKalmanFilteredEstimator(
<span class="fc" id="L167">            final INSGNSSTightlyCoupledKalmanFilteredEstimatorListener listener) {</span>
<span class="fc" id="L168">        mListener = listener;</span>
<span class="fc" id="L169">    }</span>

    /**
     * Constructor.
     *
     * @param config        INS/GNSS tightly coupled Kalman filter configuration
     *                      parameters (usually obtained through calibration).
     * @param epochInterval minimum epoch interval expressed in seconds (s) between
     *                      consecutive propagations or measurements.
     * @throws IllegalArgumentException if provided epoch interval is negative.
     */
    public INSGNSSTightlyCoupledKalmanFilteredEstimator(
            final INSTightlyCoupledKalmanConfig config, final double epochInterval) {
<span class="fc" id="L182">        this(epochInterval);</span>
<span class="fc" id="L183">        mConfig = new INSTightlyCoupledKalmanConfig(config);</span>
<span class="fc" id="L184">    }</span>

    /**
     * Constructor.
     *
     * @param config   INS/GNSS tightly coupled Kalman filter configuration parameters
     *                 (usually obtained through calibration).
     * @param listener listener to notify events raised by this instance.
     */
    public INSGNSSTightlyCoupledKalmanFilteredEstimator(
            final INSTightlyCoupledKalmanConfig config,
            final INSGNSSTightlyCoupledKalmanFilteredEstimatorListener listener) {
<span class="fc" id="L196">        this(config);</span>
<span class="fc" id="L197">        mListener = listener;</span>
<span class="fc" id="L198">    }</span>

    /**
     * Constructor.
     *
     * @param epochInterval minimum epoch interval expressed in seconds (s) between
     *                      consecutive propagations or measurements.
     * @param listener      listener to notify events raised by this instance.
     * @throws IllegalArgumentException if provided epoch interval is negative.
     */
    public INSGNSSTightlyCoupledKalmanFilteredEstimator(
            final double epochInterval,
            final INSGNSSTightlyCoupledKalmanFilteredEstimatorListener listener) {
<span class="fc" id="L211">        this(epochInterval);</span>
<span class="fc" id="L212">        mListener = listener;</span>
<span class="fc" id="L213">    }</span>

    /**
     * Constructor.
     *
     * @param config        INS/GNSS tightly coupled Kalman filter configuration
     *                      parameters (usually obtained through calibration).
     * @param epochInterval minimum epoch interval expressed in seconds (s) between
     *                      consecutive propagations or measurements.
     * @param listener      listener to notify events raised by this instance.
     * @throws IllegalArgumentException if provided epoch interval is negative.
     */
    public INSGNSSTightlyCoupledKalmanFilteredEstimator(
            final INSTightlyCoupledKalmanConfig config, final double epochInterval,
            final INSGNSSTightlyCoupledKalmanFilteredEstimatorListener listener) {
<span class="fc" id="L228">        this(config, epochInterval);</span>
<span class="fc" id="L229">        mListener = listener;</span>
<span class="fc" id="L230">    }</span>

    /**
     * Constructor.
     *
     * @param epochInterval minimum epoch interval between consecutive
     *                      propagations or measurements.
     * @throws IllegalArgumentException if provided epoch interval is negative.
     */
    public INSGNSSTightlyCoupledKalmanFilteredEstimator(final Time epochInterval) {
<span class="fc" id="L240">        this(TimeConverter.convert(epochInterval.getValue().doubleValue(),</span>
<span class="fc" id="L241">                epochInterval.getUnit(), TimeUnit.SECOND));</span>
<span class="fc" id="L242">    }</span>

    /**
     * Constructor.
     *
     * @param config        INS/GNSS tightly coupled Kalman filter configuration
     *                      parameters (usually obtained through calibration).
     * @param epochInterval minimum epoch interval between consecutive
     *                      propagations or measurements.
     * @throws IllegalArgumentException if provided epoch interval is negative.
     */
    public INSGNSSTightlyCoupledKalmanFilteredEstimator(
            final INSTightlyCoupledKalmanConfig config, final Time epochInterval) {
<span class="fc" id="L255">        this(config, TimeConverter.convert(epochInterval.getValue().doubleValue(),</span>
<span class="fc" id="L256">                epochInterval.getUnit(), TimeUnit.SECOND));</span>
<span class="fc" id="L257">    }</span>

    /**
     * Constructor.
     *
     * @param epochInterval minimum epoch interval between consecutive
     *                      propagations or measurements.
     * @param listener      listener to notify events raised by this instance.
     * @throws IllegalArgumentException if provided epoch interval is negative.
     */
    public INSGNSSTightlyCoupledKalmanFilteredEstimator(
            final Time epochInterval,
            final INSGNSSTightlyCoupledKalmanFilteredEstimatorListener listener) {
<span class="fc" id="L270">        this(epochInterval);</span>
<span class="fc" id="L271">        mListener = listener;</span>
<span class="fc" id="L272">    }</span>

    /**
     * Constructor.
     *
     * @param config        INS/GNSS tightly coupled Kalman filter configuration
     *                      parameters (usually obtained through calibration).
     * @param epochInterval minimum epoch interval between consecutive
     *                      propagations or measurements.
     * @param listener      listener to notify events raised by this instance.
     * @throws IllegalArgumentException if provided epoch interval is negative.
     */
    public INSGNSSTightlyCoupledKalmanFilteredEstimator(
            final INSTightlyCoupledKalmanConfig config, final Time epochInterval,
            final INSGNSSTightlyCoupledKalmanFilteredEstimatorListener listener) {
<span class="fc" id="L287">        this(config, epochInterval);</span>
<span class="fc" id="L288">        mListener = listener;</span>
<span class="fc" id="L289">    }</span>

    /**
     * Constructor.
     *
     * @param c body-to-ECEF coordinate transformation defining the initial body
     *          attitude.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not valid.
     */
    public INSGNSSTightlyCoupledKalmanFilteredEstimator(
            final CoordinateTransformation c)
            throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L302">        this();</span>
        try {
<span class="fc" id="L304">            setCoordinateTransformation(c);</span>
<span class="nc" id="L305">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L307">        }</span>
<span class="fc" id="L308">    }</span>

    /**
     * Constructor.
     *
     * @param config INS/GNSS Kalman filter configuration parameters (usually obtained
     *               through calibration).
     * @param c      body-to-ECEF coordinate transformation defining the initial body
     *               attitude.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not valid.
     */
    public INSGNSSTightlyCoupledKalmanFilteredEstimator(
            final INSTightlyCoupledKalmanConfig config,
            final CoordinateTransformation c)
            throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L324">        this(c);</span>
<span class="fc" id="L325">        mConfig = new INSTightlyCoupledKalmanConfig(config);</span>
<span class="fc" id="L326">    }</span>

    /**
     * Constructor.
     *
     * @param epochInterval minimum epoch interval expressed in seconds (s) between
     *                      consecutive propagations or measurements.
     * @param c             body-to-ECEF coordinate transformation defining the initial body
     *                      attitude.
     * @throws IllegalArgumentException                      if provided epoch interval is negative.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not valid.
     */
    public INSGNSSTightlyCoupledKalmanFilteredEstimator(
            final double epochInterval, final CoordinateTransformation c)
            throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L342">        this(epochInterval);</span>
        try {
<span class="fc" id="L344">            setCoordinateTransformation(c);</span>
<span class="nc" id="L345">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L347">        }</span>
<span class="fc" id="L348">    }</span>

    /**
     * Constructor.
     *
     * @param c        body-to-ECEF coordinate transformation defining the initial body
     *                 attitude.
     * @param listener listener to notify events raised by this instance.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not valid.
     */
    public INSGNSSTightlyCoupledKalmanFilteredEstimator(
            final CoordinateTransformation c,
            final INSGNSSTightlyCoupledKalmanFilteredEstimatorListener listener)
            throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L363">        this(c);</span>
<span class="fc" id="L364">        mListener = listener;</span>
<span class="fc" id="L365">    }</span>

    /**
     * Constructor.
     *
     * @param config        INS/GNSS tightly coupled Kalman filter configuration
     *                      parameters (usually obtained through calibration).
     * @param epochInterval minimum epoch interval expressed in seconds (s) between
     *                      consecutive propagations or measurements.
     * @param c             body-to-ECEF coordinate transformation defining the initial body
     *                      attitude.
     * @throws IllegalArgumentException                      if provided epoch interval is negative.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not valid.
     */
    public INSGNSSTightlyCoupledKalmanFilteredEstimator(
            final INSTightlyCoupledKalmanConfig config, final double epochInterval,
            final CoordinateTransformation c)
            throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L384">        this(config, epochInterval);</span>
        try {
<span class="fc" id="L386">            setCoordinateTransformation(c);</span>
<span class="nc" id="L387">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L389">        }</span>
<span class="fc" id="L390">    }</span>

    /**
     * Constructor.
     *
     * @param config   INS/GNSS tightly coupled Kalman filter configuration parameters
     *                 (usually obtained through calibration).
     * @param c        body-to-ECEF coordinate transformation defining the initial body
     *                 attitude.
     * @param listener listener to notify events raised by this instance.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not valid.
     */
    public INSGNSSTightlyCoupledKalmanFilteredEstimator(
            final INSTightlyCoupledKalmanConfig config,
            final CoordinateTransformation c,
            final INSGNSSTightlyCoupledKalmanFilteredEstimatorListener listener)
            throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L408">        this(config, listener);</span>
        try {
<span class="fc" id="L410">            setCoordinateTransformation(c);</span>
<span class="nc" id="L411">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L413">        }</span>
<span class="fc" id="L414">    }</span>

    /**
     * Constructor.
     *
     * @param epochInterval minimum epoch interval expressed in seconds (s) between
     *                      consecutive propagations or measurements.
     * @param c             body-to-ECEF coordinate transformation defining the initial body
     *                      attitude.
     * @param listener      listener to notify events raised by this instance.
     * @throws IllegalArgumentException                      if provided epoch interval is negative.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not valid.
     */
    public INSGNSSTightlyCoupledKalmanFilteredEstimator(
            final double epochInterval,
            final CoordinateTransformation c,
            final INSGNSSTightlyCoupledKalmanFilteredEstimatorListener listener)
            throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L433">        this(epochInterval, listener);</span>
        try {
<span class="fc" id="L435">            setCoordinateTransformation(c);</span>
<span class="nc" id="L436">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L438">        }</span>
<span class="fc" id="L439">    }</span>

    /**
     * Constructor.
     *
     * @param config        INS/GNSS tightly coupled Kalman filter configuration
     *                      parameters (usually obtained through calibration).
     * @param epochInterval minimum epoch interval expressed in seconds (s) between
     *                      consecutive propagations or measurements.
     * @param c             body-to-ECEF coordinate transformation defining the initial body
     *                      attitude.
     * @param listener      listener to notify events raised by this instance.
     * @throws IllegalArgumentException                      if provided epoch interval is negative.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not valid.
     */
    public INSGNSSTightlyCoupledKalmanFilteredEstimator(
            final INSTightlyCoupledKalmanConfig config, final double epochInterval,
            final CoordinateTransformation c,
            final INSGNSSTightlyCoupledKalmanFilteredEstimatorListener listener)
            throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L460">        this(config, epochInterval, listener);</span>
        try {
<span class="fc" id="L462">            setCoordinateTransformation(c);</span>
<span class="nc" id="L463">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L465">        }</span>
<span class="fc" id="L466">    }</span>

    /**
     * Constructor.
     *
     * @param epochInterval minimum epoch interval between consecutive
     *                      propagations or measurements.
     * @param c             body-to-ECEF coordinate transformation defining the initial body
     *                      attitude.
     * @throws IllegalArgumentException                      if provided epoch interval is negative.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not valid.
     */
    public INSGNSSTightlyCoupledKalmanFilteredEstimator(
            final Time epochInterval, final CoordinateTransformation c)
            throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L482">        this(epochInterval);</span>
        try {
<span class="fc" id="L484">            setCoordinateTransformation(c);</span>
<span class="nc" id="L485">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L487">        }</span>
<span class="fc" id="L488">    }</span>

    /**
     * Constructor.
     *
     * @param config        INS/GNSS tightly coupled Kalman filter configuration
     *                      parameters (usually obtained through calibration).
     * @param epochInterval minimum epoch interval between consecutive
     *                      propagations or measurements.
     * @param c             body-to-ECEF coordinate transformation defining the initial body
     *                      attitude.
     * @throws IllegalArgumentException                      if provided epoch interval is negative.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not valid.
     */
    public INSGNSSTightlyCoupledKalmanFilteredEstimator(
            final INSTightlyCoupledKalmanConfig config, final Time epochInterval,
            final CoordinateTransformation c)
            throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L507">        this(config, epochInterval);</span>
        try {
<span class="fc" id="L509">            setCoordinateTransformation(c);</span>
<span class="nc" id="L510">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L512">        }</span>
<span class="fc" id="L513">    }</span>

    /**
     * Constructor.
     *
     * @param epochInterval minimum epoch interval between consecutive
     *                      propagations or measurements.
     * @param c             body-to-ECEF coordinate transformation defining the initial body
     *                      attitude.
     * @param listener      listener to notify events raised by this instance.
     * @throws IllegalArgumentException                      if provided epoch interval is negative.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not valid.
     */
    public INSGNSSTightlyCoupledKalmanFilteredEstimator(
            final Time epochInterval,
            final CoordinateTransformation c,
            final INSGNSSTightlyCoupledKalmanFilteredEstimatorListener listener)
            throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L532">        this(epochInterval, listener);</span>
        try {
<span class="fc" id="L534">            setCoordinateTransformation(c);</span>
<span class="nc" id="L535">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L537">        }</span>
<span class="fc" id="L538">    }</span>

    /**
     * Constructor.
     *
     * @param config        INS/GNSS tightly coupled Kalman filter configuration
     *                      parameters (usually obtained through calibration).
     * @param epochInterval minimum epoch interval between consecutive
     *                      propagations or measurements.
     * @param c             body-to-ECEF coordinate transformation defining the initial body
     *                      attitude.
     * @param listener      listener to notify events raised by this instance.
     * @throws IllegalArgumentException                      if provided epoch interval is negative.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not valid.
     */
    public INSGNSSTightlyCoupledKalmanFilteredEstimator(
            final INSTightlyCoupledKalmanConfig config, final Time epochInterval,
            final CoordinateTransformation c,
            final INSGNSSTightlyCoupledKalmanFilteredEstimatorListener listener)
            throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L559">        this(config, epochInterval, listener);</span>
        try {
<span class="fc" id="L561">            setCoordinateTransformation(c);</span>
<span class="nc" id="L562">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L564">        }</span>
<span class="fc" id="L565">    }</span>

    /**
     * Constructor.
     *
     * @param initialConfig initial INS tightly coupled Kalman configuration to
     *                      set proper initial covariance during filter initialization.
     */
    public INSGNSSTightlyCoupledKalmanFilteredEstimator(
            final INSTightlyCoupledKalmanInitializerConfig initialConfig) {
<span class="fc" id="L575">        this();</span>
        try {
<span class="fc" id="L577">            setInitialConfig(initialConfig);</span>
<span class="nc" id="L578">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L580">        }</span>
<span class="fc" id="L581">    }</span>

    /**
     * Constructor.
     *
     * @param config        INS/GNSS Kalman filter configuration parameters (usually obtained
     *                      through calibration).
     * @param initialConfig initial INS tightly coupled Kalman configuration to
     *                      set proper initial covariance during filter initialization.
     */
    public INSGNSSTightlyCoupledKalmanFilteredEstimator(
            final INSTightlyCoupledKalmanConfig config,
            final INSTightlyCoupledKalmanInitializerConfig initialConfig) {
<span class="fc" id="L594">        this(config);</span>
        try {
<span class="fc" id="L596">            setInitialConfig(initialConfig);</span>
<span class="nc" id="L597">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L599">        }</span>
<span class="fc" id="L600">    }</span>

    /**
     * Constructor.
     *
     * @param epochInterval minimum epoch interval expressed in seconds (s) between
     *                      consecutive propagations or measurements.
     * @param initialConfig initial INS tightly coupled Kalman configuration to
     *                      set proper initial covariance during filter initialization.
     * @throws IllegalArgumentException if provided epoch interval is negative.
     */
    public INSGNSSTightlyCoupledKalmanFilteredEstimator(
            final double epochInterval,
            final INSTightlyCoupledKalmanInitializerConfig initialConfig) {
<span class="fc" id="L614">        this(epochInterval);</span>
        try {
<span class="fc" id="L616">            setInitialConfig(initialConfig);</span>
<span class="nc" id="L617">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L619">        }</span>
<span class="fc" id="L620">    }</span>

    /**
     * Constructor.
     *
     * @param initialConfig initial INS tightly coupled Kalman configuration to
     *                      set proper initial covariance during filter initialization.
     * @param listener      listener to notify events raised by this instance.
     */
    public INSGNSSTightlyCoupledKalmanFilteredEstimator(
            final INSTightlyCoupledKalmanInitializerConfig initialConfig,
            final INSGNSSTightlyCoupledKalmanFilteredEstimatorListener listener) {
<span class="fc" id="L632">        this(initialConfig);</span>
<span class="fc" id="L633">        mListener = listener;</span>
<span class="fc" id="L634">    }</span>

    /**
     * Constructor.
     *
     * @param config        INS/GNSS tightly coupled Kalman filter configuration
     *                      parameters (usually obtained through calibration).
     * @param epochInterval minimum epoch interval expressed in seconds (s) between
     *                      consecutive propagations or measurements.
     * @param initialConfig initial INS tightly coupled Kalman configuration to
     *                      set proper initial covariance during filter initialization.
     * @throws IllegalArgumentException if provided epoch interval is negative.
     */
    public INSGNSSTightlyCoupledKalmanFilteredEstimator(
            final INSTightlyCoupledKalmanConfig config, final double epochInterval,
            final INSTightlyCoupledKalmanInitializerConfig initialConfig) {
<span class="fc" id="L650">        this(config, epochInterval);</span>
        try {
<span class="fc" id="L652">            setInitialConfig(initialConfig);</span>
<span class="nc" id="L653">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L655">        }</span>
<span class="fc" id="L656">    }</span>

    /**
     * Constructor.
     *
     * @param config        INS/GNSS tightly coupled Kalman filter configuration parameters
     *                      (usually obtained through calibration).
     * @param initialConfig initial INS tightly coupled Kalman configuration to
     *                      set proper initial covariance during filter initialization.
     * @param listener      listener to notify events raised by this instance.
     */
    public INSGNSSTightlyCoupledKalmanFilteredEstimator(
            final INSTightlyCoupledKalmanConfig config,
            final INSTightlyCoupledKalmanInitializerConfig initialConfig,
            final INSGNSSTightlyCoupledKalmanFilteredEstimatorListener listener) {
<span class="fc" id="L671">        this(config, listener);</span>
        try {
<span class="fc" id="L673">            setInitialConfig(initialConfig);</span>
<span class="nc" id="L674">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L676">        }</span>
<span class="fc" id="L677">    }</span>

    /**
     * Constructor.
     *
     * @param epochInterval minimum epoch interval expressed in seconds (s) between
     *                      consecutive propagations or measurements.
     * @param initialConfig initial INS tightly coupled Kalman configuration to
     *                      set proper initial covariance during filter initialization.
     * @param listener      listener to notify events raised by this instance.
     * @throws IllegalArgumentException if provided epoch interval is negative.
     */
    public INSGNSSTightlyCoupledKalmanFilteredEstimator(
            final double epochInterval,
            final INSTightlyCoupledKalmanInitializerConfig initialConfig,
            final INSGNSSTightlyCoupledKalmanFilteredEstimatorListener listener) {
<span class="fc" id="L693">        this(epochInterval, listener);</span>
        try {
<span class="fc" id="L695">            setInitialConfig(initialConfig);</span>
<span class="nc" id="L696">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L698">        }</span>
<span class="fc" id="L699">    }</span>

    /**
     * Constructor.
     *
     * @param config        INS/GNSS tightly coupled Kalman filter configuration
     *                      parameters (usually obtained through calibration).
     * @param epochInterval minimum epoch interval expressed in seconds (s) between
     *                      consecutive propagations or measurements.
     * @param initialConfig initial INS tightly coupled Kalman configuration to
     *                      set proper initial covariance during filter initialization.
     * @param listener      listener to notify events raised by this instance.
     * @throws IllegalArgumentException if provided epoch interval is negative.
     */
    public INSGNSSTightlyCoupledKalmanFilteredEstimator(
            final INSTightlyCoupledKalmanConfig config, final double epochInterval,
            final INSTightlyCoupledKalmanInitializerConfig initialConfig,
            final INSGNSSTightlyCoupledKalmanFilteredEstimatorListener listener) {
<span class="fc" id="L717">        this(config, epochInterval, listener);</span>
        try {
<span class="fc" id="L719">            setInitialConfig(initialConfig);</span>
<span class="nc" id="L720">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L722">        }</span>
<span class="fc" id="L723">    }</span>

    /**
     * Constructor.
     *
     * @param epochInterval minimum epoch interval between consecutive
     *                      propagations or measurements.
     * @param initialConfig initial INS tightly coupled Kalman configuration to
     *                      set proper initial covariance during filter initialization.
     * @throws IllegalArgumentException if provided epoch interval is negative.
     */
    public INSGNSSTightlyCoupledKalmanFilteredEstimator(
            final Time epochInterval,
            final INSTightlyCoupledKalmanInitializerConfig initialConfig) {
<span class="fc" id="L737">        this(epochInterval);</span>
        try {
<span class="fc" id="L739">            setInitialConfig(initialConfig);</span>
<span class="nc" id="L740">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L742">        }</span>
<span class="fc" id="L743">    }</span>

    /**
     * Constructor.
     *
     * @param config        INS/GNSS tightly coupled Kalman filter configuration
     *                      parameters (usually obtained through calibration).
     * @param epochInterval minimum epoch interval between consecutive
     *                      propagations or measurements.
     * @param initialConfig initial INS tightly coupled Kalman configuration to
     *                      set proper initial covariance during filter initialization.
     * @throws IllegalArgumentException if provided epoch interval is negative.
     */
    public INSGNSSTightlyCoupledKalmanFilteredEstimator(
            final INSTightlyCoupledKalmanConfig config, final Time epochInterval,
            final INSTightlyCoupledKalmanInitializerConfig initialConfig) {
<span class="fc" id="L759">        this(config, epochInterval);</span>
        try {
<span class="fc" id="L761">            setInitialConfig(initialConfig);</span>
<span class="nc" id="L762">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L764">        }</span>
<span class="fc" id="L765">    }</span>

    /**
     * Constructor.
     *
     * @param epochInterval minimum epoch interval between consecutive
     *                      propagations or measurements.
     * @param initialConfig initial INS tightly coupled Kalman configuration to
     *                      set proper initial covariance during filter initialization.
     * @param listener      listener to notify events raised by this instance.
     * @throws IllegalArgumentException if provided epoch interval is negative.
     */
    public INSGNSSTightlyCoupledKalmanFilteredEstimator(
            final Time epochInterval,
            final INSTightlyCoupledKalmanInitializerConfig initialConfig,
            final INSGNSSTightlyCoupledKalmanFilteredEstimatorListener listener) {
<span class="fc" id="L781">        this(epochInterval, listener);</span>
        try {
<span class="fc" id="L783">            setInitialConfig(initialConfig);</span>
<span class="nc" id="L784">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L786">        }</span>
<span class="fc" id="L787">    }</span>

    /**
     * Constructor.
     *
     * @param config        INS/GNSS tightly coupled Kalman filter configuration
     *                      parameters (usually obtained through calibration).
     * @param epochInterval minimum epoch interval between consecutive
     *                      propagations or measurements.
     * @param initialConfig initial INS tightly coupled Kalman configuration to
     *                      set proper initial covariance during filter initialization.
     * @param listener      listener to notify events raised by this instance.
     * @throws IllegalArgumentException if provided epoch interval is negative.
     */
    public INSGNSSTightlyCoupledKalmanFilteredEstimator(
            final INSTightlyCoupledKalmanConfig config, final Time epochInterval,
            final INSTightlyCoupledKalmanInitializerConfig initialConfig,
            final INSGNSSTightlyCoupledKalmanFilteredEstimatorListener listener) {
<span class="fc" id="L805">        this(config, epochInterval, listener);</span>
        try {
<span class="fc" id="L807">            setInitialConfig(initialConfig);</span>
<span class="nc" id="L808">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L810">        }</span>
<span class="fc" id="L811">    }</span>

    /**
     * Constructor.
     *
     * @param initialConfig initial INS tightly coupled Kalman configuration to
     *                      set proper initial covariance during filter initialization.
     * @param c             body-to-ECEF coordinate transformation defining the initial body
     *                      attitude.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not valid.
     */
    public INSGNSSTightlyCoupledKalmanFilteredEstimator(
            final INSTightlyCoupledKalmanInitializerConfig initialConfig,
            final CoordinateTransformation c)
            throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L827">        this(c);</span>
        try {
<span class="fc" id="L829">            setInitialConfig(initialConfig);</span>
<span class="nc" id="L830">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L832">        }</span>
<span class="fc" id="L833">    }</span>

    /**
     * Constructor.
     *
     * @param config        INS/GNSS Kalman filter configuration parameters (usually obtained
     *                      through calibration).
     * @param initialConfig initial INS tightly coupled Kalman configuration to
     *                      set proper initial covariance during filter initialization.
     * @param c             body-to-ECEF coordinate transformation defining the initial body
     *                      attitude.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not valid.
     */
    public INSGNSSTightlyCoupledKalmanFilteredEstimator(
            final INSTightlyCoupledKalmanConfig config,
            final INSTightlyCoupledKalmanInitializerConfig initialConfig,
            final CoordinateTransformation c)
            throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L852">        this(config, c);</span>
        try {
<span class="fc" id="L854">            setInitialConfig(initialConfig);</span>
<span class="nc" id="L855">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L857">        }</span>
<span class="fc" id="L858">    }</span>

    /**
     * Constructor.
     *
     * @param epochInterval minimum epoch interval expressed in seconds (s) between
     *                      consecutive propagations or measurements.
     * @param initialConfig initial INS tightly coupled Kalman configuration to
     *                      set proper initial covariance during filter initialization.
     * @param c             body-to-ECEF coordinate transformation defining the initial body
     *                      attitude.
     * @throws IllegalArgumentException                      if provided epoch interval is negative.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not valid.
     */
    public INSGNSSTightlyCoupledKalmanFilteredEstimator(
            final double epochInterval,
            final INSTightlyCoupledKalmanInitializerConfig initialConfig,
            final CoordinateTransformation c)
            throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L878">        this(epochInterval, c);</span>
        try {
<span class="fc" id="L880">            setInitialConfig(initialConfig);</span>
<span class="nc" id="L881">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L883">        }</span>
<span class="fc" id="L884">    }</span>

    /**
     * Constructor.
     *
     * @param initialConfig initial INS tightly coupled Kalman configuration to
     *                      set proper initial covariance during filter initialization.
     * @param c             body-to-ECEF coordinate transformation defining the initial body
     *                      attitude.
     * @param listener      listener to notify events raised by this instance.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not valid.
     */
    public INSGNSSTightlyCoupledKalmanFilteredEstimator(
            final INSTightlyCoupledKalmanInitializerConfig initialConfig,
            final CoordinateTransformation c,
            final INSGNSSTightlyCoupledKalmanFilteredEstimatorListener listener)
            throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L902">        this(c, listener);</span>
        try {
<span class="fc" id="L904">            setInitialConfig(initialConfig);</span>
<span class="nc" id="L905">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L907">        }</span>
<span class="fc" id="L908">    }</span>

    /**
     * Constructor.
     *
     * @param config        INS/GNSS tightly coupled Kalman filter configuration
     *                      parameters (usually obtained through calibration).
     * @param epochInterval minimum epoch interval expressed in seconds (s) between
     *                      consecutive propagations or measurements.
     * @param initialConfig initial INS tightly coupled Kalman configuration to
     *                      set proper initial covariance during filter initialization.
     * @param c             body-to-ECEF coordinate transformation defining the initial body
     *                      attitude.
     * @throws IllegalArgumentException                      if provided epoch interval is negative.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not valid.
     */
    public INSGNSSTightlyCoupledKalmanFilteredEstimator(
            final INSTightlyCoupledKalmanConfig config, final double epochInterval,
            final INSTightlyCoupledKalmanInitializerConfig initialConfig,
            final CoordinateTransformation c)
            throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L930">        this(config, epochInterval, c);</span>
        try {
<span class="fc" id="L932">            setInitialConfig(initialConfig);</span>
<span class="nc" id="L933">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L935">        }</span>
<span class="fc" id="L936">    }</span>

    /**
     * Constructor.
     *
     * @param config        INS/GNSS tightly coupled Kalman filter configuration parameters
     *                      (usually obtained through calibration).
     * @param initialConfig initial INS tightly coupled Kalman configuration to
     *                      set proper initial covariance during filter initialization.
     * @param c             body-to-ECEF coordinate transformation defining the initial body
     *                      attitude.
     * @param listener      listener to notify events raised by this instance.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not valid.
     */
    public INSGNSSTightlyCoupledKalmanFilteredEstimator(
            final INSTightlyCoupledKalmanConfig config,
            final INSTightlyCoupledKalmanInitializerConfig initialConfig,
            final CoordinateTransformation c,
            final INSGNSSTightlyCoupledKalmanFilteredEstimatorListener listener)
            throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L957">        this(config, c, listener);</span>
        try {
<span class="fc" id="L959">            setInitialConfig(initialConfig);</span>
<span class="nc" id="L960">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L962">        }</span>
<span class="fc" id="L963">    }</span>

    /**
     * Constructor.
     *
     * @param epochInterval minimum epoch interval expressed in seconds (s) between
     *                      consecutive propagations or measurements.
     * @param initialConfig initial INS tightly coupled Kalman configuration to
     *                      set proper initial covariance during filter initialization.
     * @param c             body-to-ECEF coordinate transformation defining the initial body
     *                      attitude.
     * @param listener      listener to notify events raised by this instance.
     * @throws IllegalArgumentException                      if provided epoch interval is negative.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not valid.
     */
    public INSGNSSTightlyCoupledKalmanFilteredEstimator(
            final double epochInterval,
            final INSTightlyCoupledKalmanInitializerConfig initialConfig,
            final CoordinateTransformation c,
            final INSGNSSTightlyCoupledKalmanFilteredEstimatorListener listener)
            throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L985">        this(epochInterval, c, listener);</span>
        try {
<span class="fc" id="L987">            setInitialConfig(initialConfig);</span>
<span class="nc" id="L988">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L990">        }</span>
<span class="fc" id="L991">    }</span>

    /**
     * Constructor.
     *
     * @param config        INS/GNSS tightly coupled Kalman filter configuration
     *                      parameters (usually obtained through calibration).
     * @param epochInterval minimum epoch interval expressed in seconds (s) between
     *                      consecutive propagations or measurements.
     * @param initialConfig initial INS tightly coupled Kalman configuration to
     *                      set proper initial covariance during filter initialization.
     * @param c             body-to-ECEF coordinate transformation defining the initial body
     *                      attitude.
     * @param listener      listener to notify events raised by this instance.
     * @throws IllegalArgumentException                      if provided epoch interval is negative.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not valid.
     */
    public INSGNSSTightlyCoupledKalmanFilteredEstimator(
            final INSTightlyCoupledKalmanConfig config, final double epochInterval,
            final INSTightlyCoupledKalmanInitializerConfig initialConfig,
            final CoordinateTransformation c,
            final INSGNSSTightlyCoupledKalmanFilteredEstimatorListener listener)
            throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L1015">        this(config, epochInterval, c, listener);</span>
        try {
<span class="fc" id="L1017">            setInitialConfig(initialConfig);</span>
<span class="nc" id="L1018">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L1020">        }</span>
<span class="fc" id="L1021">    }</span>

    /**
     * Constructor.
     *
     * @param epochInterval minimum epoch interval between consecutive
     *                      propagations or measurements.
     * @param initialConfig initial INS tightly coupled Kalman configuration to
     *                      set proper initial covariance during filter initialization.
     * @param c             body-to-ECEF coordinate transformation defining the initial body
     *                      attitude.
     * @throws IllegalArgumentException                      if provided epoch interval is negative.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not valid.
     */
    public INSGNSSTightlyCoupledKalmanFilteredEstimator(
            final Time epochInterval,
            final INSTightlyCoupledKalmanInitializerConfig initialConfig,
            final CoordinateTransformation c)
            throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L1041">        this(epochInterval, c);</span>
        try {
<span class="fc" id="L1043">            setInitialConfig(initialConfig);</span>
<span class="nc" id="L1044">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L1046">        }</span>
<span class="fc" id="L1047">    }</span>

    /**
     * Constructor.
     *
     * @param config        INS/GNSS tightly coupled Kalman filter configuration
     *                      parameters (usually obtained through calibration).
     * @param epochInterval minimum epoch interval between consecutive
     *                      propagations or measurements.
     * @param initialConfig initial INS tightly coupled Kalman configuration to
     *                      set proper initial covariance during filter initialization.
     * @param c             body-to-ECEF coordinate transformation defining the initial body
     *                      attitude.
     * @throws IllegalArgumentException                      if provided epoch interval is negative.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not valid.
     */
    public INSGNSSTightlyCoupledKalmanFilteredEstimator(
            final INSTightlyCoupledKalmanConfig config, final Time epochInterval,
            final INSTightlyCoupledKalmanInitializerConfig initialConfig,
            final CoordinateTransformation c)
            throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L1069">        this(config, epochInterval, c);</span>
        try {
<span class="fc" id="L1071">            setInitialConfig(initialConfig);</span>
<span class="nc" id="L1072">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L1074">        }</span>
<span class="fc" id="L1075">    }</span>

    /**
     * Constructor.
     *
     * @param epochInterval minimum epoch interval between consecutive
     *                      propagations or measurements.
     * @param initialConfig initial INS tightly coupled Kalman configuration to
     *                      set proper initial covariance during filter initialization.
     * @param c             body-to-ECEF coordinate transformation defining the initial body
     *                      attitude.
     * @param listener      listener to notify events raised by this instance.
     * @throws IllegalArgumentException                      if provided epoch interval is negative.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not valid.
     */
    public INSGNSSTightlyCoupledKalmanFilteredEstimator(
            final Time epochInterval,
            final INSTightlyCoupledKalmanInitializerConfig initialConfig,
            final CoordinateTransformation c,
            final INSGNSSTightlyCoupledKalmanFilteredEstimatorListener listener)
            throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L1097">        this(epochInterval, c, listener);</span>
        try {
<span class="fc" id="L1099">            setInitialConfig(initialConfig);</span>
<span class="nc" id="L1100">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L1102">        }</span>
<span class="fc" id="L1103">    }</span>

    /**
     * Constructor.
     *
     * @param config        INS/GNSS tightly coupled Kalman filter configuration
     *                      parameters (usually obtained through calibration).
     * @param epochInterval minimum epoch interval between consecutive
     *                      propagations or measurements.
     * @param initialConfig initial INS tightly coupled Kalman configuration to
     *                      set proper initial covariance during filter initialization.
     * @param c             body-to-ECEF coordinate transformation defining the initial body
     *                      attitude.
     * @param listener      listener to notify events raised by this instance.
     * @throws IllegalArgumentException                      if provided epoch interval is negative.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not valid.
     */
    public INSGNSSTightlyCoupledKalmanFilteredEstimator(
            final INSTightlyCoupledKalmanConfig config, final Time epochInterval,
            final INSTightlyCoupledKalmanInitializerConfig initialConfig,
            final CoordinateTransformation c,
            final INSGNSSTightlyCoupledKalmanFilteredEstimatorListener listener)
            throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L1127">        this(config, epochInterval, c, listener);</span>
        try {
<span class="fc" id="L1129">            setInitialConfig(initialConfig);</span>
<span class="nc" id="L1130">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L1132">        }</span>
<span class="fc" id="L1133">    }</span>

    /**
     * Gets listener to notify events raised by this instance.
     *
     * @return listener to notify events raised by this instance.
     */
    public INSGNSSTightlyCoupledKalmanFilteredEstimatorListener getListener() {
<span class="fc" id="L1141">        return mListener;</span>
    }

    /**
     * Sets listener to notify events raised by this instance.
     *
     * @param listener listener to notify events raised by this instance.
     * @throws LockedException if this estimator is already running.
     */
    public void setListener(
            final INSGNSSTightlyCoupledKalmanFilteredEstimatorListener listener)
            throws LockedException {
<span class="fc bfc" id="L1153" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L1154">            throw new LockedException();</span>
        }

<span class="fc" id="L1157">        mListener = listener;</span>
<span class="fc" id="L1158">    }</span>

    /**
     * Gets minimum epoch interval expressed in seconds (s) between consecutive
     * propagations or measurements expressed in seconds.
     * Attempting to propagate results using Kalman filter or updating measurements
     * when intervals are less than this value, will be ignored.
     *
     * @return minimum epoch interval between consecutive propagations or
     * measurements.
     */
    public double getEpochInterval() {
<span class="fc" id="L1170">        return mEpochInterval;</span>
    }

    /**
     * Sets minimum epoch interval expressed in seconds (s) between consecutive
     * propagations or measurements expressed in seconds.
     * Attempting to propagate results using Kalman filter or updating measurements
     * when intervals are less than this value, will be ignored.
     *
     * @param epochInterval minimum epoch interval expressed in seconds (s) between
     *                      consecutive propagations or measurements.
     * @throws LockedException          if this estimator is already running.
     * @throws IllegalArgumentException if provided epoch interval is negative.
     */
    public void setEpochInterval(final double epochInterval) throws LockedException {
<span class="fc bfc" id="L1185" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L1186">            throw new LockedException();</span>
        }

<span class="fc bfc" id="L1189" title="All 2 branches covered.">        if (epochInterval &lt; 0.0) {</span>
<span class="fc" id="L1190">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L1193">        mEpochInterval = epochInterval;</span>
<span class="fc" id="L1194">    }</span>

    /**
     * Gets minimum epoch interval between consecutive propagations or measurements.
     * Attempting to propagate results using Kalman filter or updating measurements
     * when intervals are less than this value, will be ignored.
     *
     * @param result instance where minimum epoch interval will be stored.
     */
    public void getEpochIntervalAsTime(final Time result) {
<span class="fc" id="L1204">        result.setValue(mEpochInterval);</span>
<span class="fc" id="L1205">        result.setUnit(TimeUnit.SECOND);</span>
<span class="fc" id="L1206">    }</span>

    /**
     * Gets minimum epoch interval between consecutive propagations or measurements.
     * Attempting to propagate results using Kalman filter or updating measurements
     * when intervals are less than this value, will be ignored.
     *
     * @return minimum epoch interval.
     */
    public Time getEpochIntervalAsTime() {
<span class="fc" id="L1216">        return new Time(mEpochInterval, TimeUnit.SECOND);</span>
    }

    /**
     * Sets minimum epoch interval between consecutive propagations or measurements.
     * Attempting to propagate results using Kalman filter or updating measurements
     * when intervals are less than this value, will be ignored.
     *
     * @param epochInterval minimum epoch interval.
     * @throws LockedException          if this estimator is already running.
     * @throws IllegalArgumentException if provided epoch interval is negative.
     */
    public void setEpochInterval(final Time epochInterval) throws LockedException {
<span class="fc" id="L1229">        final double epochIntervalSeconds = TimeConverter.convert(</span>
<span class="fc" id="L1230">                epochInterval.getValue().doubleValue(),</span>
<span class="fc" id="L1231">                epochInterval.getUnit(), TimeUnit.SECOND);</span>
<span class="fc" id="L1232">        setEpochInterval(epochIntervalSeconds);</span>
<span class="fc" id="L1233">    }</span>

    /**
     * Gets INS/GNSS tightly coupled Kalman configuration parameters (usually
     * obtained through calibration).
     *
     * @param result instance where INS/GNSS tightly coupled Kalman configuration
     *               parameters will be stored.
     * @return true if result instance is updated, false otherwise.
     */
    public boolean getConfig(final INSTightlyCoupledKalmanConfig result) {
<span class="fc bfc" id="L1244" title="All 2 branches covered.">        if (mConfig != null) {</span>
<span class="fc" id="L1245">            result.copyFrom(mConfig);</span>
<span class="fc" id="L1246">            return true;</span>
        } else {
<span class="fc" id="L1248">            return false;</span>
        }
    }

    /**
     * Gets INS/GNSS tightly coupled Kalman configuration parameters (usually
     * obtained through calibration).
     *
     * @return INS/GNSS tightly coupled Kalman configuration parameters.
     */
    public INSTightlyCoupledKalmanConfig getConfig() {
<span class="fc" id="L1259">        return mConfig;</span>
    }

    /**
     * Sets INS/GNSS tightly coupled Kalman configuration parameters (usually
     * obtained through calibration).
     *
     * @param config INS/GNSS tightly coupled Kalman configuration parameters
     *               to be set.
     * @throws LockedException if this estimator is already running.
     */
    public void setConfig(final INSTightlyCoupledKalmanConfig config)
            throws LockedException {
<span class="fc bfc" id="L1272" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L1273">            throw new LockedException();</span>
        }

<span class="fc" id="L1276">        mConfig = new INSTightlyCoupledKalmanConfig(config);</span>
<span class="fc" id="L1277">    }</span>

    /**
     * Gets body-to-ECEF coordinate transformation defining the body attitude.
     * This can be used to set the initial body attitude before starting the
     * estimator, or to update body attitude between INS/GNSS measurement updates.
     *
     * @return body-to-ECEF coordinate transformation.
     */
    public CoordinateTransformation getCoordinateTransformation() {
<span class="fc bfc" id="L1287" title="All 2 branches covered.">        return mFrame != null ? mFrame.getCoordinateTransformation() : null;</span>
    }

    /**
     * Gets body-to-ECEF coordinate transformation defining the body attitude.
     * This can be used to set the initial body attitude before starting the
     * estimator, or to update body attitude between INS/GNSS measurement updates.
     *
     * @param result instance where body-to-ECEF data will be stored.
     * @return true if result instance was updated, false otherwise.
     */
    public boolean getCoordinateTransformation(final CoordinateTransformation result) {
<span class="fc bfc" id="L1299" title="All 2 branches covered.">        if (mFrame != null) {</span>
<span class="fc" id="L1300">            mFrame.getCoordinateTransformation(result);</span>
<span class="fc" id="L1301">            return true;</span>
        } else {
<span class="fc" id="L1303">            return false;</span>
        }
    }

    /**
     * Sets body-to-ECEF coordinate transformation defining the body attitude.
     * This can be used to set the initial body attitude before starting the
     * estimator, or to update body attitude between INS/GNSS measurement updates.
     *
     * @param c body-to-ECEF coordinate transformation to be set.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not valid (is not a
     *                                                       body-to-ECEF transformation).
     * @throws LockedException                               if this estimator is already running.
     */
    public void setCoordinateTransformation(final CoordinateTransformation c)
            throws InvalidSourceAndDestinationFrameTypeException, LockedException {
<span class="fc bfc" id="L1320" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L1321">            throw new LockedException();</span>
        }

<span class="fc" id="L1324">        initFrame();</span>
<span class="fc" id="L1325">        mFrame.setCoordinateTransformation(c);</span>
<span class="fc" id="L1326">    }</span>

    /**
     * Gets initial INS tightly coupled Kalman configuration to set a proper
     * initial covariance matrix during the first Kalman filter propagation.
     * Once this estimator is initialized, covariance will be updated with new provided
     * GNSS and INS measurements until convergence is reached.
     *
     * @param result instance where configuration data will be stored.
     * @return true if result instance was updated, false otherwise.
     */
    public boolean getInitialConfig(
            final INSTightlyCoupledKalmanInitializerConfig result) {
<span class="fc bfc" id="L1339" title="All 2 branches covered.">        if (mInitialConfig != null) {</span>
<span class="fc" id="L1340">            result.copyFrom(mInitialConfig);</span>
<span class="fc" id="L1341">            return true;</span>
        } else {
<span class="fc" id="L1343">            return false;</span>
        }
    }

    /**
     * Gets initial INS tightly coupled Kalman configuration to set a proper
     * initial covariance matrix during the first Kalman filter propagation.
     * Once this estimator is initialized, covariance will be updated with new provided
     * GNSS and INS measurements until convergence is reached.
     *
     * @return initial INS tightly coupled Kalman configuration.
     */
    public INSTightlyCoupledKalmanInitializerConfig getInitialConfig() {
<span class="fc" id="L1356">        return mInitialConfig;</span>
    }

    /**
     * Sets initial INS tightly coupled Kalman configuration to set a proper
     * initial covariance matrix during the first Kalman filter propagation.
     * Once this estimator is initialized, covariance will be updated with new provided
     * GNSS and INS measurements until convergence is reached.
     *
     * @param initialConfig initial configuration to be set.
     * @throws LockedException if this estimator is already running.
     */
    public void setInitialConfig(
            final INSTightlyCoupledKalmanInitializerConfig initialConfig)
            throws LockedException {

<span class="fc bfc" id="L1372" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L1373">            throw new LockedException();</span>
        }

<span class="fc" id="L1376">        mInitialConfig = initialConfig;</span>
<span class="fc" id="L1377">    }</span>

    /**
     * Gets last updated GNSS measurements of a collection of satellites.
     *
     * @return last updated GNSS measurements of a collection of satellites.
     */
    public Collection&lt;GNSSMeasurement&gt; getMeasurements() {
<span class="fc bfc" id="L1385" title="All 2 branches covered.">        if (mMeasurements == null) {</span>
<span class="fc" id="L1386">            return null;</span>
        }

<span class="fc" id="L1389">        final List&lt;GNSSMeasurement&gt; result = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L1390" title="All 2 branches covered.">        for (final GNSSMeasurement measurement : mMeasurements) {</span>
<span class="fc" id="L1391">            result.add(new GNSSMeasurement(measurement));</span>
<span class="fc" id="L1392">        }</span>
<span class="fc" id="L1393">        return result;</span>
    }

    /**
     * Gets last provided user kinematics containing applied specific force and
     * angular rates resolved in body axes.
     *
     * @return last provided user kinematics.
     */
    public BodyKinematics getKinematics() {
<span class="fc bfc" id="L1403" title="All 2 branches covered.">        return mKinematics != null ? new BodyKinematics(mKinematics) : null;</span>
    }

    /**
     * Gets last provided user kinematics containing applied specific force and
     * angular rates resolved in body axes.
     *
     * @param result instance where last provided body kinematics will be stored.
     * @return true if provided result instance was updated, false otherwise.
     */
    public boolean getKinematics(final BodyKinematics result) {
<span class="fc bfc" id="L1414" title="All 2 branches covered.">        if (mKinematics != null) {</span>
<span class="fc" id="L1415">            result.copyFrom(mKinematics);</span>
<span class="fc" id="L1416">            return true;</span>
        } else {
<span class="fc" id="L1418">            return false;</span>
        }
    }

    /**
     * Gets corrected kinematics which are the last provided user kinematics after
     * removal of the biases estimated by the Kalman filter.
     *
     * @return corrected kinematics.
     * @see #getKinematics()
     */
    public BodyKinematics getCorrectedKinematics() {
<span class="fc bfc" id="L1430" title="All 2 branches covered.">        return mCorrectedKinematics != null ?</span>
<span class="fc" id="L1431">                new BodyKinematics(mCorrectedKinematics) : null;</span>
    }

    /**
     * Gets corrected kinematics which are the last provided user kinematics after
     * removal of the biases estimated by the Kalman filter.
     *
     * @param result instance where corrected body kinematics will be stored.
     * @return true if provided result instance was updated, false otherwise.
     */
    public boolean getCorrectedKinematics(final BodyKinematics result) {
<span class="fc bfc" id="L1442" title="All 2 branches covered.">        if (mCorrectedKinematics != null) {</span>
<span class="fc" id="L1443">            result.copyFrom(mCorrectedKinematics);</span>
<span class="fc" id="L1444">            return true;</span>
        } else {
<span class="fc" id="L1446">            return false;</span>
        }
    }

    /**
     * Gets current estimation containing user ECEF position, user ECEF velocity,
     * clock offset and clock drift.
     *
     * @return current estimation containing user ECEF position, user ECEF velocity,
     * clock offset and clock drift.
     */
    public GNSSEstimation getEstimation() {
<span class="fc bfc" id="L1458" title="All 2 branches covered.">        return mEstimation != null ? new GNSSEstimation(mEstimation) : null;</span>
    }

    /**
     * Gets current estimation containing user ECEF position, user ECEF velocity,
     * clock offset and clock drift.
     * This method does not update result instance if no estimation is available.
     *
     * @param result instance where estimation will be stored.
     * @return true if result estimation was updated, false otherwise.
     */
    public boolean getEstimation(final GNSSEstimation result) {
<span class="fc bfc" id="L1470" title="All 2 branches covered.">        if (mEstimation != null) {</span>
<span class="fc" id="L1471">            result.copyFrom(mEstimation);</span>
<span class="fc" id="L1472">            return true;</span>
        } else {
<span class="fc" id="L1474">            return false;</span>
        }
    }

    /**
     * Gets current Kalman filter state containing current INS/GNSS estimation along
     * with Kalman filter covariance error matrix.
     *
     * @return current Kalman filter state containing current INS/GNSS estimation
     * along with Kalman filter covariance error matrix.
     */
    public INSTightlyCoupledKalmanState getState() {
<span class="fc bfc" id="L1486" title="All 2 branches covered.">        return mState != null ? new INSTightlyCoupledKalmanState(mState) : null;</span>
    }

    /**
     * Gets current Kalman filter state containing current INS/GNSS estimation along
     * with Kalman filter covariance error matrix.
     * This method does not update result instance if no state is available.
     *
     * @param result instance where state will be stored.
     * @return true if result state was updated, false otherwise.
     */
    public boolean getState(final INSTightlyCoupledKalmanState result) {
<span class="fc bfc" id="L1498" title="All 2 branches covered.">        if (mState != null) {</span>
<span class="fc" id="L1499">            result.copyFrom(mState);</span>
<span class="fc" id="L1500">            return true;</span>
        } else {
<span class="fc" id="L1502">            return false;</span>
        }
    }

    /**
     * Gets timestamp expressed in seconds since epoch time when Kalman filter state
     * was last propagated.
     *
     * @return timestamp expressed in seconds since epoch time when Kalman filter
     * state was last propagated.
     */
    public Double getLastStateTimestamp() {
<span class="fc" id="L1514">        return mLastStateTimestamp;</span>
    }

    /**
     * Gets timestamp since epoch time when Kalman filter state was last propagated.
     *
     * @param result instance where timestamp since epoch time when Kalman filter
     *               state was last propagated will be stored.
     * @return true if result instance is updated, false otherwise.
     */
    public boolean getLastStateTimestampAsTime(final Time result) {
<span class="fc bfc" id="L1525" title="All 2 branches covered.">        if (mLastStateTimestamp != null) {</span>
<span class="fc" id="L1526">            result.setValue(mLastStateTimestamp);</span>
<span class="fc" id="L1527">            result.setUnit(TimeUnit.SECOND);</span>
<span class="fc" id="L1528">            return true;</span>
        } else {
<span class="fc" id="L1530">            return false;</span>
        }
    }

    /**
     * Gets timestamp since epoch time when Kalman filter state was last propagated.
     *
     * @return timestamp since epoch time when Kalman filter state was last
     * propagated.
     */
    public Time getLastStateTimestampAsTime() {
<span class="fc bfc" id="L1541" title="All 2 branches covered.">        return mLastStateTimestamp != null ?</span>
<span class="fc" id="L1542">                new Time(mLastStateTimestamp, TimeUnit.SECOND) : null;</span>
    }

    /**
     * Indicates whether this estimator is running or not.
     *
     * @return true if this estimator is running, false otherwise.
     */
    public boolean isRunning() {
<span class="fc" id="L1551">        return mRunning;</span>
    }

    /**
     * Indicates whether provided measurements are ready to
     * be used for an update.
     *
     * @param measurements measurements to be checked.
     * @return true if estimator is ready, false otherwise.
     */
    public static boolean isUpdateMeasurementsReady(
            final Collection&lt;GNSSMeasurement&gt; measurements) {
<span class="fc" id="L1563">        return GNSSLeastSquaresPositionAndVelocityEstimator</span>
<span class="fc" id="L1564">                .isValidMeasurements(measurements);</span>
    }

    /**
     * Updates GNSS measurements of this estimator when new satellite measurements
     * are available.
     * Calls to this method will be ignored if interval between provided timestamp
     * and last timestamp when Kalman filter was updated is less than epoch interval.
     *
     * @param measurements GNSS measurements to be updated.
     * @param timestamp    timestamp since epoch time when GNSS measurements were
     *                     updated.
     * @return true if measurements were updated, false otherwise.
     * @throws LockedException   if this estimator is already running.
     * @throws NotReadyException if estimator is not ready for measurements updates.
     * @throws INSGNSSException  if estimation fails due to numerical instabilities.
     */
    public boolean updateMeasurements(
            final Collection&lt;GNSSMeasurement&gt; measurements, final Time timestamp)
            throws LockedException, NotReadyException, INSGNSSException {
<span class="fc" id="L1584">        return updateMeasurements(measurements, TimeConverter.convert(</span>
<span class="fc" id="L1585">                timestamp.getValue().doubleValue(), timestamp.getUnit(),</span>
                TimeUnit.SECOND));
    }

    /**
     * Updates GNSS measurements of this estimator when new satellite measurements
     * are available.
     * Call to this method will be ignored if interval between provided timestamp
     * and last timestamp when Kalman filter was updated is less than epoch interval.
     *
     * @param measurements GNSS measurements to be updated.
     * @param timestamp    timestamp expressed in seconds since epoch time when
     *                     GNSS measurements were updated.
     * @return true if measurements were updated, false otherwise.
     * @throws LockedException   if this estimator is already running.
     * @throws NotReadyException if estimator is not ready for measurements updates.
     * @throws INSGNSSException  if estimation fails due to numerical instabilities.
     */
    public boolean updateMeasurements(
            final Collection&lt;GNSSMeasurement&gt; measurements, final double timestamp)
            throws LockedException, NotReadyException, INSGNSSException {

<span class="fc bfc" id="L1607" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L1608">            throw new LockedException();</span>
        }

<span class="fc bfc" id="L1611" title="All 2 branches covered.">        if (!isUpdateMeasurementsReady(measurements)) {</span>
<span class="fc" id="L1612">            throw new NotReadyException();</span>
        }

<span class="fc bfc" id="L1615" title="All 2 branches covered.">        if (mLastStateTimestamp != null &amp;&amp;</span>
<span class="pc bpc" id="L1616" title="1 of 2 branches missed.">                timestamp - mLastStateTimestamp &lt;= mEpochInterval) {</span>
<span class="fc" id="L1617">            return false;</span>
        }

        try {
<span class="fc" id="L1621">            mRunning = true;</span>

<span class="pc bpc" id="L1623" title="1 of 2 branches missed.">            if (mListener != null) {</span>
<span class="fc" id="L1624">                mListener.onUpdateGNSSMeasurementsStart(this);</span>
            }

<span class="fc" id="L1627">            mMeasurements = new ArrayList&lt;&gt;(measurements);</span>

<span class="fc" id="L1629">            mLsEstimator.setMeasurements(mMeasurements);</span>
<span class="fc" id="L1630">            mLsEstimator.setPriorPositionAndVelocityFromEstimation(mEstimation);</span>
<span class="pc bpc" id="L1631" title="1 of 2 branches missed.">            if (mEstimation != null) {</span>
<span class="nc" id="L1632">                mLsEstimator.estimate(mEstimation);</span>
            } else {
<span class="fc" id="L1634">                mEstimation = mLsEstimator.estimate();</span>
            }

<span class="pc bpc" id="L1637" title="1 of 2 branches missed.">            if (mListener != null) {</span>
<span class="fc" id="L1638">                mListener.onUpdateGNSSMeasurementsEnd(this);</span>
            }

<span class="fc" id="L1641">        } catch (final GNSSException e) {</span>
<span class="fc" id="L1642">            throw new INSGNSSException(e);</span>
        } finally {
<span class="fc" id="L1644">            mRunning = false;</span>
        }

<span class="fc" id="L1647">        updateBodyKinematics(mKinematics, timestamp);</span>

<span class="fc" id="L1649">        return true;</span>
    }

    /**
     * Updates specific force and angular rate applied to the user's
     * body expressed in coordinates resolved along body-frame axes.
     *
     * @param kinematics kinematics applied to body (specific force and angular rate)
     *                   during last period of time. These measures are obtained from
     *                   an inertial unit (IMU).
     * @param timestamp  timestamp since epoch time when specific force and
     *                   angular rate values were updated.
     * @return true if body kinematics values were updated, false otherwise.
     * @throws LockedException  if this estimator is already running.
     * @throws INSGNSSException if estimation fails due to numerical instabilities.
     */
    public boolean updateBodyKinematics(
            final BodyKinematics kinematics, final Time timestamp)
            throws LockedException, INSGNSSException {
<span class="fc" id="L1668">        return updateBodyKinematics(kinematics, TimeConverter.convert(</span>
<span class="fc" id="L1669">                timestamp.getValue().doubleValue(), timestamp.getUnit(),</span>
                TimeUnit.SECOND));
    }

    /**
     * Updates specific force and angular rate applied to the user's
     * body expressed in coordinates resolved along body-frame axes.
     *
     * @param kinematics kinematics applied to body (specific force and angular rate)
     *                   during last period of time. These measures are obtained from
     *                   an inertial unit (IMU).
     * @param timestamp  timestamp expressed in seconds since epoch time when specific
     *                   force and angular rate values were updated.
     * @return true if body kinematics values were updated, false otherwise.
     * @throws LockedException  if this estimator is already running.
     * @throws INSGNSSException if estimation fails due to numerical instabilities.
     */
    public boolean updateBodyKinematics(
            final BodyKinematics kinematics, final double timestamp)
            throws LockedException, INSGNSSException {

<span class="fc bfc" id="L1690" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L1691">            throw new LockedException();</span>
        }

<span class="fc bfc" id="L1694" title="All 2 branches covered.">        final double propagationInterval = mLastStateTimestamp != null ?</span>
<span class="fc" id="L1695">                timestamp - mLastStateTimestamp : 0.0;</span>
<span class="fc bfc" id="L1696" title="All 4 branches covered.">        if (mLastStateTimestamp != null &amp;&amp; propagationInterval &lt;= mEpochInterval) {</span>
<span class="fc" id="L1697">            return false;</span>
        }

        try {
<span class="fc" id="L1701">            mRunning = true;</span>

<span class="pc bpc" id="L1703" title="1 of 2 branches missed.">            if (mListener != null) {</span>
<span class="fc" id="L1704">                mListener.onUpdateBodyKinematicsStart(this);</span>
            }

<span class="fc" id="L1707">            initFrame();</span>
<span class="fc bfc" id="L1708" title="All 2 branches covered.">            if (mEstimation != null) {</span>
<span class="fc" id="L1709">                mFrame.setCoordinates(</span>
<span class="fc" id="L1710">                        mEstimation.getX(), mEstimation.getY(), mEstimation.getZ());</span>
<span class="fc" id="L1711">                mFrame.setVelocityCoordinates(</span>
<span class="fc" id="L1712">                        mEstimation.getVx(), mEstimation.getVy(), mEstimation.getVz());</span>
            }

<span class="fc bfc" id="L1715" title="All 2 branches covered.">            if (kinematics != null) {</span>
<span class="fc" id="L1716">                correctKinematics(kinematics);</span>
<span class="fc" id="L1717">                ECEFInertialNavigator.navigateECEF(propagationInterval, mFrame,</span>
                        mCorrectedKinematics, mFrame);
            }

<span class="fc" id="L1721">            mKinematics = kinematics;</span>

<span class="pc bpc" id="L1723" title="1 of 2 branches missed.">            if (mListener != null) {</span>
<span class="fc" id="L1724">                mListener.onUpdateBodyKinematicsEnd(this);</span>
            }

<span class="nc" id="L1727">        } catch (final InertialNavigatorException e) {</span>
<span class="nc" id="L1728">            return false;</span>
        } finally {
<span class="fc" id="L1730">            mRunning = false;</span>
        }

<span class="fc" id="L1733">        propagate(timestamp);</span>

<span class="fc" id="L1735">        return true;</span>
    }

    /**
     * Indicates whether this estimator is ready for state propagations.
     *
     * @return true if estimator is ready, false otherwise.
     */
    public boolean isPropagateReady() {
<span class="fc bfc" id="L1744" title="All 4 branches covered.">        return mConfig != null &amp;&amp; mEstimation != null;</span>
    }

    /**
     * Propagates Kalman filter state held by this estimator at provided
     * timestamp.
     * Call to this method will be ignored if interval between provided timestamp
     * and last timestamp when Kalman filter was updated is less than epoch interval.
     *
     * @param timestamp timestamp since epoch to propagate state.
     * @return true if state was propagated, false otherwise.
     * @throws LockedException  if this estimator is already running.
     * @throws INSGNSSException if estimation fails due to numerical instabilities.
     */
    public boolean propagate(final Time timestamp) throws LockedException,
            INSGNSSException {
<span class="fc" id="L1760">        return propagate(TimeConverter.convert(timestamp.getValue().doubleValue(),</span>
<span class="fc" id="L1761">                timestamp.getUnit(), TimeUnit.SECOND));</span>
    }

    /**
     * Propagates Kalman filter state held by this estimator at provided
     * timestamp.
     * Call to this method will be ignored if interval between provided timestamp
     * and last timestamp when Kalman filter was updated is less than epoch interval.
     *
     * @param timestamp timestamp expressed in seconds since epoch to propagate state.
     * @return true if state was propagated, false otherwise.
     * @throws LockedException  if this estimator is already running.
     * @throws INSGNSSException if estimation fails due to numerical instabilities.
     */
    public boolean propagate(final double timestamp) throws LockedException,
            INSGNSSException {

<span class="fc bfc" id="L1778" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L1779">            throw new LockedException();</span>
        }

<span class="fc bfc" id="L1782" title="All 2 branches covered.">        if (!isPropagateReady()) {</span>
<span class="fc" id="L1783">            return false;</span>
        }

<span class="fc bfc" id="L1786" title="All 2 branches covered.">        final double propagationInterval = mLastStateTimestamp != null ?</span>
<span class="fc" id="L1787">                timestamp - mLastStateTimestamp : 0.0;</span>
<span class="fc bfc" id="L1788" title="All 4 branches covered.">        if (mLastStateTimestamp != null &amp;&amp; propagationInterval &lt;= mEpochInterval) {</span>
<span class="fc" id="L1789">            return false;</span>
        }

        try {
<span class="fc" id="L1793">            mRunning = true;</span>

<span class="pc bpc" id="L1795" title="1 of 2 branches missed.">            if (mListener != null) {</span>
<span class="fc" id="L1796">                mListener.onPropagateStart(this);</span>
            }

<span class="pc bpc" id="L1799" title="1 of 2 branches missed.">            if (initFrame()) {</span>
<span class="nc" id="L1800">                mFrame.setCoordinates(</span>
<span class="nc" id="L1801">                        mEstimation.getX(), mEstimation.getY(), mEstimation.getZ());</span>
<span class="nc" id="L1802">                mFrame.setVelocityCoordinates(</span>
<span class="nc" id="L1803">                        mEstimation.getVx(), mEstimation.getVy(), mEstimation.getVz());</span>
            }

<span class="fc bfc" id="L1806" title="All 2 branches covered.">            if (mState == null) {</span>
                // initialize state
<span class="fc" id="L1808">                initInitialConfig();</span>
<span class="fc" id="L1809">                final Matrix covariance = INSTightlyCoupledKalmanInitializer</span>
<span class="fc" id="L1810">                        .initialize(mInitialConfig);</span>

<span class="fc" id="L1812">                mState = new INSTightlyCoupledKalmanState();</span>
<span class="fc" id="L1813">                mState.setFrame(mFrame);</span>
<span class="fc" id="L1814">                mState.setCovariance(covariance);</span>
            }

<span class="fc bfc" id="L1817" title="All 2 branches covered.">            if (mKinematics != null) {</span>
<span class="fc" id="L1818">                correctKinematics(mKinematics);</span>
            }

            final double fx;
            final double fy;
            final double fz;
<span class="fc bfc" id="L1824" title="All 2 branches covered.">            if (mCorrectedKinematics != null) {</span>
<span class="fc" id="L1825">                fx = mCorrectedKinematics.getFx();</span>
<span class="fc" id="L1826">                fy = mCorrectedKinematics.getFy();</span>
<span class="fc" id="L1827">                fz = mCorrectedKinematics.getFz();</span>
            } else {
<span class="fc" id="L1829">                fx = 0.0;</span>
<span class="fc" id="L1830">                fy = 0.0;</span>
<span class="fc" id="L1831">                fz = 0.0;</span>
            }

<span class="fc" id="L1834">            INSTightlyCoupledKalmanEpochEstimator.estimate(mMeasurements,</span>
                    propagationInterval, mState, fx, fy, fz, mConfig, mState);
<span class="fc" id="L1836">            mLastStateTimestamp = timestamp;</span>

<span class="fc" id="L1838">            mState.getGNSSEstimation(mEstimation);</span>
<span class="fc" id="L1839">            mState.getFrame(mFrame);</span>

<span class="pc bpc" id="L1841" title="1 of 2 branches missed.">            if (mListener != null) {</span>
<span class="fc" id="L1842">                mListener.onPropagateEnd(this);</span>
            }

<span class="nc" id="L1845">        } catch (final AlgebraException e) {</span>
<span class="nc" id="L1846">            throw new INSGNSSException(e);</span>
        } finally {
<span class="fc" id="L1848">            mRunning = false;</span>
        }

<span class="fc" id="L1851">        return true;</span>
    }

    /**
     * Resets this estimator.
     *
     * @throws LockedException if this estimator is already running.
     */
    public void reset() throws LockedException {
<span class="fc bfc" id="L1860" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L1861">            throw new LockedException();</span>
        }

<span class="fc" id="L1864">        mRunning = true;</span>
<span class="fc" id="L1865">        mMeasurements = null;</span>
<span class="fc" id="L1866">        mEstimation = null;</span>
<span class="fc" id="L1867">        mState = null;</span>
<span class="fc" id="L1868">        mLastStateTimestamp = null;</span>
<span class="fc" id="L1869">        mKinematics = null;</span>
<span class="fc" id="L1870">        mCorrectedKinematics = null;</span>
<span class="fc" id="L1871">        mFrame = null;</span>

<span class="pc bpc" id="L1873" title="1 of 2 branches missed.">        if (mListener != null) {</span>
<span class="fc" id="L1874">            mListener.onReset(this);</span>
        }

<span class="fc" id="L1877">        mRunning = false;</span>
<span class="fc" id="L1878">    }</span>

    /**
     * Initializes current ECEF frame containing user position, velocity and
     * orientation expressed an resolved in ECEF coordinates.
     * This method makes no action if an initial frame already exists.
     *
     * @return true if frame was initialized, false otherwise.
     */
    private boolean initFrame() {
<span class="fc bfc" id="L1888" title="All 2 branches covered.">        if (mFrame == null) {</span>
<span class="fc" id="L1889">            mFrame = new ECEFFrame();</span>
<span class="fc" id="L1890">            return true;</span>
        } else {
<span class="fc" id="L1892">            return false;</span>
        }
    }

    /**
     * Initializes initial INS tightly coupled Kalman configuration to set
     * a proper initial covariance matrix.
     * This method makes no action if an initial configuration already exists.
     */
    private void initInitialConfig() {
<span class="pc bpc" id="L1902" title="1 of 2 branches missed.">        if (mInitialConfig == null) {</span>
<span class="nc" id="L1903">            mInitialConfig = new INSTightlyCoupledKalmanInitializerConfig();</span>
        }
<span class="fc" id="L1905">    }</span>

    /**
     * Corrects provided kinematics by taking into account currently estimated
     * specific force and angular rate biases.
     * This method stores the result into the variable member containing corrected
     * kinematics values.
     *
     * @param kinematics kinematics instance to be corrected.
     */
    private void correctKinematics(final BodyKinematics kinematics) {
<span class="fc bfc" id="L1916" title="All 2 branches covered.">        if (mCorrectedKinematics == null) {</span>
<span class="fc" id="L1917">            mCorrectedKinematics = new BodyKinematics();</span>
        }

        final double accelBiasX;
        final double accelBiasY;
        final double accelBiasZ;
        final double gyroBiasX;
        final double gyroBiasY;
        final double gyroBiasZ;
<span class="fc bfc" id="L1926" title="All 2 branches covered.">        if (mState != null) {</span>
<span class="fc" id="L1927">            accelBiasX = mState.getAccelerationBiasX();</span>
<span class="fc" id="L1928">            accelBiasY = mState.getAccelerationBiasY();</span>
<span class="fc" id="L1929">            accelBiasZ = mState.getAccelerationBiasZ();</span>
<span class="fc" id="L1930">            gyroBiasX = mState.getGyroBiasX();</span>
<span class="fc" id="L1931">            gyroBiasY = mState.getGyroBiasY();</span>
<span class="fc" id="L1932">            gyroBiasZ = mState.getGyroBiasZ();</span>
        } else {
<span class="fc" id="L1934">            accelBiasX = 0.0;</span>
<span class="fc" id="L1935">            accelBiasY = 0.0;</span>
<span class="fc" id="L1936">            accelBiasZ = 0.0;</span>
<span class="fc" id="L1937">            gyroBiasX = 0.0;</span>
<span class="fc" id="L1938">            gyroBiasY = 0.0;</span>
<span class="fc" id="L1939">            gyroBiasZ = 0.0;</span>
        }

<span class="fc" id="L1942">        final double fx = kinematics.getFx();</span>
<span class="fc" id="L1943">        final double fy = kinematics.getFy();</span>
<span class="fc" id="L1944">        final double fz = kinematics.getFz();</span>
<span class="fc" id="L1945">        final double angularRateX = kinematics.getAngularRateX();</span>
<span class="fc" id="L1946">        final double angularRateY = kinematics.getAngularRateY();</span>
<span class="fc" id="L1947">        final double angularRateZ = kinematics.getAngularRateZ();</span>

<span class="fc" id="L1949">        mCorrectedKinematics.setSpecificForceCoordinates(</span>
                fx - accelBiasX, fy - accelBiasY, fz - accelBiasZ);
<span class="fc" id="L1951">        mCorrectedKinematics.setAngularRateCoordinates(</span>
                angularRateX - gyroBiasX,
                angularRateY - gyroBiasY,
                angularRateZ - gyroBiasZ);
<span class="fc" id="L1955">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>