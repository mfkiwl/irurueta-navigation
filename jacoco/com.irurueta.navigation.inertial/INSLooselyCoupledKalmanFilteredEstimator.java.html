<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>INSLooselyCoupledKalmanFilteredEstimator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.irurueta:irurueta-navigation</a> &gt; <a href="index.source.html" class="el_package">com.irurueta.navigation.inertial</a> &gt; <span class="el_source">INSLooselyCoupledKalmanFilteredEstimator.java</span></div><h1>INSLooselyCoupledKalmanFilteredEstimator.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2020 Alberto Irurueta Carro (alberto@irurueta.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.irurueta.navigation.inertial;

import com.irurueta.algebra.AlgebraException;
import com.irurueta.algebra.Matrix;
import com.irurueta.navigation.LockedException;
import com.irurueta.navigation.NotReadyException;
import com.irurueta.navigation.frames.ECEFFrame;
import com.irurueta.navigation.inertial.navigators.ECEFInertialNavigator;
import com.irurueta.navigation.inertial.navigators.InertialNavigatorException;
import com.irurueta.units.Time;
import com.irurueta.units.TimeConverter;
import com.irurueta.units.TimeUnit;

/**
 * Calculates position, velocity, attitude and IMU biases using an INS loosely
 * coupled Kalman filter to take into account intertial measurements to
 * smooth results and taking into account an initial position.
 * This implementation is based on the equations defined in &quot;Principles of GNSS, Inertial, and Multisensor
 * Integrated Navigation Systems, Second Edition&quot; and on the companion software available at:
 * https://github.com/ymjdz/MATLAB-Codes/blob/master/Loosely_coupled_INS_GNSS.m
 */
public class INSLooselyCoupledKalmanFilteredEstimator {

    /**
     * Listener to notify events raised by this instance.
     */
    private INSLooselyCoupledKalmanFilteredEstimatorListener mListener;

    /**
     * Minimum epoch interval expressed in seconds (s) between consecutive
     * propagations or measurements.
     * Attempting to propagate results using Kalman filter or updating measurements
     * when intervals are less than this value, will be ignored.
     */
    private double mEpochInterval;

    /**
     * INS loosely coupled Kalman filter configuration parameters (usually
     * obtained through calibration).
     */
    private INSLooselyCoupledKalmanConfig mConfig;

    /**
     * Last provided user kinematics containing applied specific force and
     * angular rates resolved in body axes.
     */
    private BodyKinematics mKinematics;

    /**
     * Contains last provided user kinematics minus currently estimated bias
     * for acceleration and angular rate values.
     */
    private BodyKinematics mCorrectedKinematics;

    /**
     * Contains current or initial user position, velocity and attitude.
     */
    private ECEFFrame mFrame;

    /**
     * Configuration containing uncertainty measures to set initial covariance matrix
     * within estimated state.
     * Once this estimator is initialized, covariance will be updated with new provided
     * INS measurements until convergence is reached.
     */
    private INSLooselyCoupledKalmanInitializerConfig mInitialConfig;

    /**
     * Current Kalman filter state containing current INS estimation along with
     * Kalman filter covariance error matrix.
     */
    private INSLooselyCoupledKalmanState mState;

    /**
     * Timestamp expressed in seconds since epoch time when Kalman filter state
     * was last propagated.
     */
    private Double mLastStateTimestamp;

    /**
     * Indicates whether this estimator is running or not.
     */
    private boolean mRunning;

    /**
     * Constructor.
     */
<span class="fc" id="L103">    public INSLooselyCoupledKalmanFilteredEstimator() {</span>
<span class="fc" id="L104">    }</span>

    /**
     * Constructor.
     *
     * @param config INS Kalman filter configuration parameters (usually obtained
     *               through calibration).
     */
    public INSLooselyCoupledKalmanFilteredEstimator(
<span class="fc" id="L113">            final INSLooselyCoupledKalmanConfig config) {</span>
<span class="fc" id="L114">        mConfig = new INSLooselyCoupledKalmanConfig(config);</span>
<span class="fc" id="L115">    }</span>

    /**
     * Constructor.
     *
     * @param epochInterval minimum epoch interval expressed in seconds (s) between
     *                      consecutive propagations or measurements.
     * @throws IllegalArgumentException if provided epoch interval is negative.
     */
    public INSLooselyCoupledKalmanFilteredEstimator(
<span class="fc" id="L125">            final double epochInterval) {</span>
        try {
<span class="fc" id="L127">            setEpochInterval(epochInterval);</span>
<span class="nc" id="L128">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L130">        }</span>
<span class="fc" id="L131">    }</span>

    /**
     * Constructor.
     *
     * @param listener listener to notify events raised by this instance.
     */
    public INSLooselyCoupledKalmanFilteredEstimator(
<span class="fc" id="L139">            final INSLooselyCoupledKalmanFilteredEstimatorListener listener) {</span>
<span class="fc" id="L140">        mListener = listener;</span>
<span class="fc" id="L141">    }</span>

    /**
     * Constructor.
     *
     * @param config        INS loosely coupled Kalman filter configuration
     *                      parameters (usually obtained through calibration).
     * @param epochInterval minimum epoch interval expressed in seconds (s) between
     *                      consecutive propagations or measurements.
     * @throws IllegalArgumentException if provided epoch interval is negative.
     */
    public INSLooselyCoupledKalmanFilteredEstimator(
            final INSLooselyCoupledKalmanConfig config, final double epochInterval) {
<span class="fc" id="L154">        this(epochInterval);</span>
<span class="fc" id="L155">        mConfig = new INSLooselyCoupledKalmanConfig(config);</span>
<span class="fc" id="L156">    }</span>

    /**
     * Constructor.
     *
     * @param config   INS tightly coupled Kalman filter configuration parameters
     *                 (usually obtained through calibration).
     * @param listener listener to notify events raised by this instance.
     */
    public INSLooselyCoupledKalmanFilteredEstimator(
            final INSLooselyCoupledKalmanConfig config,
            final INSLooselyCoupledKalmanFilteredEstimatorListener listener) {
<span class="fc" id="L168">        this(config);</span>
<span class="fc" id="L169">        mListener = listener;</span>
<span class="fc" id="L170">    }</span>

    /**
     * Constructor.
     *
     * @param epochInterval minimum epoch interval expressed in seconds (s) between
     *                      consecutive propagations or measurements.
     * @param listener      listener to notify events raised by this instance.
     * @throws IllegalArgumentException if provided epoch interval is negative.
     */
    public INSLooselyCoupledKalmanFilteredEstimator(
            final double epochInterval,
            final INSLooselyCoupledKalmanFilteredEstimatorListener listener) {
<span class="fc" id="L183">        this(epochInterval);</span>
<span class="fc" id="L184">        mListener = listener;</span>
<span class="fc" id="L185">    }</span>

    /**
     * Constructor.
     *
     * @param config        INS loosely coupled Kalman filter configuration
     *                      parameters (usually obtained through calibration).
     * @param epochInterval minimum epoch interval expressed in seconds (s) between
     *                      consecutive propagations or measurements.
     * @param listener      listener to notify events raised by this instance.
     * @throws IllegalArgumentException if provided epoch interval is negative.
     */
    public INSLooselyCoupledKalmanFilteredEstimator(
            final INSLooselyCoupledKalmanConfig config, final double epochInterval,
            final INSLooselyCoupledKalmanFilteredEstimatorListener listener) {
<span class="fc" id="L200">        this(config, epochInterval);</span>
<span class="fc" id="L201">        mListener = listener;</span>
<span class="fc" id="L202">    }</span>

    /**
     * Constructor.
     *
     * @param epochInterval minimum epoch interval between consecutive
     *                      propagations or measurements.
     * @throws IllegalArgumentException if provided epoch interval is negative.
     */
    public INSLooselyCoupledKalmanFilteredEstimator(final Time epochInterval) {
<span class="fc" id="L212">        this(TimeConverter.convert(epochInterval.getValue().doubleValue(),</span>
<span class="fc" id="L213">                epochInterval.getUnit(), TimeUnit.SECOND));</span>
<span class="fc" id="L214">    }</span>

    /**
     * Constructor.
     *
     * @param config        INS tightly coupled Kalman filter configuration
     *                      parameters (usually obtained through calibration).
     * @param epochInterval minimum epoch interval between consecutive
     *                      propagations or measurements.
     * @throws IllegalArgumentException if provided epoch interval is negative.
     */
    public INSLooselyCoupledKalmanFilteredEstimator(
            final INSLooselyCoupledKalmanConfig config, final Time epochInterval) {
<span class="fc" id="L227">        this(config, TimeConverter.convert(epochInterval.getValue().doubleValue(),</span>
<span class="fc" id="L228">                epochInterval.getUnit(), TimeUnit.SECOND));</span>
<span class="fc" id="L229">    }</span>

    /**
     * Constructor.
     *
     * @param epochInterval minimum epoch interval between consecutive
     *                      propagations or measurements.
     * @param listener      listener to notify events raised by this instance.
     * @throws IllegalArgumentException if provided epoch interval is negative.
     */
    public INSLooselyCoupledKalmanFilteredEstimator(
            final Time epochInterval,
            final INSLooselyCoupledKalmanFilteredEstimatorListener listener) {
<span class="fc" id="L242">        this(epochInterval);</span>
<span class="fc" id="L243">        mListener = listener;</span>
<span class="fc" id="L244">    }</span>

    /**
     * Constructor.
     *
     * @param config        INS loosely coupled Kalman filter configuration
     *                      parameters (usually obtained through calibration).
     * @param epochInterval minimum epoch interval between consecutive
     *                      propagations or measurements.
     * @param listener      listener to notify events raised by this instance.
     * @throws IllegalArgumentException if provided epoch interval is negative.
     */
    public INSLooselyCoupledKalmanFilteredEstimator(
            final INSLooselyCoupledKalmanConfig config, final Time epochInterval,
            final INSLooselyCoupledKalmanFilteredEstimatorListener listener) {
<span class="fc" id="L259">        this(config, epochInterval);</span>
<span class="fc" id="L260">        mListener = listener;</span>
<span class="fc" id="L261">    }</span>

    /**
     * Constructor.
     *
     * @param frame frame containing initial user position, velocity and attitude
     *              resolved along ECEF axes.
     */
    public INSLooselyCoupledKalmanFilteredEstimator(final ECEFFrame frame) {
<span class="fc" id="L270">        this();</span>
        try {
<span class="fc" id="L272">            setFrame(frame);</span>
<span class="nc" id="L273">        } catch (final LockedException ignore) {</span>
            // never happens.
<span class="fc" id="L275">        }</span>
<span class="fc" id="L276">    }</span>

    /**
     * Constructor.
     *
     * @param config INS Kalman filter configuration parameters (usually obtained
     *               through calibration).
     * @param frame  frame containing initial user position, velocity and attitude
     *               resolved along ECEF axes.
     */
    public INSLooselyCoupledKalmanFilteredEstimator(
            final INSLooselyCoupledKalmanConfig config,
            final ECEFFrame frame) {
<span class="fc" id="L289">        this(frame);</span>
<span class="fc" id="L290">        mConfig = new INSLooselyCoupledKalmanConfig(config);</span>
<span class="fc" id="L291">    }</span>

    /**
     * Constructor.
     *
     * @param epochInterval minimum epoch interval expressed in seconds (s) between
     *                      consecutive propagations or measurements.
     * @param frame         frame containing initial user position, velocity and attitude
     *                      resolved along ECEF axes.
     * @throws IllegalArgumentException if provided epoch interval is negative.
     */
    public INSLooselyCoupledKalmanFilteredEstimator(
            final double epochInterval, final ECEFFrame frame) {
<span class="fc" id="L304">        this(epochInterval);</span>
        try {
<span class="fc" id="L306">            setFrame(frame);</span>
<span class="nc" id="L307">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L309">        }</span>
<span class="fc" id="L310">    }</span>

    /**
     * Constructor.
     *
     * @param frame    frame containing initial user position, velocity and attitude
     *                 resolved along ECEF axes.
     * @param listener listener to notify events raised by this instance.
     */
    public INSLooselyCoupledKalmanFilteredEstimator(
            final ECEFFrame frame,
            final INSLooselyCoupledKalmanFilteredEstimatorListener listener) {
<span class="fc" id="L322">        this(frame);</span>
<span class="fc" id="L323">        mListener = listener;</span>
<span class="fc" id="L324">    }</span>

    /**
     * Constructor.
     *
     * @param config        INS loosely coupled Kalman filter configuration
     *                      parameters (usually obtained through calibration).
     * @param epochInterval minimum epoch interval expressed in seconds (s) between
     *                      consecutive propagations or measurements.
     * @param frame         frame containing initial user position, velocity and attitude
     *                      resolved along ECEF axes.
     * @throws IllegalArgumentException if provided epoch interval is negative.
     */
    public INSLooselyCoupledKalmanFilteredEstimator(
            final INSLooselyCoupledKalmanConfig config, final double epochInterval,
            final ECEFFrame frame) {
<span class="fc" id="L340">        this(config, epochInterval);</span>
        try {
<span class="fc" id="L342">            setFrame(frame);</span>
<span class="nc" id="L343">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L345">        }</span>
<span class="fc" id="L346">    }</span>

    /**
     * Constructor.
     *
     * @param config   INS loosely coupled Kalman filter configuration parameters
     *                 (usually obtained through calibration).
     * @param frame    frame containing initial user position, velocity and attitude
     *                 resolved along ECEF axes.
     * @param listener listener to notify events raised by this instance.
     */
    public INSLooselyCoupledKalmanFilteredEstimator(
            final INSLooselyCoupledKalmanConfig config,
            final ECEFFrame frame,
            final INSLooselyCoupledKalmanFilteredEstimatorListener listener) {
<span class="fc" id="L361">        this(config, listener);</span>
        try {
<span class="fc" id="L363">            setFrame(frame);</span>
<span class="nc" id="L364">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L366">        }</span>
<span class="fc" id="L367">    }</span>

    /**
     * Constructor.
     *
     * @param epochInterval minimum epoch interval expressed in seconds (s) between
     *                      consecutive propagations or measurements.
     * @param frame         frame containing initial user position, velocity and attitude
     *                      resolved along ECEF axes.
     * @param listener      listener to notify events raised by this instance.
     * @throws IllegalArgumentException if provided epoch interval is negative.
     */
    public INSLooselyCoupledKalmanFilteredEstimator(
            final double epochInterval,
            final ECEFFrame frame,
            final INSLooselyCoupledKalmanFilteredEstimatorListener listener) {
<span class="fc" id="L383">        this(epochInterval, listener);</span>
        try {
<span class="fc" id="L385">            setFrame(frame);</span>
<span class="nc" id="L386">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L388">        }</span>
<span class="fc" id="L389">    }</span>

    /**
     * Constructor.
     *
     * @param config        INS loosely coupled Kalman filter configuration
     *                      parameters (usually obtained through calibration).
     * @param epochInterval minimum epoch interval expressed in seconds (s) between
     *                      consecutive propagations or measurements.
     * @param frame         frame containing initial user position, velocity and attitude
     *                      resolved along ECEF axes.
     * @param listener      listener to notify events raised by this instance.
     * @throws IllegalArgumentException if provided epoch interval is negative.
     */
    public INSLooselyCoupledKalmanFilteredEstimator(
            final INSLooselyCoupledKalmanConfig config, final double epochInterval,
            final ECEFFrame frame,
            final INSLooselyCoupledKalmanFilteredEstimatorListener listener) {
<span class="fc" id="L407">        this(config, epochInterval, listener);</span>
        try {
<span class="fc" id="L409">            setFrame(frame);</span>
<span class="nc" id="L410">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L412">        }</span>
<span class="fc" id="L413">    }</span>

    /**
     * Constructor.
     *
     * @param epochInterval minimum epoch interval between consecutive
     *                      propagations or measurements.
     * @param frame         frame containing initial user position, velocity and attitude
     *                      resolved along eCEF axes.
     * @throws IllegalArgumentException if provided epoch interval is negative.
     */
    public INSLooselyCoupledKalmanFilteredEstimator(
            final Time epochInterval, final ECEFFrame frame) {
<span class="fc" id="L426">        this(epochInterval);</span>
        try {
<span class="fc" id="L428">            setFrame(frame);</span>
<span class="nc" id="L429">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L431">        }</span>
<span class="fc" id="L432">    }</span>

    /**
     * Constructor.
     *
     * @param config        INS loosely coupled Kalman filter configuration
     *                      parameters (usually obtained through calibration).
     * @param epochInterval minimum epoch interval between consecutive
     *                      propagations or measurements.
     * @param frame         frame containing initial user position, velocity and attitude
     *                      resolved along ECEF axes.
     * @throws IllegalArgumentException if provided epoch interval is negative.
     */
    public INSLooselyCoupledKalmanFilteredEstimator(
            final INSLooselyCoupledKalmanConfig config, final Time epochInterval,
            final ECEFFrame frame) {
<span class="fc" id="L448">        this(config, epochInterval);</span>
        try {
<span class="fc" id="L450">            setFrame(frame);</span>
<span class="nc" id="L451">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L453">        }</span>
<span class="fc" id="L454">    }</span>

    /**
     * Constructor.
     *
     * @param epochInterval minimum epoch interval between consecutive
     *                      propagations or measurements.
     * @param frame         frame containing initial user position, velocity and attitude
     *                      resolved along ECEF axes.
     * @param listener      listener to notify events raised by this instance.
     * @throws IllegalArgumentException if provided epoch interval is negative.
     */
    public INSLooselyCoupledKalmanFilteredEstimator(
            final Time epochInterval, final ECEFFrame frame,
            final INSLooselyCoupledKalmanFilteredEstimatorListener listener) {
<span class="fc" id="L469">        this(epochInterval, listener);</span>
        try {
<span class="fc" id="L471">            setFrame(frame);</span>
<span class="nc" id="L472">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L474">        }</span>
<span class="fc" id="L475">    }</span>

    /**
     * Constructor.
     *
     * @param config        INS loosely coupled Kalman filter configuration
     *                      parameters (usually obtained through calibration).
     * @param epochInterval minimum epoch interval between consecutive
     *                      propagations or measurements.
     * @param frame         frame containing initial user position, velocity and attitude
     *                      resolved along ECEF axes.
     * @param listener      listener to notify events raised by this instance.
     * @throws IllegalArgumentException if provided epoch interval is negative.
     */
    public INSLooselyCoupledKalmanFilteredEstimator(
            final INSLooselyCoupledKalmanConfig config, final Time epochInterval,
            final ECEFFrame frame,
            final INSLooselyCoupledKalmanFilteredEstimatorListener listener) {
<span class="fc" id="L493">        this(config, epochInterval, listener);</span>
        try {
<span class="fc" id="L495">            setFrame(frame);</span>
<span class="nc" id="L496">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L498">        }</span>
<span class="fc" id="L499">    }</span>

    /**
     * Constructor.
     *
     * @param initialConfig initial INS loosely coupled Kalman configuration to
     *                      set proper initial covariance during filter initialization.
     */
    public INSLooselyCoupledKalmanFilteredEstimator(
            final INSLooselyCoupledKalmanInitializerConfig initialConfig) {
<span class="fc" id="L509">        this();</span>
        try {
<span class="fc" id="L511">            setInitialConfig(initialConfig);</span>
<span class="nc" id="L512">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L514">        }</span>
<span class="fc" id="L515">    }</span>

    /**
     * Constructor.
     *
     * @param config        INS Kalman filter configuration parameters (usually obtained
     *                      through calibration).
     * @param initialConfig initial INS loosely coupled Kalman configuration to
     *                      set proper initial covariance during filter initialization.
     */
    public INSLooselyCoupledKalmanFilteredEstimator(
            final INSLooselyCoupledKalmanConfig config,
            final INSLooselyCoupledKalmanInitializerConfig initialConfig) {
<span class="fc" id="L528">        this(config);</span>
        try {
<span class="fc" id="L530">            setInitialConfig(initialConfig);</span>
<span class="nc" id="L531">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L533">        }</span>
<span class="fc" id="L534">    }</span>

    /**
     * Constructor.
     *
     * @param epochInterval minimum epoch interval expressed in seconds (s) between
     *                      consecutive propagations or measurements.
     * @param initialConfig initial INS loosely coupled Kalman configuration to
     *                      set proper initial covariance during filter initialization.
     * @throws IllegalArgumentException if provided epoch interval is negative.
     */
    public INSLooselyCoupledKalmanFilteredEstimator(
            final double epochInterval,
            final INSLooselyCoupledKalmanInitializerConfig initialConfig) {
<span class="fc" id="L548">        this(epochInterval);</span>
        try {
<span class="fc" id="L550">            setInitialConfig(initialConfig);</span>
<span class="nc" id="L551">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L553">        }</span>
<span class="fc" id="L554">    }</span>

    /**
     * Constructor.
     *
     * @param initialConfig initial INS loosely coupled Kalman configuration to
     *                      set proper initial covariance during filter initialization.
     * @param listener      listener to notify events raised by this instance.
     */
    public INSLooselyCoupledKalmanFilteredEstimator(
            final INSLooselyCoupledKalmanInitializerConfig initialConfig,
            final INSLooselyCoupledKalmanFilteredEstimatorListener listener) {
<span class="fc" id="L566">        this(initialConfig);</span>
<span class="fc" id="L567">        mListener = listener;</span>
<span class="fc" id="L568">    }</span>

    /**
     * Constructor.
     *
     * @param config        INS loosely coupled Kalman filter configuration
     *                      parameters (usually obtained through calibration).
     * @param epochInterval minimum epoch interval expressed in seconds (s) between
     *                      consecutive propagations or measurements.
     * @param initialConfig initial INS loosely coupled Kalman configuration to
     *                      set proper initial covariane during filter initialization.
     * @throws IllegalArgumentException if provided epoch intervla is negative.
     */
    public INSLooselyCoupledKalmanFilteredEstimator(
            final INSLooselyCoupledKalmanConfig config, final double epochInterval,
            final INSLooselyCoupledKalmanInitializerConfig initialConfig) {
<span class="fc" id="L584">        this(config, epochInterval);</span>
        try {
<span class="fc" id="L586">            setInitialConfig(initialConfig);</span>
<span class="nc" id="L587">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L589">        }</span>
<span class="fc" id="L590">    }</span>

    /**
     * Constructor.
     *
     * @param config        INS loosely coupled Kalman filter configuration parameters
     *                      (usually obtained through calibration).
     * @param initialConfig initial INS loosely coupled Kalman configuration to
     *                      set proper initial covariance during filter initialization.
     * @param listener      listener to notify events raised by this instance.
     */
    public INSLooselyCoupledKalmanFilteredEstimator(
            final INSLooselyCoupledKalmanConfig config,
            final INSLooselyCoupledKalmanInitializerConfig initialConfig,
            final INSLooselyCoupledKalmanFilteredEstimatorListener listener) {
<span class="fc" id="L605">        this(config, listener);</span>
        try {
<span class="fc" id="L607">            setInitialConfig(initialConfig);</span>
<span class="nc" id="L608">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L610">        }</span>
<span class="fc" id="L611">    }</span>

    /**
     * Constructor.
     *
     * @param epochInterval minimum epoch interval expressed in seconds (s) between
     *                      consecutive propagations or measurements.
     * @param initialConfig initial INS loosely coupled Kalman configuration to
     *                      set proper initial covariance during filter initialization.
     * @param listener      listener to notify events raised by this instance.
     * @throws IllegalArgumentException if provided epoch interval is negative.
     */
    public INSLooselyCoupledKalmanFilteredEstimator(
            final double epochInterval,
            final INSLooselyCoupledKalmanInitializerConfig initialConfig,
            final INSLooselyCoupledKalmanFilteredEstimatorListener listener) {
<span class="fc" id="L627">        this(epochInterval, listener);</span>
        try {
<span class="fc" id="L629">            setInitialConfig(initialConfig);</span>
<span class="nc" id="L630">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L632">        }</span>
<span class="fc" id="L633">    }</span>

    /**
     * Constructor.
     *
     * @param config        INS loosely coupled Kalman filter configuration
     *                      parameters (usually obtained through calibration).
     * @param epochInterval minimum epoch interval expressed in seconds (s) between
     *                      consecutive propagations or measurements.
     * @param initialConfig initial INS loosely coupled Kalman configuration to
     *                      set proper initial covariance during filter initialization.
     * @param listener      listener to notify events raised by this instance.
     * @throws IllegalArgumentException if provided epoch interval is negative.
     */
    public INSLooselyCoupledKalmanFilteredEstimator(
            final INSLooselyCoupledKalmanConfig config, final double epochInterval,
            final INSLooselyCoupledKalmanInitializerConfig initialConfig,
            final INSLooselyCoupledKalmanFilteredEstimatorListener listener) {
<span class="fc" id="L651">        this(config, epochInterval, listener);</span>
        try {
<span class="fc" id="L653">            setInitialConfig(initialConfig);</span>
<span class="nc" id="L654">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L656">        }</span>
<span class="fc" id="L657">    }</span>

    /**
     * Constructor.
     *
     * @param epochInterval minimum epoch interval between consecutive
     *                      propagations or measurements.
     * @param initialConfig initial INS loosely coupled Kalman configuration to
     *                      set proper initial covariance during filter initialization.
     * @throws IllegalArgumentException if provided epoch interval is negative.
     */
    public INSLooselyCoupledKalmanFilteredEstimator(
            final Time epochInterval,
            final INSLooselyCoupledKalmanInitializerConfig initialConfig) {
<span class="fc" id="L671">        this(epochInterval);</span>
        try {
<span class="fc" id="L673">            setInitialConfig(initialConfig);</span>
<span class="nc" id="L674">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L676">        }</span>
<span class="fc" id="L677">    }</span>

    /**
     * Constructor.
     *
     * @param config        INS loosely coupled Kalman filter configuration
     *                      parameters (usually obtained through calibration).
     * @param epochInterval minimum epoch interval between consecutive
     *                      propagations or measurements.
     * @param initialConfig initial INS loosely coupled Kalman configuration to
     *                      set proper initial covariance during filter initialization.
     * @throws IllegalArgumentException if provided epoch interval is negative.
     */
    public INSLooselyCoupledKalmanFilteredEstimator(
            final INSLooselyCoupledKalmanConfig config, final Time epochInterval,
            final INSLooselyCoupledKalmanInitializerConfig initialConfig) {
<span class="fc" id="L693">        this(config, epochInterval);</span>
        try {
<span class="fc" id="L695">            setInitialConfig(initialConfig);</span>
<span class="nc" id="L696">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L698">        }</span>
<span class="fc" id="L699">    }</span>

    /**
     * Constructor.
     *
     * @param epochInterval minimum epoch interval between consecutive
     *                      propagations or measurements.
     * @param initialConfig initial INS loosely coupled Kalman configuration to
     *                      set proper initial covariance during filter initialization.
     * @param listener      listener to notify events raised by this instance.
     * @throws IllegalArgumentException if provided epoch interval is negative.
     */
    public INSLooselyCoupledKalmanFilteredEstimator(
            final Time epochInterval,
            final INSLooselyCoupledKalmanInitializerConfig initialConfig,
            final INSLooselyCoupledKalmanFilteredEstimatorListener listener) {
<span class="fc" id="L715">        this(epochInterval, listener);</span>
        try {
<span class="fc" id="L717">            setInitialConfig(initialConfig);</span>
<span class="nc" id="L718">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L720">        }</span>
<span class="fc" id="L721">    }</span>

    /**
     * Constructor.
     *
     * @param config        INS loosely coupled Kalman filter configuration
     *                      parameters (usually obtained through calibration).
     * @param epochInterval minimum epoch interval between consecutive
     *                      propagations or measurements.
     * @param initialConfig initial INS loosely coupled Kalman configuration to
     *                      set proper initial covariance during filter initialization.
     * @param listener      listener to notify events raised by this instance.
     * @throws IllegalArgumentException if provided epoch interval is negative.
     */
    public INSLooselyCoupledKalmanFilteredEstimator(
            final INSLooselyCoupledKalmanConfig config, final Time epochInterval,
            final INSLooselyCoupledKalmanInitializerConfig initialConfig,
            final INSLooselyCoupledKalmanFilteredEstimatorListener listener) {
<span class="fc" id="L739">        this(config, epochInterval, listener);</span>
        try {
<span class="fc" id="L741">            setInitialConfig(initialConfig);</span>
<span class="nc" id="L742">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L744">        }</span>
<span class="fc" id="L745">    }</span>

    /**
     * Constructor.
     *
     * @param initialConfig initial INS loosely coupled Kalman configuration to
     *                      set proper initial covariance during filter initialization.
     * @param frame         frame containing initial user position, velocity and attitude
     *                      resolved along ECEF axes.
     */
    public INSLooselyCoupledKalmanFilteredEstimator(
            final INSLooselyCoupledKalmanInitializerConfig initialConfig,
            final ECEFFrame frame) {
<span class="fc" id="L758">        this(frame);</span>
        try {
<span class="fc" id="L760">            setInitialConfig(initialConfig);</span>
<span class="nc" id="L761">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L763">        }</span>
<span class="fc" id="L764">    }</span>

    /**
     * Constructor.
     *
     * @param config        INS Kalman filter configuration parameters (usually obtained
     *                      through calibration).
     * @param initialConfig initial INS loosely coupled Kalman configuration to
     *                      set proper initial covariance during filter initialization.
     * @param frame         frame containing initial user position, velocity and attitude
     *                      resolved along ECEF axes.
     */
    public INSLooselyCoupledKalmanFilteredEstimator(
            final INSLooselyCoupledKalmanConfig config,
            final INSLooselyCoupledKalmanInitializerConfig initialConfig,
            final ECEFFrame frame) {
<span class="fc" id="L780">        this(config, frame);</span>
        try {
<span class="fc" id="L782">            setInitialConfig(initialConfig);</span>
<span class="nc" id="L783">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L785">        }</span>
<span class="fc" id="L786">    }</span>

    /**
     * Constructor.
     *
     * @param epochInterval minimum epoch interval expressed in seconds (s) between
     *                      consecutive propagations or measurements.
     * @param initialConfig initial INS loosely coupled Kalman configuration to
     *                      set proper initial covariance during filter initialization.
     * @param frame         frame containing initial user position, velocity and attitude
     *                      resolved along ECEF axes.
     * @throws IllegalArgumentException if provided epoch interval is negative.
     */
    public INSLooselyCoupledKalmanFilteredEstimator(
            final double epochInterval,
            final INSLooselyCoupledKalmanInitializerConfig initialConfig,
            final ECEFFrame frame) {
<span class="fc" id="L803">        this(epochInterval, frame);</span>
        try {
<span class="fc" id="L805">            setInitialConfig(initialConfig);</span>
<span class="nc" id="L806">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L808">        }</span>
<span class="fc" id="L809">    }</span>

    /**
     * Constructor.
     *
     * @param initialConfig initial INS loosely coupled Kalman configuration to
     *                      set proper initial covariance during filter initialization.
     * @param frame         frame containing initial user position, velocity and attitude
     *                      resolved along ECEF axes.
     * @param listener      listener to notify events raised by this instance.
     */
    public INSLooselyCoupledKalmanFilteredEstimator(
            final INSLooselyCoupledKalmanInitializerConfig initialConfig,
            final ECEFFrame frame,
            final INSLooselyCoupledKalmanFilteredEstimatorListener listener) {
<span class="fc" id="L824">        this(frame, listener);</span>
        try {
<span class="fc" id="L826">            setInitialConfig(initialConfig);</span>
<span class="nc" id="L827">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L829">        }</span>
<span class="fc" id="L830">    }</span>

    /**
     * Constructor.
     *
     * @param config        INS loosely coupled Kalman filter configuration
     *                      parameters (usually obtained through calibration).
     * @param epochInterval minimum epoch interval expressed in seconds (s) between
     *                      consecutive propagations or measurements.
     * @param initialConfig initial INS loosely coupled Kalman configuration to
     *                      set proper initial covariance during filter initialization.
     * @param frame         frame containing initial user position, velocity and attitude
     *                      resolved along ECEF axes.
     * @throws IllegalArgumentException if provided epoch interval is negative.
     */
    public INSLooselyCoupledKalmanFilteredEstimator(
            final INSLooselyCoupledKalmanConfig config, final double epochInterval,
            final INSLooselyCoupledKalmanInitializerConfig initialConfig,
            final ECEFFrame frame) {
<span class="fc" id="L849">        this(config, epochInterval, frame);</span>
        try {
<span class="fc" id="L851">            setInitialConfig(initialConfig);</span>
<span class="nc" id="L852">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L854">        }</span>
<span class="fc" id="L855">    }</span>

    /**
     * Constructor.
     *
     * @param config        INS loosely coupled Kalman filter configuration parameters
     *                      (usually obtained through calibration).
     * @param initialConfig initial INS loosely coupled Kalman configuration to
     *                      set proper initial covariance during filter initialization.
     * @param frame         frame containing initial user position, velocity and attitude
     *                      resolved along ECEF axes.
     * @param listener      listener to notify events raised by this instance.
     */
    public INSLooselyCoupledKalmanFilteredEstimator(
            final INSLooselyCoupledKalmanConfig config,
            final INSLooselyCoupledKalmanInitializerConfig initialConfig,
            final ECEFFrame frame,
            final INSLooselyCoupledKalmanFilteredEstimatorListener listener) {
<span class="fc" id="L873">        this(config, frame, listener);</span>
        try {
<span class="fc" id="L875">            setInitialConfig(initialConfig);</span>
<span class="nc" id="L876">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L878">        }</span>
<span class="fc" id="L879">    }</span>

    /**
     * Constructor.
     *
     * @param epochInterval minimum epoch interval expressed in seconds (s) between
     *                      consecutive propagations or measurements.
     * @param initialConfig initial INS loosely coupled Kalman configuration to
     *                      set proper initial covariance during filter initialization.
     * @param frame         frame containing initial user position, velocity and attitude
     *                      resolved along ECEF axes.
     * @param listener      listener to notify events raised by this instance.
     * @throws IllegalArgumentException if provided epoch interval is negative.
     */
    public INSLooselyCoupledKalmanFilteredEstimator(
            final double epochInterval,
            final INSLooselyCoupledKalmanInitializerConfig initialConfig,
            final ECEFFrame frame,
            final INSLooselyCoupledKalmanFilteredEstimatorListener listener) {
<span class="fc" id="L898">        this(epochInterval, frame, listener);</span>
        try {
<span class="fc" id="L900">            setInitialConfig(initialConfig);</span>
<span class="nc" id="L901">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L903">        }</span>
<span class="fc" id="L904">    }</span>

    /**
     * Constructor.
     *
     * @param config        INS loosely coupled Kalman filter configuration
     *                      parameters (usually obtained through calibration).
     * @param epochInterval minimum epoch interval expressed in seconds (s) between
     *                      consecutive propagations or measurements.
     * @param initialConfig initial INS loosely coupled Kalman configuration to
     *                      set proper initial covariance during filter initialization.
     * @param frame         frame containing initial user position, velocity and attitude
     *                      resolved along ECEF axes.
     * @param listener      listener to notify events raised by this instance.
     * @throws IllegalArgumentException if provided epoch interval is negative.
     */
    public INSLooselyCoupledKalmanFilteredEstimator(
            final INSLooselyCoupledKalmanConfig config, final double epochInterval,
            final INSLooselyCoupledKalmanInitializerConfig initialConfig,
            final ECEFFrame frame,
            final INSLooselyCoupledKalmanFilteredEstimatorListener listener) {
<span class="fc" id="L925">        this(config, epochInterval, frame, listener);</span>
        try {
<span class="fc" id="L927">            setInitialConfig(initialConfig);</span>
<span class="nc" id="L928">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L930">        }</span>
<span class="fc" id="L931">    }</span>

    /**
     * Constructor.
     *
     * @param epochInterval minimum epoch interval between consecutive
     *                      propagations or measurements.
     * @param initialConfig initial INS loosely coupled Kalman configuration to
     *                      set proper initial covariance during filter initialization.
     * @param frame         frame containing initial user position, velocity and attitude
     *                      resolved along ECEF axes.
     * @throws IllegalArgumentException if provided epoch interval is negative.
     */
    public INSLooselyCoupledKalmanFilteredEstimator(
            final Time epochInterval,
            final INSLooselyCoupledKalmanInitializerConfig initialConfig,
            final ECEFFrame frame) {
<span class="fc" id="L948">        this(epochInterval, frame);</span>
        try {
<span class="fc" id="L950">            setInitialConfig(initialConfig);</span>
<span class="nc" id="L951">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L953">        }</span>
<span class="fc" id="L954">    }</span>

    /**
     * Constructor.
     *
     * @param config        INS loosely coupled Kalman filter configuration
     *                      parameters (usually obtained through calibration).
     * @param epochInterval minimum epoch interval between consecutive
     *                      propagations or measurements.
     * @param initialConfig initial INS loosely coupled Kalman configuration to
     *                      set proper initial covariance during filter initialization.
     * @param frame         frame containing initial user position, velocity and attitude
     *                      resolved along ECEF axes.
     * @throws IllegalArgumentException if provided epoch interval is negative.
     */
    public INSLooselyCoupledKalmanFilteredEstimator(
            final INSLooselyCoupledKalmanConfig config, final Time epochInterval,
            final INSLooselyCoupledKalmanInitializerConfig initialConfig,
            final ECEFFrame frame) {
<span class="fc" id="L973">        this(config, epochInterval, frame);</span>
        try {
<span class="fc" id="L975">            setInitialConfig(initialConfig);</span>
<span class="nc" id="L976">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L978">        }</span>
<span class="fc" id="L979">    }</span>

    /**
     * Constructor.
     *
     * @param epochInterval minimum epoch interval between consecutive
     *                      propagations or measurements.
     * @param initialConfig initial INS loosely coupled Kalman configuration to
     *                      set proper initial covariance during filter initialization.
     * @param frame         frame containing initial user position, velocity and attitude
     *                      resolved along ECEF axes.
     * @param listener      listener to notify events raised by this instance.
     * @throws IllegalArgumentException if provided epoch interval is negative.
     */
    public INSLooselyCoupledKalmanFilteredEstimator(
            final Time epochInterval,
            final INSLooselyCoupledKalmanInitializerConfig initialConfig,
            final ECEFFrame frame,
            final INSLooselyCoupledKalmanFilteredEstimatorListener listener) {
<span class="fc" id="L998">        this(epochInterval, frame, listener);</span>
        try {
<span class="fc" id="L1000">            setInitialConfig(initialConfig);</span>
<span class="nc" id="L1001">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L1003">        }</span>
<span class="fc" id="L1004">    }</span>

    /**
     * Constructor.
     *
     * @param config        INS loosely coupled Kalman filter configuration
     *                      parameters (usually obtained through calibration).
     * @param epochInterval minimum epoch interval between consecutive
     *                      propagations or measurements.
     * @param initialConfig initial INS loosely coupled Kalman configuration to
     *                      set proper initial covariance during filter initialization.
     * @param frame         frame containing initial user position, velocity and attitude
     *                      resolved along ECEF axes.
     * @param listener      listener to notify events raised by this instance.
     * @throws IllegalArgumentException if provided epoch interval is negative.
     */
    public INSLooselyCoupledKalmanFilteredEstimator(
            final INSLooselyCoupledKalmanConfig config, final Time epochInterval,
            final INSLooselyCoupledKalmanInitializerConfig initialConfig,
            final ECEFFrame frame,
            final INSLooselyCoupledKalmanFilteredEstimatorListener listener) {
<span class="fc" id="L1025">        this(config, epochInterval, frame, listener);</span>
        try {
<span class="fc" id="L1027">            setInitialConfig(initialConfig);</span>
<span class="nc" id="L1028">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L1030">        }</span>
<span class="fc" id="L1031">    }</span>

    /**
     * Gets listener to notify events raised by this instance.
     *
     * @return listener to notify events raised by this instance.
     */
    public INSLooselyCoupledKalmanFilteredEstimatorListener getListener() {
<span class="fc" id="L1039">        return mListener;</span>
    }

    /**
     * Sets listener to notify events raised by this instance.
     *
     * @param listener listener to notify events raised by this instance.
     * @throws LockedException if this estimator is already running.
     */
    public void setListener(
            final INSLooselyCoupledKalmanFilteredEstimatorListener listener)
            throws LockedException {
<span class="fc bfc" id="L1051" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L1052">            throw new LockedException();</span>
        }

<span class="fc" id="L1055">        mListener = listener;</span>
<span class="fc" id="L1056">    }</span>

    /**
     * Gets minimum epoch interval expressed in seconds (s) between consecutive
     * propagations or measurements expressed in seconds.
     * Attempting to propagate results using Kalman filter or updating measurements
     * when intervals are less than this value, will be ignored.
     *
     * @return minimum epoch interval between consecutive propagations or
     * measurements.
     */
    public double getEpochInterval() {
<span class="fc" id="L1068">        return mEpochInterval;</span>
    }

    /**
     * Sets minimum epoch interval expressed in seconds (s) between consecutive
     * propagations or measurements expressed in seconds.
     * Attempting to propagate results using Kalman filter or updating measurements
     * when interval are less than this value, will be ignored.
     *
     * @param epochInterval minimum epoch interval expressed in seconds (s) between
     *                      consecutive propagations or measurements.
     * @throws LockedException          if this estimator is already running.
     * @throws IllegalArgumentException if provided epoch interval is negative.
     */
    public void setEpochInterval(final double epochInterval) throws LockedException {
<span class="fc bfc" id="L1083" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L1084">            throw new LockedException();</span>
        }

<span class="fc bfc" id="L1087" title="All 2 branches covered.">        if (epochInterval &lt; 0.0) {</span>
<span class="fc" id="L1088">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L1091">        mEpochInterval = epochInterval;</span>
<span class="fc" id="L1092">    }</span>

    /**
     * Gets minimum epoch interval between consecutive propagations or measurements.
     * Attempting to propagate results using Kalman filter or updating measurements
     * when intervals are less than this value, will be ignored.
     *
     * @param result instance where minimum epoch interval will be stored.
     */
    public void getEpochIntervalAsTime(final Time result) {
<span class="fc" id="L1102">        result.setValue(mEpochInterval);</span>
<span class="fc" id="L1103">        result.setUnit(TimeUnit.SECOND);</span>
<span class="fc" id="L1104">    }</span>

    /**
     * Gets minimum epoch interval between consecutive propagations or measurements.
     * Attempting to propagate results using Kalman filter or updating measurements
     * when intervals are less than this value, will be ignored.
     *
     * @return minimum epoch interval.
     */
    public Time getEpochIntervalAsTime() {
<span class="fc" id="L1114">        return new Time(mEpochInterval, TimeUnit.SECOND);</span>
    }

    /**
     * Sets minimum epoch interval between consecutive propagations or measurements.
     * Attempting to propagate results using Kalman filter or updating measurements
     * when intervals are less than this value, will be ignored.
     *
     * @param epochInterval minimum epoch interval.
     * @throws LockedException          if this estimator is already running.
     * @throws IllegalArgumentException if provided epoch interval is negative.
     */
    public void setEpochInterval(final Time epochInterval) throws LockedException {
<span class="fc" id="L1127">        final double epochIntervalSeconds = TimeConverter.convert(</span>
<span class="fc" id="L1128">                epochInterval.getValue().doubleValue(),</span>
<span class="fc" id="L1129">                epochInterval.getUnit(), TimeUnit.SECOND);</span>
<span class="fc" id="L1130">        setEpochInterval(epochIntervalSeconds);</span>
<span class="fc" id="L1131">    }</span>

    /**
     * Gets INS loosely coupled Kalman configuration parameters (usually
     * obtained through calibration).
     *
     * @param result instance where INS loosely coupled Kalman configuration
     *               parameters will be stored.
     * @return true if result instance is updated, false otherwise.
     */
    public boolean getConfig(INSLooselyCoupledKalmanConfig result) {
<span class="fc bfc" id="L1142" title="All 2 branches covered.">        if (mConfig != null) {</span>
<span class="fc" id="L1143">            result.copyFrom(mConfig);</span>
<span class="fc" id="L1144">            return true;</span>
        } else {
<span class="fc" id="L1146">            return false;</span>
        }
    }

    /**
     * Gets INS loosely coupled Kalman configuration parameters (usually
     * obtained through calibration).
     *
     * @return INS loosely coupled Kalman configuration parameters.
     */
    public INSLooselyCoupledKalmanConfig getConfig() {
<span class="fc" id="L1157">        return mConfig;</span>
    }

    /**
     * Sets INS loosely coupled Kalman configuration parameters (usually
     * obtained through calibration).
     *
     * @param config INS loosely coupled Kalman configuration parameters
     *               to be set.
     * @throws LockedException if this estimator is already running.
     */
    public void setConfig(final INSLooselyCoupledKalmanConfig config)
            throws LockedException {
<span class="fc bfc" id="L1170" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L1171">            throw new LockedException();</span>
        }

<span class="fc" id="L1174">        mConfig = new INSLooselyCoupledKalmanConfig(config);</span>
<span class="fc" id="L1175">    }</span>

    /**
     * Gets ECEF frame containing current or initial user position, velocity and
     * attitude.
     *
     * @param result instance where current ECEF frame will be stored.
     * @return true if provided result instance is updated, false otherwise.
     */
    public boolean getFrame(final ECEFFrame result) {
<span class="fc bfc" id="L1185" title="All 2 branches covered.">        if (mFrame != null) {</span>
<span class="fc" id="L1186">            mFrame.copyTo(result);</span>
<span class="fc" id="L1187">            return true;</span>
        } else {
<span class="fc" id="L1189">            return false;</span>
        }
    }

    /**
     * Gets ECEF frame containing current or initial user position, velocity and
     * attitude.
     *
     * @return ECEF frame containing current or initial user position, velocity
     * and attitude.
     */
    public ECEFFrame getFrame() {
<span class="fc bfc" id="L1201" title="All 2 branches covered.">        return mFrame != null ? new ECEFFrame(mFrame) : null;</span>
    }

    /**
     * Sets ECEF frame containing current or initial user position, velocity and
     * attitude.
     *
     * @param frame ECEF frame containing current or initial user position, velocity
     *              and attitude to be set.
     * @throws LockedException if this estimator is already running.
     */
    public void setFrame(final ECEFFrame frame) throws LockedException {
<span class="fc bfc" id="L1213" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L1214">            throw new LockedException();</span>
        }

<span class="fc" id="L1217">        mFrame = frame;</span>
<span class="fc" id="L1218">    }</span>

    /**
     * Gets initial INS loosely coupled Kalman configuration to set a proper
     * initial covariance matrix during the first Kalman filter propagation.
     * Once this estimator is initialized, covariance will be updated with new provided
     * INS measurements until convergence is reached.
     *
     * @param result instance where configuration data will be stored.
     * @return true if result instance was updated, false otherwise.
     */
    public boolean getInitialConfig(
            final INSLooselyCoupledKalmanInitializerConfig result) {
<span class="fc bfc" id="L1231" title="All 2 branches covered.">        if (mInitialConfig != null) {</span>
<span class="fc" id="L1232">            result.copyFrom(mInitialConfig);</span>
<span class="fc" id="L1233">            return true;</span>
        } else {
<span class="fc" id="L1235">            return false;</span>
        }
    }

    /**
     * Gets initial INS loosely coupled Kalman configuration to set a proper
     * initial covariance matrix during the first Kalman filter propagation.
     * Once this estimator is initialized, covariance will be updated with new provided
     * INS measurements until convergence is reached.
     *
     * @return initial INS loosely coupled Kalman configuration.
     */
    public INSLooselyCoupledKalmanInitializerConfig getInitialConfig() {
<span class="fc" id="L1248">        return mInitialConfig;</span>
    }

    /**
     * Sets initial INS loosely coupled Kalman configuration to set a proper
     * initial covariance matrix during the first Kalman filter propagation.
     * Once this estimator is initialized, covariance will be updated with new provided
     * INS measurements until convergence is reached.
     *
     * @param initialConfig initial configuration to be set.
     * @throws LockedException if this estimator is already running.
     */
    public void setInitialConfig(
            final INSLooselyCoupledKalmanInitializerConfig initialConfig)
            throws LockedException {

<span class="fc bfc" id="L1264" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L1265">            throw new LockedException();</span>
        }

<span class="fc" id="L1268">        mInitialConfig = initialConfig;</span>
<span class="fc" id="L1269">    }</span>

    /**
     * Gets last provided user kinematics containing applied specific force and
     * angular rates resolved in body axes.
     *
     * @return last provided user kinematics.
     */
    public BodyKinematics getKinematics() {
<span class="fc bfc" id="L1278" title="All 2 branches covered.">        return mKinematics != null ? new BodyKinematics(mKinematics) : null;</span>
    }

    /**
     * Gets last provided user kinematics containing applied specific force and
     * angular rates resolved in body axes.
     *
     * @param result instance where last provided body kinematics will be stored.
     * @return true if provided result instance was updated, false otherwise.
     */
    public boolean getKinematics(final BodyKinematics result) {
<span class="fc bfc" id="L1289" title="All 2 branches covered.">        if (mKinematics != null) {</span>
<span class="fc" id="L1290">            result.copyFrom(mKinematics);</span>
<span class="fc" id="L1291">            return true;</span>
        } else {
<span class="fc" id="L1293">            return false;</span>
        }
    }

    /**
     * Gets corrected kinematics which are the last provided user kinematics after
     * removal of the biases estimated by the Kalman filter.
     *
     * @return corrected kinematics.
     * @see #getKinematics()
     */
    public BodyKinematics getCorrectedKinematics() {
<span class="fc bfc" id="L1305" title="All 2 branches covered.">        return mCorrectedKinematics != null ?</span>
<span class="fc" id="L1306">                new BodyKinematics(mCorrectedKinematics) : null;</span>
    }

    /**
     * Gets corrected kinematics which are the las provided user kinematics after
     * removal of the biases estimated by the Kalman filter.
     *
     * @param result instance where corrected body kinematics will be stored.
     * @return true if provided result instance was updated, false otherwise.
     */
    public boolean getCorrectedKinematics(final BodyKinematics result) {
<span class="fc bfc" id="L1317" title="All 2 branches covered.">        if (mCorrectedKinematics != null) {</span>
<span class="fc" id="L1318">            result.copyFrom(mCorrectedKinematics);</span>
<span class="fc" id="L1319">            return true;</span>
        } else {
<span class="fc" id="L1321">            return false;</span>
        }
    }

    /**
     * Gets current Kalman filter state containing current INS estimation along
     * with Kalman filter covariance error matrix.
     *
     * @return current Kalman filter state containing current INS estimation
     * along with Kalman filter covariance error matrix.
     */
    public INSLooselyCoupledKalmanState getState() {
<span class="fc bfc" id="L1333" title="All 2 branches covered.">        return mState != null ? new INSLooselyCoupledKalmanState(mState) : null;</span>
    }

    /**
     * Gets current Kalman filter state containing current INS estimation along
     * with Kalman filter covariance error matrix.
     * This method does not update result instance if no state is available.
     *
     * @param result instance where state will be stored.
     * @return true if result state was updated, false otherwise.
     */
    public boolean getState(final INSLooselyCoupledKalmanState result) {
<span class="fc bfc" id="L1345" title="All 2 branches covered.">        if (mState != null) {</span>
<span class="fc" id="L1346">            result.copyFrom(mState);</span>
<span class="fc" id="L1347">            return true;</span>
        } else {
<span class="fc" id="L1349">            return false;</span>
        }
    }

    /**
     * Gets timestamp expressed in seconds since epoch time when Kalman filter state
     * was last propagated.
     *
     * @return timestamp expressed in seconds since epoch time when Kalman filter
     * state was last propagated.
     */
    public Double getLastStateTimestamp() {
<span class="fc" id="L1361">        return mLastStateTimestamp;</span>
    }

    /**
     * Gets timestamp since epoch time when Kalman filter state was last propagated.
     *
     * @param result instance where timestamp since epoch time when Kalman filter
     *               state was last propagated will be stored.
     * @return true if result instance is updated, false otherwise.
     */
    public boolean getLastStateTimestampAsTime(final Time result) {
<span class="fc bfc" id="L1372" title="All 2 branches covered.">        if (mLastStateTimestamp != null) {</span>
<span class="fc" id="L1373">            result.setValue(mLastStateTimestamp);</span>
<span class="fc" id="L1374">            result.setUnit(TimeUnit.SECOND);</span>
<span class="fc" id="L1375">            return true;</span>
        } else {
<span class="fc" id="L1377">            return false;</span>
        }
    }

    /**
     * Gets timestamp since epoch time when Kalman filter state was last propagated.
     *
     * @return timestamp since epoch time when Kalman filter state was last
     * propagated.
     */
    public Time getLastStateTimestampAsTime() {
<span class="fc bfc" id="L1388" title="All 2 branches covered.">        return mLastStateTimestamp != null ?</span>
<span class="fc" id="L1389">                new Time(mLastStateTimestamp, TimeUnit.SECOND) : null;</span>
    }

    /**
     * Indicates whether this estimator is running or not.
     *
     * @return true if this estimator is running, false otherwise.
     */
    public boolean isRunning() {
<span class="fc" id="L1398">        return mRunning;</span>
    }

    /**
     * Indicates whether this instance is ready to update state using available
     * IMU data (specific force and angular rates).
     *
     * @return true if ready, false otherwise.
     */
    public boolean isUpdateReady() {
<span class="fc bfc" id="L1408" title="All 2 branches covered.">        return mFrame != null;</span>
    }

    /**
     * Updates specific force and angular rate applied to the user's
     * body expressed in coordinates resolved along body-frame axes.
     *
     * @param kinematics kinematics applied to body (specific force and angular rate)
     *                   during las period of time. These measures are obtained from
     *                   an inertial unit (IMU).
     * @param timestamp  timestamp since epoch time when specific force and
     *                   angular rate values were updated.
     * @return true if body kinematics values were updated, false otherwise.
     * @throws LockedException   if this estimator is already running.
     * @throws NotReadyException if this estimator is not ready to be updated.
     * @throws INSException      if estimation fails due to numerical instabilities.
     */
    public boolean update(final BodyKinematics kinematics, final Time timestamp)
            throws LockedException, NotReadyException, INSException {
<span class="fc" id="L1427">        return update(kinematics, TimeConverter.convert(</span>
<span class="fc" id="L1428">                timestamp.getValue().doubleValue(), timestamp.getUnit(),</span>
                TimeUnit.SECOND));
    }

    /**
     * Updates specific force and angular rate applied to the user's
     * body expressed in coordinates resolved along body-frame axes.
     *
     * @param kinematics kinematics applied to body (specific force and angular rate)
     *                   during las period of time. These measures are obtained from
     *                   an inertial unit (IMU).
     * @param timestamp  timestamp expressed in seconds since epoch time when specific
     *                   force and angular rate values were updated.
     * @return true if body kinematics values were updated, false otherwise.
     * @throws LockedException   if this estimator is already running.
     * @throws NotReadyException if this estimator is not ready to be updated.
     * @throws INSException      if estimation fails due to numerical instabilities.
     */
    public boolean update(final BodyKinematics kinematics, final double timestamp)
            throws LockedException, NotReadyException, INSException {

<span class="fc bfc" id="L1449" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L1450">            throw new LockedException();</span>
        }

<span class="fc bfc" id="L1453" title="All 2 branches covered.">        if (!isUpdateReady()) {</span>
<span class="fc" id="L1454">            throw new NotReadyException();</span>
        }

<span class="fc bfc" id="L1457" title="All 2 branches covered.">        final double propagationInterval = mLastStateTimestamp != null ?</span>
<span class="fc" id="L1458">                timestamp - mLastStateTimestamp : 0.0;</span>
<span class="fc bfc" id="L1459" title="All 4 branches covered.">        if (mLastStateTimestamp != null &amp;&amp; propagationInterval &lt;= mEpochInterval) {</span>
<span class="fc" id="L1460">            return false;</span>
        }

        try {
<span class="fc" id="L1464">            mRunning = true;</span>

<span class="pc bpc" id="L1466" title="1 of 2 branches missed.">            if (mListener != null) {</span>
<span class="fc" id="L1467">                mListener.onUpdateStart(this);</span>
            }

<span class="fc bfc" id="L1470" title="All 2 branches covered.">            if (kinematics != null) {</span>
<span class="fc" id="L1471">                correctKinematics(kinematics);</span>
<span class="fc" id="L1472">                ECEFInertialNavigator.navigateECEF(propagationInterval, mFrame,</span>
                        mCorrectedKinematics, mFrame);
            }

<span class="fc" id="L1476">            mKinematics = kinematics;</span>

<span class="pc bpc" id="L1478" title="1 of 2 branches missed.">            if (mListener != null) {</span>
<span class="fc" id="L1479">                mListener.onUpdateEnd(this);</span>
            }

<span class="nc" id="L1482">        } catch (final InertialNavigatorException e) {</span>
<span class="nc" id="L1483">            throw new INSException(e);</span>
        } finally {
<span class="fc" id="L1485">            mRunning = false;</span>
        }

<span class="fc" id="L1488">        propagate(timestamp);</span>

<span class="fc" id="L1490">        return true;</span>
    }

    /**
     * Indicates whether this estimator is ready for state propagations.
     *
     * @return true if estimator is ready, false otherwise.
     */
    public boolean isPropagateReady() {
<span class="fc bfc" id="L1499" title="All 4 branches covered.">        return mConfig != null &amp;&amp; mFrame != null;</span>
    }

    /**
     * Propagates Kalman filter state held by this estimator at provided
     * timestamp.
     * Call to this method will be ignored if interval between provided timestamp
     * and last timestamp when Kalman filter was updated is less than epoch interval.
     *
     * @param timestamp timestamp since epoch to propagate state.
     * @return true if state was propagated, false otherwise.
     * @throws LockedException   if this estimator is already running.
     * @throws NotReadyException if estimator is not ready for measurements updates.
     * @throws INSException      if estimation fails due to numerical instabilities.
     */
    public boolean propagate(final Time timestamp)
            throws LockedException, NotReadyException, INSException {
<span class="fc" id="L1516">        return propagate(TimeConverter.convert(timestamp.getValue().doubleValue(),</span>
<span class="fc" id="L1517">                timestamp.getUnit(), TimeUnit.SECOND));</span>
    }

    /**
     * Propagates Kalman filter state held by this estimator at provided
     * timestamp.
     * Call to this method will be ignored if interval between provided timestamp
     * and last timestamp when Kalman filter was updated is less than epoch interval.
     *
     * @param timestamp timestamp expressed in seconds since epoch to propagate state.
     * @return true if state was propagated, false otherwise.
     * @throws LockedException   if this estimator is already running.
     * @throws NotReadyException if estimator is not ready for measurements updates.
     * @throws INSException      if estimation fails due to numerical instabilities.
     */
    public boolean propagate(final double timestamp)
            throws LockedException, NotReadyException, INSException {

<span class="fc bfc" id="L1535" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L1536">            throw new LockedException();</span>
        }

<span class="fc bfc" id="L1539" title="All 2 branches covered.">        if (!isPropagateReady()) {</span>
<span class="fc" id="L1540">            throw new NotReadyException();</span>
        }

<span class="fc bfc" id="L1543" title="All 2 branches covered.">        final double propagationInterval = mLastStateTimestamp != null ?</span>
<span class="fc" id="L1544">                timestamp - mLastStateTimestamp : 0.0;</span>
<span class="fc bfc" id="L1545" title="All 4 branches covered.">        if (mLastStateTimestamp != null &amp;&amp; propagationInterval &lt;= mEpochInterval) {</span>
<span class="fc" id="L1546">            return false;</span>
        }

        try {
<span class="fc" id="L1550">            mRunning = true;</span>

<span class="pc bpc" id="L1552" title="1 of 2 branches missed.">            if (mListener != null) {</span>
<span class="fc" id="L1553">                mListener.onPropagateStart(this);</span>
            }

<span class="fc bfc" id="L1556" title="All 2 branches covered.">            if (mState == null) {</span>
                // initialize state
<span class="fc" id="L1558">                initInitialConfig();</span>
<span class="fc" id="L1559">                final Matrix covariance = INSLooselyCoupledKalmanInitializer</span>
<span class="fc" id="L1560">                        .initialize(mInitialConfig);</span>

<span class="fc" id="L1562">                mState = new INSLooselyCoupledKalmanState();</span>
<span class="fc" id="L1563">                mState.setFrame(mFrame);</span>
<span class="fc" id="L1564">                mState.setCovariance(covariance);</span>
            }

<span class="fc bfc" id="L1567" title="All 2 branches covered.">            if (mKinematics != null) {</span>
<span class="fc" id="L1568">                correctKinematics(mKinematics);</span>
            }

            final double fx;
            final double fy;
            final double fz;
<span class="fc bfc" id="L1574" title="All 2 branches covered.">            if (mCorrectedKinematics != null) {</span>
<span class="fc" id="L1575">                fx = mCorrectedKinematics.getFx();</span>
<span class="fc" id="L1576">                fy = mCorrectedKinematics.getFy();</span>
<span class="fc" id="L1577">                fz = mCorrectedKinematics.getFz();</span>
            } else {
<span class="fc" id="L1579">                fx = 0.0;</span>
<span class="fc" id="L1580">                fy = 0.0;</span>
<span class="fc" id="L1581">                fz = 0.0;</span>
            }

<span class="fc" id="L1584">            final double x = mFrame.getX();</span>
<span class="fc" id="L1585">            final double y = mFrame.getY();</span>
<span class="fc" id="L1586">            final double z = mFrame.getZ();</span>
<span class="fc" id="L1587">            final double vx = mFrame.getVx();</span>
<span class="fc" id="L1588">            final double vy = mFrame.getVy();</span>
<span class="fc" id="L1589">            final double vz = mFrame.getVz();</span>
<span class="fc" id="L1590">            INSLooselyCoupledKalmanEpochEstimator.estimate(x, y, z, vx, vy, vz,</span>
                    propagationInterval, mState, fx, fy, fz, mConfig, mState);
<span class="fc" id="L1592">            mLastStateTimestamp = timestamp;</span>

<span class="fc" id="L1594">            mState.getFrame(mFrame);</span>

<span class="pc bpc" id="L1596" title="1 of 2 branches missed.">            if (mListener != null) {</span>
<span class="fc" id="L1597">                mListener.onPropagateEnd(this);</span>
            }

<span class="nc" id="L1600">        } catch (final AlgebraException e) {</span>
<span class="nc" id="L1601">            throw new INSException(e);</span>
        } finally {
<span class="fc" id="L1603">            mRunning = false;</span>
        }

<span class="fc" id="L1606">        return true;</span>
    }

    /**
     * Resets this estimator.
     *
     * @throws LockedException if this estimator is already running.
     */
    public void reset() throws LockedException {
<span class="fc bfc" id="L1615" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L1616">            throw new LockedException();</span>
        }

<span class="fc" id="L1619">        mRunning = true;</span>
<span class="fc" id="L1620">        mState = null;</span>
<span class="fc" id="L1621">        mLastStateTimestamp = null;</span>
<span class="fc" id="L1622">        mKinematics = null;</span>
<span class="fc" id="L1623">        mCorrectedKinematics = null;</span>
<span class="fc" id="L1624">        mFrame = null;</span>

<span class="pc bpc" id="L1626" title="1 of 2 branches missed.">        if (mListener != null) {</span>
<span class="fc" id="L1627">            mListener.onReset(this);</span>
        }

<span class="fc" id="L1630">        mRunning = false;</span>
<span class="fc" id="L1631">    }</span>

    /**
     * Initializes initial INS loosely coupled Kalman configuration to set
     * a proper initial covariance matrix.
     * This method makes no action if an initial configuration already exists.
     */
    private void initInitialConfig() {
<span class="pc bpc" id="L1639" title="1 of 2 branches missed.">        if (mInitialConfig == null) {</span>
<span class="nc" id="L1640">            mInitialConfig = new INSLooselyCoupledKalmanInitializerConfig();</span>
        }
<span class="fc" id="L1642">    }</span>

    /**
     * Corrects provided kinematics by taking into account currently estimated
     * specific force and angular rate biases.
     * This method stores the result into the variable member containing corrected
     * kinematics values.
     *
     * @param kinematics kinematics instance to be corrected.
     */
    private void correctKinematics(final BodyKinematics kinematics) {
<span class="fc bfc" id="L1653" title="All 2 branches covered.">        if (mCorrectedKinematics == null) {</span>
<span class="fc" id="L1654">            mCorrectedKinematics = new BodyKinematics();</span>
        }

        final double accelBiasX;
        final double accelBiasY;
        final double accelBiasZ;
        final double gyroBiasX;
        final double gyroBiasY;
        final double gyroBiasZ;
<span class="fc bfc" id="L1663" title="All 2 branches covered.">        if (mState != null) {</span>
<span class="fc" id="L1664">            accelBiasX = getValueOrZero(mState.getAccelerationBiasX());</span>
<span class="fc" id="L1665">            accelBiasY = getValueOrZero(mState.getAccelerationBiasY());</span>
<span class="fc" id="L1666">            accelBiasZ = getValueOrZero(mState.getAccelerationBiasZ());</span>
<span class="fc" id="L1667">            gyroBiasX = getValueOrZero(mState.getGyroBiasX());</span>
<span class="fc" id="L1668">            gyroBiasY = getValueOrZero(mState.getGyroBiasY());</span>
<span class="fc" id="L1669">            gyroBiasZ = getValueOrZero(mState.getGyroBiasZ());</span>
        } else {
<span class="fc" id="L1671">            accelBiasX = 0.0;</span>
<span class="fc" id="L1672">            accelBiasY = 0.0;</span>
<span class="fc" id="L1673">            accelBiasZ = 0.0;</span>
<span class="fc" id="L1674">            gyroBiasX = 0.0;</span>
<span class="fc" id="L1675">            gyroBiasY = 0.0;</span>
<span class="fc" id="L1676">            gyroBiasZ = 0.0;</span>
        }

<span class="fc" id="L1679">        final double fx = kinematics.getFx();</span>
<span class="fc" id="L1680">        final double fy = kinematics.getFy();</span>
<span class="fc" id="L1681">        final double fz = kinematics.getFz();</span>
<span class="fc" id="L1682">        final double angularRateX = kinematics.getAngularRateX();</span>
<span class="fc" id="L1683">        final double angularRateY = kinematics.getAngularRateY();</span>
<span class="fc" id="L1684">        final double angularRateZ = kinematics.getAngularRateZ();</span>

<span class="fc" id="L1686">        mCorrectedKinematics.setSpecificForceCoordinates(</span>
                fx - accelBiasX, fy - accelBiasY, fz - accelBiasZ);
<span class="fc" id="L1688">        mCorrectedKinematics.setAngularRateCoordinates(</span>
                angularRateX - gyroBiasX,
                angularRateY - gyroBiasY,
                angularRateZ - gyroBiasZ);
<span class="fc" id="L1692">    }</span>

    /**
     * Returns provided value if not infinity and not NaN.
     *
     * @param value value to be returned.
     * @return value or 0.0.
     */
    private double getValueOrZero(final double value) {
<span class="pc bpc" id="L1701" title="2 of 4 branches missed.">        if (Double.isNaN(value) || Double.isInfinite(value)) {</span>
<span class="nc" id="L1702">            return 0.0;</span>
        } else {
<span class="fc" id="L1704">            return value;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>