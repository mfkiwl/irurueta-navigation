<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>NEDtoECEFPositionVelocityConverter.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.irurueta:irurueta-navigation</a> &gt; <a href="index.source.html" class="el_package">com.irurueta.navigation.frames.converters</a> &gt; <span class="el_source">NEDtoECEFPositionVelocityConverter.java</span></div><h1>NEDtoECEFPositionVelocityConverter.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2019 Alberto Irurueta Carro (alberto@irurueta.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.irurueta.navigation.frames.converters;

import com.irurueta.algebra.Matrix;
import com.irurueta.algebra.WrongSizeException;
import com.irurueta.navigation.frames.CoordinateTransformation;
import com.irurueta.navigation.frames.NEDFrame;
import com.irurueta.navigation.geodesic.Constants;
import com.irurueta.navigation.inertial.ECEFPosition;
import com.irurueta.navigation.inertial.ECEFVelocity;
import com.irurueta.navigation.inertial.NEDPosition;
import com.irurueta.navigation.inertial.NEDVelocity;

/**
 * Converts curvilinear to cartesian position and velocity resolving
 * axes from NED to ECEF.
 * This implementation is based on the equations defined in &quot;Principles of GNSS, Inertial, and Multisensor
 * Integrated Navigation Systems, Second Edition&quot; and on the companion software available at:
 * https://github.com/ymjdz/MATLAB-Codes/blob/master/pv_NED_to_ECEF.m
 */
<span class="fc" id="L35">public class NEDtoECEFPositionVelocityConverter {</span>

    /**
     * The equatorial radius of WGS84 ellipsoid (6378137 m) defining Earth's shape.
     */
    public static final double EARTH_EQUATORIAL_RADIUS_WGS84 = Constants.EARTH_EQUATORIAL_RADIUS_WGS84;

    /**
     * Earth eccentricity as defined on the WGS84 ellipsoid.
     */
    public static final double EARTH_ECCENTRICITY = Constants.EARTH_ECCENTRICITY;

    /**
     * Converts curvilinear to cartesian position and velocity resolving axes
     * from NED to ECEF.
     *
     * @param sourcePosition      source position resolved on NED frame.
     * @param sourceVelocity      source velocity resolved on NED frame.
     * @param destinationPosition instance where position resolved on ECEF frame will
     *                            be stored.
     * @param destinationVelocity instance where velocity resolved on ECEF frame will
     *                            be stored.
     */
    public void convert(final NEDPosition sourcePosition,
                        final NEDVelocity sourceVelocity,
                        final ECEFPosition destinationPosition,
                        final ECEFVelocity destinationVelocity) {
<span class="fc" id="L62">        convertNEDtoECEF(sourcePosition, sourceVelocity, destinationPosition,</span>
                destinationVelocity);
<span class="fc" id="L64">    }</span>

    /**
     * Converts curvilinear to cartesian position and velocity resolving axes
     * from NED to ECEF.
     *
     * @param latitude            latitude expressed in radians (rad).
     * @param longitude           longitude expressed in radians (rad).
     * @param height              height expressed in meters (m).
     * @param vn                  north coordinate of velocity of body frame expressed
     *                            in meters per second (m/s).
     * @param ve                  east coordinate of velocity of body frame expressed
     *                            in meters per second (m/s).
     * @param vd                  down coordinate of velocity of body frame expressed
     *                            in meters per second (m/s).
     * @param destinationPosition instance where position resolved on ECEF frame will
     *                            be stored.
     * @param destinationVelocity instance where velocity resolved on ECEF frame will
     *                            be stored.
     */
    public void convert(final double latitude, final double longitude,
                        final double height, final double vn,
                        final double ve, final double vd,
                        final ECEFPosition destinationPosition,
                        final ECEFVelocity destinationVelocity) {
<span class="fc" id="L89">        convertNEDtoECEF(latitude, longitude, height, vn, ve, vd,</span>
                destinationPosition, destinationVelocity);
<span class="fc" id="L91">    }</span>

    /**
     * Converts curvilinear to cartesian position and velocity resolving axes
     * from NED to ECEF.
     *
     * @param sourcePosition      source position resolved on NED frame.
     * @param sourceVelocity      source velocity resolved on NED frame.
     * @param destinationPosition instance where position resolved on ECEF frame will
     *                            be stored.
     * @param destinationVelocity instance where velocity resolved on ECEF frame will
     *                            be stored.
     */
    public static void convertNEDtoECEF(final NEDPosition sourcePosition,
                                        final NEDVelocity sourceVelocity,
                                        final ECEFPosition destinationPosition,
                                        final ECEFVelocity destinationVelocity) {
<span class="fc" id="L108">        final double latitude = sourcePosition.getLatitude();</span>
<span class="fc" id="L109">        final double longitude = sourcePosition.getLongitude();</span>
<span class="fc" id="L110">        final double height = sourcePosition.getHeight();</span>

<span class="fc" id="L112">        final double vn = sourceVelocity.getVn();</span>
<span class="fc" id="L113">        final double ve = sourceVelocity.getVe();</span>
<span class="fc" id="L114">        final double vd = sourceVelocity.getVd();</span>

<span class="fc" id="L116">        convertNEDtoECEF(latitude, longitude, height, vn, ve, vd,</span>
                destinationPosition, destinationVelocity);
<span class="fc" id="L118">    }</span>

    /**
     * Converts curvilinear to cartesian position and velocity resolving axes
     * from NED to ECEF.
     *
     * @param latitude            latitude expressed in radians (rad).
     * @param longitude           longitude expressed in radians (rad).
     * @param height              height expressed in meters (m).
     * @param vn                  north coordinate of velocity of body frame expressed
     *                            in meters per second (m/s).
     * @param ve                  east coordinate of velocity of body frame expressed
     *                            in meters per second (m/s).
     * @param vd                  down coordinate of velocity of body frame expressed
     *                            in meters per second (m/s).
     * @param destinationPosition instance where position resolved on ECEF frame will
     *                            be stored.
     * @param destinationVelocity instance where velocity resolved on ECEF frame will
     *                            be stored.
     */
    public static void convertNEDtoECEF(final double latitude, final double longitude,
                                        final double height, final double vn,
                                        final double ve, final double vd,
                                        final ECEFPosition destinationPosition,
                                        final ECEFVelocity destinationVelocity) {
        try {

            // Calculate transverse radius of curvature using (2.105)
<span class="fc" id="L146">            final double re = EARTH_EQUATORIAL_RADIUS_WGS84</span>
<span class="fc" id="L147">                    / Math.sqrt(1.0 - Math.pow(EARTH_ECCENTRICITY * Math.sin(latitude), 2.0));</span>

            // Convert position using (2.112)
<span class="fc" id="L150">            final double cosLat = Math.cos(latitude);</span>
<span class="fc" id="L151">            final double sinLat = Math.sin(latitude);</span>
<span class="fc" id="L152">            final double cosLong = Math.cos(longitude);</span>
<span class="fc" id="L153">            final double sinLong = Math.sin(longitude);</span>

<span class="fc" id="L155">            final double x = (re + height) * cosLat * cosLong;</span>
<span class="fc" id="L156">            final double y = (re + height) * cosLat * sinLong;</span>
<span class="fc" id="L157">            final double z = ((1.0 - EARTH_ECCENTRICITY * EARTH_ECCENTRICITY) * re + height) * sinLat;</span>

<span class="fc" id="L159">            destinationPosition.setCoordinates(x, y, z);</span>

            // Calculate NED to ECEF coordinate transformation matrix
<span class="fc" id="L162">            final Matrix cne = CoordinateTransformation.nedToEcefMatrix(latitude, longitude);</span>

            // Transform velocity using (2.73)
<span class="fc" id="L165">            final Matrix vEbn = new Matrix(NEDFrame.NUM_VELOCITY_COORDINATES, 1);</span>
<span class="fc" id="L166">            vEbn.setElementAtIndex(0, vn);</span>
<span class="fc" id="L167">            vEbn.setElementAtIndex(1, ve);</span>
<span class="fc" id="L168">            vEbn.setElementAtIndex(2, vd);</span>

<span class="fc" id="L170">            final Matrix vEbe = cne.multiplyAndReturnNew(vEbn);</span>
<span class="fc" id="L171">            final double vx = vEbe.getElementAtIndex(0);</span>
<span class="fc" id="L172">            final double vy = vEbe.getElementAtIndex(1);</span>
<span class="fc" id="L173">            final double vz = vEbe.getElementAtIndex(2);</span>

<span class="fc" id="L175">            destinationVelocity.setCoordinates(vx, vy, vz);</span>
<span class="nc" id="L176">        } catch (WrongSizeException ignore) {</span>
            // never happens
<span class="fc" id="L178">        }</span>
<span class="fc" id="L179">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>