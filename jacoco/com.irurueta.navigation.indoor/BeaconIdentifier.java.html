<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>BeaconIdentifier.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.irurueta:irurueta-navigation</a> &gt; <a href="index.source.html" class="el_package">com.irurueta.navigation.indoor</a> &gt; <span class="el_source">BeaconIdentifier.java</span></div><h1>BeaconIdentifier.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2018 Alberto Irurueta Carro (alberto@irurueta.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.irurueta.navigation.indoor;

import java.io.Serializable;
import java.nio.ByteBuffer;
import java.nio.LongBuffer;
import java.util.Arrays;
import java.util.UUID;
import java.util.regex.Pattern;

/**
 * Encapsulates a beacon identifier of arbitrary byte length.
 * It can encapsulate an identifier that is a 16-byte UUID, or an integer.
 * Based on: https://github.com/AltBeacon/android-beacon-library/blob/master/src/main/java/org/altbeacon/beacon/Identifier.java
 */
@SuppressWarnings(&quot;WeakerAccess&quot;)
public class BeaconIdentifier implements Comparable&lt;BeaconIdentifier&gt;, Serializable {
    /**
     * Parses beacon identifiers in hexadecimal format.
     */
<span class="fc" id="L35">    private static final Pattern HEX_PATTERN = Pattern.compile(&quot;^0x[0-9A-Fa-f]*$&quot;);</span>

    /**
     * Parses beacon identifiers in hexadecimal format without prefix.
     */
<span class="fc" id="L40">    private static final Pattern HEX_PATTERN_NO_PREFIX = Pattern.compile(&quot;^[0-9A-Fa-f]*$&quot;);</span>

    /**
     * Parses beacon identifiers in decimal format.
     */
<span class="fc" id="L45">    private static final Pattern DECIMAL_PATTERN = Pattern.compile(&quot;^0|[1-9][0-9]*$&quot;);</span>

    /**
     * Parses beacon identifiers in UUID format.
     */
<span class="fc" id="L50">    private static final Pattern UUID_PATTERN = Pattern.compile(</span>
            &quot;^[0-9A-Fa-f]{8}-?[0-9A-Fa-f]{4}-?[0-9A-Fa-f]{4}-?[0-9A-Fa-f]{4}-?[0-9A-Fa-f]{12}$&quot;);

    /**
     * Maximum allowed identifier value from an integer.
     */
    private static final int MAX_INTEGER = 65535;

    /**
     * Contains digits to represent this instance in hexadecimal format.
     */
<span class="fc" id="L61">    private static final char[] HEX_DIGITS =</span>
            {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};

    /**
     * Internal value holding a beacon identifier as a byte array.
     */
    private byte[] mValue;


    /**
     * Empty constructor to prevent deserialization issues.
     */
<span class="fc" id="L73">    protected BeaconIdentifier() {</span>
<span class="fc" id="L74">    }</span>

    /**
     * Creates a nw instance of a beacon identifier.
     *
     * @param value value to use.
     * @throws NullPointerException if provided value is null.
     */
<span class="fc" id="L82">    protected BeaconIdentifier(final byte[] value) {</span>
<span class="fc bfc" id="L83" title="All 2 branches covered.">        if (value == null) {</span>
<span class="fc" id="L84">            throw new NullPointerException(</span>
                    &quot;Identifiers cannot be constructed from null pointers but \&quot;value\&quot; is null.&quot;);
        }

<span class="fc" id="L88">        mValue = value;</span>
<span class="fc" id="L89">    }</span>

    /**
     * Takes the passed string and tries to figure out what format it is in.
     * Then turns the string into plain bytes and constructs an identifier.
     * &lt;p&gt;
     * This method parses UUIDs without dashes for compatibility (although this is not a standard behaviour).
     * &lt;p&gt;
     * Allowed formats:
     * &lt;ul&gt;
     *   &lt;li&gt;UUID: 2F234454-CF6D-4A0F-ADF2-F4911BA9FFA6 (16 bytes)&lt;/li&gt;
     *   &lt;li&gt;Hexadecimal: 0x000000000003 (variable length)&lt;/li&gt;
     *   &lt;li&gt;Decimal: 1337 (2 bytes)&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @param stringValue string to be parsed.
     * @return an identifier representinf the specified value.
     * @throws NullPointerException     if string value is null.
     * @throws IllegalArgumentException if parsing fails for some other reason (invalid format, etc).
     * @see &lt;a href=&quot;https://www.ietf.org/rfc/rfc4122.txt&quot;&gt;RFC 4122 on UUIDs&lt;/a&gt;
     */
    public static BeaconIdentifier parse(final String stringValue) {
<span class="fc" id="L111">        return parse(stringValue, -1);</span>
    }

    /**
     * Variant of the parse method that allows specifying the byte length of the identifier.
     *
     * @param stringValue       value to be parsed.
     * @param desiredByteLength requested number of bytes to hold the identifier or -1 if not specified.
     * @return the parsed identifier.
     * @throws NullPointerException     if string value is null.
     * @throws IllegalArgumentException if parsing fails for some other reason (invalid format, etc).
     */
    public static BeaconIdentifier parse(
            final String stringValue, final int desiredByteLength) {
<span class="fc bfc" id="L125" title="All 2 branches covered.">        if (stringValue == null) {</span>
<span class="fc" id="L126">            throw new NullPointerException(</span>
                    &quot;Identifiers cannot be constructed from null pointers but \&quot;stringValue\&quot; is null.&quot;);
        }

<span class="fc bfc" id="L130" title="All 2 branches covered.">        if (HEX_PATTERN.matcher(stringValue).matches()) {</span>
            //parse hexadecimal format
<span class="fc" id="L132">            return parseHex(stringValue.substring(2), desiredByteLength);</span>
        }

<span class="fc bfc" id="L135" title="All 2 branches covered.">        if (UUID_PATTERN.matcher(stringValue).matches()) {</span>
            //parse UUID format
<span class="fc" id="L137">            return parseHex(stringValue.replace(&quot;-&quot;, &quot;&quot;), desiredByteLength);</span>
        }

<span class="fc bfc" id="L140" title="All 2 branches covered.">        if (DECIMAL_PATTERN.matcher(stringValue).matches()) {</span>
            //parse decimal format
<span class="fc" id="L142">            int value = Integer.parseInt(stringValue);</span>
<span class="pc bpc" id="L143" title="1 of 4 branches missed.">            if (desiredByteLength &lt;= 0 || desiredByteLength == 2) {</span>
<span class="fc" id="L144">                return fromInt(value);</span>
            } else {
<span class="fc" id="L146">                return fromLong(value, desiredByteLength);</span>
            }
        }

<span class="fc bfc" id="L150" title="All 2 branches covered.">        if (HEX_PATTERN_NO_PREFIX.matcher(stringValue).matches()) {</span>
            //parse hexadecimal format without prefix
<span class="fc" id="L152">            return parseHex(stringValue, desiredByteLength);</span>
        }

<span class="fc" id="L155">        throw new IllegalArgumentException(&quot;Unable to parse identifier&quot;);</span>
    }

    /**
     * Creates an identifier backed by an array of length desiredByteLength.
     *
     * @param longValue         a long to put into the identifier.
     * @param desiredByteLength how many bytes to make the identifier.
     * @return the parsed identifier.
     * @throws IllegalArgumentException if desired number of bytes is negative.
     */
    public static BeaconIdentifier fromLong(
            long longValue, final int desiredByteLength) {
<span class="fc bfc" id="L168" title="All 2 branches covered.">        if (desiredByteLength &lt; 0) {</span>
<span class="fc" id="L169">            throw new IllegalArgumentException(&quot;identifier length must be &gt; 0&quot;);</span>
        }
<span class="fc" id="L171">        final byte[] newValue = new byte[desiredByteLength];</span>
<span class="fc bfc" id="L172" title="All 2 branches covered.">        for (int i = desiredByteLength - 1; i &gt;= 0; i--) {</span>
<span class="fc" id="L173">            newValue[i] = (byte) (longValue &amp; 0xff);</span>
<span class="fc" id="L174">            longValue = longValue &gt;&gt; 8;</span>
        }
<span class="fc" id="L176">        return new BeaconIdentifier(newValue);</span>
    }

    /**
     * Creates an identifier backed by a two byte array (big endia).
     *
     * @param intValue an integer between 0 and 65535 (inclusive).
     * @return an identifier with the specified value.
     * @throws IllegalArgumentException if provided value is out of valid range (from 0 to 65535).
     */
    public static BeaconIdentifier fromInt(final int intValue) {
<span class="fc bfc" id="L187" title="All 4 branches covered.">        if (intValue &lt; 0 || intValue &gt; MAX_INTEGER) {</span>
<span class="fc" id="L188">            throw new IllegalArgumentException(</span>
                    &quot;Identifiers can only be constructed from integers between 0 and &quot; + MAX_INTEGER + &quot; (inclusive).&quot;);
        }

<span class="fc" id="L192">        final byte[] newValue = new byte[2];</span>

<span class="fc" id="L194">        newValue[0] = (byte) (intValue &gt;&gt; 8);</span>
<span class="fc" id="L195">        newValue[1] = (byte) (intValue);</span>

<span class="fc" id="L197">        return new BeaconIdentifier(newValue);</span>
    }

    /**
     * Creates an identifier from the specified byte array.
     *
     * @param bytes        array to copy from.
     * @param start        the start index, inclusive.
     * @param end          the end index, exclusive.
     * @param littleEndian whether the bytes are ordered in little endian.
     * @return a new identifier.
     * @throws NullPointerException           if bytes is null.
     * @throws ArrayIndexOutOfBoundsException if start or end are outside the bounds of the array.
     * @throws IllegalArgumentException       start is larger than end.
     */
    public static BeaconIdentifier fromBytes(
            final byte[] bytes, final int start, final int end,
            final boolean littleEndian) {
<span class="fc bfc" id="L215" title="All 2 branches covered.">        if (bytes == null) {</span>
<span class="fc" id="L216">            throw new NullPointerException(</span>
                    &quot;Identifiers cannot be constructed from null pointers but \&quot;bytes\&quot; is null.&quot;);
        }
<span class="pc bpc" id="L219" title="1 of 4 branches missed.">        if (start &lt; 0 || start &gt; bytes.length) {</span>
<span class="fc" id="L220">            throw new ArrayIndexOutOfBoundsException(&quot;start &lt; 0 || start &gt; bytes.length&quot;);</span>
        }
<span class="fc bfc" id="L222" title="All 2 branches covered.">        if (end &gt; bytes.length) {</span>
<span class="fc" id="L223">            throw new ArrayIndexOutOfBoundsException(&quot;end &gt; bytes.length&quot;);</span>
        }
<span class="fc bfc" id="L225" title="All 2 branches covered.">        if (start &gt; end) {</span>
<span class="fc" id="L226">            throw new IllegalArgumentException(&quot;start &gt; end&quot;);</span>
        }

<span class="fc" id="L229">        final byte[] byteRange = Arrays.copyOfRange(bytes, start, end);</span>
<span class="fc bfc" id="L230" title="All 2 branches covered.">        if (littleEndian) {</span>
<span class="fc" id="L231">            reverseArray(byteRange);</span>
        }
<span class="fc" id="L233">        return new BeaconIdentifier(byteRange);</span>
    }

    /**
     * Transforms a {@link UUID} into an identifier.
     * No mangling with strings, only the underlying bytes of the
     * UUID are used so this is fast and stable.
     *
     * @param uuid UUID to create identifier from.
     * @return a new identifier.
     */
    public static BeaconIdentifier fromUuid(final UUID uuid) {
<span class="fc" id="L245">        final ByteBuffer buf = ByteBuffer.allocate(16);</span>
<span class="fc" id="L246">        buf.putLong(uuid.getMostSignificantBits());</span>
<span class="fc" id="L247">        buf.putLong(uuid.getLeastSignificantBits());</span>
<span class="fc" id="L248">        return new BeaconIdentifier(buf.array());</span>
    }

    /**
     * Represents the value as a String. The output varies based on the length of the value.
     * &lt;ul&gt;&lt;li&gt;When the value is 2 bytes long: decimal, for example 6536.
     * &lt;li&gt;When the value is 16 bytes long: uuid, for example 2f234454-cf6d-4a0f-adf2-f4911ba9ffa6
     * &lt;li&gt;Else: hexadecimal prefixed with &lt;code&gt;0x&lt;/code&gt;, for example 0x0012ab&lt;/ul&gt;
     *
     * @return string representation of the current value.
     */
    @Override
    public String toString() {
        // Note:  the toString() method is also used for serialization and deserialization.  So
        // toString() and parse() must always return objects that return true when you call equals()
<span class="fc bfc" id="L263" title="All 2 branches covered.">        if (mValue == null) {</span>
<span class="fc" id="L264">            return super.toString();</span>
        }

<span class="fc bfc" id="L267" title="All 2 branches covered.">        if (mValue.length == 2) {</span>
<span class="fc" id="L268">            return Integer.toString(toInt());</span>
        }
<span class="fc bfc" id="L270" title="All 2 branches covered.">        if (mValue.length == 16) {</span>
<span class="fc" id="L271">            return toUuid().toString();</span>
        }
<span class="fc" id="L273">        return toHexString();</span>
    }

    /**
     * Represents the value as an &lt;code&gt;int&lt;/code&gt;.
     *
     * @return value represented as int.
     * @throws UnsupportedOperationException when value length is longer than 2.
     */
    public int toInt() {
<span class="fc bfc" id="L283" title="All 2 branches covered.">        if (mValue == null) {</span>
<span class="fc" id="L284">            return 0;</span>
        }

<span class="fc bfc" id="L287" title="All 2 branches covered.">        if (mValue.length &gt; 2) {</span>
<span class="fc" id="L288">            throw new UnsupportedOperationException(&quot;Only supported for Identifiers with max byte length of 2&quot;);</span>
        }
<span class="fc" id="L290">        int result = 0;</span>

<span class="fc bfc" id="L292" title="All 2 branches covered.">        for (int i = 0; i &lt; mValue.length; i++) {</span>
<span class="fc" id="L293">            result |= (mValue[i] &amp; 0xFF) &lt;&lt; ((mValue.length - i - 1) * 8);</span>
        }

<span class="fc" id="L296">        return result;</span>
    }

    /**
     * Converts identifier to a byte array.
     *
     * @param bigEndian true if bytes are MSB first.
     * @return a new byte array with a copy of the value.
     */
    public byte[] toByteArrayOfSpecifiedEndianness(final boolean bigEndian) {
<span class="fc bfc" id="L306" title="All 2 branches covered.">        if (mValue == null) {</span>
<span class="fc" id="L307">            return null;</span>
        }

<span class="fc" id="L310">        final byte[] copy = Arrays.copyOf(mValue, mValue.length);</span>

<span class="fc bfc" id="L312" title="All 2 branches covered.">        if (!bigEndian) {</span>
<span class="fc" id="L313">            reverseArray(copy);</span>
        }

<span class="fc" id="L316">        return copy;</span>
    }

    /**
     * Returns the byte length of this identifier.
     *
     * @return length of identifier.
     */
    public int getByteCount() {
<span class="fc bfc" id="L325" title="All 2 branches covered.">        return mValue != null ? mValue.length : 0;</span>
    }

    /**
     * Represents the vlaue as a hexadecimal String. The String is prefixed with &lt;code&gt;0x&lt;/code&gt;. For example
     * 0x0034ab.
     *
     * @return value as hexadecimal String.
     */
    public String toHexString() {
<span class="fc bfc" id="L335" title="All 2 branches covered.">        if (mValue == null) {</span>
<span class="fc" id="L336">            return null;</span>
        }

<span class="fc" id="L339">        final int l = mValue.length;</span>
<span class="fc" id="L340">        final char[] out = new char[l * 2 + 2];</span>
<span class="fc" id="L341">        out[0] = '0';</span>
<span class="fc" id="L342">        out[1] = 'x';</span>
<span class="fc bfc" id="L343" title="All 2 branches covered.">        for (int i = 0, j = 2; i &lt; l; i++) {</span>
<span class="fc" id="L344">            out[j++] = HEX_DIGITS[(0xF0 &amp; mValue[i]) &gt;&gt;&gt; 4];</span>
<span class="fc" id="L345">            out[j++] = HEX_DIGITS[0x0F &amp; mValue[i]];</span>
        }
<span class="fc" id="L347">        return new String(out);</span>
    }

    /**
     * Gives you the identifier as a UUID if possible.
     *
     * @return the identifier as a UUID.
     * @throws UnsupportedOperationException if conversion to UUID fails.
     */
    public UUID toUuid() {
<span class="fc bfc" id="L357" title="All 2 branches covered.">        if (mValue == null) {</span>
<span class="fc" id="L358">            return null;</span>
        }

<span class="fc bfc" id="L361" title="All 2 branches covered.">        if (mValue.length != 16) {</span>
<span class="fc" id="L362">            throw new UnsupportedOperationException(&quot;Only Identifiers backed by a byte array with length of exactly 16 can be UUIDs.&quot;);</span>
        }
<span class="fc" id="L364">        final LongBuffer buf = ByteBuffer.wrap(mValue).asLongBuffer();</span>
<span class="fc" id="L365">        return new UUID(buf.get(), buf.get());</span>
    }

    /**
     * Gives you the byte array backing this identifier. Note that identifiers are immutable,
     * so changing that the returned array will not result in a changed identifier.
     *
     * @return a deep copy of the data backing this identifier.
     */
    public byte[] toByteArray() {
<span class="fc bfc" id="L375" title="All 2 branches covered.">        return mValue != null ? mValue.clone() : null;</span>
    }

    /**
     * Computes hash code for this instance.
     *
     * @return this instance hash code.
     */
    @Override
    public int hashCode() {
<span class="fc bfc" id="L385" title="All 2 branches covered.">        return mValue != null ? Arrays.hashCode(mValue) : 0;</span>
    }

    /**
     * Returns whether both identifiers contain equal value.
     * This is the case when the value is the same and has the same length.
     *
     * @param that object to compare to.
     * @return whether that equals this.
     */
    @Override
    public boolean equals(final Object that) {
<span class="fc bfc" id="L397" title="All 2 branches covered.">        if (!(that instanceof BeaconIdentifier)) {</span>
<span class="fc" id="L398">            return false;</span>
        }
<span class="fc" id="L400">        final BeaconIdentifier thatIdentifier = (BeaconIdentifier) that;</span>
<span class="fc" id="L401">        return Arrays.equals(mValue, thatIdentifier.mValue);</span>
    }

    /**
     * Compares two identifiers.
     * When the identifiers don't have the same length, the identifier having the shortest
     * array is considered smaller than the other.
     *
     * @param that the other identifier.
     * @return 0 if both identifiers are equal. Otherwise returns -1 or 1 depending on
     * which is bigger than th other.
     * @see Comparable#compareTo(Object)
     */
    @Override
    public int compareTo(final BeaconIdentifier that) {
<span class="fc bfc" id="L416" title="All 2 branches covered.">        if (mValue.length != that.mValue.length) {</span>
<span class="fc bfc" id="L417" title="All 2 branches covered.">            return mValue.length &lt; that.mValue.length ? -1 : 1;</span>
        }
<span class="fc bfc" id="L419" title="All 2 branches covered.">        for (int i = 0; i &lt; mValue.length; i++) {</span>
<span class="fc bfc" id="L420" title="All 2 branches covered.">            if (mValue[i] != that.mValue[i]) {</span>
<span class="fc bfc" id="L421" title="All 2 branches covered.">                return mValue[i] &lt; that.mValue[i] ? -1 : 1;</span>
            }
        }
<span class="fc" id="L424">        return 0;</span>
    }

    /**
     * Reverses provided array.
     *
     * @param bytes array to be reversed.
     */
    private static void reverseArray(final byte[] bytes) {
<span class="fc bfc" id="L433" title="All 2 branches covered.">        for (int i = 0; i &lt; bytes.length / 2; i++) {</span>
<span class="fc" id="L434">            final int mirroredIndex = bytes.length - i - 1;</span>
<span class="fc" id="L435">            final byte tmp = bytes[i];</span>
<span class="fc" id="L436">            bytes[i] = bytes[mirroredIndex];</span>
<span class="fc" id="L437">            bytes[mirroredIndex] = tmp;</span>
        }
<span class="fc" id="L439">    }</span>

    /**
     * Parses a string containing a beacon identifier in hexadecimal format.
     *
     * @param identifierString  string to be parsed.
     * @param desiredByteLength length of byte array to create to hold provided value.
     * @return the parsed identifier.
     */
    private static BeaconIdentifier parseHex(
            final String identifierString, final int desiredByteLength) {
<span class="pc bpc" id="L450" title="1 of 2 branches missed.">        String str = identifierString.length() % 2 == 0 ? &quot;&quot; : &quot;0&quot;;</span>
<span class="fc" id="L451">        str += identifierString.toUpperCase();</span>
<span class="fc" id="L452">        int len = str.length();</span>

<span class="fc bfc" id="L454" title="All 4 branches covered.">        if (desiredByteLength &gt; 0 &amp;&amp; desiredByteLength &lt; len / 2) {</span>
<span class="fc" id="L455">            str = str.substring(len - desiredByteLength * 2);</span>
<span class="fc" id="L456">            len = str.length();</span>
        }
<span class="fc bfc" id="L458" title="All 4 branches covered.">        if (desiredByteLength &gt; 0 &amp;&amp; desiredByteLength &gt; len / 2) {</span>
<span class="fc" id="L459">            final int extraCharsToAdd = desiredByteLength * 2 - len;</span>
<span class="fc" id="L460">            final StringBuilder sb = new StringBuilder();</span>
<span class="fc bfc" id="L461" title="All 2 branches covered.">            while (sb.length() &lt; extraCharsToAdd) {</span>
<span class="fc" id="L462">                sb.append(&quot;0&quot;);</span>
            }
<span class="fc" id="L464">            str = sb.toString() + str;</span>
<span class="fc" id="L465">            len = str.length();</span>
        }

<span class="fc" id="L468">        final byte[] result = new byte[len / 2];</span>
<span class="fc bfc" id="L469" title="All 2 branches covered.">        for (int i = 0; i &lt; result.length; i++) {</span>
<span class="fc" id="L470">            result[i] = (byte) (Integer.parseInt(str.substring(i * 2, i * 2 + 2), 16) &amp; 0xFF);</span>
        }
<span class="fc" id="L472">        return new BeaconIdentifier(result);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>