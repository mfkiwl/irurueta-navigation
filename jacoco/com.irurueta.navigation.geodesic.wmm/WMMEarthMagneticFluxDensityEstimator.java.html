<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>WMMEarthMagneticFluxDensityEstimator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.irurueta:irurueta-navigation</a> &gt; <a href="index.source.html" class="el_package">com.irurueta.navigation.geodesic.wmm</a> &gt; <span class="el_source">WMMEarthMagneticFluxDensityEstimator.java</span></div><h1>WMMEarthMagneticFluxDensityEstimator.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2020 Alberto Irurueta Carro (alberto@irurueta.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.irurueta.navigation.geodesic.wmm;

import com.irurueta.navigation.geodesic.Constants;
import com.irurueta.navigation.inertial.NEDMagneticFluxDensity;
import com.irurueta.navigation.inertial.NEDPosition;
import com.irurueta.units.Angle;
import com.irurueta.units.AngleConverter;
import com.irurueta.units.AngleUnit;
import com.irurueta.units.Distance;
import com.irurueta.units.DistanceConverter;
import com.irurueta.units.DistanceUnit;

import java.io.IOException;
import java.util.Calendar;
import java.util.Date;
import java.util.GregorianCalendar;

/**
 * Estimates Earth magnetic flux density  resolved around NED frame at
 * a given Earth location.
 */
public class WMMEarthMagneticFluxDensityEstimator {

    /**
     * Guaranteed accuracy of estimated angles by the WMM during
     * the valid timespan of a model.
     * Accuracy is expressed in degrees and refers to estimated
     * declination and dip angles.
     */
    public static final double ANGLE_ACCURACY_DEGREES = 5e-3;

    /**
     * Guaranteed accuracy of estimated angles by the WMM during
     * the valid timespan of a model.
     * Accuracy is expressed in radians and refers to estimated
     * declination and dip angles.
     */
<span class="fc" id="L53">    public static final double ANGLE_ACCURACY_RADIANS =</span>
<span class="fc" id="L54">            Math.toRadians(ANGLE_ACCURACY_DEGREES);</span>

    /**
     * Guaranteed accuracy of estimated magnetic flux density
     * values by the WMM during the valid timespan of a model.
     * This value refers to intensity norm, vertical intensity,
     * horizontal intensity, north intensity and east intensity.
     */
    public static final double INTENSITY_ACCURACY = 5e-2;

    /**
     * Number of coefficients.
     */
    private static final int N = WorldMagneticModel.N;

    /**
     * Coefficients file.
     */
    private static final String COEFFICIENTS_FILE = &quot;wmm.cof&quot;;

    /**
     * Mean radius of IAU-66 ellipsoid expressed in Km.
     */
    private static final double RE_KM = 6371.2;

    /**
     * Converts to nanos.
     */
    private static final double FROM_NANO = 1e-9;

    /**
     * Time value used in previous calculation.
     * This is used to save on calculation time if some
     * inputs don't change.
     * Old time is expressed in decimal years.
     */
    private Double mOldTime;

    /**
     * Geodetic height (a.k.a. altitude) value used in previous
     * calculation.
     * This is used to save on calculation time if some
     * inputs don't change.
     * Old height is expressed in Kilometers (Km).
     */
    private Double mOldHeight;

    /**
     * Old geodetic latitude value used in previous
     * calculation.
     * This is used to save on calculation time if some
     * inputs don't change.
     * Old latitude is expressed in degrees (deg).
     */
    private Double mOldLatitude;

    /**
     * Old geodetic longitude value used in previous
     * calculation.
     * This is used to save on calculation time if some
     * inputs don't change.
     * Old longitude is expressed in degrees (deg).
     */
    private Double mOldLongitude;

    /**
     * Geomagnetic declination in degrees.
     * East is positive, West is negative.
     * (The negative of variation).
     */
    private double mDec;

    /**
     * Geomagnetic inclination in degrees.
     * Down is positive, up is negative.
     */
    private double mDip;

    /**
     * Geomagnetic total intensity expressed in nano Teslas (nT)
     */
    private double mTi;

    /**
     * A World Magnetic Model containing all required coefficients.
     */
    private final WorldMagneticModel mModel;

    /**
     * The time adjusted geomagnetic gauss coefficients (nt).
     */
<span class="fc" id="L145">    private final double[][] mTc = new double[N][N];</span>

    /**
     * The theta derivative of p(n,m) (unnormalized).
     */
<span class="fc" id="L150">    private final double[][] mDp = new double[N][N];</span>

    /**
     * The sine of (m*spherical coord. longitude).
     */
<span class="fc" id="L155">    private final double[] mSp = new double[N];</span>

    /**
     * The cosine of (m*spherical coord. longitude).
     */
<span class="fc" id="L160">    private final double[] mCp = new double[N];</span>

    /**
     * The associated Legendre polynomials for m=1 (unnormalized).
     */
<span class="fc" id="L165">    private final double[] mPp = new double[N];</span>

    /**
     * The north-south field intensity expressed in nano Teslas (nT).
     */
    private double mBx;

    /**
     * The east-west field intensity expressed in nano Teslas (nT).
     */
    private double mBy;

    /**
     * The vertical field intensity positive downward expressed
     * in nano Teslas (nT)
     */
    private double mBz;

    /**
     * The horizontal field intensity expressed in nano Teslas (nT)
     */
    private double mBh;

    /**
     * Semi-major axis of WGS-84 ellipsoid, in Km, squared.
     */
    private final double mA2;

    /**
     * Semi-minor axis of WGS-84 ellipsoid, in Km, squared.
     */
    private final double mB2;

    /**
     * The difference between the squared semi axes.
     * c2 = a2 - b2
     */
    private final double mC2;

    /**
     * {@link #mA2} squared.
     */
    private final double mA4;

    /**
     * The difference between a4 and b4
     * c4 = a4 - b4
     */
    private final double mC4;

    // Below: internal values being reused. These values are only
    // recalculated if the height (altitude) changes.

    private double mR;

    private double mCa;

    private double mSa;

    private double mCt;

    private double mSt;

    /**
     * Constructor.
     *
     * @throws IOException if an I/O error occurs while loading
     *                     model coefficients.
     */
    public WMMEarthMagneticFluxDensityEstimator()
            throws IOException {
<span class="fc" id="L236">        this(WMMLoader.loadFromResource(COEFFICIENTS_FILE));</span>
<span class="fc" id="L237">    }</span>

    /**
     * Constructor.
     *
     * @param model a World Magnetic Model.
     * @throws NullPointerException if provided model is null.
     */
    public WMMEarthMagneticFluxDensityEstimator(
<span class="fc" id="L246">            final WorldMagneticModel model) {</span>
<span class="fc bfc" id="L247" title="All 2 branches covered.">        if (model == null) {</span>
<span class="fc" id="L248">            throw new NullPointerException();</span>
        }
<span class="fc" id="L250">        mModel = model;</span>
<span class="fc" id="L251">        mSp[0] = 0.0;</span>
<span class="fc" id="L252">        mCp[0] = 1.0;</span>
<span class="fc" id="L253">        mPp[0] = 1.0;</span>

        // semi-major axis of WGS-84 ellipsoid, in Km (6378.137 Km).
<span class="fc" id="L256">        final double a = DistanceConverter.convert(</span>
                Constants.EARTH_EQUATORIAL_RADIUS_WGS84,
                DistanceUnit.METER, DistanceUnit.KILOMETER);

        // semi-minor axis of WGS-84 ellipsoid, in Km (6356.7523142 Km).
<span class="fc" id="L261">        final double b = DistanceConverter.convert(</span>
                Constants.EARTH_POLAR_RADIUS_WGS84,
                DistanceUnit.METER, DistanceUnit.KILOMETER);
<span class="fc" id="L264">        mA2 = a * a;</span>
<span class="fc" id="L265">        mB2 = b * b;</span>
<span class="fc" id="L266">        mC2 = mA2 - mB2;</span>
<span class="fc" id="L267">        mA4 = mA2 * mA2;</span>

<span class="fc" id="L269">        final double b4 = mB2 * mB2;</span>
<span class="fc" id="L270">        mC4 = mA4 - b4;</span>
<span class="fc" id="L271">    }</span>

    /**
     * Returns the declination from the Department of Defense geomagnetic
     * model and data, in radians.
     * The magnetic heading + declination is the true heading of a device
     * in terms of geographical north pole.
     * This method uses default altitude (0.0 - mean sea level) and time
     * (half way through the valid 5 year period of the model).
     *
     * @param latitude  latitude expressed in radians.
     * @param longitude longitude expressed in radians.
     * @return magnetic field declination expressed in radians.
     */
    public double getDeclination(
            final double latitude, final double longitude) {
<span class="fc" id="L287">        final double defaultTime = mModel.epoch</span>
                + WorldMagneticModel.LIFESPAN / 2.0;
<span class="fc" id="L289">        calcGeoMag(Math.toDegrees(latitude), Math.toDegrees(longitude),</span>
                0.0, defaultTime);
<span class="fc" id="L291">        return Math.toRadians(mDec);</span>
    }

    /**
     * Returns the declination from the Department of Defense geomagnetic
     * model and data, in radians.
     * The magnetic heading + declination is the true heading of a device
     * in terms of geographical north pole.
     * This method uses default altitude (0.0 - mean sea level) and time
     * (half way through the valid 5 year period of the model).
     *
     * @param latitude  latitude angle.
     * @param longitude longitude angle.
     * @return magnetic field declination expressed in radians.
     */
    public double getDeclination(
            final Angle latitude, final Angle longitude) {
<span class="fc" id="L308">        return getDeclination(convertAngle(latitude),</span>
<span class="fc" id="L309">                convertAngle(longitude));</span>
    }

    /**
     * Returns the declination from the Department of Defense geomagnetic
     * model and data, in radians.
     * The magnetic heading + declination is the true heading of a device
     * in terms of geographical north pole.
     * This method uses default altitude (0.0 - mean sea level) and time
     * (half way through the valid 5 year period of the model).
     *
     * @param latitude  latitude expressed in radians.
     * @param longitude longitude expressed in radians.
     * @param result    instance where magnetic field declination will be
     *                  stored.
     */
    public void getDeclinationAsAngle(
            final double latitude, final double longitude,
            final Angle result) {
<span class="fc" id="L328">        result.setUnit(AngleUnit.RADIANS);</span>
<span class="fc" id="L329">        result.setValue(getDeclination(latitude, longitude));</span>
<span class="fc" id="L330">    }</span>

    /**
     * Returns the declination from the Department of Defense geomagnetic
     * model and data, in radians.
     * The magnetic heading + declination is the true heading of a device
     * in terms of geographical north pole.
     * This method uses default altitude (0.0 - mean sea level) and time
     * (half way through the valid 5 year period of the model).
     *
     * @param latitude  latitude angle.
     * @param longitude longitude angle.
     * @return magnetic field declination.
     */
    public Angle getDeclinationAsAngle(
            final double latitude, final double longitude) {
<span class="fc" id="L346">        return new Angle(getDeclination(latitude, longitude),</span>
                AngleUnit.RADIANS);
    }

    /**
     * Returns the declination from the Department of Defense geomagnetic
     * model and data, in radians.
     * The magnetic heading + declination is the true heading of a device
     * in terms of geographical north pole.
     * This method uses default altitude (0.0 - mean sea level) and time
     * (half way through the valid 5 year period of the model).
     *
     * @param latitude  latitude angle.
     * @param longitude longitude angle.
     * @param result    instance where magnetic field declination will be
     *                  stored.
     */
    public void getDeclinationAsAngle(
            final Angle latitude, final Angle longitude,
            final Angle result) {
<span class="fc" id="L366">        result.setUnit(AngleUnit.RADIANS);</span>
<span class="fc" id="L367">        result.setValue(getDeclination(latitude, longitude));</span>
<span class="fc" id="L368">    }</span>

    /**
     * Returns the declination from the Department of Defense geomagnetic
     * model and data, in radians.
     * The magnetic heading + declination is the true heading of a device
     * in terms of geographical north pole.
     * This method uses default altitude (0.0 - mean sea level) and time
     * (half way through the valid 5 year period of the model).
     *
     * @param latitude  latitude angle.
     * @param longitude longitude angle.
     * @return magnetic field declination.
     */
    public Angle getDeclinationAsAngle(
            final Angle latitude, final Angle longitude) {
<span class="fc" id="L384">        return new Angle(getDeclination(latitude, longitude),</span>
                AngleUnit.RADIANS);
    }

    /**
     * Returns the declination from the Department of Defense geomagnetic
     * model and data, in radians.
     * The magnetic heading + declination is the true heading of a device
     * in terms of geographical north pole.
     *
     * @param latitude  latitude expressed in radians.
     * @param longitude longitude expressed in radians.
     * @param height    height expressed in meters.
     * @param year      year expressed in decimal years.
     * @return magnetic field declination expressed in radians.
     */
    public double getDeclination(
            final double latitude, final double longitude,
            final double height, final double year) {
<span class="fc" id="L403">        final double heightKm = DistanceConverter.convert(height,</span>
                DistanceUnit.METER,
                DistanceUnit.KILOMETER);
<span class="fc" id="L406">        calcGeoMag(Math.toDegrees(latitude), Math.toDegrees(longitude),</span>
                heightKm, year);
<span class="fc" id="L408">        return Math.toRadians(mDec);</span>
    }

    /**
     * Returns the declination from the Department of Defense geomagnetic
     * model and data, in radians.
     * &lt;p&gt;
     * The magnetic heading + declination is the true heading of a device
     * in terms of geographical north pole.
     *
     * @param latitude  latitude expressed in radians.
     * @param longitude longitude expressed in radians.
     * @param height    height expressed in meters.
     * @param calendar  a calendar containing a specific instant.
     * @return magnetic field declination expressed in radians.
     */
    public double getDeclination(
            final double latitude, final double longitude,
            final double height, final GregorianCalendar calendar) {
<span class="fc" id="L427">        return getDeclination(latitude, longitude, height,</span>
<span class="fc" id="L428">                convertTime(calendar));</span>
    }

    /**
     * Returns the declination from the Department of Defense geomagnetic
     * model and data, in radians.
     * &lt;p&gt;
     * The magnetic heading + declination is the true heading of a device
     * in terms of geographical north pole.
     *
     * @param latitude  latitude expressed in radians.
     * @param longitude longitude expressed in radians.
     * @param height    height expressed in meters.
     * @param time      a specific time instant.
     * @return magnetic field declination expressed in radians.
     */
    public double getDeclination(
            final double latitude, final double longitude,
            final double height, final Date time) {
<span class="fc" id="L447">        final GregorianCalendar calendar = new GregorianCalendar();</span>
<span class="fc" id="L448">        calendar.setTime(time);</span>
<span class="fc" id="L449">        return getDeclination(latitude, longitude, height, calendar);</span>
    }

    /**
     * Returns the declination from the Department of Defense geomagnetic
     * model and data, in radians.
     * The magnetic heading + declination is the true heading of a device
     * in terms of geographical north pole.
     *
     * @param latitude  latitude angle.
     * @param longitude longitude angle.
     * @param height    height.
     * @param year      year expressed in decimal years.
     * @return magnetic field declination expressed in radians.
     */
    public double getDeclination(
            final Angle latitude, final Angle longitude,
            final Distance height, final double year) {
<span class="fc" id="L467">        return getDeclination(convertAngle(latitude),</span>
<span class="fc" id="L468">                convertAngle(longitude), convertDistance(height),</span>
                year);
    }

    /**
     * Returns the declination from the Department of Defense geomagnetic
     * model and data, in radians.
     * &lt;p&gt;
     * The magnetic heading + declination is the true heading of a device
     * in terms of geographical north pole.
     *
     * @param latitude  latitude angle.
     * @param longitude longitude angle.
     * @param height    height.
     * @param calendar  a calendar containing a specific instant.
     * @return magnetic field declination expressed in radians.
     */
    public double getDeclination(
            final Angle latitude, final Angle longitude,
            final Distance height, final GregorianCalendar calendar) {
<span class="fc" id="L488">        return getDeclination(convertAngle(latitude),</span>
<span class="fc" id="L489">                convertAngle(longitude), convertDistance(height),</span>
                calendar);
    }

    /**
     * Returns the declination from the Department of Defense geomagnetic
     * model and data, in radians.
     * &lt;p&gt;
     * The magnetic heading + declination is the true heading of a device
     * in terms of geographical north pole.
     *
     * @param latitude  latitude angle.
     * @param longitude longitude angle.
     * @param height    height.
     * @param time      a specific time instant.
     * @return magnetic field declination expressed in radians.
     */
    public double getDeclination(
            final Angle latitude, final Angle longitude,
            final Distance height, final Date time) {
<span class="fc" id="L509">        return getDeclination(convertAngle(latitude), convertAngle(longitude),</span>
<span class="fc" id="L510">                convertDistance(height), time);</span>
    }

    /**
     * Returns the declination from the Department of Defense geomagnetic
     * model and data, in radians.
     * The magnetic heading + declination is the true heading of a device
     * in terms of geographical north pole.
     *
     * @param position a position expressed in geodetic coordinates.
     * @param year     year expressed in decimal years.
     * @return magnetic field declination expressed in radians.
     */
    public double getDeclination(
            final NEDPosition position, final double year) {
<span class="fc" id="L525">        return getDeclination(position.getLatitude(), position.getLongitude(),</span>
<span class="fc" id="L526">                position.getHeight(), year);</span>
    }

    /**
     * Returns the declination from the Department of Defense geomagnetic
     * model and data, in radians.
     * The magnetic heading + declination is the true heading of a device
     * in terms of geographical north pole.
     *
     * @param position a position expressed in geodetic coordinates.
     * @param calendar a calendar containing a specific instant.
     * @return magnetic field declination expressed in radians.
     */
    public double getDeclination(
            final NEDPosition position, final GregorianCalendar calendar) {
<span class="fc" id="L541">        return getDeclination(position.getLatitude(), position.getLongitude(),</span>
<span class="fc" id="L542">                position.getHeight(), calendar);</span>
    }

    /**
     * Returns the declination from the Department of Defense geomagnetic
     * model and data, in radians.
     * The magnetic heading + declination is the true heading of a device
     * in terms of geographical north pole.
     *
     * @param position a position expressed in geodetic coordinates.
     * @param time     a specific time instant.
     * @return magnetic field declination expressed in radians.
     */
    public double getDeclination(
            final NEDPosition position, final Date time) {
<span class="fc" id="L557">        return getDeclination(position.getLatitude(),</span>
<span class="fc" id="L558">                position.getLongitude(), position.getHeight(), time);</span>
    }

    /**
     * Returns the declination from the Department of Defense geomagnetic
     * model and data, in radians.
     * The magnetic heading + declination is the true heading of a device
     * in terms of geographical north pole.
     *
     * @param latitude  latitude expressed in radians.
     * @param longitude longitude expressed in radians.
     * @param height    height expressed in meters.
     * @param year      year expressed in decimal years.
     * @param result    instance where magnetic field declination will be
     *                  stored.
     */
    public void getDeclinationAsAngle(
            final double latitude, final double longitude,
            final double height, final double year, final Angle result) {
<span class="fc" id="L577">        result.setUnit(AngleUnit.RADIANS);</span>
<span class="fc" id="L578">        result.setValue(getDeclination(latitude, longitude, height, year));</span>
<span class="fc" id="L579">    }</span>

    /**
     * Returns the declination from the Department of Defense geomagnetic
     * model and data, in radians.
     * The magnetic heading + declination is the true heading of a device
     * in terms of geographical north pole.
     *
     * @param latitude  latitude expressed in radians.
     * @param longitude longitude expressed in radians.
     * @param height    height expressed in meters.
     * @param year      year expressed in decimal years.
     * @return magnetic field declination.
     */
    public Angle getDeclinationAsAngle(
            final double latitude, final double longitude,
            final double height, final double year) {
<span class="fc" id="L596">        return new Angle(getDeclination(latitude, longitude, height, year),</span>
                AngleUnit.RADIANS);
    }

    /**
     * Returns the declination from the Department of Defense geomagnetic
     * model and data, in radians.
     * &lt;p&gt;
     * The magnetic heading + declination is the true heading of a device
     * in terms of geographical north pole.
     *
     * @param latitude  latitude expressed in radians.
     * @param longitude longitude expressed in radians.
     * @param height    height expressed in meters.
     * @param calendar  a calendar containing a specific instant.
     * @param result    instance where magnetic field declination will be
     *                  stored.
     */
    public void getDeclinationAsAngle(
            final double latitude, final double longitude,
            final double height, final GregorianCalendar calendar,
            final Angle result) {
<span class="fc" id="L618">        result.setUnit(AngleUnit.RADIANS);</span>
<span class="fc" id="L619">        result.setValue(getDeclination(latitude, longitude, height,</span>
                calendar));
<span class="fc" id="L621">    }</span>

    /**
     * Returns the declination from the Department of Defense geomagnetic
     * model and data, in radians.
     * &lt;p&gt;
     * The magnetic heading + declination is the true heading of a device
     * in terms of geographical north pole.
     *
     * @param latitude  latitude expressed in radians.
     * @param longitude longitude expressed in radians.
     * @param height    height expressed in meters.
     * @param calendar  a calendar containing a specific instant.
     * @return magnetic field declination.
     */
    public Angle getDeclinationAsAngle(
            final double latitude, final double longitude,
            final double height, final GregorianCalendar calendar) {
<span class="fc" id="L639">        return new Angle(getDeclination(latitude, longitude, height,</span>
                calendar), AngleUnit.RADIANS);
    }

    /**
     * Returns the declination from the Department of Defense geomagnetic
     * model and data, in radians.
     * &lt;p&gt;
     * The magnetic heading + declination is the true heading of a device
     * in terms of geographical north pole.
     *
     * @param latitude  latitude expressed in radians.
     * @param longitude longitude expressed in radians.
     * @param height    height expressed in meters.
     * @param time      a specific time instant.
     * @param result    instance where magnetic field declination will be
     *                  stored.
     */
    public void getDeclinationAsAngle(
            final double latitude, final double longitude,
            final double height, final Date time, final Angle result) {
<span class="fc" id="L660">        result.setUnit(AngleUnit.RADIANS);</span>
<span class="fc" id="L661">        result.setValue(getDeclination(latitude, longitude, height, time));</span>
<span class="fc" id="L662">    }</span>

    /**
     * Returns the declination from the Department of Defense geomagnetic
     * model and data, in radians.
     * &lt;p&gt;
     * The magnetic heading + declination is the true heading of a device
     * in terms of geographical north pole.
     *
     * @param latitude  latitude expressed in radians.
     * @param longitude longitude expressed in radians.
     * @param height    height expressed in meters.
     * @param time      a specific time instant.
     * @return magnetic field declination.
     */
    public Angle getDeclinationAsAngle(
            final double latitude, final double longitude,
            final double height, final Date time) {
<span class="fc" id="L680">        return new Angle(getDeclination(latitude, longitude, height, time),</span>
                AngleUnit.RADIANS);
    }

    /**
     * Returns the declination from the Department of Defense geomagnetic
     * model and data, in radians.
     * The magnetic heading + declination is the true heading of a device
     * in terms of geographical north pole.
     *
     * @param latitude  latitude angle.
     * @param longitude longitude angle.
     * @param height    height.
     * @param year      year expressed in decimal years.
     * @param result    instance where magnetic field declination will be
     *                  stored.
     */
    public void getDeclinationAsAngle(
            final Angle latitude, final Angle longitude,
            final Distance height, final double year, final Angle result) {
<span class="fc" id="L700">        result.setUnit(AngleUnit.RADIANS);</span>
<span class="fc" id="L701">        result.setValue(getDeclination(latitude, longitude, height, year));</span>
<span class="fc" id="L702">    }</span>

    /**
     * Returns the declination from the Department of Defense geomagnetic
     * model and data, in radians.
     * The magnetic heading + declination is the true heading of a device
     * in terms of geographical north pole.
     *
     * @param latitude  latitude angle.
     * @param longitude longitude angle.
     * @param height    height.
     * @param year      year expressed in decimal years.
     * @return magnetic field declination.
     */
    public Angle getDeclinationAsAngle(
            final Angle latitude, final Angle longitude,
            final Distance height, final double year) {
<span class="fc" id="L719">        return new Angle(getDeclination(latitude, longitude, height, year),</span>
                AngleUnit.RADIANS);
    }

    /**
     * Returns the declination from the Department of Defense geomagnetic
     * model and data, in radians.
     * &lt;p&gt;
     * The magnetic heading + declination is the true heading of a device
     * in terms of geographical north pole.
     *
     * @param latitude  latitude angle.
     * @param longitude longitude angle.
     * @param height    height.
     * @param calendar  a calendar containing a specific instant.
     * @param result    instance where magnetic field declination will be
     *                  stored.
     */
    public void getDeclinationAsAngle(
            final Angle latitude, final Angle longitude,
            final Distance height, final GregorianCalendar calendar,
            final Angle result) {
<span class="fc" id="L741">        result.setUnit(AngleUnit.RADIANS);</span>
<span class="fc" id="L742">        result.setValue(getDeclination(latitude, longitude, height,</span>
                calendar));
<span class="fc" id="L744">    }</span>

    /**
     * Returns the declination from the Department of Defense geomagnetic
     * model and data, in radians.
     * &lt;p&gt;
     * The magnetic heading + declination is the true heading of a device
     * in terms of geographical north pole.
     *
     * @param latitude  latitude angle.
     * @param longitude longitude angle.
     * @param height    height.
     * @param calendar  a calendar containing a specific instant.
     * @return magnetic field declination.
     */
    public Angle getDeclinationAsAngle(
            final Angle latitude, final Angle longitude,
            final Distance height, final GregorianCalendar calendar) {
<span class="fc" id="L762">        return new Angle(getDeclination(latitude, longitude, height,</span>
                calendar), AngleUnit.RADIANS);
    }

    /**
     * Returns the declination from the Department of Defense geomagnetic
     * model and data, in radians.
     * &lt;p&gt;
     * The magnetic heading + declination is the true heading of a device
     * in terms of geographical north pole.
     *
     * @param latitude  latitude angle.
     * @param longitude longitude angle.
     * @param height    height.
     * @param time      a specific time instant.
     * @param result    instance where magnetic field declination will be
     *                  stored.
     */
    public void getDeclinationAsAngle(
            final Angle latitude, final Angle longitude,
            final Distance height, final Date time, final Angle result) {
<span class="fc" id="L783">        result.setUnit(AngleUnit.RADIANS);</span>
<span class="fc" id="L784">        result.setValue(getDeclination(latitude, longitude, height, time));</span>
<span class="fc" id="L785">    }</span>

    /**
     * Returns the declination from the Department of Defense geomagnetic
     * model and data, in radians.
     * &lt;p&gt;
     * The magnetic heading + declination is the true heading of a device
     * in terms of geographical north pole.
     *
     * @param latitude  latitude angle.
     * @param longitude longitude angle.
     * @param height    height.
     * @param time      a specific time instant.
     * @return magnetic field declination.
     */
    public Angle getDeclinationAsAngle(
            final Angle latitude, final Angle longitude,
            final Distance height, final Date time) {
<span class="fc" id="L803">        return new Angle(getDeclination(latitude, longitude, height, time),</span>
                AngleUnit.RADIANS);
    }

    /**
     * Returns the declination from the Department of Defense geomagnetic
     * model and data, in radians.
     * The magnetic heading + declination is the true heading of a device
     * in terms of geographical north pole.
     *
     * @param position a position expressed in geodetic coordinates.
     * @param year     year expressed in decimal years.
     * @param result   instance where magnetic field declination will be
     *                 stored.
     */
    public void getDeclinationAsAngle(
            final NEDPosition position, final double year,
            final Angle result) {
<span class="fc" id="L821">        result.setUnit(AngleUnit.RADIANS);</span>
<span class="fc" id="L822">        result.setValue(getDeclination(position, year));</span>
<span class="fc" id="L823">    }</span>

    /**
     * Returns the declination from the Department of Defense geomagnetic
     * model and data, in radians.
     * The magnetic heading + declination is the true heading of a device
     * in terms of geographical north pole.
     *
     * @param position a position expressed in geodetic coordinates.
     * @param year     year expressed in decimal years.
     * @return magnetic field declination.
     */
    public Angle getDeclinationAsAngle(
            final NEDPosition position, final double year) {
<span class="fc" id="L837">        return new Angle(getDeclination(position, year), AngleUnit.RADIANS);</span>
    }

    /**
     * Returns the declination from the Department of Defense geomagnetic
     * model and data, in radians.
     * The magnetic heading + declination is the true heading of a device
     * in terms of geographical north pole.
     *
     * @param position a position expressed in geodetic coordinates.
     * @param calendar a calendar containing a specific instant.
     * @param result   instance where magnetic field declination will be
     *                 stored.
     */
    public void getDeclinationAsAngle(
            final NEDPosition position, final GregorianCalendar calendar,
            final Angle result) {
<span class="fc" id="L854">        result.setUnit(AngleUnit.RADIANS);</span>
<span class="fc" id="L855">        result.setValue(getDeclination(position, calendar));</span>
<span class="fc" id="L856">    }</span>

    /**
     * Returns the declination from the Department of Defense geomagnetic
     * model and data, in radians.
     * The magnetic heading + declination is the true heading of a device
     * in terms of geographical north pole.
     *
     * @param position a position expressed in geodetic coordinates.
     * @param calendar a calendar containing a specific instant.
     * @return magnetic field declination.
     */
    public Angle getDeclinationAsAngle(
            final NEDPosition position, final GregorianCalendar calendar) {
<span class="fc" id="L870">        return new Angle(getDeclination(position, calendar),</span>
                AngleUnit.RADIANS);
    }

    /**
     * Returns the declination from the Department of Defense geomagnetic
     * model and data, in radians.
     * The magnetic heading + declination is the true heading of a device
     * in terms of geographical north pole.
     *
     * @param position a position expressed in geodetic coordinates.
     * @param time     a specific time instant.
     * @param result   instance where magnetic field declination will be
     *                 stored.
     */
    public void getDeclinationAsAngle(
            final NEDPosition position, final Date time,
            final Angle result) {
<span class="fc" id="L888">        result.setUnit(AngleUnit.RADIANS);</span>
<span class="fc" id="L889">        result.setValue(getDeclination(position, time));</span>
<span class="fc" id="L890">    }</span>

    /**
     * Returns the declination from the Department of Defense geomagnetic
     * model and data, in radians.
     * The magnetic heading + declination is the true heading of a device
     * in terms of geographical north pole.
     *
     * @param position a position expressed in geodetic coordinates.
     * @param time     a specific time instant.
     * @return magnetic field declination.
     */
    public Angle getDeclinationAsAngle(
            final NEDPosition position, final Date time) {
<span class="fc" id="L904">        return new Angle(getDeclination(position, time),</span>
                AngleUnit.RADIANS);
    }

    /**
     * Returns the magnetic field dip angle from the Department of
     * Defense geomagnetic model and data, in radians.
     * This method uses default altitude (0.0 - mean sea level) and time
     * (half way through the valid 5 year period of the model).
     *
     * @param latitude  latitude expressed in radians.
     * @param longitude longitude expressed in radians.
     * @return the magnetic field dip angle expressed in radians.
     */
    public double getDip(final double latitude, final double longitude) {
<span class="fc" id="L919">        final double defaultTime = mModel.epoch</span>
                + WorldMagneticModel.LIFESPAN / 2.0;
<span class="fc" id="L921">        calcGeoMag(Math.toDegrees(latitude), Math.toDegrees(longitude),</span>
                0.0, defaultTime);
<span class="fc" id="L923">        return Math.toRadians(mDip);</span>
    }

    /**
     * Returns the magnetic field dip angle from the Department of
     * Defense geomagnetic model and data, in radians.
     * This method uses default altitude (0.0 - mean sea level) and time
     * (half way through the valid 5 year period of the model).
     *
     * @param latitude  latitude angle.
     * @param longitude longitude angle.
     * @return the magnetic field dip angle expressed in radians.
     */
    public double getDip(final Angle latitude, final Angle longitude) {
<span class="fc" id="L937">        return getDip(convertAngle(latitude), convertAngle(longitude));</span>
    }

    /**
     * Returns the magnetic field dip angle from the Department of
     * Defense geomagnetic model and data, in radians.
     * This method uses default altitude (0.0 - mean sea level) and time
     * (half way through the valid 5 year period of the model).
     *
     * @param latitude  latitude expressed in radians.
     * @param longitude longitude expressed in radians.
     * @param result    instance where magnetic field dip angle will be
     *                  stored.
     */
    public void getDipAsAngle(
            final double latitude, final double longitude,
            final Angle result) {
<span class="fc" id="L954">        result.setUnit(AngleUnit.RADIANS);</span>
<span class="fc" id="L955">        result.setValue(getDip(latitude, longitude));</span>
<span class="fc" id="L956">    }</span>

    /**
     * Returns the magnetic field dip angle from the Department of
     * Defense geomagnetic model and data, in radians.
     * This method uses default altitude (0.0 - mean sea level) and time
     * (half way through the valid 5 year period of the model).
     *
     * @param latitude  latitude angle.
     * @param longitude longitude angle.
     * @return the magnetic field dip angle.
     */
    public Angle getDipAsAngle(
            final double latitude, final double longitude) {
<span class="fc" id="L970">        return new Angle(getDip(latitude, longitude), AngleUnit.RADIANS);</span>
    }

    /**
     * Returns the magnetic field dip angle from the Department of
     * Defense geomagnetic model and data, in radians.
     * This method uses default altitude (0.0 - mean sea level) and time
     * (half way through the valid 5 year period of the model).
     *
     * @param latitude  latitude angle.
     * @param longitude longitude angle.
     * @param result    instance where magnetic field dip angle will be
     *                  stored.
     */
    public void getDipAsAngle(
            final Angle latitude, final Angle longitude,
            final Angle result) {
<span class="fc" id="L987">        result.setUnit(AngleUnit.RADIANS);</span>
<span class="fc" id="L988">        result.setValue(getDip(latitude, longitude));</span>
<span class="fc" id="L989">    }</span>

    /**
     * Returns the magnetic field dip angle from the Department of
     * Defense geomagnetic model and data, in radians.
     * This method uses default altitude (0.0 - mean sea level) and time
     * (half way through the valid 5 year period of the model).
     *
     * @param latitude  latitude angle.
     * @param longitude longitude angle.
     * @return the magnetic field dip angle.
     */
    public Angle getDipAsAngle(
            final Angle latitude, final Angle longitude) {
<span class="fc" id="L1003">        return new Angle(getDip(latitude, longitude), AngleUnit.RADIANS);</span>
    }

    /**
     * Returns the magnetic field dip angle from the Department of
     * Defense geomagnetic model and data, in radians.
     *
     * @param latitude  latitude expressed in radians.
     * @param longitude longitude expressed in radians.
     * @param height    height expressed in meters.
     * @param year      year expressed in decimal years.
     * @return the magnetic field dip angle expressed in radians.
     */
    public double getDip(
            final double latitude, final double longitude,
            final double height, final double year) {
<span class="fc" id="L1019">        final double heightKm = DistanceConverter.convert(height,</span>
                DistanceUnit.METER,
                DistanceUnit.KILOMETER);
<span class="fc" id="L1022">        calcGeoMag(Math.toDegrees(latitude), Math.toDegrees(longitude),</span>
                heightKm, year);
<span class="fc" id="L1024">        return Math.toRadians(mDip);</span>
    }

    /**
     * Returns the magnetic field dip angle from the Department of
     * Defense geomagnetic model and data, in radians.
     *
     * @param latitude  latitude expressed in radians.
     * @param longitude longitude expressed in radians.
     * @param height    height expressed in meters.
     * @param calendar  a calendar containing a specific instant.
     * @return the magnetic field dip angle expressed in radians.
     */
    public double getDip(
            final double latitude, final double longitude,
            final double height, final GregorianCalendar calendar) {
<span class="fc" id="L1040">        return getDip(latitude, longitude, height,</span>
<span class="fc" id="L1041">                convertTime(calendar));</span>
    }

    /**
     * Returns the magnetic field dip angle from the Department of
     * Defense geomagnetic model and data, in radians.
     *
     * @param latitude  latitude expressed in radians.
     * @param longitude longitude expressed in radians.
     * @param height    height expressed in meters.
     * @param time      a specific time instant.
     * @return the magnetic field dip angle expressed in radians.
     */
    public double getDip(
            final double latitude, final double longitude,
            final double height, final Date time) {
<span class="fc" id="L1057">        final GregorianCalendar calendar = new GregorianCalendar();</span>
<span class="fc" id="L1058">        calendar.setTime(time);</span>
<span class="fc" id="L1059">        return getDip(latitude, longitude, height, calendar);</span>
    }

    /**
     * Returns the magnetic field dip angle from the Department of
     * Defense geomagnetic model and data, in radians.
     *
     * @param latitude  latitude angle.
     * @param longitude longitude angle.
     * @param height    height.
     * @param year      year expressed in decimal years.
     * @return the magnetic field dip angle expressed in radians.
     */
    public double getDip(
            final Angle latitude, final Angle longitude,
            final Distance height, final double year) {
<span class="fc" id="L1075">        return getDip(convertAngle(latitude), convertAngle(longitude),</span>
<span class="fc" id="L1076">                convertDistance(height), year);</span>
    }

    /**
     * Returns the magnetic field dip angle from the Department of
     * Defense geomagnetic model and data, in radians.
     *
     * @param latitude  latitude angle.
     * @param longitude longitude angle.
     * @param height    height.
     * @param calendar  a calendar containing a specific instant.
     * @return the magnetic field dip angle expressed in radians.
     */
    public double getDip(
            final Angle latitude, final Angle longitude,
            final Distance height, final GregorianCalendar calendar) {
<span class="fc" id="L1092">        return getDip(convertAngle(latitude), convertAngle(longitude),</span>
<span class="fc" id="L1093">                convertDistance(height), calendar);</span>
    }

    /**
     * Returns the magnetic field dip angle from the Department of
     * Defense geomagnetic model and data, in radians.
     *
     * @param latitude  latitude angle.
     * @param longitude longitude angle.
     * @param height    height.
     * @param time      a specific time instant.
     * @return the magnetic field dip angle expressed in radians.
     */
    public double getDip(
            final Angle latitude, final Angle longitude,
            final Distance height, final Date time) {
<span class="fc" id="L1109">        return getDip(convertAngle(latitude), convertAngle(longitude),</span>
<span class="fc" id="L1110">                convertDistance(height), time);</span>
    }

    /**
     * Returns the magnetic field dip angle from the Department of
     * Defense geomagnetic model and data, in radians.
     *
     * @param position a position expressed in geodetic coordinates.
     * @param year     year expressed in decimal years.
     * @return the magnetic field dip angle expressed in radians.
     */
    public double getDip(final NEDPosition position, final double year) {
<span class="fc" id="L1122">        return getDip(position.getLatitude(), position.getLongitude(),</span>
<span class="fc" id="L1123">                position.getHeight(), year);</span>
    }

    /**
     * Returns the magnetic field dip angle from the Department of
     * Defense geomagnetic model and data, in radians.
     *
     * @param position a position expressed in geodetic coordinates.
     * @param calendar a calendar containing a specific instant.
     * @return the magnetic field dip angle expressed in radians.
     */
    public double getDip(
            final NEDPosition position,
            final GregorianCalendar calendar) {

<span class="fc" id="L1138">        return getDip(position.getLatitude(), position.getLongitude(),</span>
<span class="fc" id="L1139">                position.getHeight(), calendar);</span>
    }

    /**
     * Returns the magnetic field dip angle from the Department of
     * Defense geomagnetic model and data, in radians.
     *
     * @param position a position expressed in geodetic coordinates.
     * @param time     a specific time instant.
     * @return the magnetic field dip angle expressed in radians.
     */
    public double getDip(
            final NEDPosition position, final Date time) {
<span class="fc" id="L1152">        return getDip(position.getLatitude(), position.getLongitude(),</span>
<span class="fc" id="L1153">                position.getHeight(), time);</span>
    }

    /**
     * Returns the magnetic field dip angle from the Department of
     * Defense geomagnetic model and data, in radians.
     *
     * @param latitude  latitude expressed in radians.
     * @param longitude longitude expressed in radians.
     * @param height    height expressed in meters.
     * @param year      year expressed in decimal years.
     * @param result    instance where magnetic field dip angle will be
     *                  stored.
     */
    public void getDipAsAngle(
            final double latitude, final double longitude,
            final double height, final double year, final Angle result) {
<span class="fc" id="L1170">        result.setUnit(AngleUnit.RADIANS);</span>
<span class="fc" id="L1171">        result.setValue(getDip(latitude, longitude, height, year));</span>
<span class="fc" id="L1172">    }</span>

    /**
     * Returns the magnetic field dip angle from the Department of
     * Defense geomagnetic model and data, in radians.
     *
     * @param latitude  latitude expressed in radians.
     * @param longitude longitude expressed in radians.
     * @param height    height expressed in meters.
     * @param year      year expressed in decimal years.
     * @return the magnetic field dip angle.
     */
    public Angle getDipAsAngle(
            final double latitude, final double longitude,
            final double height, final double year) {
<span class="fc" id="L1187">        return new Angle(getDip(latitude, longitude, height, year),</span>
                AngleUnit.RADIANS);
    }

    /**
     * Returns the magnetic field dip angle from the Department of
     * Defense geomagnetic model and data, in radians.
     *
     * @param latitude  latitude expressed in radians.
     * @param longitude longitude expressed in radians.
     * @param height    height expressed in meters.
     * @param calendar  a calendar containing a specific instant.
     * @param result    instance where magnetic field dip angle will be
     *                  stored.
     */
    public void getDipAsAngle(
            final double latitude, final double longitude,
            final double height, final GregorianCalendar calendar,
            final Angle result) {
<span class="fc" id="L1206">        result.setUnit(AngleUnit.RADIANS);</span>
<span class="fc" id="L1207">        result.setValue(getDip(latitude, longitude, height, calendar));</span>
<span class="fc" id="L1208">    }</span>

    /**
     * Returns the magnetic field dip angle from the Department of
     * Defense geomagnetic model and data, in radians.
     *
     * @param latitude  latitude expressed in radians.
     * @param longitude longitude expressed in radians.
     * @param height    height expressed in meters.
     * @param calendar  a calendar containing a specific instant.
     * @return the magnetic field dip angle.
     */
    public Angle getDipAsAngle(
            final double latitude, final double longitude,
            final double height, final GregorianCalendar calendar) {
<span class="fc" id="L1223">        return new Angle(getDip(latitude, longitude, height, calendar),</span>
                AngleUnit.RADIANS);
    }

    /**
     * Returns the magnetic field dip angle from the Department of
     * Defense geomagnetic model and data, in radians.
     *
     * @param latitude  latitude expressed in radians.
     * @param longitude longitude expressed in radians.
     * @param height    height expressed in meters.
     * @param time      a specific time instant.
     * @param result    instance where magnetic field dip angle will be
     *                  stored.
     */
    public void getDipAsAngle(
            final double latitude, final double longitude,
            final double height, final Date time, final Angle result) {
<span class="fc" id="L1241">        result.setUnit(AngleUnit.RADIANS);</span>
<span class="fc" id="L1242">        result.setValue(getDip(latitude, longitude, height, time));</span>
<span class="fc" id="L1243">    }</span>

    /**
     * Returns the magnetic field dip angle from the Department of
     * Defense geomagnetic model and data, in radians.
     *
     * @param latitude  latitude expressed in radians.
     * @param longitude longitude expressed in radians.
     * @param height    height expressed in meters.
     * @param time      a specific time instant.
     * @return the magnetic field dip angle.
     */
    public Angle getDipAsAngle(
            final double latitude, final double longitude,
            final double height, final Date time) {
<span class="fc" id="L1258">        return new Angle(getDip(latitude, longitude, height, time),</span>
                AngleUnit.RADIANS);
    }

    /**
     * Returns the magnetic field dip angle from the Department of
     * Defense geomagnetic model and data, in radians.
     *
     * @param latitude  latitude angle.
     * @param longitude longitude angle.
     * @param height    height.
     * @param year      year expressed in decimal years.
     * @param result    instance where magnetic field dip angle will be
     *                  stored.
     */
    public void getDipAsAngle(
            final Angle latitude, final Angle longitude,
            final Distance height, final double year, final Angle result) {
<span class="fc" id="L1276">        result.setUnit(AngleUnit.RADIANS);</span>
<span class="fc" id="L1277">        result.setValue(getDip(latitude, longitude, height, year));</span>
<span class="fc" id="L1278">    }</span>

    /**
     * Returns the magnetic field dip angle from the Department of
     * Defense geomagnetic model and data, in radians.
     *
     * @param latitude  latitude angle.
     * @param longitude longitude angle.
     * @param height    height.
     * @param year      year expressed in decimal years.
     * @return the magnetic field dip angle.
     */
    public Angle getDipAsAngle(
            final Angle latitude, final Angle longitude,
            final Distance height, final double year) {
<span class="fc" id="L1293">        return new Angle(getDip(latitude, longitude, height, year),</span>
                AngleUnit.RADIANS);
    }

    /**
     * Returns the magnetic field dip angle from the Department of
     * Defense geomagnetic model and data, in radians.
     *
     * @param latitude  latitude angle.
     * @param longitude longitude angle.
     * @param height    height.
     * @param calendar  a calendar containing a specific instant.
     * @param result    instance where magnetic field dip angle will be
     *                  stored.
     */
    public void getDipAsAngle(
            final Angle latitude, final Angle longitude,
            final Distance height, final GregorianCalendar calendar,
            final Angle result) {
<span class="fc" id="L1312">        result.setUnit(AngleUnit.RADIANS);</span>
<span class="fc" id="L1313">        result.setValue(getDip(latitude, longitude, height, calendar));</span>
<span class="fc" id="L1314">    }</span>

    /**
     * Returns the magnetic field dip angle from the Department of
     * Defense geomagnetic model and data, in radians.
     *
     * @param latitude  latitude angle.
     * @param longitude longitude angle.
     * @param height    height.
     * @param calendar  a calendar containing a specific instant.
     * @return the magnetic field dip angle.
     */
    public Angle getDipAsAngle(
            final Angle latitude, final Angle longitude,
            final Distance height, final GregorianCalendar calendar) {
<span class="fc" id="L1329">        return new Angle(getDip(latitude, longitude, height, calendar),</span>
                AngleUnit.RADIANS);
    }

    /**
     * Returns the magnetic field dip angle from the Department of
     * Defense geomagnetic model and data, in radians.
     *
     * @param latitude  latitude angle.
     * @param longitude longitude angle.
     * @param height    height.
     * @param time      a specific time instant.
     * @param result    instance where magnetic field dip angle will be
     *                  stored.
     */
    public void getDipAsAngle(
            final Angle latitude, final Angle longitude,
            final Distance height, final Date time, final Angle result) {
<span class="fc" id="L1347">        result.setUnit(AngleUnit.RADIANS);</span>
<span class="fc" id="L1348">        result.setValue(getDip(latitude, longitude, height, time));</span>
<span class="fc" id="L1349">    }</span>

    /**
     * Returns the magnetic field dip angle from the Department of
     * Defense geomagnetic model and data, in radians.
     *
     * @param latitude  latitude angle.
     * @param longitude longitude angle.
     * @param height    height.
     * @param time      a specific time instant.
     * @return the magnetic field dip angle.
     */
    public Angle getDipAsAngle(
            final Angle latitude, final Angle longitude,
            final Distance height, final Date time) {
<span class="fc" id="L1364">        return new Angle(getDip(latitude, longitude, height, time),</span>
                AngleUnit.RADIANS);
    }

    /**
     * Returns the magnetic field dip angle from the Department of
     * Defense geomagnetic model and data, in radians.
     *
     * @param position a position expressed in geodetic coordinates.
     * @param year     year expressed in decimal years.
     * @param result   instance where magnetic field dip angle will be
     *                 stored.
     */
    public void getDipAsAngle(
            final NEDPosition position, final double year,
            final Angle result) {
<span class="fc" id="L1380">        result.setUnit(AngleUnit.RADIANS);</span>
<span class="fc" id="L1381">        result.setValue(getDip(position, year));</span>
<span class="fc" id="L1382">    }</span>

    /**
     * Returns the magnetic field dip angle from the Department of
     * Defense geomagnetic model and data, in radians.
     *
     * @param position a position expressed in geodetic coordinates.
     * @param year     year expressed in decimal years.
     * @return the magnetic field dip angle.
     */
    public Angle getDipAsAngle(
            final NEDPosition position, final double year) {
<span class="fc" id="L1394">        return new Angle(getDip(position, year), AngleUnit.RADIANS);</span>
    }

    /**
     * Returns the magnetic field dip angle from the Department of
     * Defense geomagnetic model and data, in radians.
     *
     * @param position a position expressed in geodetic coordinates.
     * @param calendar a calendar containing a specific instant.
     * @param result   instance where magnetic field dip angle will be
     *                 stored.
     */
    public void getDipAsAngle(
            final NEDPosition position, final GregorianCalendar calendar,
            final Angle result) {
<span class="fc" id="L1409">        result.setUnit(AngleUnit.RADIANS);</span>
<span class="fc" id="L1410">        result.setValue(getDip(position, calendar));</span>
<span class="fc" id="L1411">    }</span>

    /**
     * Returns the magnetic field dip angle from the Department of
     * Defense geomagnetic model and data, in radians.
     *
     * @param position a position expressed in geodetic coordinates.
     * @param calendar a calendar containing a specific instant.
     * @return the magnetic field dip angle.
     */
    public Angle getDipAsAngle(
            final NEDPosition position,
            final GregorianCalendar calendar) {
<span class="fc" id="L1424">        return new Angle(getDip(position, calendar), AngleUnit.RADIANS);</span>
    }

    /**
     * Returns the magnetic field dip angle from the Department of
     * Defense geomagnetic model and data, in radians.
     *
     * @param position a position expressed in geodetic coordinates.
     * @param time     a specific time instant.
     * @param result   instance where magnetic field dip angle will be
     *                 stored.
     */
    public void getDipAsAngle(
            final NEDPosition position, final Date time,
            final Angle result) {
<span class="fc" id="L1439">        result.setUnit(AngleUnit.RADIANS);</span>
<span class="fc" id="L1440">        result.setValue(getDip(position, time));</span>
<span class="fc" id="L1441">    }</span>

    /**
     * Returns the magnetic field dip angle from the Department of
     * Defense geomagnetic model and data, in radians.
     *
     * @param position a position expressed in geodetic coordinates.
     * @param time     a specific time instant.
     * @return the magnetic field dip angle.
     */
    public Angle getDipAsAngle(
            final NEDPosition position, final Date time) {
<span class="fc" id="L1453">        return new Angle(getDip(position, time), AngleUnit.RADIANS);</span>
    }

    /**
     * Returns the magnetic field intensity from the Department of
     * Defense geomagnetic model and data expressed in Teslas.
     * This method uses default altitude (0.0 - mean sea level) and time
     * (half way through the valid 5 year period of the model).
     *
     * @param latitude  latitude expressed in radians.
     * @param longitude longitude expressed in radians.
     * @return magnetic field strength expressed in Teslas (T).
     */
    public double getIntensity(
            final double latitude, final double longitude) {
<span class="fc" id="L1468">        final double defaultTime = mModel.epoch</span>
                + WorldMagneticModel.LIFESPAN / 2.0;
<span class="fc" id="L1470">        calcGeoMag(Math.toDegrees(latitude), Math.toDegrees(longitude),</span>
                0.0, defaultTime);
<span class="fc" id="L1472">        return mTi * FROM_NANO;</span>
    }

    /**
     * Returns the magnetic field intensity from the Department of
     * Defense geomagnetic model and data expressed in Teslas.
     * This method uses default altitude (0.0 - mean sea level) and time
     * (half way through the valid 5 year period of the model).
     *
     * @param latitude  latitude angle.
     * @param longitude longitude angle.
     * @return magnetic field strength expressed in Teslas (T).
     */
    public double getIntensity(
            final Angle latitude, final Angle longitude) {
<span class="fc" id="L1487">        return getIntensity(convertAngle(latitude),</span>
<span class="fc" id="L1488">                convertAngle(longitude));</span>
    }

    /**
     * Returns the magnetic field intensity from the Department of
     * Defense geomagnetic model and data expressed in Teslas.
     *
     * @param latitude  latitude expressed in radians.
     * @param longitude longitude expressed in radians.
     * @param height    height expressed in meters.
     * @param year      year expressed in decimal years.
     * @return magnetic field strength expressed in Teslas (T).
     */
    public double getIntensity(
            final double latitude, final double longitude,
            final double height, final double year) {
<span class="fc" id="L1504">        final double heightKm = DistanceConverter.convert(height,</span>
                DistanceUnit.METER,
                DistanceUnit.KILOMETER);
<span class="fc" id="L1507">        calcGeoMag(Math.toDegrees(latitude), Math.toDegrees(longitude),</span>
                heightKm, year);
<span class="fc" id="L1509">        return mTi * FROM_NANO;</span>
    }

    /**
     * Returns the magnetic field intensity from the Department of
     * Defense geomagnetic model and data expressed in Teslas.
     *
     * @param latitude  latitude expressed in radians.
     * @param longitude longitude expressed in radians.
     * @param height    height expressed in meters.
     * @param calendar  a calendar containing a specific instant.
     * @return magnetic field strength expressed in Teslas (T).
     */
    public double getIntensity(
            final double latitude, final double longitude,
            final double height, final GregorianCalendar calendar) {
<span class="fc" id="L1525">        return getIntensity(latitude, longitude, height,</span>
<span class="fc" id="L1526">                convertTime(calendar));</span>
    }

    /**
     * Returns the magnetic field intensity from the Department of
     * Defense geomagnetic model and data expressed in Teslas.
     *
     * @param latitude  latitude expressed in radians.
     * @param longitude longitude expressed in radians.
     * @param height    height expressed in meters.
     * @param time      a specific time instant.
     * @return magnetic field strength expressed in Teslas (T).
     */
    public double getIntensity(
            final double latitude, final double longitude,
            final double height, final Date time) {
<span class="fc" id="L1542">        final GregorianCalendar calendar = new GregorianCalendar();</span>
<span class="fc" id="L1543">        calendar.setTime(time);</span>
<span class="fc" id="L1544">        return getIntensity(latitude, longitude, height, calendar);</span>
    }

    /**
     * Returns the magnetic field intensity from the Department of
     * Defense geomagnetic model and data expressed in Teslas.
     *
     * @param latitude  latitude angle.
     * @param longitude longitude angle.
     * @param height    height.
     * @param year      year expressed in decimal years.
     * @return magnetic field strength expressed in Teslas (T).
     */
    public double getIntensity(
            final Angle latitude, final Angle longitude,
            final Distance height, final double year) {
<span class="fc" id="L1560">        return getIntensity(convertAngle(latitude),</span>
<span class="fc" id="L1561">                convertAngle(longitude), convertDistance(height),</span>
                year);
    }

    /**
     * Returns the magnetic field intensity from the Department of
     * Defense geomagnetic model and data expressed in Teslas.
     *
     * @param latitude  latitude angle.
     * @param longitude longitude angle.
     * @param height    height.
     * @param calendar  a calendar containing a specific instant.
     * @return magnetic field strength expressed in Teslas (T).
     */
    public double getIntensity(
            final Angle latitude, final Angle longitude,
            final Distance height, final GregorianCalendar calendar) {
<span class="fc" id="L1578">        return getIntensity(convertAngle(latitude),</span>
<span class="fc" id="L1579">                convertAngle(longitude), convertDistance(height),</span>
                calendar);
    }

    /**
     * Returns the magnetic field intensity from the Department of
     * Defense geomagnetic model and data expressed in Teslas.
     *
     * @param latitude  latitude angle.
     * @param longitude longitude angle.
     * @param height    height.
     * @param time      a specific time instant.
     * @return magnetic field strength expressed in Teslas (T).
     */
    public double getIntensity(
            final Angle latitude, final Angle longitude,
            final Distance height, final Date time) {
<span class="fc" id="L1596">        return getIntensity(convertAngle(latitude),</span>
<span class="fc" id="L1597">                convertAngle(longitude), convertDistance(height),</span>
                time);
    }

    /**
     * Returns the magnetic field intensity from the Department of
     * Defense geomagnetic model and data expressed in Teslas.
     *
     * @param position a position expressed in geodetic coordinates.
     * @param year     year expressed in decimal years.
     * @return magnetic field strength expressed in Teslas (T).
     */
    public double getIntensity(
            final NEDPosition position, final double year) {
<span class="fc" id="L1611">        return getIntensity(position.getLatitude(), position.getLongitude(),</span>
<span class="fc" id="L1612">                position.getHeight(), year);</span>
    }

    /**
     * Returns the magnetic field intensity from the Department of
     * Defense geomagnetic model and data expressed in Teslas.
     *
     * @param position a position expressed in geodetic coordinates.
     * @param calendar a calendar containing a specific instant.
     * @return magnetic field strength expressed in Teslas (T).
     */
    public double getIntensity(
            final NEDPosition position, final GregorianCalendar calendar) {
<span class="fc" id="L1625">        return getIntensity(position.getLatitude(), position.getLongitude(),</span>
<span class="fc" id="L1626">                position.getHeight(), calendar);</span>
    }

    /**
     * Returns the magnetic field intensity from the Department of
     * Defense geomagnetic model and data expressed in Teslas.
     *
     * @param position a position expressed in geodetic coordinates.
     * @param time     a specific time instant.
     * @return magnetic field strength expressed in Teslas (T).
     */
    public double getIntensity(
            final NEDPosition position, final Date time) {
<span class="fc" id="L1639">        return getIntensity(position.getLatitude(), position.getLongitude(),</span>
<span class="fc" id="L1640">                position.getHeight(), time);</span>
    }

    /**
     * Returns the horizontal magnetic field intensity from the
     * Department of Defense geomagnetic model and data expressed
     * in Teslas.
     * This method uses default altitude (0.0 - mean sea level) and time
     * (half way through the valid 5 year period of the model).
     *
     * @param latitude  latitude expressed in radians.
     * @param longitude longitude expressed in radians.
     * @return the horizontal magnetic field strength expressed in
     * Teslas (T).
     */
    public double getHorizontalIntensity(
            final double latitude, final double longitude) {
<span class="fc" id="L1657">        final double defaultTime = mModel.epoch</span>
                + WorldMagneticModel.LIFESPAN / 2.0;
<span class="fc" id="L1659">        calcGeoMag(Math.toDegrees(latitude), Math.toDegrees(longitude),</span>
                0.0, defaultTime);
<span class="fc" id="L1661">        return mBh * FROM_NANO;</span>
    }

    /**
     * Returns the horizontal magnetic field intensity from the
     * Department of Defense geomagnetic model and data expressed
     * in Teslas.
     * This method uses default altitude (0.0 - mean sea level) and time
     * (half way through the valid 5 year period of the model).
     *
     * @param latitude  latitude angle.
     * @param longitude longitude angle.
     * @return the horizontal magnetic field strength expressed in
     * Teslas (T).
     */
    public double getHorizontalIntensity(
            final Angle latitude, final Angle longitude) {
<span class="fc" id="L1678">        return getHorizontalIntensity(convertAngle(latitude),</span>
<span class="fc" id="L1679">                convertAngle(longitude));</span>
    }

    /**
     * Returns the horizontal magnetic field intensity from the
     * Department of Defense geomagnetic model and data expressed
     * in Teslas.
     *
     * @param latitude  latitude expressed in radians.
     * @param longitude longitude expressed in radians.
     * @param height    height expressed in meters.
     * @param year      year expressed in decimal years.
     * @return the horizontal magnetic field strength expressed in
     * Teslas (T).
     */
    public double getHorizontalIntensity(
            final double latitude, final double longitude,
            final double height, final double year) {
<span class="fc" id="L1697">        final double heightKm = DistanceConverter.convert(height,</span>
                DistanceUnit.METER,
                DistanceUnit.KILOMETER);
<span class="fc" id="L1700">        calcGeoMag(Math.toDegrees(latitude), Math.toDegrees(longitude),</span>
                heightKm, year);
<span class="fc" id="L1702">        return mBh * FROM_NANO;</span>
    }

    /**
     * Returns the horizontal magnetic field intensity from the
     * Department of Defense geomagnetic model and data expressed
     * in Teslas.
     *
     * @param latitude  latitude expressed in radians.
     * @param longitude longitude expressed in radians.
     * @param height    height expressed in meters.
     * @param calendar  a calendar containing a specific instant.
     * @return the horizontal magnetic field strength expressed in
     * Teslas (T).
     */
    public double getHorizontalIntensity(
            final double latitude, final double longitude,
            final double height, final GregorianCalendar calendar) {
<span class="fc" id="L1720">        return getHorizontalIntensity(latitude, longitude, height,</span>
<span class="fc" id="L1721">                convertTime(calendar));</span>
    }

    /**
     * Returns the horizontal magnetic field intensity from the
     * Department of Defense geomagnetic model and data expressed
     * in Teslas.
     *
     * @param latitude  latitude expressed in radians.
     * @param longitude longitude expressed in radians.
     * @param height    height expressed in meters.
     * @param time      a specific time instant.
     * @return the horizontal magnetic field strength expressed in
     * Teslas (T).
     */
    public double getHorizontalIntensity(
            final double latitude, final double longitude,
            final double height, final Date time) {
<span class="fc" id="L1739">        final GregorianCalendar calendar = new GregorianCalendar();</span>
<span class="fc" id="L1740">        calendar.setTime(time);</span>
<span class="fc" id="L1741">        return getHorizontalIntensity(latitude, longitude, height,</span>
                calendar);
    }

    /**
     * Returns the horizontal magnetic field intensity from the
     * Department of Defense geomagnetic model and data expressed
     * in Teslas.
     *
     * @param latitude  latitude angle.
     * @param longitude longitude angle.
     * @param height    height.
     * @param year      year expressed in decimal years.
     * @return the horizontal magnetic field strength expressed in
     * Teslas (T).
     */
    public double getHorizontalIntensity(
            final Angle latitude, final Angle longitude,
            final Distance height, final double year) {
<span class="fc" id="L1760">        return getHorizontalIntensity(convertAngle(latitude),</span>
<span class="fc" id="L1761">                convertAngle(longitude), convertDistance(height),</span>
                year);
    }

    /**
     * Returns the horizontal magnetic field intensity from the
     * Department of Defense geomagnetic model and data expressed
     * in Teslas.
     *
     * @param latitude  latitude angle.
     * @param longitude longitude angle.
     * @param height    height.
     * @param calendar  a calendar containing a specific instant.
     * @return the horizontal magnetic field strength expressed in
     * Teslas (T).
     */
    public double getHorizontalIntensity(
            final Angle latitude, final Angle longitude,
            final Distance height, final GregorianCalendar calendar) {
<span class="fc" id="L1780">        return getHorizontalIntensity(convertAngle(latitude),</span>
<span class="fc" id="L1781">                convertAngle(longitude), convertDistance(height),</span>
                calendar);
    }

    /**
     * Returns the horizontal magnetic field intensity from the
     * Department of Defense geomagnetic model and data expressed
     * in Teslas.
     *
     * @param latitude  latitude angle.
     * @param longitude longitude angle.
     * @param height    height.
     * @param time      a specific time instant.
     * @return the horizontal magnetic field strength expressed in
     * Teslas (T).
     */
    public double getHorizontalIntensity(
            final Angle latitude, final Angle longitude,
            final Distance height, final Date time) {
<span class="fc" id="L1800">        return getHorizontalIntensity(convertAngle(latitude),</span>
<span class="fc" id="L1801">                convertAngle(longitude), convertDistance(height),</span>
                time);
    }

    /**
     * Returns the horizontal magnetic field intensity from the
     * Department of Defense geomagnetic model and data expressed
     * in Teslas.
     *
     * @param position a position expressed in geodetic coordinates.
     * @param year     year expressed in decimal years.
     * @return the horizontal magnetic field strength expressed in
     * Teslas (T).
     */
    public double getHorizontalIntensity(
            final NEDPosition position, final double year) {
<span class="fc" id="L1817">        return getHorizontalIntensity(position.getLatitude(),</span>
<span class="fc" id="L1818">                position.getLongitude(), position.getHeight(), year);</span>
    }

    /**
     * Returns the horizontal magnetic field intensity from the
     * Department of Defense geomagnetic model and data expressed
     * in Teslas.
     *
     * @param position a position expressed in geodetic coordinates.
     * @param calendar a calendar containing a specific instant.
     * @return the horizontal magnetic field strength expressed in
     * Teslas (T).
     */
    public double getHorizontalIntensity(
            final NEDPosition position, final GregorianCalendar calendar) {
<span class="fc" id="L1833">        return getHorizontalIntensity(position.getLatitude(),</span>
<span class="fc" id="L1834">                position.getLongitude(), position.getHeight(), calendar);</span>
    }

    /**
     * Returns the horizontal magnetic field intensity from the
     * Department of Defense geomagnetic model and data expressed
     * in Teslas.
     *
     * @param position a position expressed in geodetic coordinates.
     * @param time     a specific time instant.
     * @return the horizontal magnetic field strength expressed in
     * Teslas (T).
     */
    public double getHorizontalIntensity(
            final NEDPosition position, final Date time) {
<span class="fc" id="L1849">        return getHorizontalIntensity(position.getLatitude(),</span>
<span class="fc" id="L1850">                position.getLongitude(), position.getHeight(), time);</span>
    }

    /**
     * Returns the vertical magnetic field intensity from the
     * Department of Defense geomagnetic model and data expressed
     * in Teslas.
     * This method uses default altitude (0.0 - mean sea level) and time
     * (half way through the valid 5 year period of the model).
     *
     * @param latitude  latitude expressed in radians.
     * @param longitude longitude expressed in radians.
     * @return the vertical magnetic field strength expressed in
     * Teslas (T).
     */
    public double getVerticalIntensity(
            final double latitude, final double longitude) {
<span class="fc" id="L1867">        final double defaultTime = mModel.epoch</span>
                + WorldMagneticModel.LIFESPAN / 2.0;
<span class="fc" id="L1869">        calcGeoMag(Math.toDegrees(latitude), Math.toDegrees(longitude),</span>
                0.0, defaultTime);
<span class="fc" id="L1871">        return mBz * FROM_NANO;</span>
    }

    /**
     * Returns the vertical magnetic field intensity from the
     * Department of Defense geomagnetic model and data expressed
     * in Teslas.
     * This method uses default altitude (0.0 - mean sea level) and time
     * (half way through the valid 5 year period of the model).
     *
     * @param latitude  latitude angle.
     * @param longitude longitude angle.
     * @return the vertical magnetic field strength expressed in
     * Teslas (T).
     */
    public double getVerticalIntensity(
            final Angle latitude, final Angle longitude) {
<span class="fc" id="L1888">        return getVerticalIntensity(convertAngle(latitude),</span>
<span class="fc" id="L1889">                convertAngle(longitude));</span>
    }

    /**
     * Returns the vertical magnetic field intensity from the
     * Department of Defense geomagnetic model and data expressed
     * in Teslas.
     *
     * @param latitude  latitude expressed in radians.
     * @param longitude longitude expressed in radians.
     * @param height    height expressed in meters.
     * @param year      year expressed in decimal years.
     * @return the vertical magnetic field strength expressed in
     * Teslas (T).
     */
    public double getVerticalIntensity(
            final double latitude, final double longitude,
            final double height, final double year) {
<span class="fc" id="L1907">        final double heightKm = DistanceConverter.convert(height,</span>
                DistanceUnit.METER,
                DistanceUnit.KILOMETER);
<span class="fc" id="L1910">        calcGeoMag(Math.toDegrees(latitude), Math.toDegrees(longitude),</span>
                heightKm, year);
<span class="fc" id="L1912">        return mBz * FROM_NANO;</span>
    }

    /**
     * Returns the vertical magnetic field intensity from the
     * Department of Defense geomagnetic model and data expressed
     * in Teslas.
     *
     * @param latitude  latitude expressed in radians.
     * @param longitude longitude expressed in radians.
     * @param height    height expressed in meters.
     * @param calendar  a calendar containing a specific instant.
     * @return the vertical magnetic field strength expressed in
     * Teslas (T).
     */
    public double getVerticalIntensity(
            final double latitude, final double longitude,
            final double height, final GregorianCalendar calendar) {
<span class="fc" id="L1930">        return getVerticalIntensity(latitude, longitude, height,</span>
<span class="fc" id="L1931">                convertTime(calendar));</span>
    }

    /**
     * Returns the vertical magnetic field intensity from the
     * Department of Defense geomagnetic model and data expressed
     * in Teslas.
     *
     * @param latitude  latitude expressed in radians.
     * @param longitude longitude expressed in radians.
     * @param height    height expressed in meters.
     * @param time      a specific time instant.
     * @return the vertical magnetic field strength expressed in
     * Teslas (T).
     */
    public double getVerticalIntensity(
            final double latitude, final double longitude,
            final double height, final Date time) {
<span class="fc" id="L1949">        final GregorianCalendar calendar = new GregorianCalendar();</span>
<span class="fc" id="L1950">        calendar.setTime(time);</span>
<span class="fc" id="L1951">        return getVerticalIntensity(latitude, longitude, height,</span>
                calendar);
    }

    /**
     * Returns the vertical magnetic field intensity from the
     * Department of Defense geomagnetic model and data expressed
     * in Teslas.
     *
     * @param latitude  latitude angle.
     * @param longitude longitude angle.
     * @param height    height.
     * @param year      year expressed in decimal years.
     * @return the vertical magnetic field strength expressed in
     * Teslas (T).
     */
    public double getVerticalIntensity(
            final Angle latitude, final Angle longitude,
            final Distance height, final double year) {
<span class="fc" id="L1970">        return getVerticalIntensity(convertAngle(latitude),</span>
<span class="fc" id="L1971">                convertAngle(longitude), convertDistance(height),</span>
                year);
    }

    /**
     * Returns the vertical magnetic field intensity from the
     * Department of Defense geomagnetic model and data expressed
     * in Teslas.
     *
     * @param latitude  latitude angle.
     * @param longitude longitude angle.
     * @param height    height.
     * @param calendar  a calendar containing a specific instant.
     * @return the vertical magnetic field strength expressed in
     * Teslas (T).
     */
    public double getVerticalIntensity(
            final Angle latitude, final Angle longitude,
            final Distance height, final GregorianCalendar calendar) {
<span class="fc" id="L1990">        return getVerticalIntensity(convertAngle(latitude),</span>
<span class="fc" id="L1991">                convertAngle(longitude), convertDistance(height),</span>
                calendar);
    }

    /**
     * Returns the vertical magnetic field intensity from the
     * Department of Defense geomagnetic model and data expressed
     * in Teslas.
     *
     * @param latitude  latitude angle.
     * @param longitude longitude angle.
     * @param height    height.
     * @param time      a specific time instant.
     * @return the vertical magnetic field strength expressed in
     * Teslas (T).
     */
    public double getVerticalIntensity(
            final Angle latitude, final Angle longitude,
            final Distance height, final Date time) {
<span class="fc" id="L2010">        return getVerticalIntensity(convertAngle(latitude),</span>
<span class="fc" id="L2011">                convertAngle(longitude), convertDistance(height),</span>
                time);
    }

    /**
     * Returns the vertical magnetic field intensity from the
     * Department of Defense geomagnetic model and data expressed
     * in Teslas.
     *
     * @param position a position expressed in geodetic coordinates.
     * @param year     year expressed in decimal years.
     * @return the vertical magnetic field strength expressed in
     * Teslas (T).
     */
    public double getVerticalIntensity(
            final NEDPosition position, final double year) {
<span class="fc" id="L2027">        return getVerticalIntensity(position.getLatitude(),</span>
<span class="fc" id="L2028">                position.getLongitude(), position.getHeight(), year);</span>
    }

    /**
     * Returns the vertical magnetic field intensity from the
     * Department of Defense geomagnetic model and data expressed
     * in Teslas.
     *
     * @param position a position expressed in geodetic coordinates.
     * @param calendar a calendar containing a specific instant.
     * @return the vertical magnetic field strength expressed in
     * Teslas (T).
     */
    public double getVerticalIntensity(
            final NEDPosition position, final GregorianCalendar calendar) {
<span class="fc" id="L2043">        return getVerticalIntensity(position.getLatitude(),</span>
<span class="fc" id="L2044">                position.getLongitude(), position.getHeight(), calendar);</span>
    }

    /**
     * Returns the vertical magnetic field intensity from the
     * Department of Defense geomagnetic model and data expressed
     * in Teslas.
     *
     * @param position a position expressed in geodetic coordinates.
     * @param time     a specific time instant.
     * @return the vertical magnetic field strength expressed in
     * Teslas (T).
     */
    public double getVerticalIntensity(
            final NEDPosition position, final Date time) {
<span class="fc" id="L2059">        return getVerticalIntensity(position.getLatitude(),</span>
<span class="fc" id="L2060">                position.getLongitude(), position.getHeight(), time);</span>
    }

    /**
     * Returns the northerly magnetic field intensity from the
     * Department of Defense geomagnetic model and data expressed
     * in Teslas.
     * This method uses default altitude (0.0 - mean sea level) and time
     * (half way through the valid 5 year period of the model).
     *
     * @param latitude  latitude expressed in radians.
     * @param longitude longitude expressed in radians.
     * @return the northerly component of the magnetic field strength
     * expressed in Teslas (T).
     */
    public double getNorthIntensity(
            final double latitude, final double longitude) {
<span class="fc" id="L2077">        final double defaultTime = mModel.epoch</span>
                + WorldMagneticModel.LIFESPAN / 2.0;
<span class="fc" id="L2079">        calcGeoMag(Math.toDegrees(latitude), Math.toDegrees(longitude),</span>
                0.0, defaultTime);
<span class="fc" id="L2081">        return mBx * FROM_NANO;</span>
    }

    /**
     * Returns the northerly magnetic field intensity from the
     * Department of Defense geomagnetic model and data expressed
     * in Teslas.
     * This method uses default altitude (0.0 - mean sea level) and time
     * (half way through the valid 5 year period of the model).
     *
     * @param latitude  latitude angle.
     * @param longitude longitude angle.
     * @return the northerly component of the magnetic field strength
     * expressed in Teslas (T).
     */
    public double getNorthIntensity(
            final Angle latitude, final Angle longitude) {
<span class="fc" id="L2098">        return getNorthIntensity(convertAngle(latitude),</span>
<span class="fc" id="L2099">                convertAngle(longitude));</span>
    }

    /**
     * Returns the northerly magnetic field intensity from the
     * Department of Defense geomagnetic model and data expressed
     * in Teslas.
     *
     * @param latitude  latitude expressed in radians.
     * @param longitude longitude expressed in radians.
     * @param height    height expressed in meters.
     * @param year      year expressed in decimal years.
     * @return the northerly component of the magnetic field strength
     * expressed in Teslas (T).
     */
    public double getNorthIntensity(
            final double latitude, final double longitude,
            final double height, final double year) {
<span class="fc" id="L2117">        final double heightKm = DistanceConverter.convert(height,</span>
                DistanceUnit.METER,
                DistanceUnit.KILOMETER);
<span class="fc" id="L2120">        calcGeoMag(Math.toDegrees(latitude), Math.toDegrees(longitude),</span>
                heightKm, year);
<span class="fc" id="L2122">        return mBx * FROM_NANO;</span>
    }

    /**
     * Returns the northerly magnetic field intensity from the
     * Department of Defense geomagnetic model and data expressed
     * in Teslas.
     *
     * @param latitude  latitude expressed in radians.
     * @param longitude longitude expressed in radians.
     * @param height    height expressed in meters.
     * @param calendar  a calendar containing a specific instant.
     * @return the northerly component of the magnetic field strength
     * expressed in Teslas (T).
     */
    public double getNorthIntensity(
            final double latitude, final double longitude,
            final double height, final GregorianCalendar calendar) {
<span class="fc" id="L2140">        return getNorthIntensity(latitude, longitude, height,</span>
<span class="fc" id="L2141">                convertTime(calendar));</span>
    }

    /**
     * Returns the northerly magnetic field intensity from the
     * Department of Defense geomagnetic model and data expressed
     * in Teslas.
     *
     * @param latitude  latitude expressed in radians.
     * @param longitude longitude expressed in radians.
     * @param height    height expressed in meters.
     * @param time      a specific time instant.
     * @return the northerly component of the magnetic field strength
     * expressed in Teslas (T).
     */
    public double getNorthIntensity(
            final double latitude, final double longitude,
            final double height, final Date time) {
<span class="fc" id="L2159">        final GregorianCalendar calendar = new GregorianCalendar();</span>
<span class="fc" id="L2160">        calendar.setTime(time);</span>
<span class="fc" id="L2161">        return getNorthIntensity(latitude, longitude, height,</span>
                calendar);
    }

    /**
     * Returns the northerly magnetic field intensity from the
     * Department of Defense geomagnetic model and data expressed
     * in Teslas.
     *
     * @param latitude  latitude angle.
     * @param longitude longitude angle.
     * @param height    height.
     * @param year      year expressed in decimal years.
     * @return the northerly component of the magnetic field strength
     * expressed in Teslas (T).
     */
    public double getNorthIntensity(
            final Angle latitude, final Angle longitude,
            final Distance height, final double year) {
<span class="fc" id="L2180">        return getNorthIntensity(convertAngle(latitude),</span>
<span class="fc" id="L2181">                convertAngle(longitude), convertDistance(height),</span>
                year);
    }

    /**
     * Returns the northerly magnetic field intensity from the
     * Department of Defense geomagnetic model and data expressed
     * in Teslas.
     *
     * @param latitude  latitude angle.
     * @param longitude longitude angle.
     * @param height    height.
     * @param calendar  a calendar containing a specific instant.
     * @return the northerly component of the magnetic field strength
     * expressed in Teslas (T).
     */
    public double getNorthIntensity(
            final Angle latitude, final Angle longitude,
            final Distance height, final GregorianCalendar calendar) {
<span class="fc" id="L2200">        return getNorthIntensity(convertAngle(latitude),</span>
<span class="fc" id="L2201">                convertAngle(longitude), convertDistance(height),</span>
                calendar);
    }

    /**
     * Returns the northerly magnetic field intensity from the
     * Department of Defense geomagnetic model and data expressed
     * in Teslas.
     *
     * @param latitude  latitude angle.
     * @param longitude longitude angle.
     * @param height    height.
     * @param time      a specific time instant.
     * @return the northerly component of the magnetic field strength
     * expressed in Teslas (T).
     */
    public double getNorthIntensity(
            final Angle latitude, final Angle longitude,
            final Distance height, final Date time) {
<span class="fc" id="L2220">        return getNorthIntensity(convertAngle(latitude),</span>
<span class="fc" id="L2221">                convertAngle(longitude), convertDistance(height),</span>
                time);
    }

    /**
     * Returns the northerly magnetic field intensity from the
     * Department of Defense geomagnetic model and data expressed
     * in Teslas.
     *
     * @param position a position expressed in geodetic coordinates.
     * @param year     year expressed in decimal years.
     * @return the northerly component of the magnetic field strength
     * expressed in Teslas (T).
     */
    public double getNorthIntensity(
            final NEDPosition position, final double year) {
<span class="fc" id="L2237">        return getNorthIntensity(position.getLatitude(),</span>
<span class="fc" id="L2238">                position.getLongitude(), position.getHeight(), year);</span>
    }

    /**
     * Returns the northerly magnetic field intensity from the
     * Department of Defense geomagnetic model and data expressed
     * in Teslas.
     *
     * @param position a position expressed in geodetic coordinates.
     * @param calendar a calendar containing a specific instant.
     * @return the northerly component of the magnetic field strength
     * expressed in Teslas (T).
     */
    public double getNorthIntensity(
            final NEDPosition position, final GregorianCalendar calendar) {
<span class="fc" id="L2253">        return getNorthIntensity(position.getLatitude(),</span>
<span class="fc" id="L2254">                position.getLongitude(), position.getHeight(), calendar);</span>
    }

    /**
     * Returns the northerly magnetic field intensity from the
     * Department of Defense geomagnetic model and data expressed
     * in Teslas.
     *
     * @param position a position expressed in geodetic coordinates.
     * @param time     a specific time instant.
     * @return the northerly component of the magnetic field strength
     * expressed in Teslas (T).
     */
    public double getNorthIntensity(
            final NEDPosition position, final Date time) {
<span class="fc" id="L2269">        return getNorthIntensity(position.getLatitude(),</span>
<span class="fc" id="L2270">                position.getLongitude(), position.getHeight(), time);</span>
    }

    /**
     * Returns the easterly magnetic field intensity from the
     * Department of Defense geomagnetic model and data expressed
     * in nano Teslas.
     * This method uses default altitude (0.0 - mean sea level) and time
     * (half way through the valid 5 year period of the model).
     *
     * @param latitude  latitude expressed in radians.
     * @param longitude longitude expressed in radians.
     * @return the easterly component of the magnetic field strength
     * expressed in Teslas (T).
     */
    public double getEastIntensity(
            final double latitude, final double longitude) {
<span class="fc" id="L2287">        final double defaultTime = mModel.epoch</span>
                + WorldMagneticModel.LIFESPAN / 2.0;
<span class="fc" id="L2289">        calcGeoMag(Math.toDegrees(latitude), Math.toDegrees(longitude),</span>
                0.0, defaultTime);
<span class="fc" id="L2291">        return mBy * FROM_NANO;</span>
    }

    /**
     * Returns the easterly magnetic field intensity from the
     * Department of Defense geomagnetic model and data expressed
     * in nano Teslas.
     * This method uses default altitude (0.0 - mean sea level) and time
     * (half way through the valid 5 year period of the model).
     *
     * @param latitude  latitude angle.
     * @param longitude longitude angle.
     * @return the easterly component of the magnetic field strength
     * expressed in Teslas (T).
     */
    public double getEastIntensity(
            final Angle latitude, final Angle longitude) {
<span class="fc" id="L2308">        return getEastIntensity(convertAngle(latitude),</span>
<span class="fc" id="L2309">                convertAngle(longitude));</span>
    }

    /**
     * Returns the easterly magnetic field intensity from the
     * Department of Defense geomagnetic model and data expressed
     * in nano Teslas.
     *
     * @param latitude  latitude expressed in radians.
     * @param longitude longitude expressed in radians.
     * @param height    height expressed in meters.
     * @param year      year expressed in decimal years.
     * @return the easterly component of the magnetic field strength
     * expressed in Teslas (T).
     */
    public double getEastIntensity(
            final double latitude, final double longitude,
            final double height, final double year) {
<span class="fc" id="L2327">        final double heightKm = DistanceConverter.convert(height,</span>
                DistanceUnit.METER,
                DistanceUnit.KILOMETER);
<span class="fc" id="L2330">        calcGeoMag(Math.toDegrees(latitude), Math.toDegrees(longitude),</span>
                heightKm, year);
<span class="fc" id="L2332">        return mBy * FROM_NANO;</span>
    }

    /**
     * Returns the easterly magnetic field intensity from the
     * Department of Defense geomagnetic model and data expressed
     * in nano Teslas.
     *
     * @param latitude  latitude expressed in radians.
     * @param longitude longitude expressed in radians.
     * @param height    height expressed in meters.
     * @param calendar  a calendar containing a specific instant.
     * @return the easterly component of the magnetic field strength
     * expressed in Teslas (T).
     */
    public double getEastIntensity(
            final double latitude, final double longitude,
            final double height, final GregorianCalendar calendar) {
<span class="fc" id="L2350">        return getEastIntensity(latitude, longitude, height,</span>
<span class="fc" id="L2351">                convertTime(calendar));</span>
    }

    /**
     * Returns the easterly magnetic field intensity from the
     * Department of Defense geomagnetic model and data expressed
     * in nano Teslas.
     *
     * @param latitude  latitude expressed in radians.
     * @param longitude longitude expressed in radians.
     * @param height    height expressed in meters.
     * @param time      a specific time instant.
     * @return the easterly component of the magnetic field strength
     * expressed in Teslas (T).
     */
    public double getEastIntensity(
            final double latitude, final double longitude,
            final double height, final Date time) {
<span class="fc" id="L2369">        final GregorianCalendar calendar = new GregorianCalendar();</span>
<span class="fc" id="L2370">        calendar.setTime(time);</span>
<span class="fc" id="L2371">        return getEastIntensity(latitude, longitude, height, calendar);</span>
    }

    /**
     * Returns the easterly magnetic field intensity from the
     * Department of Defense geomagnetic model and data expressed
     * in nano Teslas.
     *
     * @param latitude  latitude angle.
     * @param longitude longitude angle.
     * @param height    height.
     * @param year      year expressed in decimal years.
     * @return the easterly component of the magnetic field strength
     * expressed in Teslas (T).
     */
    public double getEastIntensity(
            final Angle latitude, final Angle longitude,
            final Distance height, final double year) {
<span class="fc" id="L2389">        return getEastIntensity(convertAngle(latitude),</span>
<span class="fc" id="L2390">                convertAngle(longitude), convertDistance(height),</span>
                year);
    }

    /**
     * Returns the easterly magnetic field intensity from the
     * Department of Defense geomagnetic model and data expressed
     * in nano Teslas.
     *
     * @param latitude  latitude angle.
     * @param longitude longitude angle.
     * @param height    height.
     * @param calendar  a calendar containing a specific instant.
     * @return the easterly component of the magnetic field strength
     * expressed in Teslas (T).
     */
    public double getEastIntensity(
            final Angle latitude, final Angle longitude,
            final Distance height, final GregorianCalendar calendar) {
<span class="fc" id="L2409">        return getEastIntensity(convertAngle(latitude),</span>
<span class="fc" id="L2410">                convertAngle(longitude),</span>
<span class="fc" id="L2411">                convertDistance(height), calendar);</span>
    }

    /**
     * Returns the easterly magnetic field intensity from the
     * Department of Defense geomagnetic model and data expressed
     * in nano Teslas.
     *
     * @param latitude  latitude angle.
     * @param longitude longitude angle.
     * @param height    height.
     * @param time      a specific time instant.
     * @return the easterly component of the magnetic field strength
     * expressed in Teslas (T).
     */
    public double getEastIntensity(
            final Angle latitude, final Angle longitude,
            final Distance height, final Date time) {
<span class="fc" id="L2429">        return getEastIntensity(convertAngle(latitude),</span>
<span class="fc" id="L2430">                convertAngle(longitude), convertDistance(height),</span>
                time);
    }

    /**
     * Returns the easterly magnetic field intensity from the
     * Department of Defense geomagnetic model and data expressed
     * in nano Teslas.
     *
     * @param position a position expressed in geodetic coordinates.
     * @param year     year expressed in decimal years.
     * @return the easterly component of the magnetic field strength
     * expressed in Teslas (T).
     */
    public double getEastIntensity(
            final NEDPosition position, final double year) {
<span class="fc" id="L2446">        return getEastIntensity(position.getLatitude(),</span>
<span class="fc" id="L2447">                position.getLongitude(), position.getHeight(), year);</span>
    }

    /**
     * Returns the easterly magnetic field intensity from the
     * Department of Defense geomagnetic model and data expressed
     * in nano Teslas.
     *
     * @param position a position expressed in geodetic coordinates.
     * @param calendar a calendar containing a specific instant.
     * @return the easterly component of the magnetic field strength
     * expressed in Teslas (T).
     */
    public double getEastIntensity(
            final NEDPosition position, final GregorianCalendar calendar) {
<span class="fc" id="L2462">        return getEastIntensity(position.getLatitude(),</span>
<span class="fc" id="L2463">                position.getLongitude(), position.getHeight(), calendar);</span>
    }

    /**
     * Returns the easterly magnetic field intensity from the
     * Department of Defense geomagnetic model and data expressed
     * in nano Teslas.
     *
     * @param position a position expressed in geodetic coordinates.
     * @param time     a specific time instant.
     * @return the easterly component of the magnetic field strength
     * expressed in Teslas (T).
     */
    public double getEastIntensity(
            final NEDPosition position, final Date time) {
<span class="fc" id="L2478">        return getEastIntensity(position.getLatitude(),</span>
<span class="fc" id="L2479">                position.getLongitude(), position.getHeight(), time);</span>
    }

    /**
     * Estimates Earth magnetic flux density.
     * This method uses default altitude (0.0 - mean sea level) and time
     * (half way through the valid 5 year period of the model).
     *
     * @param latitude  latitude expressed in radians.
     * @param longitude longitude expressed in radians.
     * @param result    instance where magnetic flux will be stored resolved
     *                  around NED frame.
     */
    public void estimate(
            final double latitude, final double longitude,
            final NEDMagneticFluxDensity result) {
<span class="nc" id="L2495">        final double defaultTime = mModel.epoch</span>
                + WorldMagneticModel.LIFESPAN / 2.0;
<span class="nc" id="L2497">        calcGeoMag(Math.toDegrees(latitude), Math.toDegrees(longitude),</span>
                0.0, defaultTime);
<span class="nc" id="L2499">        final double bn = mBx * FROM_NANO;</span>
<span class="nc" id="L2500">        final double be = mBy * FROM_NANO;</span>
<span class="nc" id="L2501">        final double bd = mBz * FROM_NANO;</span>

<span class="nc" id="L2503">        result.setCoordinates(bn, be, bd);</span>
<span class="nc" id="L2504">    }</span>

    /**
     * Estimates Earth magnetic flux density.
     * This method uses default altitude (0.0 - mean sea level) and time
     * (half way through the valid 5 year period of the model).
     *
     * @param latitude  latitude expressed in radians.
     * @param longitude longitude expressed in radians.
     * @return Earth magnetic flux density resolved around NED frame.
     */
    public NEDMagneticFluxDensity estimate(
            final double latitude, final double longitude) {
<span class="nc" id="L2517">        final NEDMagneticFluxDensity result = new NEDMagneticFluxDensity();</span>
<span class="nc" id="L2518">        estimate(latitude, longitude, result);</span>
<span class="nc" id="L2519">        return result;</span>
    }

    /**
     * Estimates Earth magnetic flux density.
     * This method uses default altitude (0.0 - mean sea level) and time
     * (half way through the valid 5 year period of the model).
     *
     * @param latitude  latitude angle.
     * @param longitude longitude angle.
     * @param result    instance where magnetic flux will be stored resolved
     *                  around NED frame.
     */
    public void estimate(
            final Angle latitude, final Angle longitude,
            final NEDMagneticFluxDensity result) {
<span class="nc" id="L2535">        estimate(convertAngle(latitude), convertAngle(longitude),</span>
                result);
<span class="nc" id="L2537">    }</span>

    /**
     * Estimates Earth magnetic flux density.
     * This method uses default altitude (0.0 - mean sea level) and time
     * (half way through the valid 5 year period of the model).
     *
     * @param latitude  latitude angle.
     * @param longitude longitude angle.
     * @return Earth magnetic flux density resolved around NED frame.
     */
    public NEDMagneticFluxDensity estimate(
            final Angle latitude, final Angle longitude) {
<span class="nc" id="L2550">        return estimate(convertAngle(latitude), convertAngle(longitude));</span>
    }

    /**
     * Estimates Earth magnetic flux density.
     *
     * @param latitude  latitude expressed in radians.
     * @param longitude longitude expressed in radians.
     * @param height    height expressed in meters.
     * @param year      year expressed in decimal years.
     * @param result    instance where magnetic flux will be stored resolved
     *                  around NED frame.
     */
    public void estimate(
            final double latitude, final double longitude,
            final double height, final double year,
            final NEDMagneticFluxDensity result) {

<span class="fc" id="L2568">        final double heightKm = DistanceConverter.convert(height,</span>
                DistanceUnit.METER,
                DistanceUnit.KILOMETER);
<span class="fc" id="L2571">        calcGeoMag(Math.toDegrees(latitude), Math.toDegrees(longitude),</span>
                heightKm, year);
<span class="fc" id="L2573">        final double bn = mBx * FROM_NANO;</span>
<span class="fc" id="L2574">        final double be = mBy * FROM_NANO;</span>
<span class="fc" id="L2575">        final double bd = mBz * FROM_NANO;</span>

<span class="fc" id="L2577">        result.setCoordinates(bn, be, bd);</span>
<span class="fc" id="L2578">    }</span>

    /**
     * Estimates Earth magnetic flux density.
     *
     * @param latitude  latitude expressed in radians.
     * @param longitude longitude expressed in radians.
     * @param height    height expressed in meters.
     * @param year      year expressed in decimal years.
     * @return Earth magnetic flux density resolved around NED frame.
     */
    public NEDMagneticFluxDensity estimate(
            final double latitude, final double longitude,
            final double height, final double year) {
<span class="nc" id="L2592">        final NEDMagneticFluxDensity result = new NEDMagneticFluxDensity();</span>
<span class="nc" id="L2593">        estimate(latitude, longitude, height, year, result);</span>
<span class="nc" id="L2594">        return result;</span>
    }

    /**
     * Estimates Earth magnetic flux density.
     *
     * @param latitude  latitude expressed in radians.
     * @param longitude longitude expressed in radians.
     * @param height    height expressed in meters.
     * @param calendar  a calendar containing a specific instant.
     * @param result    instance where magnetic flux will be stored resolved
     *                  around NED frame.
     */
    public void estimate(
            final double latitude, final double longitude,
            final double height, final GregorianCalendar calendar,
            final NEDMagneticFluxDensity result) {
<span class="fc" id="L2611">        estimate(latitude, longitude, height, convertTime(calendar),</span>
                result);
<span class="fc" id="L2613">    }</span>

    /**
     * Estimates Earth magnetic flux density.
     *
     * @param latitude  latitude expressed in radians.
     * @param longitude longitude expressed in radians.
     * @param height    height expressed in meters.
     * @param calendar  a calendar containing a specific instant.
     * @return Earth magnetic flux density resolved around NED frame.
     */
    public NEDMagneticFluxDensity estimate(
            final double latitude, final double longitude,
            final double height, final GregorianCalendar calendar) {
<span class="nc" id="L2627">        final NEDMagneticFluxDensity result = new NEDMagneticFluxDensity();</span>
<span class="nc" id="L2628">        estimate(latitude, longitude, height, calendar, result);</span>
<span class="nc" id="L2629">        return result;</span>
    }

    /**
     * Estimates Earth magnetic flux density.
     *
     * @param latitude  latitude expressed in radians.
     * @param longitude longitude expressed in radians.
     * @param height    height expressed in meters.
     * @param time      a specific time instant.
     * @param result    instance where magnetic flux will be stored resolved
     *                  around NED frame.
     */
    public void estimate(
            final double latitude, final double longitude,
            final double height, final Date time,
            final NEDMagneticFluxDensity result) {
<span class="fc" id="L2646">        final GregorianCalendar calendar = new GregorianCalendar();</span>
<span class="fc" id="L2647">        calendar.setTime(time);</span>
<span class="fc" id="L2648">        estimate(latitude, longitude, height, calendar, result);</span>
<span class="fc" id="L2649">    }</span>

    /**
     * Estimates Earth magnetic flux density.
     *
     * @param latitude  latitude expressed in radians.
     * @param longitude longitude expressed in radians.
     * @param height    height expressed in meters.
     * @param time      a specific time instant.
     * @return Earth magnetic flux density resolved around NED frame.
     */
    public NEDMagneticFluxDensity estimate(
            final double latitude, final double longitude,
            final double height, final Date time) {
<span class="nc" id="L2663">        final NEDMagneticFluxDensity result = new NEDMagneticFluxDensity();</span>
<span class="nc" id="L2664">        estimate(latitude, longitude, height, time, result);</span>
<span class="nc" id="L2665">        return result;</span>
    }

    /**
     * Estimates Earth magnetic flux density.
     *
     * @param latitude  latitude angle.
     * @param longitude longitude angle.
     * @param height    height.
     * @param year      year expressed in decimal years.
     * @param result    instance where magnetic flux will be stored resolved
     *                  around NED frame.
     */
    public void estimate(
            final Angle latitude, final Angle longitude,
            final Distance height, final double year,
            final NEDMagneticFluxDensity result) {
<span class="nc" id="L2682">        estimate(convertAngle(latitude), convertAngle(longitude),</span>
<span class="nc" id="L2683">                convertDistance(height), year, result);</span>
<span class="nc" id="L2684">    }</span>

    /**
     * Estimates Earth magnetic flux density.
     *
     * @param latitude  latitude angle.
     * @param longitude longitude angle.
     * @param height    height.
     * @param year      year expressed in decimal years.
     * @return Earth magnetic flux density resolved around NED frame.
     */
    public NEDMagneticFluxDensity estimate(
            final Angle latitude, final Angle longitude,
            final Distance height, final double year) {
<span class="nc" id="L2698">        final NEDMagneticFluxDensity result = new NEDMagneticFluxDensity();</span>
<span class="nc" id="L2699">        estimate(latitude, longitude, height, year, result);</span>
<span class="nc" id="L2700">        return result;</span>
    }

    /**
     * Estimates Earth magnetic flux density.
     *
     * @param latitude  latitude angle.
     * @param longitude longitude angle.
     * @param height    height.
     * @param calendar  a calendar containing a specific instant.
     * @param result    instance where magnetic flux will be stored resolved
     *                  around NED frame.
     */
    public void estimate(
            final Angle latitude, final Angle longitude,
            final Distance height, final GregorianCalendar calendar,
            final NEDMagneticFluxDensity result) {
<span class="nc" id="L2717">        estimate(convertAngle(latitude), convertAngle(longitude),</span>
<span class="nc" id="L2718">                convertDistance(height), calendar, result);</span>
<span class="nc" id="L2719">    }</span>

    /**
     * Estimates Earth magnetic flux density.
     *
     * @param latitude  latitude angle.
     * @param longitude longitude angle.
     * @param height    height.
     * @param calendar  a calendar containing a specific instant.
     * @return Earth magnetic flux density resolved around NED frame.
     */
    public NEDMagneticFluxDensity estimate(
            final Angle latitude, final Angle longitude,
            final Distance height, final GregorianCalendar calendar) {
<span class="nc" id="L2733">        final NEDMagneticFluxDensity result = new NEDMagneticFluxDensity();</span>
<span class="nc" id="L2734">        estimate(latitude, longitude, height, calendar, result);</span>
<span class="nc" id="L2735">        return result;</span>
    }

    /**
     * Estimates Earth magnetic flux density.
     *
     * @param latitude  latitude angle.
     * @param longitude longitude angle.
     * @param height    height.
     * @param time      a specific time instant.
     * @param result    instance where magnetic flux will be stored resolved
     *                  around NED frame.
     */
    public void estimate(
            final Angle latitude, final Angle longitude,
            final Distance height, final Date time,
            final NEDMagneticFluxDensity result) {
<span class="nc" id="L2752">        estimate(convertAngle(latitude), convertAngle(longitude),</span>
<span class="nc" id="L2753">                convertDistance(height), time, result);</span>
<span class="nc" id="L2754">    }</span>

    /**
     * Estimates Earth magnetic flux density.
     *
     * @param latitude  latitude angle.
     * @param longitude longitude angle.
     * @param height    height.
     * @param time      a specific time instant.
     * @return Earth magnetic flux density resolved around NED frame.
     */
    public NEDMagneticFluxDensity estimate(
            final Angle latitude, final Angle longitude,
            final Distance height, final Date time) {
<span class="nc" id="L2768">        final NEDMagneticFluxDensity result = new NEDMagneticFluxDensity();</span>
<span class="nc" id="L2769">        estimate(latitude, longitude, height, time, result);</span>
<span class="nc" id="L2770">        return result;</span>
    }

    /**
     * Estimates Earth magnetic flux density.
     *
     * @param position a position expressed in geodetic coordinates.
     * @param year     year expressed in decimal years.
     * @param result   instance where magnetic flux will be stored resolved
     *                 around NED frame.
     */
    public void estimate(
            final NEDPosition position, final double year,
            final NEDMagneticFluxDensity result) {
<span class="fc" id="L2784">        estimate(position.getLatitude(), position.getLongitude(),</span>
<span class="fc" id="L2785">                position.getHeight(), year, result);</span>
<span class="fc" id="L2786">    }</span>

    /**
     * Estimates Earth magnetic flux density.
     *
     * @param position a position expressed in geodetic coordinates.
     * @param year     year expressed in decimal years.
     * @return Earth magnetic flux density resolved around NED frame.
     */
    public NEDMagneticFluxDensity estimate(
            final NEDPosition position, final double year) {
<span class="fc" id="L2797">        final NEDMagneticFluxDensity result = new NEDMagneticFluxDensity();</span>
<span class="fc" id="L2798">        estimate(position, year, result);</span>
<span class="fc" id="L2799">        return result;</span>
    }

    /**
     * Estimates Earth magnetic flux density.
     *
     * @param position a position expressed in geodetic coordinates.
     * @param calendar a calendar containing a specific instant.
     * @param result   instance where magnetic flux will be stored resolved
     *                 around NED frame.
     */
    public void estimate(
            final NEDPosition position, final GregorianCalendar calendar,
            final NEDMagneticFluxDensity result) {
<span class="fc" id="L2813">        estimate(position.getLatitude(), position.getLongitude(),</span>
<span class="fc" id="L2814">                position.getHeight(), calendar, result);</span>
<span class="fc" id="L2815">    }</span>

    /**
     * Estimates Earth magnetic flux density.
     *
     * @param position a position expressed in geodetic coordinates.
     * @param calendar a calendar containing a specific instant.
     * @return Earth magnetic flux density resolved around NED frame.
     */
    public NEDMagneticFluxDensity estimate(
            final NEDPosition position, final GregorianCalendar calendar) {
<span class="fc" id="L2826">        final NEDMagneticFluxDensity result = new NEDMagneticFluxDensity();</span>
<span class="fc" id="L2827">        estimate(position, calendar, result);</span>
<span class="fc" id="L2828">        return result;</span>
    }

    /**
     * Estimates Earth magnetic flux density.
     *
     * @param position a position expressed in geodetic coordinates.
     * @param time     a specific time instant.
     * @param result   instance where magnetic flux will be stored resolved
     *                 around NED frame.
     */
    public void estimate(
            final NEDPosition position, final Date time,
            final NEDMagneticFluxDensity result) {
<span class="fc" id="L2842">        estimate(position.getLatitude(), position.getLongitude(),</span>
<span class="fc" id="L2843">                position.getHeight(), time, result);</span>
<span class="fc" id="L2844">    }</span>

    /**
     * Estimates Earth magnetic flux density.
     *
     * @param position a position expressed in geodetic coordinates.
     * @param time     a specific time instant.
     * @return Earth magnetic flux density resolved around NED frame.
     */
    public NEDMagneticFluxDensity estimate(
            final NEDPosition position, final Date time) {
<span class="fc" id="L2855">        final NEDMagneticFluxDensity result = new NEDMagneticFluxDensity();</span>
<span class="fc" id="L2856">        estimate(position, time, result);</span>
<span class="fc" id="L2857">        return result;</span>
    }

    /**
     * Converts a time instant contained in a gregorian calendar to a
     * decimal year.
     *
     * @param calendar calendar containing a specific instant to be
     *                 converted.
     * @return converted value expressed in decimal years.
     */
    public static double convertTime(final GregorianCalendar calendar) {
<span class="fc" id="L2869">        final int year = calendar.get(Calendar.YEAR);</span>
        final double daysInYear;
<span class="fc bfc" id="L2871" title="All 2 branches covered.">        if (calendar.isLeapYear(year)) {</span>
<span class="fc" id="L2872">            daysInYear = 366.0;</span>
        } else {
<span class="fc" id="L2874">            daysInYear = 365.0;</span>
        }

<span class="fc" id="L2877">        return year + calendar.get(Calendar.DAY_OF_YEAR) / daysInYear;</span>
    }

    /**
     * Computes the declination (dec), inclination (dip), total intensity
     * (TI) and grid variation (GV - polar regions only, referenced to grid
     * north of polar stereographic projection) of the Earth's magnetic field
     * in geodetic coordinates from the coefficients of the current official
     * department of defense (DoD) spherical harmonic World Magnetic Model
     * (WMM-2010).  The WMM series of models is updated every 5 years on
     * January 1st of those years which are divisible by 5 (i.e. 1980, 1985,
     * 1990, etc.) by the Navan Oceanographic Office in cooperation with the
     * British Geological Survey (BGS). The model is based on geomagnetic
     * survey measurements from aircraft, satellite and geomagnetic
     * observatories.
     *
     * Accuracy:
     * In ocean areas at the Earth's surface over the entire 5 year life of
     * a degree and order 12 spherical harmonic model such as WMM-95, the
     * estimated RMS errors for the various magnetic components are:
     *     DEC  - 0.5 degrees
     *     DIP  - 0.5 degrees
     *     TI   - 200.0 nano Teslas (nT)
     *     GV   - 0.5 Degrees
     *
     * Other magnetic components that can be derived from these four by
     * simple trigonometric relations will have the following approximate
     * errors over ocean areas:
     *     X    - 140 nT (North)
     *     Y    - 140 nT (East)
     *     Z    - 200 nT (Vertical) Positive is down
     *     H    - 200 nT (Horizontal)
     *
     * Over land the RMS errors are expected to be somewhat higher, although
     * the RMS errors for DEC, DIP and GV are still estimated to be less than
     * 0.5 degree, for the entire 5-year life of the model at the Earth's
     * surface. The other component errors over land are more difficult to
     * estimate and so are not given.
     *
     * The accuracy at any given time of all four geomagnetic parameters
     * depends on the geomagnetic latitude. The errors are least at the
     * equator and greatest at the magnetic poles.
     *
     * It is very important to note that a degree and order 12 model, such
     * as WMM-2010 describes only the long wavelength spatial magnetic
     * fluctuations due to Earth's core. Not included in the WMM series
     * models are intermediate and short wavelength spatial fluctuations of
     * the geomagnetic field which originate in the Earth's mantle and crust.
     * Consequently, isolated angular errors at various positions on the
     * surface (primarily over land, in continental margins and over oceanic
     * seamounts, ridges and trenches) of several degrees may be expected.
     * Also not included in the model are nonsecular temporal fluctuations
     * of the geomagnetic field of magnetospheric and ionospheric origin.
     * During magnetic storms, temporal fluctuations can cause substantial
     * deviations of the geomagnetic field from model values. In arctic and
     * antarctic regions, as well as in equatorial regions, deviations from
     * model values are both frequent and persistent.
     *
     * If the required declination accuracy is more stringent than the WMM
     * series of models provide, then the user is advised to request special
     * (regional or local) surveys be performed and models prepared by the
     * USGS, which operates the US geomagnetic observatories.
     *
     * @param latitude  the latitude in decimal degrees.
     * @param longitude the longitude in decimal degrees.
     * @param height    the height (altitude) in kilometers.
     * @param year      the date as a decimal year.
     */
    private void calcGeoMag(
            final double latitude,
            final double longitude,
            final double height,
            final double year) {

<span class="fc" id="L2951">        final double dt = year - mModel.epoch;</span>
<span class="fc" id="L2952">        final double rlon = Math.toRadians(longitude);</span>
<span class="fc" id="L2953">        final double rlat = Math.toRadians(latitude);</span>
<span class="fc" id="L2954">        final double srlon = Math.sin(rlon);</span>
<span class="fc" id="L2955">        final double srlat = Math.sin(rlat);</span>
<span class="fc" id="L2956">        final double crlon = Math.cos(rlon);</span>
<span class="fc" id="L2957">        final double crlat = Math.cos(rlat);</span>
<span class="fc" id="L2958">        final double srlat2 = srlat * srlat;</span>
<span class="fc" id="L2959">        final double crlat2 = crlat * crlat;</span>
<span class="fc" id="L2960">        mSp[1] = srlon;</span>
<span class="fc" id="L2961">        mCp[1] = crlon;</span>

        // Convert from geodetic coords to spherical coords.
<span class="pc bpc" id="L2964" title="1 of 6 branches missed.">        if (mOldHeight == null || height != mOldHeight</span>
<span class="fc bfc" id="L2965" title="All 2 branches covered.">                || mOldLatitude == null || latitude != mOldLatitude) {</span>
<span class="fc" id="L2966">            final double q = Math.sqrt(mA2 - mC2 * srlat2);</span>
<span class="fc" id="L2967">            final double q1 = height * q;</span>
<span class="fc" id="L2968">            final double q2 = ((q1 + mA2) / (q1 + mB2)) * ((q1 + mA2) / (q1 + mB2));</span>
<span class="fc" id="L2969">            mCt = srlat / Math.sqrt(q2 * crlat2 + srlat2);</span>
<span class="fc" id="L2970">            mSt = Math.sqrt(1.0 - (mCt * mCt));</span>
<span class="fc" id="L2971">            final double r2 = ((height * height) + 2.0 * q1 + (mA4 - mC4 * srlat2) / (q * q));</span>
<span class="fc" id="L2972">            mR = Math.sqrt(r2);</span>
<span class="fc" id="L2973">            final double mD = Math.sqrt(mA2 * crlat2 + mB2 * srlat2);</span>
<span class="fc" id="L2974">            mCa = (height + mD) / mR;</span>
<span class="fc" id="L2975">            mSa = mC2 * crlat * srlat / (mR * mD);</span>
        }
<span class="fc bfc" id="L2977" title="All 4 branches covered.">        if (mOldLongitude == null || longitude != mOldLongitude) {</span>
<span class="fc bfc" id="L2978" title="All 2 branches covered.">            for (int m = 2; m &lt;= WorldMagneticModel.MAX_ORDER; m++) {</span>
<span class="fc" id="L2979">                mSp[m] = mSp[1] * mCp[m - 1] + mCp[1] * mSp[m - 1];</span>
<span class="fc" id="L2980">                mCp[m] = mCp[1] * mCp[m - 1] - mSp[1] * mSp[m - 1];</span>
            }
        }

<span class="fc" id="L2984">        final double aor = RE_KM / mR;</span>
<span class="fc" id="L2985">        double ar = aor * aor;</span>
<span class="fc" id="L2986">        double br = 0, bt = 0, bp = 0, bpp = 0;</span>

<span class="fc bfc" id="L2988" title="All 2 branches covered.">        for (int n = 1; n &lt;= WorldMagneticModel.MAX_ORDER; n++) {</span>
<span class="fc" id="L2989">            ar = ar * aor;</span>
<span class="fc bfc" id="L2990" title="All 2 branches covered.">            for (int m = 0, D3 = 1, D4 = (n + m + D3) / D3; D4 &gt; 0; D4--, m += D3) {</span>

                // compute unnormalized associated Legendre polynomials
                // and derivatives via recursion relations
<span class="pc bpc" id="L2994" title="1 of 6 branches missed.">                if (mOldHeight == null || height != mOldHeight</span>
<span class="fc bfc" id="L2995" title="All 2 branches covered.">                        || mOldLatitude == null || latitude != mOldLatitude) {</span>
<span class="fc bfc" id="L2996" title="All 2 branches covered.">                    if (n == m) {</span>
<span class="fc" id="L2997">                        mModel.snorm[n + m * N] = mSt * mModel.snorm[n - 1 + (m - 1) * N];</span>
<span class="fc" id="L2998">                        mDp[m][n] = mSt * mDp[m - 1][n - 1] + mCt * mModel.snorm[n - 1 + (m - 1) * N];</span>
                    }
<span class="fc bfc" id="L3000" title="All 4 branches covered.">                    if (n == 1 &amp;&amp; m == 0) {</span>
<span class="fc" id="L3001">                        mModel.snorm[n + m * N] = mCt * mModel.snorm[n - 1 + m * N];</span>
<span class="fc" id="L3002">                        mDp[m][n] = mCt * mDp[m][n - 1] - mSt * mModel.snorm[n - 1 + m * N];</span>
                    }
<span class="fc bfc" id="L3004" title="All 4 branches covered.">                    if (n &gt; 1 &amp;&amp; n != m) {</span>
<span class="fc bfc" id="L3005" title="All 2 branches covered.">                        if (m &gt; n - 2) {</span>
<span class="fc" id="L3006">                            mModel.snorm[n - 2 + m * N] = 0.0;</span>
                        }
<span class="fc bfc" id="L3008" title="All 2 branches covered.">                        if (m &gt; n - 2) {</span>
<span class="fc" id="L3009">                            mDp[m][n - 2] = 0.0;</span>
                        }
<span class="fc" id="L3011">                        mModel.snorm[n + m * N] = mCt * mModel.snorm[n - 1 + m * N]</span>
                                - mModel.k[m][n] * mModel.snorm[n - 2 + m * N];
<span class="fc" id="L3013">                        mDp[m][n] = mCt * mDp[m][n - 1] - mSt * mModel.snorm[n - 1 + m * N]</span>
                                - mModel.k[m][n] * mDp[m][n - 2];
                    }
                }

                // time adjust the Gauss coefficients

<span class="fc bfc" id="L3020" title="All 4 branches covered.">                if (mOldTime == null || year != mOldTime) {</span>
<span class="fc" id="L3021">                    mTc[m][n] = mModel.c[m][n] + dt * mModel.cd[m][n];</span>

<span class="fc bfc" id="L3023" title="All 2 branches covered.">                    if (m != 0) {</span>
<span class="fc" id="L3024">                        mTc[n][m - 1] = mModel.c[n][m - 1] + dt * mModel.cd[n][m - 1];</span>
                    }
                }

                // accumulate terms of the spherical harmonic expansions
                double temp1, temp2;
<span class="fc" id="L3030">                double par = ar * mModel.snorm[n + m * N];</span>
<span class="fc bfc" id="L3031" title="All 2 branches covered.">                if (m == 0) {</span>
<span class="fc" id="L3032">                    temp1 = mTc[m][n] * mCp[m];</span>
<span class="fc" id="L3033">                    temp2 = mTc[m][n] * mSp[m];</span>
                } else {
<span class="fc" id="L3035">                    temp1 = mTc[m][n] * mCp[m] + mTc[n][m - 1] * mSp[m];</span>
<span class="fc" id="L3036">                    temp2 = mTc[m][n] * mSp[m] - mTc[n][m - 1] * mCp[m];</span>
                }

<span class="fc" id="L3039">                bt = bt - ar * temp1 * mDp[m][n];</span>
<span class="fc" id="L3040">                bp += (mModel.fm[m] * temp2 * par);</span>
<span class="fc" id="L3041">                br += (mModel.fn[n] * temp1 * par);</span>

                // Special case: North/sourth geographic poles

<span class="pc bpc" id="L3045" title="3 of 4 branches missed.">                if (mSt == 0.0 &amp;&amp; m == 1) {</span>
<span class="nc bnc" id="L3046" title="All 2 branches missed.">                    if (n == 1)</span>
<span class="nc" id="L3047">                        mPp[n] = mPp[n - 1];</span>
                    else
<span class="nc" id="L3049">                        mPp[n] = mCt * mPp[n - 1] - mModel.k[m][n] * mPp[n - 2];</span>
<span class="nc" id="L3050">                    double parp = ar * mPp[n];</span>
<span class="nc" id="L3051">                    bpp += (mModel.fm[m] * temp2 * parp);</span>
                }

            }    //for(m...)

        }    //for(n...)


<span class="pc bpc" id="L3059" title="1 of 2 branches missed.">        if (mSt == 0.0) {</span>
<span class="nc" id="L3060">            bp = bpp;</span>
        } else {
<span class="fc" id="L3062">            bp /= mSt;</span>
        }

        // Rotate magnetic vector components from spherical to
        // geodetic coordinates.
        // by is the east-west field component
        // bx is the north-south field component
        // bz is the vertical field component.
<span class="fc" id="L3070">        mBx = -bt * mCa - br * mSa;</span>
<span class="fc" id="L3071">        mBy = bp;</span>
<span class="fc" id="L3072">        mBz = bt * mSa - br * mCa;</span>

        // Compute declination (DEC), INCLINATION (DIP) and
        // total intensity (TI)

<span class="fc" id="L3077">        mBh = Math.sqrt((mBx * mBx) + (mBy * mBy));</span>
<span class="fc" id="L3078">        mTi = Math.sqrt((mBh * mBh) + (mBz * mBz));</span>
        //	Calculate the declination.
<span class="fc" id="L3080">        mDec = Math.toDegrees(Math.atan2(mBy, mBx));</span>
<span class="fc" id="L3081">        mDip = Math.toDegrees(Math.atan2(mBz, mBh));</span>

<span class="fc" id="L3083">        mOldTime = year;</span>
<span class="fc" id="L3084">        mOldHeight = height;</span>
<span class="fc" id="L3085">        mOldLatitude = latitude;</span>
<span class="fc" id="L3086">        mOldLongitude = longitude;</span>
<span class="fc" id="L3087">    }</span>

    /**
     * Converts provided angle instance to radians.
     *
     * @param angle angle to be converted.
     * @return converted value expressed in radians.
     */
    private static double convertAngle(final Angle angle) {
<span class="fc" id="L3096">        return AngleConverter.convert(angle.getValue().doubleValue(),</span>
<span class="fc" id="L3097">                angle.getUnit(), AngleUnit.RADIANS);</span>
    }

    /**
     * Converts provided distance to meters.
     *
     * @param distance distance to be converted.
     * @return converted value expressed in meters.
     */
    private static double convertDistance(final Distance distance) {
<span class="fc" id="L3107">        return DistanceConverter.convert(distance.getValue().doubleValue(),</span>
<span class="fc" id="L3108">                distance.getUnit(), DistanceUnit.METER);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>