<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GNSSLeastSquaresPositionAndVelocityEstimator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.irurueta:irurueta-navigation</a> &gt; <a href="index.source.html" class="el_package">com.irurueta.navigation.gnss</a> &gt; <span class="el_source">GNSSLeastSquaresPositionAndVelocityEstimator.java</span></div><h1>GNSSLeastSquaresPositionAndVelocityEstimator.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2019 Alberto Irurueta Carro (alberto@irurueta.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.irurueta.navigation.gnss;

import com.irurueta.algebra.AlgebraException;
import com.irurueta.algebra.Matrix;
import com.irurueta.algebra.Utils;
import com.irurueta.algebra.WrongSizeException;
import com.irurueta.navigation.LockedException;
import com.irurueta.navigation.NotReadyException;
import com.irurueta.navigation.frames.converters.ECEFtoNEDPositionVelocityConverter;
import com.irurueta.navigation.frames.converters.NEDtoECEFPositionVelocityConverter;
import com.irurueta.navigation.geodesic.Constants;
import com.irurueta.navigation.inertial.ECEFPosition;
import com.irurueta.navigation.inertial.ECEFVelocity;
import com.irurueta.navigation.inertial.NEDPosition;
import com.irurueta.navigation.inertial.NEDVelocity;

import java.util.Collection;

/**
 * Calculates position, velocity, clock offset and clock drift using
 * unweighted iterated least squares.
 * Separate calculations are implemented for position and clock offset and
 * for velocity and clock drift.
 * This implementation is based on the equations defined in &quot;Principles of GNSS, Inertial, and Multisensor
 * Integrated Navigation Systems, Second Edition&quot; and on the companion software available at:
 * https://github.com/ymjdz/MATLAB-Codes/blob/master/GNSS_LS_position_velocity.m
 */
public class GNSSLeastSquaresPositionAndVelocityEstimator {

    /**
     * Minimum nuber of measurements required to obtain a solution.
     */
    public static final int MIN_MEASUREMENTS = 4;

    /**
     * Default threshold to determine when convergence has been reached.
     */
    public static final double CONVERGENCE_THRESHOLD = 1e-4;

    /**
     * Speed of light in the vacuum expressed in meters per second (m/s).
     */
    public static final double SPEED_OF_LIGHT = Constants.SPEED_OF_LIGHT;

    /**
     * Earth rotation rate expressed in radians per second (rad/s).
     */
    public static final double EARTH_ROTATION_RATE = Constants.EARTH_ROTATION_RATE;

    /**
     * Number of components of predicted state.
     */
    private static final int STATE_COMPONENTS = ECEFPosition.COMPONENTS + 1;

    /**
     * Number of elements of position, velocity, etc.
     */
    private static final int ELEMS = ECEFPosition.COMPONENTS;

    /**
     * Number of elements of position minus one.
     */
    private static final int ELEMS_MINUS_ONE = ELEMS - 1;

    /**
     * GNSS measurements of a collection of satellites.
     */
    private Collection&lt;GNSSMeasurement&gt; mMeasurements;

    /**
     * Previously predicted ECEF user position and velocity.
     */
    private ECEFPositionAndVelocity mPriorPositionAndVelocity;

    /**
     * Listener to notify events raised by this instance.
     */
    private GNSSLeastSquaresPositionAndVelocityEstimatorListener mListener;

    /**
     * Threshold to determine when convergence has been reached.
     */
<span class="fc" id="L98">    private double mConvergenceThreshold = CONVERGENCE_THRESHOLD;</span>

    /**
     * Indicates whether estimation is currently running.
     */
    private boolean mRunning;

    /**
     * Internal matrix to be reused containing frame rotation during signal transit
     * time.
     */
    private final Matrix mCei;

    /**
     * Predicted state to be reused.
     */
    private final Matrix mXPred;

    /**
     * Temporal matrix to be reused.
     */
    private final Matrix mTmp1;

    /**
     * Temporal matrix to be reused.
     */
    private final Matrix mTmp2;

    /**
     * Estimated state to be reused.
     */
    private final Matrix mXEst;

    /**
     * Contains square representation of measurement or geometry matrix.
     */
    private final Matrix mHSqr;

    /**
     * Inverse of the square representation of measurement or geometry matrix.
     */
    private final Matrix mInvHSqr;

    /**
     * Temporal matrix to be reused.
     */
    private final Matrix mTmp3;

    /**
     * Skew symmetric matrix of Earth rotation rate.
     */
    private final Matrix mOmegaIe;

    /**
     * Temporal matrix to be reused.
     */
    private final Matrix mTmp4;

    /**
     * Temporal matrix to be reused.
     */
    private final Matrix mTmp5;

    /**
     * Temporal matrix to be reused.
     */
    private final Matrix mTmp6;

    /**
     * Temporal matrix to be reused.
     */
    private final Matrix mTmp7;

    /**
     * Temporal matrix to be reused.
     */
    private final Matrix mTmp8;

    /**
     * Temporal matrix to be reused.
     */
    private final Matrix mTmp9;

    /**
     * Temporal matrix to be reused.
     */
    private final Matrix mTmp10;

    /**
     * Measurement position to be reused.
     */
    private final Matrix mMeasurementPosition;

    /**
     * Measurement velocity to be reused.
     */
    private final Matrix mMeasurementVelocity;

    /**
     * Predicted velocity to be reused.
     */
    private final Matrix mPredVelocity;

    /**
     * Result position to be reused.
     */
    private final Matrix mResultPosition;

    /**
     * Constructor.
     */
<span class="fc" id="L209">    public GNSSLeastSquaresPositionAndVelocityEstimator() {</span>
<span class="fc" id="L210">        Matrix xPred = null;</span>
<span class="fc" id="L211">        Matrix tmp1 = null;</span>
<span class="fc" id="L212">        Matrix tmp2 = null;</span>
<span class="fc" id="L213">        Matrix xEst = null;</span>
<span class="fc" id="L214">        Matrix hSqr = null;</span>
<span class="fc" id="L215">        Matrix invHSqr = null;</span>
<span class="fc" id="L216">        Matrix tmp3 = null;</span>
<span class="fc" id="L217">        Matrix omegaIe = null;</span>
<span class="fc" id="L218">        Matrix cei = null;</span>
<span class="fc" id="L219">        Matrix tmp4 = null;</span>
<span class="fc" id="L220">        Matrix tmp5 = null;</span>
<span class="fc" id="L221">        Matrix tmp6 = null;</span>
<span class="fc" id="L222">        Matrix tmp7 = null;</span>
<span class="fc" id="L223">        Matrix tmp8 = null;</span>
<span class="fc" id="L224">        Matrix tmp9 = null;</span>
<span class="fc" id="L225">        Matrix tmp10 = null;</span>
<span class="fc" id="L226">        Matrix measurementPosition = null;</span>
<span class="fc" id="L227">        Matrix measurementVelocity = null;</span>
<span class="fc" id="L228">        Matrix predVelocity = null;</span>
<span class="fc" id="L229">        Matrix resultPosition = null;</span>
        try {
<span class="fc" id="L231">            cei = Matrix.identity(ELEMS, ELEMS);</span>
<span class="fc" id="L232">            xPred = new Matrix(STATE_COMPONENTS, 1);</span>
<span class="fc" id="L233">            tmp1 = new Matrix(ELEMS, 1);</span>
<span class="fc" id="L234">            tmp2 = new Matrix(ELEMS, 1);</span>
<span class="fc" id="L235">            xEst = new Matrix(STATE_COMPONENTS, 1);</span>
<span class="fc" id="L236">            hSqr = new Matrix(STATE_COMPONENTS, STATE_COMPONENTS);</span>
<span class="fc" id="L237">            invHSqr = new Matrix(STATE_COMPONENTS, STATE_COMPONENTS);</span>
<span class="fc" id="L238">            tmp3 = new Matrix(STATE_COMPONENTS, 1);</span>
<span class="fc" id="L239">            omegaIe = Utils.skewMatrix(new double[]{0.0, 0.0, EARTH_ROTATION_RATE});</span>
<span class="fc" id="L240">            tmp4 = new Matrix(STATE_COMPONENTS, 1);</span>
<span class="fc" id="L241">            tmp5 = new Matrix(STATE_COMPONENTS, 1);</span>
<span class="fc" id="L242">            tmp6 = new Matrix(STATE_COMPONENTS, 1);</span>
<span class="fc" id="L243">            tmp7 = new Matrix(STATE_COMPONENTS, 1);</span>
<span class="fc" id="L244">            tmp8 = new Matrix(STATE_COMPONENTS, 1);</span>
<span class="fc" id="L245">            tmp9 = new Matrix(STATE_COMPONENTS, 1);</span>
<span class="fc" id="L246">            tmp10 = new Matrix(STATE_COMPONENTS, 1);</span>
<span class="fc" id="L247">            measurementPosition = new Matrix(ELEMS, 1);</span>
<span class="fc" id="L248">            measurementVelocity = new Matrix(ELEMS, 1);</span>
<span class="fc" id="L249">            predVelocity = new Matrix(ELEMS, 1);</span>
<span class="fc" id="L250">            resultPosition = new Matrix(ELEMS, 1);</span>
<span class="nc" id="L251">        } catch (WrongSizeException ignore) {</span>
            // never happens
<span class="fc" id="L253">        }</span>

<span class="fc" id="L255">        mCei = cei;</span>
<span class="fc" id="L256">        mXPred = xPred;</span>
<span class="fc" id="L257">        mTmp1 = tmp1;</span>
<span class="fc" id="L258">        mTmp2 = tmp2;</span>
<span class="fc" id="L259">        mXEst = xEst;</span>
<span class="fc" id="L260">        mHSqr = hSqr;</span>
<span class="fc" id="L261">        mInvHSqr = invHSqr;</span>
<span class="fc" id="L262">        mTmp3 = tmp3;</span>
<span class="fc" id="L263">        mOmegaIe = omegaIe;</span>
<span class="fc" id="L264">        mTmp4 = tmp4;</span>
<span class="fc" id="L265">        mTmp5 = tmp5;</span>
<span class="fc" id="L266">        mTmp6 = tmp6;</span>
<span class="fc" id="L267">        mTmp7 = tmp7;</span>
<span class="fc" id="L268">        mTmp8 = tmp8;</span>
<span class="fc" id="L269">        mTmp9 = tmp9;</span>
<span class="fc" id="L270">        mTmp10 = tmp10;</span>
<span class="fc" id="L271">        mMeasurementPosition = measurementPosition;</span>
<span class="fc" id="L272">        mMeasurementVelocity = measurementVelocity;</span>
<span class="fc" id="L273">        mPredVelocity = predVelocity;</span>
<span class="fc" id="L274">        mResultPosition = resultPosition;</span>
<span class="fc" id="L275">    }</span>

    /**
     * Constructor.
     *
     * @param measurements GNSS measurements of a collection of satellites.
     * @throws IllegalArgumentException if less than 4 measurements are provided.
     */
    public GNSSLeastSquaresPositionAndVelocityEstimator(
            final Collection&lt;GNSSMeasurement&gt; measurements) {
<span class="fc" id="L285">        this();</span>
        try {
<span class="fc" id="L287">            setMeasurements(measurements);</span>
<span class="nc" id="L288">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L290">        }</span>
<span class="fc" id="L291">    }</span>

    /**
     * Constructor.
     *
     * @param measurements             GNSS measurements of a collection of satellites.
     * @param priorPositionAndVelocity previously predicted ECEF user position and
     *                                 velocity.
     * @throws IllegalArgumentException if less than 4 measurements are provided.
     */
    public GNSSLeastSquaresPositionAndVelocityEstimator(
            final Collection&lt;GNSSMeasurement&gt; measurements,
            final ECEFPositionAndVelocity priorPositionAndVelocity) {
<span class="fc" id="L304">        this();</span>
        try {
<span class="fc" id="L306">            setMeasurements(measurements);</span>
<span class="fc" id="L307">            setPriorPositionAndVelocity(priorPositionAndVelocity);</span>
<span class="nc" id="L308">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L310">        }</span>
<span class="fc" id="L311">    }</span>

    /**
     * Constructor.
     *
     * @param measurements GNSS measurement of a collection of satellites.
     * @param priorEstimation  previously predicted GNSS estimation.
     * @throws IllegalArgumentException if less than 4 measurements are provided.
     */
    public GNSSLeastSquaresPositionAndVelocityEstimator(
            final Collection&lt;GNSSMeasurement&gt; measurements,
            final GNSSEstimation priorEstimation) {
<span class="fc" id="L323">        this();</span>
        try {
<span class="fc" id="L325">            setMeasurements(measurements);</span>
<span class="fc" id="L326">            setPriorPositionAndVelocityFromEstimation(priorEstimation);</span>
<span class="nc" id="L327">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L329">        }</span>
<span class="fc" id="L330">    }</span>

    /**
     * Constructor.
     *
     * @param listener listener notifying events raised by this instance.
     */
    public GNSSLeastSquaresPositionAndVelocityEstimator(
            final GNSSLeastSquaresPositionAndVelocityEstimatorListener listener) {
<span class="fc" id="L339">        this();</span>
        try {
<span class="fc" id="L341">            setListener(listener);</span>
<span class="nc" id="L342">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L344">        }</span>
<span class="fc" id="L345">    }</span>

    /**
     * Constructor.
     *
     * @param measurements GNSS measurements of a collection of satellites.
     * @param listener     listener notifying events raised by this instance.
     * @throws IllegalArgumentException if less than 4 measurements are provided.
     */
    public GNSSLeastSquaresPositionAndVelocityEstimator(
            final Collection&lt;GNSSMeasurement&gt; measurements,
            final GNSSLeastSquaresPositionAndVelocityEstimatorListener listener) {
<span class="fc" id="L357">        this(measurements);</span>
        try {
<span class="fc" id="L359">            setListener(listener);</span>
<span class="nc" id="L360">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L362">        }</span>
<span class="fc" id="L363">    }</span>

    /**
     * Constructor.
     *
     * @param measurements             GNSS measurements of a collection of satellites.
     * @param priorPositionAndVelocity previously predicted ECEF user position and
     *                                 velocity.
     * @param listener                 listener notifying events raised by this
     *                                 instance.
     * @throws IllegalArgumentException if less than 4 measurements are provided.
     */
    public GNSSLeastSquaresPositionAndVelocityEstimator(
            final Collection&lt;GNSSMeasurement&gt; measurements,
            final ECEFPositionAndVelocity priorPositionAndVelocity,
            final GNSSLeastSquaresPositionAndVelocityEstimatorListener listener) {
<span class="fc" id="L379">        this(measurements, priorPositionAndVelocity);</span>
        try {
<span class="fc" id="L381">            setListener(listener);</span>
<span class="nc" id="L382">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L384">        }</span>
<span class="fc" id="L385">    }</span>

    /**
     * Constructor.
     *
     * @param measurements GNSS measurement of a collection of satellites.
     * @param priorEstimation  previously predicted GNSS estimation.
     * @param listener     listener notifying events raised by this instance.
     * @throws IllegalArgumentException if less than 4 measurements are provided.
     */
    public GNSSLeastSquaresPositionAndVelocityEstimator(
            final Collection&lt;GNSSMeasurement&gt; measurements,
            final GNSSEstimation priorEstimation,
            final GNSSLeastSquaresPositionAndVelocityEstimatorListener listener) {
<span class="fc" id="L399">        this(measurements, priorEstimation);</span>
        try {
<span class="fc" id="L401">            setListener(listener);</span>
<span class="nc" id="L402">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L404">        }</span>
<span class="fc" id="L405">    }</span>

    /**
     * Gets GNSS measurements of a collection of satellites.
     *
     * @return GNSS measurements of a collection of satellites.
     */
    public Collection&lt;GNSSMeasurement&gt; getMeasurements() {
<span class="fc" id="L413">        return mMeasurements;</span>
    }

    /**
     * Sets GNSS measurements of a collection of satellites.
     *
     * @param measurements GNSS measurements of a collection of satellites.
     * @throws IllegalArgumentException if less than 4 measurements are provided.
     * @throws LockedException          if this estimator is already running.
     */
    public void setMeasurements(
            final Collection&lt;GNSSMeasurement&gt; measurements) throws LockedException {
<span class="fc bfc" id="L425" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L426">            throw new LockedException();</span>
        }
<span class="fc bfc" id="L428" title="All 2 branches covered.">        if (!isValidMeasurements(measurements)) {</span>
<span class="fc" id="L429">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L432">        mMeasurements = measurements;</span>
<span class="fc" id="L433">    }</span>

    /**
     * Gets previously predicted ECEF user position and velocity.
     *
     * @return previously predicted ECEF user position and velocity.
     */
    public ECEFPositionAndVelocity getPriorPositionAndVelocity() {
<span class="fc" id="L441">        return mPriorPositionAndVelocity;</span>
    }

    /**
     * Sets previously predicted ECEF user position and velocity.
     *
     * @param priorPositionAndVelocity previously predicted ECEF user position and
     *                                 velocity.
     * @throws LockedException if this estimator is already running.
     */
    public void setPriorPositionAndVelocity(
            final ECEFPositionAndVelocity priorPositionAndVelocity)
            throws LockedException {
<span class="fc bfc" id="L454" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L455">            throw new LockedException();</span>
        }

<span class="fc" id="L458">        mPriorPositionAndVelocity = priorPositionAndVelocity;</span>
<span class="fc" id="L459">    }</span>

    /**
     * Sets previously predicted ECEF user position and velocity from a previous
     * predicted result.
     *
     * @param priorEstimation previously predicted GNSS estimation.
     * @throws LockedException if this estimator is already running.
     */
    public void setPriorPositionAndVelocityFromEstimation(
            final GNSSEstimation priorEstimation)
            throws LockedException {
<span class="fc bfc" id="L471" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L472">            throw new LockedException();</span>
        }

<span class="fc bfc" id="L475" title="All 2 branches covered.">        mPriorPositionAndVelocity = priorEstimation != null ?</span>
<span class="fc" id="L476">                priorEstimation.getPositionAndVelocity() : null;</span>
<span class="fc" id="L477">    }</span>

    /**
     * Gets listener to notify events raised by this instance.
     *
     * @return listener to notify events raised by this instance.
     */
    public GNSSLeastSquaresPositionAndVelocityEstimatorListener getListener() {
<span class="fc" id="L485">        return mListener;</span>
    }

    /**
     * Sets listener to notify events raised by this instance.
     *
     * @param listener listener to notify events raised by this instance.
     * @throws LockedException if this estimator is already running.
     */
    public void setListener(
            final GNSSLeastSquaresPositionAndVelocityEstimatorListener listener)
            throws LockedException {
<span class="fc bfc" id="L497" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L498">            throw new LockedException();</span>
        }
<span class="fc" id="L500">        mListener = listener;</span>
<span class="fc" id="L501">    }</span>

    /**
     * Gets threshold to determine when convergence has been reached.
     *
     * @return threshold to determine when convergence has been reached.
     */
    public double getConvergenceThreshold() {
<span class="fc" id="L509">        return mConvergenceThreshold;</span>
    }

    /**
     * Sets threshold to determine when convergence has been reached.
     *
     * @param convergenceThreshold threshold to determine when convergence has
     *                             been reached.
     * @throws LockedException          if this estimator is already running.
     * @throws IllegalArgumentException if provided threshold is zero or negative.
     */
    public void setConvergenceThreshold(final double convergenceThreshold)
            throws LockedException, IllegalArgumentException {
<span class="fc bfc" id="L522" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L523">            throw new LockedException();</span>
        }
<span class="pc bpc" id="L525" title="1 of 2 branches missed.">        if (convergenceThreshold &lt;= 0.0) {</span>
<span class="nc" id="L526">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L529">        mConvergenceThreshold = convergenceThreshold;</span>
<span class="fc" id="L530">    }</span>

    /**
     * Indicates whether this estimator is ready to start the estimation.
     *
     * @return true if estimator is ready, false otherwise.
     */
    public boolean isReady() {
<span class="fc" id="L538">        return isValidMeasurements(mMeasurements);</span>
    }

    /**
     * Indicates whether this estimator is currently running or not.
     *
     * @return true if estimator is running, false otherwise.
     */
    public boolean isRunning() {
<span class="fc" id="L547">        return mRunning;</span>
    }

    /**
     * Indicates whether provided measurements are valid or not.
     *
     * @param gnssMeasurements measurements to be checked.
     * @return true if at least 4 measurements are provided, false otherwise.
     */
    public static boolean isValidMeasurements(
            final Collection&lt;GNSSMeasurement&gt; gnssMeasurements) {
<span class="fc bfc" id="L558" title="All 4 branches covered.">        return gnssMeasurements != null &amp;&amp; gnssMeasurements.size() &gt;= MIN_MEASUREMENTS;</span>
    }

    /**
     * Estimates new ECEF user position and velocity as well as clock
     * offset and drift.
     *
     * @param result instance where result data will be stored.
     * @throws NotReadyException if estimator is not ready to start estimation.
     * @throws LockedException   if estimator is already running.
     * @throws GNSSException     if estimation fails due to numerical instabilities.
     */
    public void estimate(final GNSSEstimation result)
            throws NotReadyException, LockedException, GNSSException {
<span class="pc bpc" id="L572" title="1 of 2 branches missed.">        if (!isReady()) {</span>
<span class="nc" id="L573">            throw new NotReadyException();</span>
        }
<span class="fc bfc" id="L575" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L576">            throw new LockedException();</span>
        }

        try {
<span class="fc" id="L580">            mRunning = true;</span>

<span class="fc bfc" id="L582" title="All 2 branches covered.">            if (mListener != null) {</span>
<span class="fc" id="L583">                mListener.onEstimateStart(this);</span>
            }

            // if no prior position and velocity is available, assume that
            // we are at latitude,longitude equal to the average of satellite
            // measurements, at Earth's surface (height = 0) and with zero velocity.
<span class="fc" id="L589">            initializePriorPositionAndVelocityIfNeeded();</span>

            // POSITION AND CLOCK OFFSET

            // Setup predicted state
<span class="fc" id="L594">            final double priorX = mPriorPositionAndVelocity.getX();</span>
<span class="fc" id="L595">            final double priorY = mPriorPositionAndVelocity.getY();</span>
<span class="fc" id="L596">            final double priorZ = mPriorPositionAndVelocity.getZ();</span>

<span class="fc" id="L598">            mXPred.setElementAtIndex(0, priorX);</span>
<span class="fc" id="L599">            mXPred.setElementAtIndex(1, priorY);</span>
<span class="fc" id="L600">            mXPred.setElementAtIndex(2, priorZ);</span>
<span class="fc" id="L601">            mXPred.setElementAtIndex(3, 0.0);</span>

<span class="fc" id="L603">            final int numMeasurements = mMeasurements.size();</span>
<span class="fc" id="L604">            final Matrix predMeas = new Matrix(numMeasurements, 1);</span>
<span class="fc" id="L605">            final Matrix h = new Matrix(numMeasurements, STATE_COMPONENTS);</span>
<span class="fc bfc" id="L606" title="All 2 branches covered.">            for (int i = 0; i &lt; numMeasurements; i++) {</span>
<span class="fc" id="L607">                h.setElementAt(i, 3, 1.0);</span>
            }

<span class="fc" id="L610">            final Matrix hTrans = new Matrix(STATE_COMPONENTS, numMeasurements);</span>
<span class="fc" id="L611">            final Matrix hTmp1 = new Matrix(STATE_COMPONENTS, numMeasurements);</span>
<span class="fc" id="L612">            final Matrix deltaPseudoRange = new Matrix(numMeasurements, 1);</span>

            // Repeat until convergence
<span class="fc" id="L615">            double testConvergence = 1.0;</span>
<span class="fc bfc" id="L616" title="All 2 branches covered.">            while (testConvergence &gt; mConvergenceThreshold) {</span>

                // Loop measurements
<span class="fc" id="L619">                int j = 0;</span>
<span class="fc bfc" id="L620" title="All 2 branches covered.">                for (final GNSSMeasurement measurement : mMeasurements) {</span>

                    // Predict approx range
<span class="fc" id="L623">                    final double measX = measurement.getX();</span>
<span class="fc" id="L624">                    final double measY = measurement.getY();</span>
<span class="fc" id="L625">                    final double measZ = measurement.getZ();</span>

<span class="fc" id="L627">                    double deltaRx = measX - priorX;</span>
<span class="fc" id="L628">                    double deltaRy = measY - priorY;</span>
<span class="fc" id="L629">                    double deltaRz = measZ - priorZ;</span>
<span class="fc" id="L630">                    final double approxRange = norm(deltaRx, deltaRy, deltaRz);</span>

                    // Calculate frame rotation during signal transit time using (8.36)
<span class="fc" id="L633">                    final double ceiValue = EARTH_ROTATION_RATE * approxRange / SPEED_OF_LIGHT;</span>
<span class="fc" id="L634">                    mCei.setElementAt(0, 1, ceiValue);</span>
<span class="fc" id="L635">                    mCei.setElementAt(1, 0, -ceiValue);</span>

                    // Predict pseudo-range using (9.143)
<span class="fc" id="L638">                    mTmp1.setElementAtIndex(0, measX);</span>
<span class="fc" id="L639">                    mTmp1.setElementAtIndex(1, measY);</span>
<span class="fc" id="L640">                    mTmp1.setElementAtIndex(2, measZ);</span>

<span class="fc" id="L642">                    mCei.multiply(mTmp1, mTmp2);</span>

<span class="fc" id="L644">                    deltaRx = mTmp2.getElementAtIndex(0) - mXPred.getElementAtIndex(0);</span>
<span class="fc" id="L645">                    deltaRy = mTmp2.getElementAtIndex(1) - mXPred.getElementAtIndex(1);</span>
<span class="fc" id="L646">                    deltaRz = mTmp2.getElementAtIndex(2) - mXPred.getElementAtIndex(2);</span>
<span class="fc" id="L647">                    final double range = norm(deltaRx, deltaRy, deltaRz);</span>

<span class="fc" id="L649">                    final double predictedPseudoRange = range + mXPred.getElementAtIndex(3);</span>
<span class="fc" id="L650">                    predMeas.setElementAtIndex(j, predictedPseudoRange);</span>

<span class="fc" id="L652">                    deltaPseudoRange.setElementAtIndex(j,</span>
<span class="fc" id="L653">                            measurement.getPseudoRange() - predictedPseudoRange);</span>

                    // Predict line of sight and deploy in measurement matrix, (9.144)
<span class="fc" id="L656">                    h.setElementAt(j, 0, -deltaRx / range);</span>
<span class="fc" id="L657">                    h.setElementAt(j, 1, -deltaRy / range);</span>
<span class="fc" id="L658">                    h.setElementAt(j, 2, -deltaRz / range);</span>

<span class="fc" id="L660">                    j++;</span>
<span class="fc" id="L661">                }</span>

                // Unweighted least-squares solution, (9.35)/(9.141)
<span class="fc" id="L664">                h.transpose(hTrans);</span>
<span class="fc" id="L665">                hTrans.multiply(h, mHSqr);</span>
<span class="fc" id="L666">                Utils.inverse(mHSqr, mInvHSqr);</span>
<span class="fc" id="L667">                mInvHSqr.multiply(hTrans, hTmp1);</span>
<span class="fc" id="L668">                hTmp1.multiply(deltaPseudoRange, mTmp3);</span>

<span class="fc" id="L670">                mXPred.add(mTmp3, mXEst);</span>

                // Test convergence
<span class="fc" id="L673">                testConvergence = predictionError();</span>

                // Set predictions to estimates for next iteration
<span class="fc" id="L676">                mXPred.copyFrom(mXEst);</span>
<span class="fc" id="L677">            }</span>

            // Set outputs to estimates
<span class="fc" id="L680">            final double resultX = mXEst.getElementAtIndex(0);</span>
<span class="fc" id="L681">            final double resultY = mXEst.getElementAtIndex(1);</span>
<span class="fc" id="L682">            final double resultZ = mXEst.getElementAtIndex(2);</span>
<span class="fc" id="L683">            result.setPositionCoordinates(resultX, resultY, resultZ);</span>

<span class="fc" id="L685">            final double resultClockOffset = mXEst.getElementAtIndex(3);</span>
<span class="fc" id="L686">            result.setClockOffset(resultClockOffset);</span>


            // VELOCITY AND CLOCK DRIFT

            // Setup predicted state
<span class="fc" id="L692">            final double priorVx = mPriorPositionAndVelocity.getVx();</span>
<span class="fc" id="L693">            final double priorVy = mPriorPositionAndVelocity.getVy();</span>
<span class="fc" id="L694">            final double priorVz = mPriorPositionAndVelocity.getVz();</span>

<span class="fc" id="L696">            mXPred.setElementAtIndex(0, priorVx);</span>
<span class="fc" id="L697">            mXPred.setElementAtIndex(1, priorVy);</span>
<span class="fc" id="L698">            mXPred.setElementAtIndex(2, priorVz);</span>
<span class="fc" id="L699">            mXPred.setElementAtIndex(3, 0.0);</span>

<span class="fc" id="L701">            mResultPosition.setElementAtIndex(0, resultX);</span>
<span class="fc" id="L702">            mResultPosition.setElementAtIndex(1, resultY);</span>
<span class="fc" id="L703">            mResultPosition.setElementAtIndex(2, resultZ);</span>

<span class="fc" id="L705">            final Matrix deltaPseudoRangeRate = new Matrix(numMeasurements, 1);</span>

            // Repeat until convergence
<span class="fc" id="L708">            testConvergence = 1.0;</span>
<span class="fc bfc" id="L709" title="All 2 branches covered.">            while (testConvergence &gt; mConvergenceThreshold) {</span>

                // Loop measurements
<span class="fc" id="L712">                int j = 0;</span>
<span class="fc bfc" id="L713" title="All 2 branches covered.">                for (final GNSSMeasurement measurement : mMeasurements) {</span>
                    // Predict approx range
<span class="fc" id="L715">                    final double measX = measurement.getX();</span>
<span class="fc" id="L716">                    final double measY = measurement.getY();</span>
<span class="fc" id="L717">                    final double measZ = measurement.getZ();</span>

<span class="fc" id="L719">                    double deltaRx = measX - resultX;</span>
<span class="fc" id="L720">                    double deltaRy = measY - resultY;</span>
<span class="fc" id="L721">                    double deltaRz = measZ - resultZ;</span>
<span class="fc" id="L722">                    final double approxRange = norm(deltaRx, deltaRy, deltaRz);</span>

                    // Calculate frame rotation during signal transit time using (8.36)
<span class="fc" id="L725">                    final double ceiValue = EARTH_ROTATION_RATE * approxRange / SPEED_OF_LIGHT;</span>
<span class="fc" id="L726">                    mCei.setElementAt(0, 1, ceiValue);</span>
<span class="fc" id="L727">                    mCei.setElementAt(1, 0, -ceiValue);</span>

                    // Calculate range using (8.35)
<span class="fc" id="L730">                    mTmp1.setElementAtIndex(0, measX);</span>
<span class="fc" id="L731">                    mTmp1.setElementAtIndex(1, measY);</span>
<span class="fc" id="L732">                    mTmp1.setElementAtIndex(2, measZ);</span>

<span class="fc" id="L734">                    mCei.multiply(mTmp1, mTmp2);</span>

<span class="fc" id="L736">                    deltaRx = mTmp2.getElementAtIndex(0) - resultX;</span>
<span class="fc" id="L737">                    deltaRy = mTmp2.getElementAtIndex(1) - resultY;</span>
<span class="fc" id="L738">                    deltaRz = mTmp2.getElementAtIndex(2) - resultZ;</span>
<span class="fc" id="L739">                    final double range = norm(deltaRx, deltaRy, deltaRz);</span>

                    // Calculate line of sight using (8.41)
<span class="fc" id="L742">                    final double uaseX = deltaRx / range;</span>
<span class="fc" id="L743">                    final double uaseY = deltaRy / range;</span>
<span class="fc" id="L744">                    final double uaseZ = deltaRz / range;</span>

                    // Predict pseudo-range rate using (9.143)
<span class="fc" id="L747">                    mMeasurementPosition.setElementAtIndex(0, measX);</span>
<span class="fc" id="L748">                    mMeasurementPosition.setElementAtIndex(1, measY);</span>
<span class="fc" id="L749">                    mMeasurementPosition.setElementAtIndex(2, measZ);</span>

<span class="fc" id="L751">                    final double measVx = measurement.getVx();</span>
<span class="fc" id="L752">                    final double measVy = measurement.getVy();</span>
<span class="fc" id="L753">                    final double measVz = measurement.getVz();</span>

<span class="fc" id="L755">                    mMeasurementVelocity.setElementAtIndex(0, measVx);</span>
<span class="fc" id="L756">                    mMeasurementVelocity.setElementAtIndex(1, measVy);</span>
<span class="fc" id="L757">                    mMeasurementVelocity.setElementAtIndex(2, measVz);</span>

<span class="fc" id="L759">                    mOmegaIe.multiply(mMeasurementPosition, mTmp4);</span>

<span class="fc" id="L761">                    mMeasurementVelocity.add(mTmp4, mTmp5);</span>

<span class="fc" id="L763">                    mCei.multiply(mTmp5, mTmp6);</span>

<span class="fc" id="L765">                    mOmegaIe.multiply(mResultPosition, mTmp7);</span>

<span class="fc" id="L767">                    mXPred.getSubmatrix(0, 0,</span>
                            ELEMS_MINUS_ONE, 0, mPredVelocity);

<span class="fc" id="L770">                    mPredVelocity.add(mTmp7, mTmp8);</span>

<span class="fc" id="L772">                    mTmp6.subtract(mTmp8, mTmp9);</span>

<span class="fc" id="L774">                    final double rangeRate = uaseX * mTmp9.getElementAtIndex(0)</span>
<span class="fc" id="L775">                            + uaseY * mTmp9.getElementAtIndex(1)</span>
<span class="fc" id="L776">                            + uaseZ * mTmp9.getElementAtIndex(2);</span>

<span class="fc" id="L778">                    final double predictedPseudoRangeRate = rangeRate + mXPred.getElementAtIndex(3);</span>
<span class="fc" id="L779">                    predMeas.setElementAtIndex(j, predictedPseudoRangeRate);</span>

<span class="fc" id="L781">                    deltaPseudoRangeRate.setElementAtIndex(j,</span>
<span class="fc" id="L782">                            measurement.getPseudoRate() - predictedPseudoRangeRate);</span>

                    // Predict line of sight and deploy in measurement matrix, (9.144)
<span class="fc" id="L785">                    h.setElementAt(j, 0, -uaseX);</span>
<span class="fc" id="L786">                    h.setElementAt(j, 1, -uaseY);</span>
<span class="fc" id="L787">                    h.setElementAt(j, 2, -uaseZ);</span>

<span class="fc" id="L789">                    j++;</span>
<span class="fc" id="L790">                }</span>

                // Unweighted least-squares solution, (9.35)/(9.141)
<span class="fc" id="L793">                h.transpose(hTrans);</span>
<span class="fc" id="L794">                hTrans.multiply(h, mHSqr);</span>
<span class="fc" id="L795">                Utils.inverse(mHSqr, mInvHSqr);</span>
<span class="fc" id="L796">                mInvHSqr.multiply(hTrans, hTmp1);</span>
<span class="fc" id="L797">                hTmp1.multiply(deltaPseudoRangeRate, mTmp10);</span>

<span class="fc" id="L799">                mXPred.add(mTmp10, mXEst);</span>

                // Test convergence
<span class="fc" id="L802">                testConvergence = predictionError();</span>

                // Set predictions to estimates for next iteration
<span class="fc" id="L805">                mXPred.copyFrom(mXEst);</span>
<span class="fc" id="L806">            }</span>

            // Set outputs to estimates
<span class="fc" id="L809">            final double resultVx = mXEst.getElementAtIndex(0);</span>
<span class="fc" id="L810">            final double resultVy = mXEst.getElementAtIndex(1);</span>
<span class="fc" id="L811">            final double resultVz = mXEst.getElementAtIndex(2);</span>
<span class="fc" id="L812">            result.setVelocityCoordinates(resultVx, resultVy, resultVz);</span>

<span class="fc" id="L814">            final double resultClockDrift = mXEst.getElementAtIndex(3);</span>
<span class="fc" id="L815">            result.setClockDrift(resultClockDrift);</span>

<span class="fc" id="L817">        } catch (final AlgebraException e) {</span>
<span class="fc" id="L818">            throw new GNSSException(e);</span>
        } finally {

<span class="fc bfc" id="L821" title="All 2 branches covered.">            if (mListener != null) {</span>
<span class="fc" id="L822">                mListener.onEstimateEnd(this);</span>
            }

<span class="fc" id="L825">            mRunning = false;</span>
        }
<span class="fc" id="L827">    }</span>

    /**
     * Estimates new ECEF user position and velocity as well as clock
     * offset and drift.
     *
     * @return new ECEF user position and velocity, and clock offset and drift.
     * @throws NotReadyException if estimator is not ready to start estimation.
     * @throws LockedException   if estimator is already running.
     * @throws GNSSException     if estimation fails due to numerical instabilities.
     */
    public GNSSEstimation estimate()
            throws NotReadyException, LockedException, GNSSException {
<span class="fc" id="L840">        final GNSSEstimation result =</span>
                new GNSSEstimation();
<span class="fc" id="L842">        estimate(result);</span>
<span class="fc" id="L843">        return result;</span>
    }

    /**
     * Initializes prior position and velocity if not set, assuming that
     * user is located at the average latitude,longitud of all provided
     * satellite measurements, at Earth's surface (height = 0) and with zero velocity.
     */
    private void initializePriorPositionAndVelocityIfNeeded() {
<span class="fc bfc" id="L852" title="All 2 branches covered.">        if (mPriorPositionAndVelocity != null) {</span>
<span class="fc" id="L853">            return;</span>
        }

<span class="fc" id="L856">        int numMeasurements = mMeasurements.size();</span>
<span class="fc" id="L857">        final NEDPosition nedPosition = new NEDPosition();</span>
<span class="fc" id="L858">        final NEDVelocity nedVelocity = new NEDVelocity();</span>

<span class="fc" id="L860">        final ECEFPosition ecefPosition = new ECEFPosition();</span>
<span class="fc" id="L861">        final ECEFVelocity ecefVelocity = new ECEFVelocity();</span>

<span class="fc" id="L863">        double userLatitude = 0.0;</span>
<span class="fc" id="L864">        double userLongitude = 0.0;</span>
<span class="fc bfc" id="L865" title="All 2 branches covered.">        for (final GNSSMeasurement measurement : mMeasurements) {</span>
<span class="fc" id="L866">            measurement.getEcefPosition(ecefPosition);</span>
<span class="fc" id="L867">            measurement.getEcefVelocity(ecefVelocity);</span>
<span class="fc" id="L868">            ECEFtoNEDPositionVelocityConverter.convertECEFtoNED(</span>
                    ecefPosition, ecefVelocity, nedPosition, nedVelocity);

<span class="fc" id="L871">            final double satLatitude = nedPosition.getLatitude();</span>
<span class="fc" id="L872">            final double satLongitude = nedPosition.getLongitude();</span>

<span class="fc" id="L874">            userLatitude += satLatitude / numMeasurements;</span>
<span class="fc" id="L875">            userLongitude += satLongitude / numMeasurements;</span>
<span class="fc" id="L876">        }</span>

<span class="fc" id="L878">        nedPosition.setCoordinates(userLatitude, userLongitude, 0.0);</span>
<span class="fc" id="L879">        nedVelocity.setCoordinates(0.0, 0.0, 0.0);</span>

<span class="fc" id="L881">        NEDtoECEFPositionVelocityConverter.convertNEDtoECEF(</span>
                nedPosition, nedVelocity, ecefPosition, ecefVelocity);

<span class="fc" id="L884">        mPriorPositionAndVelocity = new ECEFPositionAndVelocity(</span>
                ecefPosition, ecefVelocity);
<span class="fc" id="L886">    }</span>

    /**
     * Computes norm of provided coordinates.
     *
     * @param x x coordinate.
     * @param y y coordinate.
     * @param z z coordinate.
     * @return computed norm.
     */
    private static double norm(final double x, final double y, final double z) {
<span class="fc" id="L897">        return Math.sqrt(x * x + y * y + z * z);</span>
    }

    /**
     * Computes norm of error between estimated state
     * and predicted state.
     *
     * @return norm of error.
     */
    private double predictionError() {
<span class="fc" id="L907">        double sqrPredictionError = 0.0;</span>
<span class="fc bfc" id="L908" title="All 2 branches covered.">        for (int i = 0; i &lt; STATE_COMPONENTS; i++) {</span>
<span class="fc" id="L909">            final double diff = mXEst.getElementAtIndex(i)</span>
<span class="fc" id="L910">                    - mXPred.getElementAtIndex(i);</span>
<span class="fc" id="L911">            sqrPredictionError += diff * diff;</span>
        }
<span class="fc" id="L913">        return Math.sqrt(sqrPredictionError);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>