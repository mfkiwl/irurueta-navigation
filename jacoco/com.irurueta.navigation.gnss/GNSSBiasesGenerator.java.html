<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GNSSBiasesGenerator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.irurueta:irurueta-navigation</a> &gt; <a href="index.source.html" class="el_package">com.irurueta.navigation.gnss</a> &gt; <span class="el_source">GNSSBiasesGenerator.java</span></div><h1>GNSSBiasesGenerator.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2019 Alberto Irurueta Carro (alberto@irurueta.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.irurueta.navigation.gnss;

import com.irurueta.algebra.Matrix;
import com.irurueta.navigation.frames.CoordinateTransformation;
import com.irurueta.navigation.frames.converters.ECEFtoNEDPositionVelocityConverter;
import com.irurueta.navigation.inertial.ECEFPosition;
import com.irurueta.navigation.inertial.NEDPosition;
import com.irurueta.navigation.inertial.NEDVelocity;

import java.util.ArrayList;
import java.util.List;
import java.util.Random;

/**
 * Generates the GNSS range errors due to signal in space, ionosphere and troposphere
 * errors based on the elevation angles.
 * This implementation is based on the equations defined in &quot;Principles of GNSS, Inertial, and Multisensor
 * Integrated Navigation Systems, Second Edition&quot; and on the companion software available at:
 * https://github.com/ymjdz/MATLAB-Codes/blob/master/Initialize_GNSS_biases.m
 */
<span class="nc" id="L36">public class GNSSBiasesGenerator {</span>

    /**
     * Ionosphere factor.
     */
    private static final double IONO_FACTOR = 0.899;

    /**
     * Troposphere factor.
     */
    private static final double TROPO_FACTOR = 0.998;

    /**
     * Generates biases.
     *
     * @param satellitePositions ECEF satellite positions expressed in meters (m).
     * @param userPosition       ECEF user position expressed in meters (m).
     * @param config             GNSS configuration.
     * @param random             random number generator.
     * @return list of generated biases for each provided satellite position.
     */
    public static List&lt;Double&gt; generateBiases(final List&lt;ECEFPosition&gt; satellitePositions,
                                              final ECEFPosition userPosition,
                                              final GNSSConfig config, final Random random) {
<span class="fc" id="L60">        final List&lt;Double&gt; result = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L61">        generateBiases(satellitePositions, userPosition, config, random, result);</span>
<span class="fc" id="L62">        return result;</span>
    }

    /**
     * Generates biases.
     *
     * @param satellitePositions ECEF satellite positions expressed in meters (m).
     * @param userPosition       ECEF user position expressed in meters (m).
     * @param config             GNSS configuration.
     * @param random             random number generator.
     * @param result             instance where generated biases for each
     *                           provided satellite position will be stored.
     */
    public static void generateBiases(final List&lt;ECEFPosition&gt; satellitePositions,
                                      final ECEFPosition userPosition,
                                      final GNSSConfig config, final Random random,
                                      final List&lt;Double&gt; result) {
        // Calculate NED user position
<span class="fc" id="L80">        final NEDPosition userNedPosition = new NEDPosition();</span>
<span class="fc" id="L81">        final NEDVelocity userNedVelocity = new NEDVelocity();</span>
<span class="fc" id="L82">        ECEFtoNEDPositionVelocityConverter.convertECEFtoNED(</span>
<span class="fc" id="L83">                userPosition.getX(), userPosition.getY(), userPosition.getZ(),</span>
                0.0, 0.0, 0.0, userNedPosition, userNedVelocity);
<span class="fc" id="L85">        generate(satellitePositions, userPosition,</span>
<span class="fc" id="L86">                userNedPosition.getLatitude(), userNedPosition.getLongitude(),</span>
                config, random, result);
<span class="fc" id="L88">    }</span>

    /**
     * Generates biases.
     *
     * @param satellitePosition ECEF satellite positions expressed in meters (m).
     * @param userPosition      ECEF user position expressed in meters (m).
     * @param config            GNSS configuration.
     * @param random            random number generator.
     * @return generated bias for provided satellite position.
     */
    public static double generateBias(final ECEFPosition satellitePosition,
                                      final ECEFPosition userPosition, final GNSSConfig config,
                                      final Random random) {
        // Calculate NED user position
<span class="fc" id="L103">        final NEDPosition userNedPosition = new NEDPosition();</span>
<span class="fc" id="L104">        final NEDVelocity userNedVelocity = new NEDVelocity();</span>
<span class="fc" id="L105">        ECEFtoNEDPositionVelocityConverter.convertECEFtoNED(</span>
<span class="fc" id="L106">                userPosition.getX(), userPosition.getY(), userPosition.getZ(),</span>
                0.0, 0.0, 0.0, userNedPosition, userNedVelocity);
<span class="fc" id="L108">        final double userLatitude = userNedPosition.getLatitude();</span>
<span class="fc" id="L109">        final double userLongitude = userNedPosition.getLongitude();</span>

        // Calculate ECEF to NED coordinate transformation matrix
<span class="fc" id="L112">        final Matrix cen = CoordinateTransformation.ecefToNedMatrix(userLatitude, userLongitude);</span>
<span class="fc" id="L113">        return generate(satellitePosition, userPosition, config, cen, random);</span>
    }

    /**
     * Generates biases.
     *
     * @param satellitePositions ECEF satellite positions expressed in meters (m).
     * @param userPosition       ECEF user position expressed in meters (m).
     * @param userLatitude       user latitude expressed in radians (rad).
     * @param userLongitude      user longitude expressed in radians (rad).
     * @param config             GNSS configuration.
     * @param random             random number generator.
     * @param result             instance where generated biases for each
     *                           provided satellite position will be stored.
     */
    private static void generate(final List&lt;ECEFPosition&gt; satellitePositions,
                                 final ECEFPosition userPosition,
                                 final double userLatitude,
                                 final double userLongitude,
                                 final GNSSConfig config, final Random random,
                                 final List&lt;Double&gt; result) {
<span class="fc" id="L134">        result.clear();</span>

        // Calculate ECEF to NED coordinate transformation matrix
<span class="fc" id="L137">        final Matrix cen = CoordinateTransformation.ecefToNedMatrix(userLatitude, userLongitude);</span>

        // Loop satellites
<span class="fc bfc" id="L140" title="All 2 branches covered.">        for (final ECEFPosition satellitePosition : satellitePositions) {</span>
<span class="fc" id="L141">            result.add(generate(satellitePosition, userPosition, config, cen, random));</span>
<span class="fc" id="L142">        }</span>
<span class="fc" id="L143">    }</span>

    /**
     * Generates bias.
     *
     * @param satellitePosition ECEF satellite position expressed in meters (m).
     * @param userPosition      ECEF user position expressed in meters (m).
     * @param config            GNSS configuration.
     * @param cen               ECEF to NED coordinate transformation matrix.
     * @param random            random number generator.
     * @return generated bias provided satellite position.
     */
    private static double generate(final ECEFPosition satellitePosition, final ECEFPosition userPosition,
                                   final GNSSConfig config, final Matrix cen, final Random random) {

        // Determine ECEF line-of-sight vector using (8.41)
<span class="fc" id="L159">        final double deltaRx = satellitePosition.getX() - userPosition.getX();</span>
<span class="fc" id="L160">        final double deltaRy = satellitePosition.getY() - userPosition.getY();</span>
<span class="fc" id="L161">        final double deltaRz = satellitePosition.getZ() - userPosition.getZ();</span>

<span class="fc" id="L163">        final double deltaRNorm = Math.sqrt(deltaRx * deltaRx + deltaRy * deltaRy + deltaRz * deltaRz);</span>

<span class="fc" id="L165">        final double uaseX = deltaRx / deltaRNorm;</span>
<span class="fc" id="L166">        final double uaseY = deltaRy / deltaRNorm;</span>
<span class="fc" id="L167">        final double uaseZ = deltaRz / deltaRNorm;</span>

        // Convert line of sight vector to NED using (8.39) and determine
        // elevation using (8.57)
<span class="fc" id="L171">        final double cen1 = cen.getElementAt(2, 0);</span>
<span class="fc" id="L172">        final double cen2 = cen.getElementAt(2, 1);</span>
<span class="fc" id="L173">        final double cen3 = cen.getElementAt(2, 2);</span>

<span class="fc" id="L175">        double elevation = -Math.asin(cen1 * uaseX + cen2 * uaseY + cen3 * uaseZ);</span>

        // Limit the minimum elevation angle to the masking angle
<span class="fc" id="L178">        elevation = Math.max(elevation, Math.toRadians(config.getMaskAngleDegrees()));</span>

        // Calculate ionosphere and troposphere error SDs using (9.79) and (9.80)
<span class="fc" id="L181">        final double cosElevation = Math.cos(elevation);</span>
<span class="fc" id="L182">        final double cosElevation2 = cosElevation * cosElevation;</span>
<span class="fc" id="L183">        final double ionoSD = config.getZenithIonosphereErrorSD() / Math.sqrt(1.0</span>
                - IONO_FACTOR * cosElevation2);
<span class="fc" id="L185">        final double tropSD = config.getZenithTroposphereErrorSD() / Math.sqrt(1.0</span>
                - TROPO_FACTOR * cosElevation2);

        // Determine range bias
<span class="fc" id="L189">        return config.getSISErrorSD() * random.nextGaussian() + ionoSD * random.nextGaussian()</span>
<span class="fc" id="L190">                + tropSD * random.nextGaussian();</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>