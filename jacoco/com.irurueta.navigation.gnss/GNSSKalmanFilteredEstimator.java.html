<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GNSSKalmanFilteredEstimator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.irurueta:irurueta-navigation</a> &gt; <a href="index.source.html" class="el_package">com.irurueta.navigation.gnss</a> &gt; <span class="el_source">GNSSKalmanFilteredEstimator.java</span></div><h1>GNSSKalmanFilteredEstimator.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2019 Alberto Irurueta Carro (alberto@irurueta.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.irurueta.navigation.gnss;

import com.irurueta.algebra.AlgebraException;
import com.irurueta.navigation.LockedException;
import com.irurueta.navigation.NotReadyException;
import com.irurueta.units.Time;
import com.irurueta.units.TimeConverter;
import com.irurueta.units.TimeUnit;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;

/**
 * Calculates position, velocity, clock offset and clock drift using an
 * unweighted iterated least squares estimator along with a Kalman filter
 * to smooth results.
 * This implementation is based on the equations defined in &quot;Principles of GNSS, Inertial, and Multisensor
 * Integrated Navigation Systems, Second Edition&quot; and on the companion software available at:
 * https://github.com/ymjdz/MATLAB-Codes/blob/master/GNSS_Kalman_Filter.m
 */
public class GNSSKalmanFilteredEstimator {

    /**
     * Internal estimator to compute least squares solution for GNSS measurements.
     */
<span class="fc" id="L42">    private final GNSSLeastSquaresPositionAndVelocityEstimator mLsEstimator =</span>
            new GNSSLeastSquaresPositionAndVelocityEstimator();

    /**
     * Listener to notify events raised by this instance.
     */
    private GNSSKalmanFilteredEstimatorListener mListener;

    /**
     * Minimum epoch interval expressed in seconds (s) between consecutive
     * propagations or measurements.
     * Attempting to propagate results using Kalman filter or updating measurements when
     * intervals are lass than this value, will be ignored.
     */
    private double mEpochInterval;

    /**
     * GNSS Kalman filter configuration parameters (usually obtained through calibration).
     */
    private GNSSKalmanConfig mConfig;

    /**
     * GNSS measurements of a collection of satellites.
     */
    private Collection&lt;GNSSMeasurement&gt; mMeasurements;

    /**
     * Current estimation containing user ECEF position, user ECEF velocity, clock offset
     * and clock drift.
     */
    private GNSSEstimation mEstimation;

    /**
     * Current Kalman filter state containing current GNSS estimation along with
     * Kalman filter covariance error matrix.
     */
    private GNSSKalmanState mState;

    /**
     * Timestamp expressed in seconds since epoch time when Kalman filter state
     * was last propagated.
     */
    private Double mLastStateTimestamp;

    /**
     * Indicates whether this estimator is running or not.
     */
    private boolean mRunning;

    /**
     * Constructor.
     */
<span class="fc" id="L94">    public GNSSKalmanFilteredEstimator() {</span>
<span class="fc" id="L95">    }</span>

    /**
     * Constructor.
     *
     * @param config GNSS Kalman filter configuration parameters (usually obtained
     *               through calibration).
     */
<span class="fc" id="L103">    public GNSSKalmanFilteredEstimator(final GNSSKalmanConfig config) {</span>
<span class="fc" id="L104">        mConfig = new GNSSKalmanConfig(config);</span>
<span class="fc" id="L105">    }</span>

    /**
     * Constructor.
     *
     * @param epochInterval minimum epoch interval expressed in seconds (s) between
     *                      consecutive propagations or measurements.
     * @throws IllegalArgumentException if provided epoch interval is negative.
     */
<span class="fc" id="L114">    public GNSSKalmanFilteredEstimator(final double epochInterval) {</span>
        try {
<span class="fc" id="L116">            setEpochInterval(epochInterval);</span>
<span class="nc" id="L117">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L119">        }</span>
<span class="fc" id="L120">    }</span>

    /**
     * Constructor.
     *
     * @param listener listener to notify events raised by this instance.
     */
    public GNSSKalmanFilteredEstimator(
<span class="fc" id="L128">            final GNSSKalmanFilteredEstimatorListener listener) {</span>
<span class="fc" id="L129">        mListener = listener;</span>
<span class="fc" id="L130">    }</span>

    /**
     * Constructor.
     *
     * @param config        GNSS Kalman filter configuration parameters (usually
     *                      obtained through calibration).
     * @param epochInterval minimum epoch interval expressed in seconds (s) between
     *                      consecutive propagations or measurements.
     * @throws IllegalArgumentException if provided epoch interval is negative.
     */
    public GNSSKalmanFilteredEstimator(final GNSSKalmanConfig config,
                                       final double epochInterval) {
<span class="fc" id="L143">        this(epochInterval);</span>
<span class="fc" id="L144">        mConfig = new GNSSKalmanConfig(config);</span>
<span class="fc" id="L145">    }</span>

    /**
     * Constructor.
     *
     * @param config   GNSS Kalman filter configuration parameters (usually
     *                 obtained through calibration).
     * @param listener listener to notify events raised by this instance.
     */
    public GNSSKalmanFilteredEstimator(
            final GNSSKalmanConfig config,
            final GNSSKalmanFilteredEstimatorListener listener) {
<span class="fc" id="L157">        this(config);</span>
<span class="fc" id="L158">        mListener = listener;</span>
<span class="fc" id="L159">    }</span>

    /**
     * Constructor.
     *
     * @param epochInterval minimum epoch interval expressed in seconds (s) between
     *                      consecutive propagations or measurements.
     * @param listener      listener to notify events raised by this instance.
     * @throws IllegalArgumentException if provided epoch interval is negative.
     */
    public GNSSKalmanFilteredEstimator(
            final double epochInterval,
            final GNSSKalmanFilteredEstimatorListener listener) {
<span class="fc" id="L172">        this(epochInterval);</span>
<span class="fc" id="L173">        mListener = listener;</span>
<span class="fc" id="L174">    }</span>

    /**
     * Constructor.
     *
     * @param config        GNSS Kalman filter configuration parameters (usually obtained
     *                      through calibration).
     * @param epochInterval minimum epoch interval expressed in seconds (s) between
     *                      consecutive propagations or measurements.
     * @param listener      listener to notify events raised by this instance.
     * @throws IllegalArgumentException if provided epoch interval is negative.
     */
    public GNSSKalmanFilteredEstimator(
            final GNSSKalmanConfig config, final double epochInterval,
            final GNSSKalmanFilteredEstimatorListener listener) {
<span class="fc" id="L189">        this(config, epochInterval);</span>
<span class="fc" id="L190">        mListener = listener;</span>
<span class="fc" id="L191">    }</span>

    /**
     * Constructor.
     *
     * @param epochInterval minimum epoch interval between consecutive
     *                      propagations or measurements.
     * @throws IllegalArgumentException if provided epoch interval is negative.
     */
    public GNSSKalmanFilteredEstimator(final Time epochInterval) {
<span class="fc" id="L201">        this(TimeConverter.convert(epochInterval.getValue().doubleValue(),</span>
<span class="fc" id="L202">                epochInterval.getUnit(), TimeUnit.SECOND));</span>
<span class="fc" id="L203">    }</span>

    /**
     * Constructor.
     *
     * @param config        GNSS Kalman filter configuration parameters (usually
     *                      obtained through calibration).
     * @param epochInterval minimum epoch interval between consecutive propagations
     *                      or measurements.
     * @throws IllegalArgumentException if provided epoch interval is negative.
     */
    public GNSSKalmanFilteredEstimator(final GNSSKalmanConfig config,
                                       final Time epochInterval) {
<span class="fc" id="L216">        this(config, TimeConverter.convert(epochInterval.getValue().doubleValue(),</span>
<span class="fc" id="L217">                epochInterval.getUnit(), TimeUnit.SECOND));</span>
<span class="fc" id="L218">    }</span>

    /**
     * Constructor.
     *
     * @param epochInterval minimum epoch interval between consecutive propagations
     *                      or measurements.
     * @param listener      listener to notify events raised by this instance.
     * @throws IllegalArgumentException if provided epoch interval is negative.
     */
    public GNSSKalmanFilteredEstimator(
            final Time epochInterval,
            final GNSSKalmanFilteredEstimatorListener listener) {
<span class="fc" id="L231">        this(epochInterval);</span>
<span class="fc" id="L232">        mListener = listener;</span>
<span class="fc" id="L233">    }</span>

    /**
     * Constructor.
     *
     * @param config        GNSS Kalman filter configuration parameters (usually
     *                      obtained through calibration).
     * @param epochInterval minimum epoch interval between consecutive propagations
     *                      or measurements.
     * @param listener      listener to notify events raised by this instance.
     * @throws IllegalArgumentException if provided epoch interval is negative.
     */
    public GNSSKalmanFilteredEstimator(
            final GNSSKalmanConfig config, final Time epochInterval,
            final GNSSKalmanFilteredEstimatorListener listener) {
<span class="fc" id="L248">        this(config, epochInterval);</span>
<span class="fc" id="L249">        mListener = listener;</span>
<span class="fc" id="L250">    }</span>

    /**
     * Gets listener to notify events raised by this instance.
     *
     * @return listener to notify events raised by this instance.
     */
    public GNSSKalmanFilteredEstimatorListener getListener() {
<span class="fc" id="L258">        return mListener;</span>
    }

    /**
     * Sets listener to notify events raised by this instance.
     *
     * @param listener listener to notify events raised by this instance.
     * @throws LockedException if this estimator is already running.
     */
    public void setListener(final GNSSKalmanFilteredEstimatorListener listener)
            throws LockedException {
<span class="fc bfc" id="L269" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L270">            throw new LockedException();</span>
        }

<span class="fc" id="L273">        mListener = listener;</span>
<span class="fc" id="L274">    }</span>

    /**
     * Gets minimum epoch interval expressed in seconds (s) between consecutive
     * propagations or measurements expressed in seconds.
     * Attempting to propagate results using Kalman filter or updating measurements
     * when intervals are less than this value, will be ignored.
     *
     * @return minimum epoch interval between consecutive propagations or
     * measurements.
     */
    public double getEpochInterval() {
<span class="fc" id="L286">        return mEpochInterval;</span>
    }

    /**
     * Sets minimum epoch interval expressed in seconds (s) between consecutive
     * propagations or measurements expressed in seconds.
     * Attempting to propagate results using Kalman filter or updating measurements
     * when intervals are less than this value, will be ignored.
     *
     * @param epochInterval minimum epoch interval expressed in seconds (s) between
     *                      consecutive propagations or measurements.
     * @throws LockedException          if this estimator is already running.
     * @throws IllegalArgumentException if provided epoch interval is negative.
     */
    public void setEpochInterval(final double epochInterval) throws LockedException {
<span class="fc bfc" id="L301" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L302">            throw new LockedException();</span>
        }

<span class="pc bpc" id="L305" title="1 of 2 branches missed.">        if (epochInterval &lt; 0.0) {</span>
<span class="nc" id="L306">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L309">        mEpochInterval = epochInterval;</span>
<span class="fc" id="L310">    }</span>

    /**
     * Gets minimum epoch interval between consecutive propagations or measurements.
     * Attempting to propagate results using Kalman filter or updating measurements
     * when intervals are less than this value, will be ignored.
     *
     * @param result instance where minimum epoch interval will be stored.
     */
    public void getEpochIntervalAsTime(final Time result) {
<span class="fc" id="L320">        result.setValue(mEpochInterval);</span>
<span class="fc" id="L321">        result.setUnit(TimeUnit.SECOND);</span>
<span class="fc" id="L322">    }</span>

    /**
     * Gets minimum epoch interval between consecutive propagations or measurements.
     * Attempting to propagate results using Kalman filter or updating measurements
     * when intervals are less than this value, will be ignored.
     *
     * @return minimum epoch interval.
     */
    public Time getEpochIntervalAsTime() {
<span class="fc" id="L332">        return new Time(mEpochInterval, TimeUnit.SECOND);</span>
    }

    /**
     * Sets minimum epoch interval between consecutive propagations or measurements.
     * Attempting to propagate results using Kalman filter or updating measurements
     * when intervals are less than this value, will be ignored.
     *
     * @param epochInterval minimum epoch interval.
     * @throws LockedException          if this estimator is already running.
     * @throws IllegalArgumentException if provided epoch interval is negative.
     */
    public void setEpochInterval(final Time epochInterval) throws LockedException {
<span class="fc" id="L345">        final double epochIntervalSeconds = TimeConverter.convert(</span>
<span class="fc" id="L346">                epochInterval.getValue().doubleValue(),</span>
<span class="fc" id="L347">                epochInterval.getUnit(), TimeUnit.SECOND);</span>
<span class="fc" id="L348">        setEpochInterval(epochIntervalSeconds);</span>
<span class="fc" id="L349">    }</span>

    /**
     * Gets GNSS Kalman configuration parameters (usually obtained through
     * calibration).
     *
     * @param result instance where GNSS Kalman configuration parameters will be
     *               stored.
     * @return true if result instance is updated, false otherwise.
     */
    public boolean getConfig(final GNSSKalmanConfig result) {
<span class="fc bfc" id="L360" title="All 2 branches covered.">        if (mConfig != null) {</span>
<span class="fc" id="L361">            result.copyFrom(mConfig);</span>
<span class="fc" id="L362">            return true;</span>
        } else {
<span class="fc" id="L364">            return false;</span>
        }
    }

    /**
     * Gets GNSS Kalman configuration parameters (usually obtained through
     * calibration).
     *
     * @return GNSS Kalman configuration parameters.
     */
    public GNSSKalmanConfig getConfig() {
<span class="fc" id="L375">        return mConfig;</span>
    }

    /**
     * Sets GNSS Kalman configuration parameters (usually obtained through
     * calibration).
     *
     * @param config GNSS Kalman configuration parameters to be set.
     * @throws LockedException if this estimator is already running.
     */
    public void setConfig(final GNSSKalmanConfig config)
            throws LockedException {
<span class="fc bfc" id="L387" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L388">            throw new LockedException();</span>
        }

<span class="fc" id="L391">        mConfig = new GNSSKalmanConfig(config);</span>
<span class="fc" id="L392">    }</span>

    /**
     * Gets last updated GNSS measurements of a collection of satellites.
     *
     * @return last updated GNSS measurements of a collection of satellites.
     */
    public Collection&lt;GNSSMeasurement&gt; getMeasurements() {
<span class="fc bfc" id="L400" title="All 2 branches covered.">        if (mMeasurements == null) {</span>
<span class="fc" id="L401">            return null;</span>
        }

<span class="fc" id="L404">        final List&lt;GNSSMeasurement&gt; result = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L405" title="All 2 branches covered.">        for (GNSSMeasurement measurement : mMeasurements) {</span>
<span class="fc" id="L406">            result.add(new GNSSMeasurement(measurement));</span>
<span class="fc" id="L407">        }</span>
<span class="fc" id="L408">        return result;</span>
    }

    /**
     * Gets current estimation containing user ECEF position, user ECEF velocity,
     * clock offset and clock drift.
     *
     * @return current estimation containing user ECEF position, user ECEF velocity,
     * clock offset and clock drift.
     */
    public GNSSEstimation getEstimation() {
<span class="fc bfc" id="L419" title="All 2 branches covered.">        return mEstimation != null ? new GNSSEstimation(mEstimation) : null;</span>
    }

    /**
     * Gets current estimation containing user ECEF position, user ECEF velocity,
     * clock offset and clock drift.
     * This method does not update result instance if no estimation is available.
     *
     * @param result instance where estimation will be stored.
     * @return true if result estimation was updated, false otherwise.
     */
    public boolean getEstimation(final GNSSEstimation result) {
<span class="fc bfc" id="L431" title="All 2 branches covered.">        if (mEstimation != null) {</span>
<span class="fc" id="L432">            result.copyFrom(mEstimation);</span>
<span class="fc" id="L433">            return true;</span>
        } else {
<span class="fc" id="L435">            return false;</span>
        }
    }

    /**
     * Gets current Kalman filter state containing current GNSS estimation along with
     * Kalman filter covariance error matrix.
     *
     * @return current Kalman filter state containing current GNSS estimation along
     * with Kalman filter covariance error matrix.
     */
    public GNSSKalmanState getState() {
<span class="fc bfc" id="L447" title="All 2 branches covered.">        return mState != null ? new GNSSKalmanState(mState) : null;</span>
    }

    /**
     * Gets current Kalman filter state containing current GNSS estimation along with
     * Kalman filter covariance error matrix.
     * This method does not update result instance if no state is available.
     *
     * @param result instance where state will be stored.
     * @return true if result state was updated, false otherwise.
     */
    public boolean getState(final GNSSKalmanState result) {
<span class="fc bfc" id="L459" title="All 2 branches covered.">        if (mState != null) {</span>
<span class="fc" id="L460">            result.copyFrom(mState);</span>
<span class="fc" id="L461">            return true;</span>
        } else {
<span class="fc" id="L463">            return false;</span>
        }
    }

    /**
     * Gets timestamp expressed in seconds since epoch time when Kalman filter state
     * was last propagated.
     *
     * @return timestamp expressed in seconds since epoch time when Kalman filter
     * state was last propagated.
     */
    public Double getLastStateTimestamp() {
<span class="fc" id="L475">        return mLastStateTimestamp;</span>
    }

    /**
     * Gets timestamp since epoch time when Kalman filter state was last propageted.
     *
     * @param result instance where timestamp since epoch time when Kalman filter
     *               state was last propagated will be stored.
     * @return true if result instance is updated, false otherwise.
     */
    public boolean getLastStateTimestampAsTime(final Time result) {
<span class="fc bfc" id="L486" title="All 2 branches covered.">        if (mLastStateTimestamp != null) {</span>
<span class="fc" id="L487">            result.setValue(mLastStateTimestamp);</span>
<span class="fc" id="L488">            result.setUnit(TimeUnit.SECOND);</span>
<span class="fc" id="L489">            return true;</span>
        } else {
<span class="fc" id="L491">            return false;</span>
        }
    }

    /**
     * Gets timestamp since epoch time when Kalman filter state was last propagated.
     *
     * @return timestamp since epoch time when Kalman filter state was last
     * propagated.
     */
    public Time getLastStateTimestampAsTime() {
<span class="fc bfc" id="L502" title="All 2 branches covered.">        return mLastStateTimestamp != null ?</span>
<span class="fc" id="L503">                new Time(mLastStateTimestamp, TimeUnit.SECOND) : null;</span>
    }

    /**
     * Indicates whether this estimator is running or not.
     *
     * @return true if this estimator is running, false otherwise.
     */
    public boolean isRunning() {
<span class="fc" id="L512">        return mRunning;</span>
    }

    /**
     * Indicates whether provided measurements are ready to
     * be used for an update.
     *
     * @param measurements measurements to be checked.
     * @return true if estimator is ready, false otherwise.
     */
    public static boolean isUpdateMeasurementsReady(
            final Collection&lt;GNSSMeasurement&gt; measurements) {
<span class="fc" id="L524">        return GNSSLeastSquaresPositionAndVelocityEstimator</span>
<span class="fc" id="L525">                .isValidMeasurements(measurements);</span>
    }

    /**
     * Updates GNSS measurements of this estimator when new satellite measurements
     * are available.
     * Calls to this method will be ignored if interval between provided timestamp
     * and last timestamp when Kalman filter was updated is less than epoch interval.
     *
     * @param measurements GNSS measurements to be updated.
     * @param timestamp    timestamp since epoch time when GNSS measurements were
     *                     updated.
     * @return true if measurements were updated, false otherwise.
     * @throws LockedException   if this estimator is already running.
     * @throws NotReadyException if estimator is not ready for measurements updates.
     * @throws GNSSException     if estimation fails due to numerical instabilities.
     */
    public boolean updateMeasurements(
            final Collection&lt;GNSSMeasurement&gt; measurements, final Time timestamp)
            throws LockedException, NotReadyException, GNSSException {
<span class="fc" id="L545">        return updateMeasurements(measurements, TimeConverter.convert(</span>
<span class="fc" id="L546">                timestamp.getValue().doubleValue(), timestamp.getUnit(),</span>
                TimeUnit.SECOND));
    }

    /**
     * Updates GNSS measurements of this estimator when new satellite measurements
     * are available.
     * Call to this method will be ignored if interval between provided timestamp
     * and last timestamp when Kalman filter was updated is less than epoch interval.
     *
     * @param measurements GNSS measurements to be updated.
     * @param timestamp    timestamp expressed in seconds since epoch time when
     *                     GNSS measurements were updated.
     * @return true if measurements were updated, false otherwise.
     * @throws LockedException   if this estimator is already running.
     * @throws NotReadyException if estimator is not ready for measurements updates.
     * @throws GNSSException     if estimation fails due to numerical instabilities.
     */
    public boolean updateMeasurements(
            final Collection&lt;GNSSMeasurement&gt; measurements, final double timestamp)
            throws LockedException, NotReadyException, GNSSException {

<span class="fc bfc" id="L568" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L569">            throw new LockedException();</span>
        }

<span class="fc bfc" id="L572" title="All 2 branches covered.">        if (!isUpdateMeasurementsReady(measurements)) {</span>
<span class="fc" id="L573">            throw new NotReadyException();</span>
        }

<span class="fc bfc" id="L576" title="All 2 branches covered.">        if (mLastStateTimestamp != null &amp;&amp;</span>
<span class="pc bpc" id="L577" title="1 of 2 branches missed.">                timestamp - mLastStateTimestamp &lt;= mEpochInterval) {</span>
<span class="fc" id="L578">            return false;</span>
        }

        try {
<span class="fc" id="L582">            mRunning = true;</span>

<span class="pc bpc" id="L584" title="1 of 2 branches missed.">            if (mListener != null) {</span>
<span class="fc" id="L585">                mListener.onUpdateStart(this);</span>
            }

<span class="fc" id="L588">            mMeasurements = new ArrayList&lt;&gt;(measurements);</span>

<span class="fc" id="L590">            mLsEstimator.setMeasurements(mMeasurements);</span>
<span class="fc" id="L591">            mLsEstimator.setPriorPositionAndVelocityFromEstimation(mEstimation);</span>
<span class="pc bpc" id="L592" title="1 of 2 branches missed.">            if (mEstimation != null) {</span>
<span class="nc" id="L593">                mLsEstimator.estimate(mEstimation);</span>
            } else {
<span class="fc" id="L595">                mEstimation = mLsEstimator.estimate();</span>
            }

<span class="pc bpc" id="L598" title="1 of 2 branches missed.">            if (mListener != null) {</span>
<span class="fc" id="L599">                mListener.onUpdateEnd(this);</span>
            }

        } finally {
<span class="fc" id="L603">            mRunning = false;</span>
        }

<span class="fc" id="L606">        propagate(timestamp);</span>

<span class="fc" id="L608">        return true;</span>
    }

    /**
     * Indicates whether this estimator is ready for state propagations.
     *
     * @return true if estimator is ready, false otherwise.
     */
    public boolean isPropagateReady() {
<span class="fc bfc" id="L617" title="All 4 branches covered.">        return mConfig != null &amp;&amp; mEstimation != null;</span>
    }

    /**
     * Propagates Kalman filter state held by this estimator at provided
     * timestamp.
     * Call to this method will be ignored if interval between provided timestamp
     * and last timestamp when Kalman filter was updated is less than epoch interval.
     *
     * @param timestamp timestamp since epoch to propagate state.
     * @return true if state was propagated, false otherwise.
     * @throws LockedException   if this estimator is already running.
     * @throws NotReadyException if estimator is not ready for measurements updates.
     * @throws GNSSException     if estimation fails due to numerical instabilities.
     */
    public boolean propagate(final Time timestamp) throws LockedException,
            NotReadyException, GNSSException {
<span class="fc" id="L634">        return propagate(TimeConverter.convert(timestamp.getValue().doubleValue(),</span>
<span class="fc" id="L635">                timestamp.getUnit(), TimeUnit.SECOND));</span>
    }

    /**
     * Propagates Kalman filter state held by this estimator at provided
     * timestamp.
     * Call to this method will be ignored if interval between provided timestamp
     * and last timestamp when Kalman filter was updated is less than epoch interval.
     *
     * @param timestamp timestamp expressed in seconds since epoch to propagate state.
     * @return true if state was propagated, false otherwise.
     * @throws LockedException   if this estimator is already running.
     * @throws NotReadyException if estimator is not ready for measurements updates.
     * @throws GNSSException     if estimation fails due to numerical instabilities.
     */
    public boolean propagate(final double timestamp) throws LockedException,
            NotReadyException, GNSSException {

<span class="fc bfc" id="L653" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L654">            throw new LockedException();</span>
        }

<span class="fc bfc" id="L657" title="All 2 branches covered.">        if (!isPropagateReady()) {</span>
<span class="fc" id="L658">            throw new NotReadyException();</span>
        }

<span class="fc bfc" id="L661" title="All 2 branches covered.">        final double propagationInterval = mLastStateTimestamp != null ?</span>
<span class="fc" id="L662">                timestamp - mLastStateTimestamp : 0.0;</span>
<span class="fc bfc" id="L663" title="All 4 branches covered.">        if (mLastStateTimestamp != null &amp;&amp; propagationInterval &lt;= mEpochInterval) {</span>
<span class="fc" id="L664">            return false;</span>
        }

        try {
<span class="fc" id="L668">            mRunning = true;</span>

<span class="pc bpc" id="L670" title="1 of 2 branches missed.">            if (mListener != null) {</span>
<span class="fc" id="L671">                mListener.onPropagateStart(this);</span>
            }

<span class="fc bfc" id="L674" title="All 2 branches covered.">            if (mState == null) {</span>
<span class="fc" id="L675">                mState = GNSSKalmanInitializer.initialize(mEstimation, mConfig);</span>
            }

<span class="fc" id="L678">            GNSSKalmanEpochEstimator.estimate(mMeasurements, propagationInterval,</span>
                    mState, mConfig, mState);
<span class="fc" id="L680">            mLastStateTimestamp = timestamp;</span>

<span class="fc" id="L682">            mState.getEstimation(mEstimation);</span>

<span class="pc bpc" id="L684" title="1 of 2 branches missed.">            if (mListener != null) {</span>
<span class="fc" id="L685">                mListener.onPropagateEnd(this);</span>
            }

<span class="nc" id="L688">        } catch (final AlgebraException e) {</span>
<span class="nc" id="L689">            throw new GNSSException(e);</span>
        } finally {
<span class="fc" id="L691">            mRunning = false;</span>
        }

<span class="fc" id="L694">        return true;</span>
    }

    /**
     * Resets this estimator.
     *
     * @throws LockedException if this estimator is already running.
     */
    public void reset() throws LockedException {
<span class="fc bfc" id="L703" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L704">            throw new LockedException();</span>
        }

<span class="fc" id="L707">        mRunning = true;</span>
<span class="fc" id="L708">        mMeasurements = null;</span>
<span class="fc" id="L709">        mEstimation = null;</span>
<span class="fc" id="L710">        mState = null;</span>
<span class="fc" id="L711">        mLastStateTimestamp = null;</span>

<span class="pc bpc" id="L713" title="1 of 2 branches missed.">        if (mListener != null) {</span>
<span class="fc" id="L714">            mListener.onReset(this);</span>
        }

<span class="fc" id="L717">        mRunning = false;</span>
<span class="fc" id="L718">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>