<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AccumulatedMeasurementNoiseEstimator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.irurueta:irurueta-navigation</a> &gt; <a href="index.source.html" class="el_package">com.irurueta.navigation.inertial.calibration.noise</a> &gt; <span class="el_source">AccumulatedMeasurementNoiseEstimator.java</span></div><h1>AccumulatedMeasurementNoiseEstimator.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2020 Alberto Irurueta Carro (alberto@irurueta.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.irurueta.navigation.inertial.calibration.noise;

import com.irurueta.navigation.LockedException;
import com.irurueta.navigation.inertial.calibration.TimeIntervalEstimator;
import com.irurueta.units.Measurement;
import com.irurueta.units.Time;
import com.irurueta.units.TimeConverter;
import com.irurueta.units.TimeUnit;

/**
 * Base class to estimate measurement noise variances and PSD's (Power Spectral Densities)
 * along with their average values.
 * Implementations of this estimator may use norms of measurement triads to estimate noise
 * levels.
 * To compute PSD's, this estimator assumes that measurement samples are obtained
 * at a constant provided rate equal to {@link #getTimeInterval()} seconds.
 * If not available, accelerometer sampling rate average can be estimated using
 * {@link TimeIntervalEstimator}.
 *
 * @param &lt;U&gt; a measurement unit type.
 * @param &lt;M&gt; a measurement type.
 * @param &lt;E&gt; an estimator type.
 * @param &lt;L&gt; a listener type.
 */
public abstract class AccumulatedMeasurementNoiseEstimator&lt;U extends Enum&lt;?&gt;,
        M extends Measurement&lt;U&gt;,
        E extends AccumulatedMeasurementNoiseEstimator&lt;U, M, E, L&gt;,
        L extends AccumulatedMeasurementNoiseEstimatorListener&lt;U, M, E&gt;&gt; {

    /**
     * Default time interval between accelerometer samples expressed in seconds
     * (s).
     */
    public static final double DEFAULT_TIME_INTERVAL_SECONDS = 0.02;

    /**
     * Time interval expressed in seconds (s) between consecutive accelerometer
     * samples.
     */
<span class="fc" id="L55">    private double mTimeInterval = DEFAULT_TIME_INTERVAL_SECONDS;</span>

    /**
     * Listener to handle events raised by this estimator.
     */
    private L mListener;

    /**
     * Last provided measurement.
     */
    private M mLastMeasurement;

    /**
     * Contains estimated average of measurement expressed in its default unit
     * (m/s^2 for acceleration, rad/s for angular speed or T for magnetic flux density).
     */
    private double mAvg;

    /**
     * Contains estimated variance of measurement expressed in its default squared unit
     * (m^2/s^4 for acceleration, rad^2/s^2 for angular speed or T^2 for magnetic
     * flux density).
     */
    private double mVariance;

    /**
     * Number of processed body kinematics samples.
     */
    private int mNumberOfProcessedSamples;

    /**
     * Number of processed timestamp samples plus one.
     */
<span class="fc" id="L88">    private int mNumberOfProcessedSamplesPlusOne = 1;</span>

    /**
     * Indicates that estimator is running.
     */
    private boolean mRunning;

    /**
     * Constructor.
     */
<span class="fc" id="L98">    public AccumulatedMeasurementNoiseEstimator() {</span>
<span class="fc" id="L99">    }</span>

    /**
     * Constructor.
     *
     * @param listener listener to handle events raised by this estimator.
     */
<span class="fc" id="L106">    public AccumulatedMeasurementNoiseEstimator(final L listener) {</span>
<span class="fc" id="L107">        mListener = listener;</span>
<span class="fc" id="L108">    }</span>

    /**
     * Gets time interval between accelerometer triad samples expressed in
     * seconds (s).
     *
     * @return time interval between accelerometer triad samples.
     */
    public double getTimeInterval() {
<span class="fc" id="L117">        return mTimeInterval;</span>
    }

    /**
     * Sets time interval between accelerometer triad samples expressed in
     * seconds (s).
     *
     * @param timeInterval time interval between accelerometer triad samples.
     * @throws IllegalArgumentException if provided value is negative.
     * @throws LockedException          if estimator is currently running.
     */
    public void setTimeInterval(final double timeInterval) throws LockedException {
<span class="fc bfc" id="L129" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L130">            throw new LockedException();</span>
        }

<span class="fc bfc" id="L133" title="All 2 branches covered.">        if (timeInterval &lt; 0.0) {</span>
<span class="fc" id="L134">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L137">        mTimeInterval = timeInterval;</span>
<span class="fc" id="L138">    }</span>

    /**
     * Gets time interval between accelerometer triad samples.
     *
     * @return time interval between accelerometer triad samples.
     */
    public Time getTimeIntervalAsTime() {
<span class="fc" id="L146">        return new Time(mTimeInterval, TimeUnit.SECOND);</span>
    }

    /**
     * Gets time interval between accelerometer triad samples.
     *
     * @param result instance where time interval will be stored.
     */
    public void getTimeIntervalAsTime(final Time result) {
<span class="fc" id="L155">        result.setValue(mTimeInterval);</span>
<span class="fc" id="L156">        result.setUnit(TimeUnit.SECOND);</span>
<span class="fc" id="L157">    }</span>

    /**
     * Sets time interval between accelerometer triad samples.
     *
     * @param timeInterval time interval between accelerometer triad samples.
     * @throws LockedException if estimator is currently running.
     */
    public void setTimeInterval(final Time timeInterval) throws LockedException {
<span class="fc" id="L166">        setTimeInterval(TimeConverter.convert(timeInterval.getValue().doubleValue(),</span>
<span class="fc" id="L167">                timeInterval.getUnit(), TimeUnit.SECOND));</span>
<span class="fc" id="L168">    }</span>

    /**
     * Gets listener to handle events raised by this estimator.
     *
     * @return listener to handle events raised by this estimator.
     */
    public L getListener() {
<span class="fc" id="L176">        return mListener;</span>
    }

    /**
     * Sets listener to handle events raised by this estimator.
     *
     * @param listener listener to handle events raised by this estimator.
     * @throws LockedException if this estimator is running.
     */
    public void setListener(final L listener) throws LockedException {
<span class="fc bfc" id="L186" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L187">            throw new LockedException();</span>
        }

<span class="fc" id="L190">        mListener = listener;</span>
<span class="fc" id="L191">    }</span>

    /**
     * Gets last provided measurement or null if not available.
     *
     * @return last provided measurement or null.
     */
    public M getLastMeasurement() {
<span class="fc" id="L199">        return mLastMeasurement;</span>
    }

    /**
     * Gets last provided measurement.
     *
     * @param result instance where last provided measurement will be stored.
     * @return true if result instance was updated, false otherwise.
     */
    public boolean getLastMeasurement(final M result) {
<span class="fc bfc" id="L209" title="All 2 branches covered.">        if (mLastMeasurement != null) {</span>
<span class="fc" id="L210">            result.setValue(mLastMeasurement.getValue());</span>
<span class="fc" id="L211">            result.setUnit(mLastMeasurement.getUnit());</span>
<span class="fc" id="L212">            return true;</span>
        } else {
<span class="fc" id="L214">            return false;</span>
        }
    }

    /**
     * Gets estimated average of measurement expressed in its default unit
     * (m/s^2 for acceleration, rad/s for angular speed or T for magnetic flux density).
     *
     * @return average of measurement in current window.
     */
    public double getAvg() {
<span class="fc" id="L225">        return mAvg;</span>
    }

    /**
     * Gets estimated average of measurement within current window.
     *
     * @return average of measurement in current window
     */
    public M getAvgAsMeasurement() {
<span class="fc" id="L234">        return createMeasurement(mAvg, getDefaultUnit());</span>
    }

    /**
     * Gets estimated average of measurement within current window.
     *
     * @param result instance where average of measurement will be stored.
     */
    public void getAvgAsMeasurement(final M result) {
<span class="fc" id="L243">        result.setValue(mAvg);</span>
<span class="fc" id="L244">        result.setUnit(getDefaultUnit());</span>
<span class="fc" id="L245">    }</span>

    /**
     * Gets estimated variance of measurement within current window
     * expressed in its default squared unit (m^2/s^4 for acceleration,
     * rad^2/s^2 for angular speed or T^2 for magnetic flux density).
     *
     * @return estimated variance of measurement within current window.
     */
    public double getVariance() {
<span class="fc" id="L255">        return mVariance;</span>
    }

    /**
     * Gets estimated standard deviation of measurement within current window
     * and expressed in its default unit (m/s^2 for acceleration, rad/s for
     * angular speed or T for magnetic flux density).
     *
     * @return estimated standard of measurement.
     */
    public double getStandardDeviation() {
<span class="fc" id="L266">        return Math.sqrt(mVariance);</span>
    }

    /**
     * Gets estimated standard deviation of measurement within current window.
     *
     * @return estimated standard deviation of measurement.
     */
    public M getStandardDeviationAsMeasurement() {
<span class="fc" id="L275">        return createMeasurement(getStandardDeviation(), getDefaultUnit());</span>
    }

    /**
     * Gets estimated standard deviation of measurement within current window.
     *
     * @param result instance where estimated standard deviation of measurement
     *               will be stored.
     */
    public void getStandardDeviationAsMeasurement(final M result) {
<span class="fc" id="L285">        result.setValue(getStandardDeviation());</span>
<span class="fc" id="L286">        result.setUnit(getDefaultUnit());</span>
<span class="fc" id="L287">    }</span>

    /**
     * Gets measurement noise PSD (Power Spectral Density) expressed
     * in (m^2 * s^-3) for accelerometer, (rad^2/s) for gyroscope or (T^2 * s) for
     * magnetometer.
     *
     * @return measureent noise PSD.
     */
    public double getPsd() {
<span class="fc" id="L297">        return mVariance * mTimeInterval;</span>
    }

    /**
     * Gets measurement noise root PSD (Power Spectral Density) expressed in
     * (m * s^-1.5) for accelerometer, (rad * s^-0.5) for gyroscope or (T * s^0.5) for
     * magnetometer.
     *
     * @return measurement noise root PSD.
     */
    public double getRootPsd() {
<span class="fc" id="L308">        return Math.sqrt(getPsd());</span>
    }

    /**
     * Gets number of samples that have been processed so far.
     *
     * @return number of samples that have been processed so far.
     */
    public int getNumberOfProcessedSamples() {
<span class="fc" id="L317">        return mNumberOfProcessedSamples;</span>
    }

    /**
     * Indicates whether estimator is currently running or not.
     *
     * @return true if estimator is running, false otherwise.
     */
    public boolean isRunning() {
<span class="fc" id="L326">        return mRunning;</span>
    }

    /**
     * Adds a measurement value expressed in its default unit (m/s^2 for acceleration, rad/s for
     * angular speed or T for magnetic flux density).
     *
     * @param value value to be added.
     * @return true if provided measurement value has been processed, false if it has
     * been ignored.
     * @throws LockedException if estimator is currently running.
     */
    public boolean addMeasurement(final double value) throws LockedException {

<span class="fc bfc" id="L340" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L341">            throw new LockedException();</span>
        }

<span class="fc" id="L344">        mRunning = true;</span>

<span class="pc bpc" id="L346" title="1 of 4 branches missed.">        if (mLastMeasurement == null &amp;&amp; mListener != null) {</span>
            //noinspection unchecked
<span class="fc" id="L348">            mListener.onStart((E) this);</span>
        }

        // compute average
<span class="fc" id="L352">        final double tmp = (double) mNumberOfProcessedSamples / (double) mNumberOfProcessedSamplesPlusOne;</span>
<span class="fc" id="L353">        mAvg = mAvg * tmp + value / (double) mNumberOfProcessedSamplesPlusOne;</span>

        // compute variance
<span class="fc" id="L356">        final double diff = value - mAvg;</span>
<span class="fc" id="L357">        final double diff2 = diff * diff;</span>

<span class="fc" id="L359">        mVariance = mVariance * tmp + diff2 / (double) mNumberOfProcessedSamplesPlusOne;</span>

<span class="fc bfc" id="L361" title="All 2 branches covered.">        if (mLastMeasurement == null) {</span>
<span class="fc" id="L362">            mLastMeasurement = createMeasurement(value, getDefaultUnit());</span>
        } else {
<span class="fc" id="L364">            mLastMeasurement.setValue(value);</span>
<span class="fc" id="L365">            mLastMeasurement.setUnit(getDefaultUnit());</span>
        }

<span class="fc" id="L368">        mNumberOfProcessedSamples++;</span>
<span class="fc" id="L369">        mNumberOfProcessedSamplesPlusOne++;</span>

<span class="pc bpc" id="L371" title="1 of 2 branches missed.">        if (mListener != null) {</span>
            //noinspection unchecked
<span class="fc" id="L373">            mListener.onMeasurementAdded((E) this);</span>
        }

<span class="fc" id="L376">        mRunning = false;</span>

<span class="fc" id="L378">        return true;</span>
    }

    /**
     * Adds a measurement value.
     *
     * @param measurement measurement to be added.
     * @return true if provided measurement value has been processed, false if it has
     * been ignored.
     * @throws LockedException if estimator is currently running.
     */
    public boolean addMeasurement(final M measurement) throws LockedException {
<span class="fc" id="L390">        return addMeasurement(convertToDefaultUnit(measurement));</span>
    }

    /**
     * Resets current estimator.
     *
     * @return true if estimator was successfully reset, false if no reset was needed.
     * @throws LockedException if estimator is currently running.
     */
    public boolean reset() throws LockedException {
<span class="fc bfc" id="L400" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L401">            throw new LockedException();</span>
        }

<span class="pc bpc" id="L404" title="1 of 2 branches missed.">        if (mNumberOfProcessedSamples == 0) {</span>
<span class="nc" id="L405">            return false;</span>
        }

<span class="fc" id="L408">        mRunning = true;</span>
<span class="fc" id="L409">        mLastMeasurement = null;</span>
<span class="fc" id="L410">        mAvg = 0.0;</span>
<span class="fc" id="L411">        mVariance = 0.0;</span>
<span class="fc" id="L412">        mNumberOfProcessedSamples = 0;</span>
<span class="fc" id="L413">        mNumberOfProcessedSamplesPlusOne = 1;</span>

<span class="pc bpc" id="L415" title="1 of 2 branches missed.">        if (mListener != null) {</span>
            //noinspection unchecked
<span class="fc" id="L417">            mListener.onReset((E) this);</span>
        }

<span class="fc" id="L420">        mRunning = false;</span>

<span class="fc" id="L422">        return true;</span>
    }

    /**
     * Gets default unit for a measurement.
     *
     * @return default unit for a measurement.
     */
    protected abstract U getDefaultUnit();

    /**
     * Creates a measurement with provided value and unit.
     *
     * @param value value to be set.
     * @param unit  unit to be set.
     * @return created measurement.
     */
    protected abstract M createMeasurement(final double value, final U unit);

    /**
     * Converts provided measurement into default unit.
     *
     * @param value measurement to be converted.
     * @return converted value.
     */
    protected abstract double convertToDefaultUnit(M value);
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>