<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AccumulatedBodyKinematicsNoiseEstimator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.irurueta:irurueta-navigation</a> &gt; <a href="index.source.html" class="el_package">com.irurueta.navigation.inertial.calibration.noise</a> &gt; <span class="el_source">AccumulatedBodyKinematicsNoiseEstimator.java</span></div><h1>AccumulatedBodyKinematicsNoiseEstimator.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2020 Alberto Irurueta Carro (alberto@irurueta.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.irurueta.navigation.inertial.calibration.noise;

import com.irurueta.navigation.LockedException;
import com.irurueta.navigation.inertial.BodyKinematics;
import com.irurueta.navigation.inertial.calibration.AccelerationTriad;
import com.irurueta.navigation.inertial.calibration.AngularSpeedTriad;
import com.irurueta.navigation.inertial.calibration.IMUTimeIntervalEstimator;
import com.irurueta.units.Acceleration;
import com.irurueta.units.AccelerationConverter;
import com.irurueta.units.AccelerationUnit;
import com.irurueta.units.AngularSpeed;
import com.irurueta.units.AngularSpeedConverter;
import com.irurueta.units.AngularSpeedUnit;
import com.irurueta.units.Time;

/**
 * Estimates accumulated acceleration and angular speed noise variances and PSD's
 * (Power Spectral Densities) along with their average values.
 * This estimator must be used when the body where the accelerometer and gyroscope
 * are attached remains static on the same position with zero velocity and
 * constant (or zero) angular speed while capturing data.
 * To compute PSD's, this estimator assumes that measurement samples are obtained
 * at a constant provided rate equal to {@link #getTimeInterval()} seconds.
 * If not available, sampling rate average can be estimated using
 * {@link IMUTimeIntervalEstimator}.
 * This estimator does NOT require the knowledge of current location and body
 * orientation.
 * Because body location and orientation is not known, estimated average values
 * cannot be used to determine biases. Only norm of noise estimations
 * (variance or standard deviation) can be safely used.
 */
public class AccumulatedBodyKinematicsNoiseEstimator {

    /**
     * Default time interval between accelerometer samples expressed in seconds
     * (s).
     */
    public static final double DEFAULT_TIME_INTERVAL_SECONDS =
            AccumulatedTriadNoiseEstimator.DEFAULT_TIME_INTERVAL_SECONDS;

    /**
     * Listener to handle events raised by this estimator.
     */
    private AccumulatedBodyKinematicsNoiseEstimatorListener mListener;

    /**
     * Last provided body kinematics.
     */
    private BodyKinematics mLastBodyKinematics;

    /**
     * Accumulated acceleration estimator.
     */
<span class="fc" id="L69">    private final AccumulatedAccelerationTriadNoiseEstimator mAccelerationEstimator =</span>
            new AccumulatedAccelerationTriadNoiseEstimator();

    /**
     * Accumulated angular speed estimator.
     */
<span class="fc" id="L75">    private final AccumulatedAngularSpeedTriadNoiseEstimator mAngularSpeedEstimator =</span>
            new AccumulatedAngularSpeedTriadNoiseEstimator();

    /**
     * Indicates that estimator is running.
     */
    private boolean mRunning;

    /**
     * Constructor.
     */
<span class="fc" id="L86">    public AccumulatedBodyKinematicsNoiseEstimator() {</span>
<span class="fc" id="L87">    }</span>

    /**
     * Constructor.
     *
     * @param listener listener to handle events raised by this estimator.
     */
    public AccumulatedBodyKinematicsNoiseEstimator(
<span class="fc" id="L95">            final AccumulatedBodyKinematicsNoiseEstimatorListener listener) {</span>
<span class="fc" id="L96">        mListener = listener;</span>
<span class="fc" id="L97">    }</span>

    /**
     * Gets time interval between body kinematics samples expressed in
     * seconds (s).
     *
     * @return time interval between body kinematics samples.
     */
    public double getTimeInterval() {
<span class="fc" id="L106">        return mAccelerationEstimator.getTimeInterval();</span>
    }

    /**
     * Sets time interval between body kinematics samples expressed in
     * seconds (s).
     *
     * @param timeInterval time interval between body kinematic samples.
     * @throws IllegalArgumentException if provided value is negative.
     * @throws LockedException          if estimator is currently running.
     */
    public void setTimeInterval(final double timeInterval) throws LockedException {
<span class="fc bfc" id="L118" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L119">            throw new LockedException();</span>
        }

<span class="fc" id="L122">        mAccelerationEstimator.setTimeInterval(timeInterval);</span>
<span class="fc" id="L123">        mAngularSpeedEstimator.setTimeInterval(timeInterval);</span>
<span class="fc" id="L124">    }</span>

    /**
     * Gets time interval between body kinematics samples.
     *
     * @return time interval between body kinematics samples.
     */
    public Time getTimeIntervalAsTime() {
<span class="fc" id="L132">        return mAccelerationEstimator.getTimeIntervalAsTime();</span>
    }

    /**
     * Gets time interval between body kinematics samples.
     *
     * @param result instance where body kinematics will be stored.
     */
    public void getTimeIntervalAsTime(final Time result) {
<span class="fc" id="L141">        mAccelerationEstimator.getTimeIntervalAsTime(result);</span>
<span class="fc" id="L142">    }</span>

    /**
     * Sets time interval between body kinematics samples.
     *
     * @param timeInterval time interval between body kinematics samples.
     * @throws LockedException if estimator is currently running.
     */
    public void setTimeInterval(final Time timeInterval) throws LockedException {
<span class="fc bfc" id="L151" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L152">            throw new LockedException();</span>
        }

<span class="fc" id="L155">        mAccelerationEstimator.setTimeInterval(timeInterval);</span>
<span class="fc" id="L156">        mAngularSpeedEstimator.setTimeInterval(timeInterval);</span>
<span class="fc" id="L157">    }</span>

    /**
     * Gets listener to handle events raised by this estimator.
     *
     * @return listener to handle events raised by this estimator.
     */
    public AccumulatedBodyKinematicsNoiseEstimatorListener getListener() {
<span class="fc" id="L165">        return mListener;</span>
    }

    /**
     * Sets listener to handle events raised by this estimator.
     *
     * @param listener listener to handle events raised by this estimator.
     * @throws LockedException if this estimator is running.
     */
    public void setListener(final AccumulatedBodyKinematicsNoiseEstimatorListener listener)
            throws LockedException {
<span class="fc bfc" id="L176" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L177">            throw new LockedException();</span>
        }

<span class="fc" id="L180">        mListener = listener;</span>
<span class="fc" id="L181">    }</span>

    /**
     * Gets last provided body kinematics or null if not available.
     *
     * @return last provided body kinematics or null.
     */
    public BodyKinematics getLastBodyKinematics() {
<span class="fc" id="L189">        return mLastBodyKinematics;</span>
    }

    /**
     * Gets last provided body kinematics.
     *
     * @param result instance where last provided body kinematics will be stored.
     * @return true if result instance was updated, false otherwise.
     */
    public boolean getLastBodyKinematics(final BodyKinematics result) {
<span class="fc bfc" id="L199" title="All 2 branches covered.">        if (mLastBodyKinematics != null) {</span>
<span class="fc" id="L200">            mLastBodyKinematics.copyTo(result);</span>
<span class="fc" id="L201">            return true;</span>
        } else {
<span class="fc" id="L203">            return false;</span>
        }
    }

    /**
     * Gets estimated average of x coordinate of accelerometer sensed specific force
     * expressed in meters per squared second (m/s^2).
     * This value will depend of body location and orientation, hence it should never
     * be used as a calibration bias.
     *
     * @return average of x coordinate of sensed specific force.
     */
    public double getAvgSpecificForceX() {
<span class="fc" id="L216">        return mAccelerationEstimator.getAvgX();</span>
    }

    /**
     * Gets estimated average of x coordinate of accelerometer sensed specific force.
     * This value will depend of body location and orientation, hence it should never
     * be used as a calibration bias.
     *
     * @return average of x coordinate of sensed specific force.
     */
    public Acceleration getAvgSpecificForceXAsMeasurement() {
<span class="fc" id="L227">        return mAccelerationEstimator.getAvgXAsMeasurement();</span>
    }

    /**
     * Gets estimated average of x coordinate of accelerometer sensed specific force.
     * This value will depend of body location and orientation, hence it should never
     * be used as a calibration bias.
     *
     * @param result instance where average of x coordinate of sensed specific force
     *               will be stored.
     */
    public void getAvgSpecificForceXAsMeasurement(final Acceleration result) {
<span class="fc" id="L239">        mAccelerationEstimator.getAvgXAsMeasurement(result);</span>
<span class="fc" id="L240">    }</span>

    /**
     * Gets estimated average of y coordinate of accelerometer sensed specific force
     * expressed in meters per squared second (m/s^2).
     * This value will depend of body location and orientation, hence it should never
     * be used as a calibration bias.
     *
     * @return average of y coordinate of sensed specific force.
     */
    public double getAvgSpecificForceY() {
<span class="fc" id="L251">        return mAccelerationEstimator.getAvgY();</span>
    }

    /**
     * Gets estimated average of y coordinate of accelerometer sensed specific force.
     * This value will depend of body location and orientation, hence it should never
     * be used as a calibration bias.
     *
     * @return average of y coordinate of sensed specific force.
     */
    public Acceleration getAvgSpecificForceYAsMeasurement() {
<span class="fc" id="L262">        return mAccelerationEstimator.getAvgYAsMeasurement();</span>
    }

    /**
     * Gets estimated average of y coordinate of accelerometer sensed specific force.
     * This value will depend of body location and orientation, hence it should never
     * be used as a calibration bias.
     *
     * @param result instance where average of y coordinate of sensed specific force
     *               will be stored.
     */
    public void getAvgSpecificForceYAsMeasurement(final Acceleration result) {
<span class="fc" id="L274">        mAccelerationEstimator.getAvgYAsMeasurement(result);</span>
<span class="fc" id="L275">    }</span>

    /**
     * Gets estimated average of z coordinate of accelerometer sensed specific force
     * expressed in meters per squared second (m/s^2).
     * This value will depend of body location and orientation, hence it should never
     * be used as a calibration bias.
     *
     * @return average of z coordinate of sensed specific force.
     */
    public double getAvgSpecificForceZ() {
<span class="fc" id="L286">        return mAccelerationEstimator.getAvgZ();</span>
    }

    /**
     * Gets estimated average of z coordinate of accelerometer sensed specific force.
     * This value will depend of body location and orientation, hence it should never
     * be used as a calibration bias.
     *
     * @return average of z coordinate of sensed specific force.
     */
    public Acceleration getAvgSpecificForceZAsMeasurement() {
<span class="fc" id="L297">        return mAccelerationEstimator.getAvgZAsMeasurement();</span>
    }

    /**
     * Gets estimated average of z coordinate of accelerometer sensed specific force.
     * This value will depend of body location and orientation, hence it should never
     * be used as a calibration bias.
     *
     * @param result instance where average of z coordinate of sensed specific force
     *               will be stored.
     */
    public void getAvgSpecificForceZAsMeasurement(final Acceleration result) {
<span class="fc" id="L309">        mAccelerationEstimator.getAvgZAsMeasurement(result);</span>
<span class="fc" id="L310">    }</span>

    /**
     * Gets estimated average of accelerometer sensed specific force as a measurement
     * triad.
     *
     * @return average accelerometer triad.
     */
    public AccelerationTriad getAvgSpecificForceAsTriad() {
<span class="fc" id="L319">        return mAccelerationEstimator.getAvgTriad();</span>
    }

    /**
     * Gets estimated average of accelerometer sensed specific force as a measurement
     * triad.
     *
     * @param result instance where average accelerometer triad will be stored.
     */
    public void getAvgSpecificForceAsTriad(final AccelerationTriad result) {
<span class="fc" id="L329">        mAccelerationEstimator.getAvgTriad(result);</span>
<span class="fc" id="L330">    }</span>

    /**
     * Gets norm of estimated average acceleration expressed in meters per squared
     * second (m/s^2). This value is independent of body orientation.
     *
     * @return norm of estimated average acceleration.
     */
    public double getAvgSpecificForceNorm() {
<span class="fc" id="L339">        return mAccelerationEstimator.getAvgNorm();</span>
    }

    /**
     * Gets norm of estimated average acceleration within current window.
     *
     * @return norm of estimated average acceleration.
     */
    public Acceleration getAvgSpecificForceNormAsMeasurement() {
<span class="fc" id="L348">        return mAccelerationEstimator.getAvgNormAsMeasurement();</span>
    }

    /**
     * Gets norm of estimated average acceleration.
     *
     * @param result instance where norm of estimated average acceleration will be stored.
     */
    public void getAvgSpecificForceNormAsMeasurement(final Acceleration result) {
<span class="fc" id="L357">        mAccelerationEstimator.getAvgNormAsMeasurement(result);</span>
<span class="fc" id="L358">    }</span>

    /**
     * Gets estimated average of x coordinate of gyroscope sensed angular rate
     * expressed in radians per second (rad/s).
     * This value will depend of body location and orientation, hence it should
     * never be used as a calibration bias.
     *
     * @return average of x coordinate of sensed angular rate.
     */
    public double getAvgAngularRateX() {
<span class="fc" id="L369">        return mAngularSpeedEstimator.getAvgX();</span>
    }

    /**
     * Gets estimated average of x coordinate of gyroscope sensed angular rate.
     * This value will depend of body location and orientation, hence it should never
     * be used as a calibration bias.
     *
     * @return average of x coordinate of sensed angular rate.
     */
    public AngularSpeed getAvgAngularRateXAsMeasurement() {
<span class="fc" id="L380">        return mAngularSpeedEstimator.getAvgXAsMeasurement();</span>
    }

    /**
     * Gets estimated average of x coordinate of gyroscope sensed angular rate.
     * This value will depend of body location and orientation, hence it should never
     * be used as a calibration bias.
     *
     * @param result instance where average of x coordinate of sensed angular rate
     *               will be stored.
     */
    public void getAvgAngularRateXAsMeasurement(final AngularSpeed result) {
<span class="fc" id="L392">        mAngularSpeedEstimator.getAvgXAsMeasurement(result);</span>
<span class="fc" id="L393">    }</span>

    /**
     * Gets estimated average of y coordinate of gyroscope sensed angular rate
     * expressed in radians per second (rad/s).
     * This value will depend of body location and orientation, hence it should never
     * be used as a calibration bias.
     *
     * @return average of y coordinate of sensed angular rate.
     */
    public double getAvgAngularRateY() {
<span class="fc" id="L404">        return mAngularSpeedEstimator.getAvgY();</span>
    }

    /**
     * Gets estimated average of y coordinate of gyroscope sensed angular rate.
     * This value will depend of body location and orientation, hence it should never
     * be used as a calibration bias.
     *
     * @return average of y coordinate of sensed angular rate.
     */
    public AngularSpeed getAvgAngularRateYAsMeasurement() {
<span class="fc" id="L415">        return mAngularSpeedEstimator.getAvgYAsMeasurement();</span>
    }

    /**
     * Gets estimated average of y coordinate of gyroscope sensed angular rate.
     * This value will depend of body location and orientation, hence it should never
     * be used as a calibration bias.
     *
     * @param result instance where average of y coordinate of sensed angular rate
     *               will be stored.
     */
    public void getAvgAngularRateYAsMeasurement(final AngularSpeed result) {
<span class="fc" id="L427">        mAngularSpeedEstimator.getAvgYAsMeasurement(result);</span>
<span class="fc" id="L428">    }</span>

    /**
     * Gets estimated average of z coordinate of gyroscope sensed angular rate
     * expressed in radians per second (rad/s).
     * This value will depend of body location and orientation, hence it should never
     * be used as a calibration bias.
     *
     * @return average of z coordinate of sensed angular rate.
     */
    public double getAvgAngularRateZ() {
<span class="fc" id="L439">        return mAngularSpeedEstimator.getAvgZ();</span>
    }

    /**
     * Gets estimated average of z coordinate of gyroscope sensed angular rate.
     * This value will depend of body location and orientation, hence it should never
     * be used as a calibration bias.
     *
     * @return average of z coordinate of sensed angular rate.
     */
    public AngularSpeed getAvgAngularRateZAsMeasurement() {
<span class="fc" id="L450">        return mAngularSpeedEstimator.getAvgZAsMeasurement();</span>
    }

    /**
     * Gets estimated average of z coordinate of gyroscope sensed angular rate.
     * This value will depend of body location and orientation, hence it should never
     * be used as a calibration bias.
     *
     * @param result instance where average of z coordinate of sensed angular rate
     *               will be stored.
     */
    public void getAvgAngularRateZAsMeasurement(final AngularSpeed result) {
<span class="fc" id="L462">        mAngularSpeedEstimator.getAvgZAsMeasurement(result);</span>
<span class="fc" id="L463">    }</span>

    /**
     * Gets estimated average of gyroscope sensed angular speed as a measurement
     * triad.
     *
     * @return average angular speed triad.
     */
    public AngularSpeedTriad getAvgAngularRateTriad() {
<span class="fc" id="L472">        return mAngularSpeedEstimator.getAvgTriad();</span>
    }

    /**
     * Gets estimated average of gyroscope sensed angular speed as a measurement
     * triad.
     *
     * @param result instance where average angular speed triad will be stored.
     */
    public void getAvgAngularRateTriad(final AngularSpeedTriad result) {
<span class="fc" id="L482">        mAngularSpeedEstimator.getAvgTriad(result);</span>
<span class="fc" id="L483">    }</span>

    /**
     * Gets norm of estimated average angular speed expressed in radians per
     * second (rad/s). This value is independent of body orientation.
     *
     * @return norm of estimated average angular speed.
     */
    public double getAvgAngularRateNorm() {
<span class="fc" id="L492">        return mAngularSpeedEstimator.getAvgNorm();</span>
    }

    /**
     * Gets norm of estimated average angular speed.
     * This value is independent of body orientation.
     *
     * @return norm of estimated average angular speed.
     */
    public AngularSpeed getAvgAngularRateNormAsMeasurement() {
<span class="fc" id="L502">        return mAngularSpeedEstimator.getAvgNormAsMeasurement();</span>
    }

    /**
     * Gets norm of estimated average angular speed.
     * This value is independent of body orientation.
     *
     * @param result instance where norm of estimated average angular speed will be stored.
     */
    public void getAvgAngularRateNormAsMeasurement(final AngularSpeed result) {
<span class="fc" id="L512">        mAngularSpeedEstimator.getAvgNormAsMeasurement(result);</span>
<span class="fc" id="L513">    }</span>

    /**
     * Gets estimated average of body kinematics.
     *
     * @return estimated average of body kinematics.
     */
    public BodyKinematics getAvgBodyKinematics() {
<span class="fc" id="L521">        final BodyKinematics result = new BodyKinematics();</span>
<span class="fc" id="L522">        getAvgBodyKinematics(result);</span>
<span class="fc" id="L523">        return result;</span>
    }

    /**
     * Gets estimated average of body kinematics.
     *
     * @param result instance where estimated average of body kinematics will be stored.
     */
    public void getAvgBodyKinematics(final BodyKinematics result) {
<span class="fc" id="L532">        final double avgFx = mAccelerationEstimator.getAvgX();</span>
<span class="fc" id="L533">        final double avgFy = mAccelerationEstimator.getAvgY();</span>
<span class="fc" id="L534">        final double avgFz = mAccelerationEstimator.getAvgZ();</span>

<span class="fc" id="L536">        final double avgWx = mAngularSpeedEstimator.getAvgX();</span>
<span class="fc" id="L537">        final double avgWy = mAngularSpeedEstimator.getAvgY();</span>
<span class="fc" id="L538">        final double avgWz = mAngularSpeedEstimator.getAvgZ();</span>

<span class="fc" id="L540">        result.setSpecificForceCoordinates(avgFx, avgFy, avgFz);</span>
<span class="fc" id="L541">        result.setAngularRateCoordinates(avgWx, avgWy, avgWz);</span>
<span class="fc" id="L542">    }</span>

    /**
     * Gets estimated variance of x coordinate of accelerometer sensed specific force
     * expressed in (m^2/s^4).
     *
     * @return estimated variance of x coordinate of sensed specific force.
     */
    public double getVarianceSpecificForceX() {
<span class="fc" id="L551">        return mAccelerationEstimator.getVarianceX();</span>
    }

    /**
     * Gets estimated variance of y coordinate of accelerometer sensed specific
     * force expressed in (m^2/s^4).
     *
     * @return estimated variance of y coordinate of sensed specific force.
     */
    public double getVarianceSpecificForceY() {
<span class="fc" id="L561">        return mAccelerationEstimator.getVarianceY();</span>
    }

    /**
     * Gets estimated variance of z coordinate of accelerometer sensed specific
     * force expressed in (m^2/s^4).
     *
     * @return estimated variance of z coordinate of sensed specific force.
     */
    public double getVarianceSpecificForceZ() {
<span class="fc" id="L571">        return mAccelerationEstimator.getVarianceZ();</span>
    }

    /**
     * Gets estimated variance of x coordinate of gyroscope sensed angular rate
     * expressed in (rad^2/s^2).
     *
     * @return estimated variance of x coordinate of sensed angular rate.
     */
    public double getVarianceAngularRateX() {
<span class="fc" id="L581">        return mAngularSpeedEstimator.getVarianceX();</span>
    }

    /**
     * Gets estimated variance of y coordinate of gyroscope sensed angular rate
     * expressed in (rad^2/s^2).
     *
     * @return estimated variance of y coordinate of sensed angular rate.
     */
    public double getVarianceAngularRateY() {
<span class="fc" id="L591">        return mAngularSpeedEstimator.getVarianceY();</span>
    }

    /**
     * Gets estimated variance of z coordinate of gyroscope sensed angular rate
     * expressed in (rad^2/s^2).
     *
     * @return estimated variance of z coordinate of sensed angular rate.
     */
    public double getVarianceAngularRateZ() {
<span class="fc" id="L601">        return mAngularSpeedEstimator.getVarianceZ();</span>
    }

    /**
     * Gets estimated standard deviation of x coordinate of accelerometer
     * sensed specific force expressed in meters per squared second (m/s^2).
     *
     * @return estimated standard deviation of x coordinate of sensed specific
     * force.
     */
    public double getStandardDeviationSpecificForceX() {
<span class="fc" id="L612">        return mAccelerationEstimator.getStandardDeviationX();</span>
    }

    /**
     * Gets estimated standard deviation of x coordinate of accelerometer
     * sensed specific force.
     *
     * @return estimated standard deviation of x coordinate of sensed specific
     * force.
     */
    public Acceleration getStandardDeviationSpecificForceXAsMeasurement() {
<span class="fc" id="L623">        return mAccelerationEstimator.getStandardDeviationXAsMeasurement();</span>
    }

    /**
     * Gets estimated standard deviation of x coordinate of accelerometer
     * sensed specific force.
     *
     * @param result instance where estimated standard deviation of x
     *               coordinate of sensed specific force will be stored.
     */
    public void getStandardDeviationSpecificForceXAsMeasurement(
            final Acceleration result) {
<span class="fc" id="L635">        mAccelerationEstimator.getStandardDeviationXAsMeasurement(result);</span>
<span class="fc" id="L636">    }</span>

    /**
     * Gets estimated standard deviation of y coordinate of accelerometer
     * sensed specific force expressed in meters per squared second (m/s^2).
     *
     * @return estimated standard deviation of y coordinate of sensed specific
     * force.
     */
    public double getStandardDeviationSpecificForceY() {
<span class="fc" id="L646">        return mAccelerationEstimator.getStandardDeviationY();</span>
    }

    /**
     * Gets estimated standard deviation of y coordinate of accelerometer
     * sensed specific force.
     *
     * @return estimated standard deviation of y coordinate of sensed specific
     * force.
     */
    public Acceleration getStandardDeviationSpecificForceYAsMeasurement() {
<span class="fc" id="L657">        return mAccelerationEstimator.getStandardDeviationYAsMeasurement();</span>
    }

    /**
     * Gets estimated standard deviation of y coordinate of accelerometer
     * sensed specific force.
     *
     * @param result instance where estimated standard deviation of y
     *               coordinate of sensed specific force will be stored.
     */
    public void getStandardDeviationSpecificForceYAsMeasurement(
            final Acceleration result) {
<span class="fc" id="L669">        mAccelerationEstimator.getStandardDeviationYAsMeasurement(result);</span>
<span class="fc" id="L670">    }</span>

    /**
     * Gets estimated standard deviation of z coordinate of accelerometer
     * sensed specific force expressed in meters per squared second (m/s^2).
     *
     * @return estimated standard deviation of z coordinate of sensed specific
     * force.
     */
    public double getStandardDeviationSpecificForceZ() {
<span class="fc" id="L680">        return mAccelerationEstimator.getStandardDeviationZ();</span>
    }

    /**
     * Gets estimated standard deviation of z coordinate of accelerometer
     * sensed specific force.
     *
     * @return estimated standard deviation of z coordinate of sensed specific
     * force.
     */
    public Acceleration getStandardDeviationSpecificForceZAsMeasurement() {
<span class="fc" id="L691">        return mAccelerationEstimator.getStandardDeviationZAsMeasurement();</span>
    }

    /**
     * Gets estimated standard deviation of z coordinate of accelerometer
     * sensed specific force.
     *
     * @param result instance where estimated standard deviation of z
     *               coordinate of sensed specific force will be stored.
     */
    public void getStandardDeviationSpecificForceZAsMeasurement(
            final Acceleration result) {
<span class="fc" id="L703">        mAccelerationEstimator.getStandardDeviationZAsMeasurement(result);</span>
<span class="fc" id="L704">    }</span>

    /**
     * Gets estimated standard deviation triad of accelerometer measurements.
     *
     * @return estimated standard deviation triad of accelerometer measurements.
     */
    public AccelerationTriad getStandardDeviationSpecificForceTriad() {
<span class="fc" id="L712">        return mAccelerationEstimator.getStandardDeviationTriad();</span>
    }

    /**
     * Gets estimated standard deviation triad of accelerometer measurements.
     *
     * @param result instance where estimated standard deviation triad of
     *               accelerometer measurements will be stored.
     */
    public void getStandardDeviationSpecificForceTriad(
            final AccelerationTriad result) {
<span class="fc" id="L723">        mAccelerationEstimator.getStandardDeviationTriad(result);</span>
<span class="fc" id="L724">    }</span>

    /**
     * Gets norm of estimated standard deviation of accelerometer measurements
     * expressed in meters per squared second (m/s^2).
     *
     * @return norm of estimated standard deviation of accelerometer
     * measurements.
     */
    public double getStandardDeviationSpecificForceNorm() {
<span class="fc" id="L734">        return mAccelerationEstimator.getStandardDeviationNorm();</span>
    }

    /**
     * Gets norm of estimated standard deviation of accelerometer measurements.
     *
     * @return norm of estimated standard deviation of measurements.
     */
    public Acceleration getStandardDeviationSpecificForceNormAsMeasurement() {
<span class="fc" id="L743">        return mAccelerationEstimator.getStandardDeviationNormAsMeasurement();</span>
    }

    /**
     * Gets norm of estimated standard deviation of accelerometer measurements.
     *
     * @param result instance where norm of estimated standard deviation will be
     *               stored.
     */
    public void getStandardDeviationSpecificForceNormAsMeasurement(
            final Acceleration result) {
<span class="fc" id="L754">        mAccelerationEstimator.getStandardDeviationNormAsMeasurement(</span>
                result);
<span class="fc" id="L756">    }</span>

    /**
     * Gets average of estimated standard deviation coordinates of accelerometer
     * measurements expressed in meters per squared second (m/s^2).
     *
     * @return average of estimated standard deviation coordinates.
     */
    public double getAverageStandardDeviationSpecificForce() {
<span class="fc" id="L765">        return mAccelerationEstimator.getAverageStandardDeviation();</span>
    }

    /**
     * Gets average of estimated standard deviation coordinates of accelerometer
     * measurements.
     *
     * @return average of estimated standard deviation coordinates.
     */
    public Acceleration getAverageStandardDeviationSpecificForceAsMeasurement() {
<span class="fc" id="L775">        return mAccelerationEstimator.getAverageStandardDeviationAsMeasurement();</span>
    }

    /**
     * Gets average of estimated standard deviation coordinates of accelerometer
     * measurements.
     *
     * @param result instance where average of estimated standard deviation coordinates
     *               will be stored.
     */
    public void getAverageStandardDeviationSpecificForceAsMeasurement(
            final Acceleration result) {
<span class="fc" id="L787">        mAccelerationEstimator.getAverageStandardDeviationAsMeasurement(result);</span>
<span class="fc" id="L788">    }</span>

    /**
     * Gets estimated standard deviation of x coordinate of gyroscope
     * expressed in radians per second (rad/s).
     *
     * @return estimated standard deviation of x coordinate of gyroscope.
     */
    public double getStandardDeviationAngularRateX() {
<span class="fc" id="L797">        return mAngularSpeedEstimator.getStandardDeviationX();</span>
    }

    /**
     * Gets estimated standard deviation of x coordinate of gyroscope.
     *
     * @return estimated standard deviation of x coordinate of gyroscope.
     */
    public AngularSpeed getStandardDeviationAngularRateXAsMeasurement() {
<span class="fc" id="L806">        return mAngularSpeedEstimator.getStandardDeviationXAsMeasurement();</span>
    }

    /**
     * Gets estimated standard deviation of x coordinate of gyroscope.
     *
     * @param result estimated standard deviation of x coordinate of gyroscope.
     */
    public void getStandardDeviationAngularRateXAsMeasurement(
            final AngularSpeed result) {
<span class="fc" id="L816">        mAngularSpeedEstimator.getStandardDeviationXAsMeasurement(result);</span>
<span class="fc" id="L817">    }</span>

    /**
     * Gets estimated standard deviation of y coordinate of gyroscope
     * expressed in radians per second (rad/s).
     *
     * @return estimated standard deviation of y coordinate of gyroscope.
     */
    public double getStandardDeviationAngularRateY() {
<span class="fc" id="L826">        return mAngularSpeedEstimator.getStandardDeviationY();</span>
    }

    /**
     * Gets estimated standard deviation of y coordinate of gyroscope.
     *
     * @return estimated standard deviation of y coordinate of gyroscope.
     */
    public AngularSpeed getStandardDeviationAngularRateYAsMeasurement() {
<span class="fc" id="L835">        return mAngularSpeedEstimator.getStandardDeviationYAsMeasurement();</span>
    }

    /**
     * Gets estimated standard deviation of y coordinate of gyroscope.
     *
     * @param result estimated standard deviation of y coordinate of gyroscope.
     */
    public void getStandardDeviationAngularRateYAsMeasurement(
            final AngularSpeed result) {
<span class="fc" id="L845">        mAngularSpeedEstimator.getStandardDeviationYAsMeasurement(result);</span>
<span class="fc" id="L846">    }</span>

    /**
     * Gets estimated standard deviation of z coordinate of gyroscope
     * expressed in radians per second (rad/s).
     *
     * @return estimated standard deviation of z coordinate of gyroscope.
     */
    public double getStandardDeviationAngularRateZ() {
<span class="fc" id="L855">        return mAngularSpeedEstimator.getStandardDeviationZ();</span>
    }

    /**
     * Gets estimated standard deviation of z coordinate of gyroscope.
     *
     * @return estimated standard deviation of z coordinate of gyroscope.
     */
    public AngularSpeed getStandardDeviationAngularRateZAsMeasurement() {
<span class="fc" id="L864">        return mAngularSpeedEstimator.getStandardDeviationZAsMeasurement();</span>
    }

    /**
     * Gets estimated standard deviation of z coordinate of gyroscope.
     *
     * @param result estimated standard deviation of z coordinate of gyroscope.
     */
    public void getStandardDeviationAngularRateZAsMeasurement(
            final AngularSpeed result) {
<span class="fc" id="L874">        mAngularSpeedEstimator.getStandardDeviationZAsMeasurement(result);</span>
<span class="fc" id="L875">    }</span>

    /**
     * Gets estimated standard deviation triad of angular speed measurements.
     *
     * @return estimated standard deviation triad of angular speed measurements.
     */
    public AngularSpeedTriad getStandardDeviationAngularSpeedTriad() {
<span class="fc" id="L883">        return mAngularSpeedEstimator.getStandardDeviationTriad();</span>
    }

    /**
     * Gets estimated standard deviation triad of angular speed measurements.
     *
     * @param result instance where estimated standard deviation triad of
     *               gyroscope measurements will be stored.
     */
    public void getStandardDeviationAngularSpeedTriad(
            final AngularSpeedTriad result) {
<span class="fc" id="L894">        mAngularSpeedEstimator.getStandardDeviationTriad(result);</span>
<span class="fc" id="L895">    }</span>

    /**
     * Gets norm of estimated standard deviation of gyroscope measurements
     * expressed in radians per second (rad/s).
     *
     * @return norm of estimated standard deviation of gyroscope
     * measurements.
     */
    public double getStandardDeviationAngularSpeedNorm() {
<span class="fc" id="L905">        return mAngularSpeedEstimator.getStandardDeviationNorm();</span>
    }

    /**
     * Gets norm of estimated standard deviation of gyroscope measurements.
     *
     * @return norm of estimated standard deviation of measurements.
     */
    public AngularSpeed getStandardDeviationAngularSpeedNormAsMeasurement() {
<span class="fc" id="L914">        return mAngularSpeedEstimator.getStandardDeviationNormAsMeasurement();</span>
    }

    /**
     * Gets norm of estimated standard deviation of gyroscope measurements.
     *
     * @param result instance where norm of estimated standard deviation will be
     *               stored.
     */
    public void getStandardDeviationAngularSpeedNormAsMeasurement(
            final AngularSpeed result) {
<span class="fc" id="L925">        mAngularSpeedEstimator.getStandardDeviationNormAsMeasurement(result);</span>
<span class="fc" id="L926">    }</span>

    /**
     * Gets average of estimated standard deviation coordinates of gyroscope
     * measurements expressed in radians per second (rad/s).
     *
     * @return average of estimated standard deviation coordinates.
     */
    public double getAverageStandardDeviationAngularSpeed() {
<span class="fc" id="L935">        return mAngularSpeedEstimator.getAverageStandardDeviation();</span>
    }

    /**
     * Gets average of estimated standard deviation coordinates of gyroscope
     * measurements.
     *
     * @return average of estimated standard deviation coordinates.
     */
    public AngularSpeed getAverageStandardDeviationAngularSpeedAsMeasurement() {
<span class="fc" id="L945">        return mAngularSpeedEstimator.getAverageStandardDeviationAsMeasurement();</span>
    }

    /**
     * Gets average of estimated standard deviation coordinates of gyroscope
     * measurements.
     *
     * @param result instance where average of estimated standard deviation coordinates
     *               will be stored.
     */
    public void getAverageStandardDeviationAngularSpeedAsMeasurement(
            final AngularSpeed result) {
<span class="fc" id="L957">        mAngularSpeedEstimator.getAverageStandardDeviationAsMeasurement(</span>
                result);
<span class="fc" id="L959">    }</span>

    /**
     * Gets estimated standard deviations of accelerometer and gyroscope components
     * as a body kinematics instance.
     *
     * @return a body kinematics instance containing standard deviation values.
     */
    public BodyKinematics getStandardDeviationAsBodyKinematics() {
<span class="fc" id="L968">        return new BodyKinematics(getStandardDeviationSpecificForceX(),</span>
<span class="fc" id="L969">                getStandardDeviationSpecificForceY(),</span>
<span class="fc" id="L970">                getStandardDeviationSpecificForceZ(),</span>
<span class="fc" id="L971">                getStandardDeviationAngularRateX(),</span>
<span class="fc" id="L972">                getStandardDeviationAngularRateY(),</span>
<span class="fc" id="L973">                getStandardDeviationAngularRateZ());</span>
    }

    /**
     * Gets estimated standard deviations of accelerometer and gyroscope components
     * as a body kinematics instance.
     *
     * @param result instance where data will be stored.
     */
    public void getStandardDeviationAsBodyKinematics(final BodyKinematics result) {
<span class="fc" id="L983">        result.setSpecificForceCoordinates(getStandardDeviationSpecificForceX(),</span>
<span class="fc" id="L984">                getStandardDeviationSpecificForceY(),</span>
<span class="fc" id="L985">                getStandardDeviationSpecificForceZ());</span>
<span class="fc" id="L986">        result.setAngularRateCoordinates(getStandardDeviationAngularRateX(),</span>
<span class="fc" id="L987">                getStandardDeviationAngularRateY(),</span>
<span class="fc" id="L988">                getStandardDeviationAngularRateZ());</span>
<span class="fc" id="L989">    }</span>

    /**
     * Gets accelerometer noise PSD (Power Spectral Density) on x axis expressed
     * in (m^2 * s^-3).
     *
     * @return accelerometer noise PSD on x axis.
     */
    public double getSpecificForcePsdX() {
<span class="fc" id="L998">        return mAccelerationEstimator.getPsdX();</span>
    }

    /**
     * Gets accelerometer noise PSD (Power Spectral Density) on y axis expressed
     * in (m^2 * s^-3).
     *
     * @return accelerometer noise PSD on y axis.
     */
    public double getSpecificForcePsdY() {
<span class="fc" id="L1008">        return mAccelerationEstimator.getPsdY();</span>
    }

    /**
     * Gets accelerometer noise PSD (Power Spectral Density) on z axis expressed
     * in (m^2 * s^-3).
     *
     * @return accelerometer noise PSD on z axis.
     */
    public double getSpecificForcePsdZ() {
<span class="fc" id="L1018">        return mAccelerationEstimator.getPsdZ();</span>
    }

    /**
     * Gets gyroscope noise PSD (Power Spectral Density) on x axis expressed
     * in (rad^2/s).
     *
     * @return gyroscope noise PSD on x axis.
     */
    public double getAngularRatePsdX() {
<span class="fc" id="L1028">        return mAngularSpeedEstimator.getPsdX();</span>
    }

    /**
     * Gets gyroscope noise PSD (Power Spectral Density) on y axis expressed
     * in (rad^2/s).
     *
     * @return gyroscope noise PSD on y axis.
     */
    public double getAngularRatePsdY() {
<span class="fc" id="L1038">        return mAngularSpeedEstimator.getPsdY();</span>
    }

    /**
     * Gets gyroscope noise PSD (Power Spectral Density) on z axis expressed
     * in (rad^2/s).
     *
     * @return gyroscope noise PSD on z axis.
     */
    public double getAngularRatePsdZ() {
<span class="fc" id="L1048">        return mAngularSpeedEstimator.getPsdZ();</span>
    }

    /**
     * Gets accelerometer noise root PSD (Power Spectral Density) on x axis
     * expressed in (m * s^-1.5).
     *
     * @return accelerometer noise root PSD on x axis.
     */
    public double getSpecificForceRootPsdX() {
<span class="fc" id="L1058">        return mAccelerationEstimator.getRootPsdX();</span>
    }

    /**
     * Gets accelerometer noise root PSD (Power Spectral Density) on y axis
     * expressed in (m * s^-1.5).
     *
     * @return accelerometer noise root PSD on y axis.
     */
    public double getSpecificForceRootPsdY() {
<span class="fc" id="L1068">        return mAccelerationEstimator.getRootPsdY();</span>
    }

    /**
     * Gets accelerometer noise root PSD (Power Spectral Density) on z axis
     * expressed in (m * s^-1.5).
     *
     * @return accelerometer noise root PSD on z axis.
     */
    public double getSpecificForceRootPsdZ() {
<span class="fc" id="L1078">        return mAccelerationEstimator.getRootPsdZ();</span>
    }

    /**
     * Gets gyroscope noise root PSD (Power Spectral Density) on x axis
     * expressed in (rad * s^-0.5).
     *
     * @return gyroscope noise root PSD on x axis.
     */
    public double getAngularRateRootPsdX() {
<span class="fc" id="L1088">        return mAngularSpeedEstimator.getRootPsdX();</span>
    }

    /**
     * Gets gyroscope noise root PSD (Power Spectral Density) on y axis
     * expressed in (rad * s^-0.5).
     *
     * @return gyroscope noise root PSD on y axis.
     */
    public double getAngularRateRootPsdY() {
<span class="fc" id="L1098">        return mAngularSpeedEstimator.getRootPsdY();</span>
    }

    /**
     * Gets gyroscope noise root PSD (Power Spectral Density) on z axis
     * expressed in (rad * s^-0.5).
     *
     * @return gyroscope noise root PSD on z axis.
     */
    public double getAngularRateRootPsdZ() {
<span class="fc" id="L1108">        return mAngularSpeedEstimator.getRootPsdZ();</span>
    }

    /**
     * Gets average accelerometer noise PSD (Power Spectral Density) among
     * x,y,z components expressed as (m^2/s^-3).
     *
     * @return average accelerometer noise PSD.
     */
    public double getAvgSpecificForceNoisePsd() {
<span class="fc" id="L1118">        return mAccelerationEstimator.getAvgNoisePsd();</span>
    }

    /**
     * Gets norm of noise root PSD (Power Spectral Density) among x,y,z
     * components expressed as (m * s^-1.5).
     *
     * @return norm of noise root PSD.
     */
    public double getSpecificForceNoiseRootPsdNorm() {
<span class="fc" id="L1128">        return mAccelerationEstimator.getNoiseRootPsdNorm();</span>
    }

    /**
     * Gets average gyroscope noise PSD (Power Spectral Density) among
     * x,y,z components expressed in (rad^2/s).
     *
     * @return average gyroscope noise PSD.
     */
    public double getAvgAngularRateNoisePsd() {
<span class="fc" id="L1138">        return mAngularSpeedEstimator.getAvgNoisePsd();</span>
    }

    /**
     * Gets norm of noise root PSD (Power Spectral Density) among x,y,z
     * components expressed as (rad * s^-0.5).
     *
     * @return norm of noise root PSD.
     */
    public double getAngularRateNoiseRootPsdNorm() {
<span class="fc" id="L1148">        return mAngularSpeedEstimator.getNoiseRootPsdNorm();</span>
    }

    /**
     * Gets number of samples that have been processed so far.
     *
     * @return number of samples that have been processed so far.
     */
    public int getNumberOfProcessedSamples() {
<span class="fc" id="L1157">        return mAccelerationEstimator.getNumberOfProcessedSamples();</span>
    }

    /**
     * Indicates whether estimator is currently running or not.
     *
     * @return true if estimator is running, false otherwise.
     */
    public boolean isRunning() {
<span class="fc" id="L1166">        return mRunning;</span>
    }

    /**
     * Adds body kinematics measurement samples.
     *
     * @param specificForceX x coordinate of specific force expressed in meters per squared second (m/s^2).
     * @param specificForceY y coordinate of specific force expressed in meters per squared second (m/s^2).
     * @param specificForceZ z coordinate of specific force expressed in meters per squared second (m/s^2).
     * @param angularRateX   x coordinate of angular rate expressed in radians per second (rad/s).
     * @param angularRateY   y coordinate of angular rate expressed in radians per second (rad/s).
     * @param angularRateZ   z coordinate of angular rate expressed in radians per second (rad/s).
     * @return true if provided measurement instance has been processed, false if it has
     * been ignored.
     * @throws LockedException if estimator is currently running.
     */
    public boolean addBodyKinematics(
            final double specificForceX, final double specificForceY, final double specificForceZ,
            final double angularRateX, final double angularRateY, final double angularRateZ)
            throws LockedException {

<span class="fc bfc" id="L1187" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L1188">            throw new LockedException();</span>
        }

<span class="fc" id="L1191">        mRunning = true;</span>

<span class="pc bpc" id="L1193" title="1 of 4 branches missed.">        if (mLastBodyKinematics == null &amp;&amp; mListener != null) {</span>
<span class="fc" id="L1194">            mListener.onStart(this);</span>
        }

<span class="fc bfc" id="L1197" title="All 2 branches covered.">        if (mLastBodyKinematics == null) {</span>
<span class="fc" id="L1198">            mLastBodyKinematics = new BodyKinematics();</span>
        }
<span class="fc" id="L1200">        mLastBodyKinematics.setSpecificForceCoordinates(specificForceX, specificForceY, specificForceZ);</span>
<span class="fc" id="L1201">        mLastBodyKinematics.setAngularRateCoordinates(angularRateX, angularRateY, angularRateZ);</span>

<span class="pc bpc" id="L1203" title="1 of 2 branches missed.">        final boolean result = mAccelerationEstimator.addTriad(specificForceX, specificForceY, specificForceZ) &amp;&amp;</span>
<span class="pc bpc" id="L1204" title="1 of 2 branches missed.">                mAngularSpeedEstimator.addTriad(angularRateX, angularRateY, angularRateZ);</span>

<span class="pc bpc" id="L1206" title="1 of 2 branches missed.">        if (mListener != null) {</span>
<span class="fc" id="L1207">            mListener.onBodyKinematicsAdded(this);</span>
        }

<span class="fc" id="L1210">        mRunning = false;</span>

<span class="fc" id="L1212">        return result;</span>
    }

    /**
     * Adds body kinematics measurement samples.
     *
     * @param specificForceX x coordinate of specific force.
     * @param specificForceY y coordinate of specific force.
     * @param specificForceZ z coordinate of specific force.
     * @param angularRateX   x coordinate of angular rate.
     * @param angularRateY   y coordinate of angular rate.
     * @param angularRateZ   z coordinate of angular rate.
     * @return true if provided measurement instance has been processed, false if it has
     * been ignored.
     * @throws LockedException if estimator is currently running.
     */
    public boolean addBodyKinematics(
            final Acceleration specificForceX,
            final Acceleration specificForceY,
            final Acceleration specificForceZ,
            final AngularSpeed angularRateX,
            final AngularSpeed angularRateY,
            final AngularSpeed angularRateZ)
            throws LockedException {
<span class="fc" id="L1236">        return addBodyKinematics(convertAcceleration(specificForceX),</span>
<span class="fc" id="L1237">                convertAcceleration(specificForceY),</span>
<span class="fc" id="L1238">                convertAcceleration(specificForceZ),</span>
<span class="fc" id="L1239">                convertAngularSpeed(angularRateX),</span>
<span class="fc" id="L1240">                convertAngularSpeed(angularRateY),</span>
<span class="fc" id="L1241">                convertAngularSpeed(angularRateZ));</span>
    }

    /**
     * Adds body kinematics measurement samples.
     *
     * @param specificForce specific force triad.
     * @param angularSpeed  angular speed triad.
     * @return true if provided measurement instance has been processed, false if it has
     * been ignored.
     * @throws LockedException if estimator is currently running.
     */
    public boolean addBodyKinematics(
            final AccelerationTriad specificForce,
            final AngularSpeedTriad angularSpeed) throws LockedException {
<span class="fc" id="L1256">        return addBodyKinematics(</span>
<span class="fc" id="L1257">                convertAcceleration(specificForce.getValueX(), specificForce.getUnit()),</span>
<span class="fc" id="L1258">                convertAcceleration(specificForce.getValueY(), specificForce.getUnit()),</span>
<span class="fc" id="L1259">                convertAcceleration(specificForce.getValueZ(), specificForce.getUnit()),</span>
<span class="fc" id="L1260">                convertAngularSpeed(angularSpeed.getValueX(), angularSpeed.getUnit()),</span>
<span class="fc" id="L1261">                convertAngularSpeed(angularSpeed.getValueY(), angularSpeed.getUnit()),</span>
<span class="fc" id="L1262">                convertAngularSpeed(angularSpeed.getValueZ(), angularSpeed.getUnit()));</span>
    }

    /**
     * Adds body kinematics measurement.
     *
     * @param bodyKinematics body kinematics.
     * @return true if provided measurement instance has been processed, false if it has
     * been ignored.
     * @throws LockedException if estimator is currently running.
     */
    public boolean addBodyKinematics(final BodyKinematics bodyKinematics) throws LockedException {
<span class="fc" id="L1274">        return addBodyKinematics(</span>
<span class="fc" id="L1275">                bodyKinematics.getFx(),</span>
<span class="fc" id="L1276">                bodyKinematics.getFy(),</span>
<span class="fc" id="L1277">                bodyKinematics.getFz(),</span>
<span class="fc" id="L1278">                bodyKinematics.getAngularRateX(),</span>
<span class="fc" id="L1279">                bodyKinematics.getAngularRateY(),</span>
<span class="fc" id="L1280">                bodyKinematics.getAngularRateZ());</span>
    }

    /**
     * Resets current estimator.
     *
     * @return true if estimator was successfully reset, false if no reset was needed.
     * @throws LockedException if estimator is currently running.
     */
    public boolean reset() throws LockedException {
<span class="fc bfc" id="L1290" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L1291">            throw new LockedException();</span>
        }

<span class="fc" id="L1294">        mRunning = true;</span>

<span class="fc" id="L1296">        mLastBodyKinematics = null;</span>
<span class="pc bpc" id="L1297" title="2 of 4 branches missed.">        final boolean result = mAccelerationEstimator.reset() &amp;&amp; mAngularSpeedEstimator.reset();</span>

<span class="pc bpc" id="L1299" title="1 of 2 branches missed.">        if (mListener != null) {</span>
<span class="fc" id="L1300">            mListener.onReset(this);</span>
        }

<span class="fc" id="L1303">        mRunning = false;</span>

<span class="fc" id="L1305">        return result;</span>
    }

    /**
     * Converts an acceleration instance to meters per squared seconds (m/s^2).
     *
     * @param value value to be converted.
     * @return converted value.
     */
    private double convertAcceleration(final Acceleration value) {
<span class="fc" id="L1315">        return AccelerationConverter.convert(</span>
<span class="fc" id="L1316">                value.getValue().doubleValue(),</span>
<span class="fc" id="L1317">                value.getUnit(),</span>
                AccelerationUnit.METERS_PER_SQUARED_SECOND);
    }

    /**
     * Converts an acceleration value and unit to meters per squared seconds (m/s^2).
     *
     * @param value value to be converted.
     * @param unit  unit of value to be converted.
     * @return converted value.
     */
    private double convertAcceleration(
            final double value, final AccelerationUnit unit) {
<span class="fc" id="L1330">        return AccelerationConverter.convert(value, unit,</span>
                AccelerationUnit.METERS_PER_SQUARED_SECOND);
    }

    /**
     * Converts an angular speed instance to radians per second (rad/s).
     *
     * @param value value to be converted.
     * @return converted value.
     */
    private double convertAngularSpeed(final AngularSpeed value) {
<span class="fc" id="L1341">        return AngularSpeedConverter.convert(</span>
<span class="fc" id="L1342">                value.getValue().doubleValue(),</span>
<span class="fc" id="L1343">                value.getUnit(),</span>
                AngularSpeedUnit.RADIANS_PER_SECOND);
    }

    /**
     * Converts an angular speed value and unit to radians per second (rad/s).
     *
     * @param value value to be converted.
     * @param unit  unit of value to be converted.
     * @return converted value.
     */
    private double convertAngularSpeed(
            final double value, final AngularSpeedUnit unit) {
<span class="fc" id="L1356">        return AngularSpeedConverter.convert(value, unit,</span>
                AngularSpeedUnit.RADIANS_PER_SECOND);
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>