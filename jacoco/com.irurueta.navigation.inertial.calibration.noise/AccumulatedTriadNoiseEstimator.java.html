<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AccumulatedTriadNoiseEstimator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.irurueta:irurueta-navigation</a> &gt; <a href="index.source.html" class="el_package">com.irurueta.navigation.inertial.calibration.noise</a> &gt; <span class="el_source">AccumulatedTriadNoiseEstimator.java</span></div><h1>AccumulatedTriadNoiseEstimator.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2020 Alberto Irurueta Carro (alberto@irurueta.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.irurueta.navigation.inertial.calibration.noise;

import com.irurueta.navigation.LockedException;
import com.irurueta.navigation.inertial.calibration.IMUTimeIntervalEstimator;
import com.irurueta.navigation.inertial.calibration.Triad;
import com.irurueta.units.Measurement;
import com.irurueta.units.Time;
import com.irurueta.units.TimeConverter;
import com.irurueta.units.TimeUnit;

/**
 * Base class to estimate measurement noise variances and PSD's (Power Spectral Densities)
 * along with their average values.
 * Implementations of this estimator must be used when the body where the measurement device
 * is attached to remains static on the same position with zero velocity, or
 * with constant anguular speed and orientation while capturing data.
 * To compute PSD's, this estimator assumes that measurement samples are obtained
 * at a constant provided rate equal to {@link #getTimeInterval()} seconds.
 * If not available, accelerometer sampling rate average can be estimated using
 * {@link IMUTimeIntervalEstimator}.
 * This estimator does NOT require the knowledge of current location and body
 * orientation.
 * Because body location and orientation is not known, estimated average values
 * cannot be used to determine biases. Only norm of noise estimations
 * (variance or standard deviation) can be safely used.
 *
 * @param &lt;U&gt; a measurement unit type.
 * @param &lt;M&gt; a measurement type.
 * @param &lt;T&gt; a triad type.
 * @param &lt;E&gt; an estimator type.
 * @param &lt;L&gt; a listener type.
 */
public abstract class AccumulatedTriadNoiseEstimator&lt;U extends Enum&lt;?&gt;,
        M extends Measurement&lt;U&gt;, T extends Triad&lt;U, M&gt;,
        E extends AccumulatedTriadNoiseEstimator&lt;U, M, T, E, L&gt;,
        L extends AccumulatedTriadNoiseEstimatorListener&lt;U, M, T, E&gt;&gt; {

    /**
     * Default time interval between accelerometer samples expressed in seconds
     * (s).
     */
    public static final double DEFAULT_TIME_INTERVAL_SECONDS = 0.02;

    /**
     * Time interval expressed in seconds (s) between consecutive accelerometer
     * samples.
     */
<span class="fc" id="L63">    private double mTimeInterval = DEFAULT_TIME_INTERVAL_SECONDS;</span>

    /**
     * Listener to handle events raised by this estimator.
     */
    private L mListener;

    /**
     * Last provided triad.
     */
    private T mLastTriad;

    /**
     * Contains estimated average of x coordinate of measurement expressed in its default
     * unit (m/s^2 for acceleration, rad/s for angular speed or T for magnetic flux density).
     */
    private double mAvgX;

    /**
     * Contains estimated average of y coordinate of measurement expressed in its default
     * unit (m/s^2 for acceleration, rad/s for angular speed or T for magnetic flux density).
     */
    private double mAvgY;

    /**
     * Contains estimated average of z coordinate of measurement expressed in its default
     * unit (m/s^2 for acceleration, rad/s for angular speed or T for magnetic flux density).
     */
    private double mAvgZ;

    /**
     * Contains estimated variance of x coordinate of measurement expressed in its default
     * squared unit (m^2/s^4 for acceleration, rad^2/s^2 for angular speed or T^2 for magnetic
     * flux density).
     */
    private double mVarianceX;

    /**
     * Contains estimated variance of y coordinate of measurement expressed in its default
     * squared unit (m^2/s^4 for acceleration, rad^2/s^2 for angular speed or T^2 for magnetic
     * flux density).
     */
    private double mVarianceY;

    /**
     * Contains estimated variance of x coordinate of measurement expressed in its default
     * squared unit (m^2/s^4 for acceleration, rad^2/s^2 for angular speed or T^2 for magnetic
     * flux density).
     */
    private double mVarianceZ;

    /**
     * Number of processed body kinematics samples.
     */
    private int mNumberOfProcessedSamples;

    /**
     * Number of processed timestamp samples plus one.
     */
<span class="fc" id="L122">    private int mNumberOfProcessedSamplesPlusOne = 1;</span>

    /**
     * Indicates that estimator is running.
     */
    private boolean mRunning;

    /**
     * Constructor.
     */
<span class="fc" id="L132">    public AccumulatedTriadNoiseEstimator() {</span>
<span class="fc" id="L133">    }</span>

    /**
     * Constructor.
     *
     * @param listener listener to handle events raised by this estimator.
     */
<span class="fc" id="L140">    public AccumulatedTriadNoiseEstimator(final L listener) {</span>
<span class="fc" id="L141">        mListener = listener;</span>
<span class="fc" id="L142">    }</span>

    /**
     * Gets time interval between accelerometer triad samples expressed in
     * seconds (s).
     *
     * @return time interval between accelerometer triad samples.
     */
    public double getTimeInterval() {
<span class="fc" id="L151">        return mTimeInterval;</span>
    }

    /**
     * Sets time interval between accelerometer triad samples expressed in
     * seconds (s).
     *
     * @param timeInterval time interval between accelerometer triad samples.
     * @throws IllegalArgumentException if provided value is negative.
     * @throws LockedException          if estimator is currently running.
     */
    public void setTimeInterval(final double timeInterval) throws LockedException {
<span class="fc bfc" id="L163" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L164">            throw new LockedException();</span>
        }

<span class="fc bfc" id="L167" title="All 2 branches covered.">        if (timeInterval &lt; 0.0) {</span>
<span class="fc" id="L168">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L171">        mTimeInterval = timeInterval;</span>
<span class="fc" id="L172">    }</span>

    /**
     * Gets time interval between accelerometer triad samples.
     *
     * @return time interval between accelerometer triad samples.
     */
    public Time getTimeIntervalAsTime() {
<span class="fc" id="L180">        return new Time(mTimeInterval, TimeUnit.SECOND);</span>
    }

    /**
     * Gets time interval between accelerometer triad samples.
     *
     * @param result instance where time interval will be stored.
     */
    public void getTimeIntervalAsTime(final Time result) {
<span class="fc" id="L189">        result.setValue(mTimeInterval);</span>
<span class="fc" id="L190">        result.setUnit(TimeUnit.SECOND);</span>
<span class="fc" id="L191">    }</span>

    /**
     * Sets time interval between accelerometer triad samples.
     *
     * @param timeInterval time interval between accelerometer triad samples.
     * @throws LockedException if estimator is currently running.
     */
    public void setTimeInterval(final Time timeInterval) throws LockedException {
<span class="fc" id="L200">        setTimeInterval(TimeConverter.convert(timeInterval.getValue().doubleValue(),</span>
<span class="fc" id="L201">                timeInterval.getUnit(), TimeUnit.SECOND));</span>
<span class="fc" id="L202">    }</span>

    /**
     * Gets listener to handle events raised by this estimator.
     *
     * @return listener to handle events raised by this estimator.
     */
    public L getListener() {
<span class="fc" id="L210">        return mListener;</span>
    }

    /**
     * Sets listener to handle events raised by this estimator.
     *
     * @param listener listener to handle events raised by this estimator.
     * @throws LockedException if this estimator is running.
     */
    public void setListener(final L listener) throws LockedException {
<span class="fc bfc" id="L220" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L221">            throw new LockedException();</span>
        }

<span class="fc" id="L224">        mListener = listener;</span>
<span class="fc" id="L225">    }</span>

    /**
     * Gets last provided triad values or null if not available.
     *
     * @return last provided triad values or null.
     */
    public T getLastTriad() {
<span class="fc" id="L233">        return mLastTriad;</span>
    }

    /**
     * Gets last provided triad values.
     *
     * @param result instance where last provided triad will be stored.
     * @return true if result instance was updated, false otherwise.
     */
    public boolean getLastTriad(final T result) {
<span class="fc bfc" id="L243" title="All 2 branches covered.">        if (mLastTriad != null) {</span>
<span class="fc" id="L244">            mLastTriad.copyTo(result);</span>
<span class="fc" id="L245">            return true;</span>
        } else {
<span class="fc" id="L247">            return false;</span>
        }
    }

    /**
     * Gets estimated average of x coordinate of measurement expressed in its default
     * unit (m/s^2 for acceleration, rad/s for angular speed or T for magnetic flux density).
     * This value will depend of body location and orientation, hence it should never
     * be used as a calibration bias.
     *
     * @return average of x coordinate of measurement in current window.
     */
    public double getAvgX() {
<span class="fc" id="L260">        return mAvgX;</span>
    }

    /**
     * Gets estimated average of x coordinate of measurement within current window.
     * This value will depend of body location and orientation, hence it should never
     * be used as a calibration bias.
     *
     * @return average of x coordinate of measurement in current window.
     */
    public M getAvgXAsMeasurement() {
<span class="fc" id="L271">        return createMeasurement(mAvgX, getDefaultUnit());</span>
    }

    /**
     * Gets estimated average of x coordinate of measurement within current window.
     * This value will depend of body location and orientation, hence it should never
     * be used as a calibration bias.
     *
     * @param result instance where average of x coordinate of measurement will be stored.
     */
    public void getAvgXAsMeasurement(final M result) {
<span class="fc" id="L282">        result.setValue(mAvgX);</span>
<span class="fc" id="L283">        result.setUnit(getDefaultUnit());</span>
<span class="fc" id="L284">    }</span>

    /**
     * Gets estimated average of y coordinate of measurement expressed in its default
     * unit (m/s^2 for acceleration, rad/s for angular speed or T for magnetic flux density).
     * This value will depend of body location and orientation, hence it should never
     * be used as a calibration bias.
     *
     * @return average of y coordinate of measurement in current window.
     */
    public double getAvgY() {
<span class="fc" id="L295">        return mAvgY;</span>
    }

    /**
     * Gets estimated average of y coordinate of measurement within current window.
     * This value will depend of body location and orientation, hence it should never
     * be used as a calibration bias.
     *
     * @return average of y coordinate of measurement in current window.
     */
    public M getAvgYAsMeasurement() {
<span class="fc" id="L306">        return createMeasurement(mAvgY, getDefaultUnit());</span>
    }

    /**
     * Gets estimated average of y coordinate of measurement within current window.
     * This value will depend of body location and orientation, hence it should never
     * be used as a calibration bias.
     *
     * @param result instance where average of y coordinate of measurement will be stored.
     */
    public void getAvgYAsMeasurement(final M result) {
<span class="fc" id="L317">        result.setValue(mAvgY);</span>
<span class="fc" id="L318">        result.setUnit(getDefaultUnit());</span>
<span class="fc" id="L319">    }</span>

    /**
     * Gets estimated average of z coordinate of measurement expressed in its default
     * unit (m/s^2 for acceleration, rad/s for angular speed or T for magnetic flux density).
     * This value will depend of body location and orientation, hence it should never
     * be used as a calibration bias.
     *
     * @return average of z coordinate of measurement in current window.
     */
    public double getAvgZ() {
<span class="fc" id="L330">        return mAvgZ;</span>
    }

    /**
     * Gets estimated average of z coordinate of measurement within current window.
     * This value will depend of body location and orientation, hence it should never
     * be used as a calibration bias.
     *
     * @return average of z coordinate of measurement in current window.
     */
    public M getAvgZAsMeasurement() {
<span class="fc" id="L341">        return createMeasurement(mAvgZ, getDefaultUnit());</span>
    }

    /**
     * Gets estimated average of z coordinate of measurement within current window.
     * This value will depend of body location and orientation, hence it should never
     * be used as a calibration bias.
     *
     * @param result instance where average of z coordinate of measurement will be stored.
     */
    public void getAvgZAsMeasurement(final M result) {
<span class="fc" id="L352">        result.setValue(mAvgZ);</span>
<span class="fc" id="L353">        result.setUnit(getDefaultUnit());</span>
<span class="fc" id="L354">    }</span>

    /**
     * Gets estimated average as a measurement triad.
     *
     * @return average measurement triad.
     */
    public T getAvgTriad() {
<span class="fc" id="L362">        return createTriad(mAvgX, mAvgY, mAvgZ, getDefaultUnit());</span>
    }

    /**
     * Gets estimated average as a measurement triad.
     *
     * @param result instance where average values and unit will be stored.
     */
    public void getAvgTriad(final T result) {
<span class="fc" id="L371">        result.setValueCoordinatesAndUnit(mAvgX, mAvgY, mAvgZ, getDefaultUnit());</span>
<span class="fc" id="L372">    }</span>

    /**
     * Gets norm of estimated average measurement expressed in its default
     * unit (m/s^2 for acceleration, rad/s for angular speed or T for magnetic flux density).
     * This value is independent of body orientation.
     *
     * @return norm of estimated average specific force.
     */
    public double getAvgNorm() {
<span class="fc" id="L382">        return Math.sqrt(mAvgX * mAvgX + mAvgY * mAvgY + mAvgZ * mAvgZ);</span>
    }

    /**
     * Gets norm of estimated average measurement within current window.
     *
     * @return norm of estimated average measurement.
     */
    public M getAvgNormAsMeasurement() {
<span class="fc" id="L391">        return createMeasurement(getAvgNorm(), getDefaultUnit());</span>
    }

    /**
     * Gets norm of estimated average measurement within current window.
     *
     * @param result instance where norm of estimated average measurement will be stored.
     */
    public void getAvgNormAsMeasurement(final M result) {
<span class="fc" id="L400">        result.setValue(getAvgNorm());</span>
<span class="fc" id="L401">        result.setUnit(getDefaultUnit());</span>
<span class="fc" id="L402">    }</span>

    /**
     * Gets estimated variance of x coordinate of measurement within current window
     * expressed in its default squared unit (m^2/s^4 for acceleration,
     * rad^2/s^2 for angular speed or T^2 for magnetic flux density).
     *
     * @return estimated variance of x coordinate of measurement within current
     * window.
     */
    public double getVarianceX() {
<span class="fc" id="L413">        return mVarianceX;</span>
    }

    /**
     * Gets estimated variance of y coordinate of measurement within current window
     * expressed in its default squared unit (m^2/s^4 for acceleration,
     * rad^2/s^2 for angular speed or T^2 for magnetic flux density).
     *
     * @return estimated variance of y coordinate of measurement within current
     * window.
     */
    public double getVarianceY() {
<span class="fc" id="L425">        return mVarianceY;</span>
    }

    /**
     * Gets estimated variance of z coordinate of measurement within current window
     * expressed in its default squared unit (m^2/s^4 for acceleration,
     * rad^2/s^2 for angular speed or T^2 for magnetic flux density).
     *
     * @return estimated variance of z coordinate of measurement within current
     * window.
     */
    public double getVarianceZ() {
<span class="fc" id="L437">        return mVarianceZ;</span>
    }

    /**
     * Gets estimated standard deviation of x coordinate of measurement within current
     * window and expressed in its default unit (m/s^2 for acceleration, rad/s for
     * angular speed or T for magnetic flux density).
     *
     * @return estimated standard deviation of x coordinate of measurement within
     * current window.
     */
    public double getStandardDeviationX() {
<span class="fc" id="L449">        return Math.sqrt(mVarianceX);</span>
    }

    /**
     * Gets estimated standard deviation of x coordinate of measurement within current
     * window.
     *
     * @return estimated standard deviation of x coordinate of measurement.
     */
    public M getStandardDeviationXAsMeasurement() {
<span class="fc" id="L459">        return createMeasurement(getStandardDeviationX(), getDefaultUnit());</span>
    }

    /**
     * Gets estimated standard deviation of x coordinate of measurement within current
     * window.
     *
     * @param result instance where estimated standard deviation of x coordinate of
     *               measurement will be stored.
     */
    public void getStandardDeviationXAsMeasurement(final M result) {
<span class="fc" id="L470">        result.setValue(getStandardDeviationX());</span>
<span class="fc" id="L471">        result.setUnit(getDefaultUnit());</span>
<span class="fc" id="L472">    }</span>

    /**
     * Gets estimated standard deviation of y coordinate of measurement within current
     * window and expressed in its default unit (m/s^2 for acceleration, rad/s for
     * angular speed or T for magnetic flux density).
     *
     * @return estimated standard deviation of y coordinate of measurement within
     * current window.
     */
    public double getStandardDeviationY() {
<span class="fc" id="L483">        return Math.sqrt(mVarianceY);</span>
    }

    /**
     * Gets estimated standard deviation of y coordinate of measurement within current
     * window.
     *
     * @return estimated standard deviation of y coordinate of measurement.
     */
    public M getStandardDeviationYAsMeasurement() {
<span class="fc" id="L493">        return createMeasurement(getStandardDeviationY(), getDefaultUnit());</span>
    }

    /**
     * Gets estimated standard deviation of y coordinate of measurement within current
     * window.
     *
     * @param result instance where estimated standard deviation of y coordinate of
     *               measurement will be stored.
     */
    public void getStandardDeviationYAsMeasurement(final M result) {
<span class="fc" id="L504">        result.setValue(getStandardDeviationY());</span>
<span class="fc" id="L505">        result.setUnit(getDefaultUnit());</span>
<span class="fc" id="L506">    }</span>

    /**
     * Gets estimated standard deviation of z coordinate of measurement within current
     * window and expressed in its default unit (m/s^2 for acceleration, rad/s for
     * angular speed or T for magnetic flux density).
     *
     * @return estimated standard deviation of z coordinate of measurement within
     * current window.
     */
    public double getStandardDeviationZ() {
<span class="fc" id="L517">        return Math.sqrt(mVarianceZ);</span>
    }

    /**
     * Gets estimated standard deviation of z coordinate of measurement within current
     * window.
     *
     * @return estimated standard deviation of z coordinate of measurement.
     */
    public M getStandardDeviationZAsMeasurement() {
<span class="fc" id="L527">        return createMeasurement(getStandardDeviationZ(), getDefaultUnit());</span>
    }

    /**
     * Gets estimated standard deviation of z coordinate of measurement within current
     * window.
     *
     * @param result instance where estimated standard deviation of z coordinate of
     *               measurement will be stored.
     */
    public void getStandardDeviationZAsMeasurement(final M result) {
<span class="fc" id="L538">        result.setValue(getStandardDeviationZ());</span>
<span class="fc" id="L539">        result.setUnit(getDefaultUnit());</span>
<span class="fc" id="L540">    }</span>

    /**
     * Gets estimated standard deviation of measurements.
     *
     * @return estimated standard deviation triad of measurements.
     */
    public T getStandardDeviationTriad() {
<span class="fc" id="L548">        return createTriad(</span>
<span class="fc" id="L549">                getStandardDeviationX(),</span>
<span class="fc" id="L550">                getStandardDeviationY(),</span>
<span class="fc" id="L551">                getStandardDeviationZ(),</span>
<span class="fc" id="L552">                getDefaultUnit());</span>
    }

    /**
     * Gets estimated standard deviation of measurement within current window.
     *
     * @param result instance where estimated standard deviation triad of
     *               measurement will be stored.
     */
    public void getStandardDeviationTriad(final T result) {
<span class="fc" id="L562">        result.setValueCoordinatesAndUnit(</span>
<span class="fc" id="L563">                getStandardDeviationX(),</span>
<span class="fc" id="L564">                getStandardDeviationY(),</span>
<span class="fc" id="L565">                getStandardDeviationZ(),</span>
<span class="fc" id="L566">                getDefaultUnit());</span>
<span class="fc" id="L567">    }</span>

    /**
     * Gets norm of estimated standard deviation of measurement
     * expressed in its default unit (m/s^2 for acceleration, rad/s for
     * angular speed or T for magnetic flux density).
     *
     * @return norm of estimated standard deviation of measurement.
     */
    public double getStandardDeviationNorm() {
<span class="fc" id="L577">        final double fx = getStandardDeviationX();</span>
<span class="fc" id="L578">        final double fy = getStandardDeviationY();</span>
<span class="fc" id="L579">        final double fz = getStandardDeviationZ();</span>
<span class="fc" id="L580">        return Math.sqrt(fx * fx + fy * fy + fz * fz);</span>
    }

    /**
     * Gets norm of estimated standard deviation of measurements.
     *
     * @return norm of estimated standard deviation of measurement.
     */
    public M getStandardDeviationNormAsMeasurement() {
<span class="fc" id="L589">        return createMeasurement(getStandardDeviationNorm(), getDefaultUnit());</span>
    }

    /**
     * Gets norm of estimated standard deviation of measurement within current window.
     *
     * @param result instance where norm of estimated standard deviation will be stored.
     */
    public void getStandardDeviationNormAsMeasurement(
            final M result) {
<span class="fc" id="L599">        result.setValue(getStandardDeviationNorm());</span>
<span class="fc" id="L600">        result.setUnit(getDefaultUnit());</span>
<span class="fc" id="L601">    }</span>

    /**
     * Gets average of estimated standard deviation coordinates of measurement
     * expressed in its default unit (m/s^2 for acceleration, rad/s for
     * angular speed or T for magnetic flux density).
     *
     * @return average of estimated standard deviation coordinates.
     */
    public double getAverageStandardDeviation() {
<span class="fc" id="L611">        final double fx = getStandardDeviationX();</span>
<span class="fc" id="L612">        final double fy = getStandardDeviationY();</span>
<span class="fc" id="L613">        final double fz = getStandardDeviationZ();</span>
<span class="fc" id="L614">        return (fx + fy + fz) / 3.0;</span>
    }

    /**
     * Gets average of estimated standard deviation coordinates of measurement within
     * current window.
     *
     * @return average of estimated standard deviation coordinates.
     */
    public M getAverageStandardDeviationAsMeasurement() {
<span class="fc" id="L624">        return createMeasurement(getAverageStandardDeviation(), getDefaultUnit());</span>
    }

    /**
     * Gets average of estimated standard deviation coordinates of measurement.
     *
     * @param result instance where average of estimated standard deviation coordinates
     *               will be stored.
     */
    public void getAverageStandardDeviationAsMeasurement(final M result) {
<span class="fc" id="L634">        result.setValue(getAverageStandardDeviation());</span>
<span class="fc" id="L635">        result.setUnit(getDefaultUnit());</span>
<span class="fc" id="L636">    }</span>

    /**
     * Gets measurement noise PSD (Power Spectral Density) on x axis expressed
     * in (m^2 * s^-3) for accelerometer, (rad^2/s) for gyroscope or (T^2 * s) for
     * magnetometer.
     *
     * @return measurement noise PSD on x axis.
     */
    public double getPsdX() {
<span class="fc" id="L646">        return mVarianceX * mTimeInterval;</span>
    }

    /**
     * Gets measurement noise PSD (Power Spectral Density) on y axis expressed
     * in (m^2 * s^-3) for accelerometer, (rad^2/s) for gyroscope or (T^2 * s) for
     * magnetometer.
     *
     * @return measurement noise PSD on y axis.
     */
    public double getPsdY() {
<span class="fc" id="L657">        return mVarianceY * mTimeInterval;</span>
    }

    /**
     * Gets measurement noise PSD (Power Spectral Density) on z axis expressed
     * in (m^2 * s^-3) for accelerometer, (rad^2/s) for gyroscope or (T^2 * s) for
     * magnetometer.
     *
     * @return measurement noise PSD on z axis.
     */
    public double getPsdZ() {
<span class="fc" id="L668">        return mVarianceZ * mTimeInterval;</span>
    }

    /**
     * Gets measurement noise root PSD (Power Spectral Density) on x axis expressed in
     * (m * s^-1.5) for accelerometer, (rad * s^-0.5) for gyroscope or (T * s^0.5) for
     * magnetometer.
     *
     * @return measurement noise root PSD on x axis.
     */
    public double getRootPsdX() {
<span class="fc" id="L679">        return Math.sqrt(getPsdX());</span>
    }

    /**
     * Gets measurement noise root PSD (Power Spectral Density) on y axis expressed in
     * (m * s^-1.5) for accelerometer, (rad * s^-0.5) for gyroscope or (T * s^0.5) for
     * magnetometer.
     *
     * @return measurement noise root PSD on y axis.
     */
    public double getRootPsdY() {
<span class="fc" id="L690">        return Math.sqrt(getPsdY());</span>
    }

    /**
     * Gets measurement noise root PSD (Power Spectral Density) on z axis expressed in
     * (m * s^-1.5) for accelerometer, (rad * s^-0.5) for gyroscope or (T * s^0.5) for
     * magnetometer.
     *
     * @return measurement noise root PSD on z axis.
     */
    public double getRootPsdZ() {
<span class="fc" id="L701">        return Math.sqrt(getPsdZ());</span>
    }

    /**
     * Gets average measurement noise PSD (Power Spectral Density) among
     * x,y,z components expressed as (m^2 * s^-3) for accelerometer,
     * (rad^2/s) for gyroscope or (T^2 * s) for magnetometer.
     *
     * @return average measurement noise PSD.
     */
    public double getAvgNoisePsd() {
<span class="fc" id="L712">        return (getPsdX() + getPsdY() + getPsdZ()) / 3.0;</span>
    }

    /**
     * Gets norm of noise root PSD (Power Spectral Density) among x,y,z
     * components expressed as (m * s^-1.5) for accelerometer,
     * (rad * s^-0.5) for gyroscope or (T * s^0.5) for magnetometer.
     *
     * @return norm of measurement noise root PSD.
     */
    public double getNoiseRootPsdNorm() {
<span class="fc" id="L723">        return Math.sqrt(getPsdX() + getPsdY() + getPsdZ());</span>
    }

    /**
     * Gets number of samples that have been processed so far.
     *
     * @return number of samples that have been processed so far.
     */
    public int getNumberOfProcessedSamples() {
<span class="fc" id="L732">        return mNumberOfProcessedSamples;</span>
    }

    /**
     * Indicates whether estimator is currently running or not.
     *
     * @return true if estimator is running, false otherwise.
     */
    public boolean isRunning() {
<span class="fc" id="L741">        return mRunning;</span>
    }

    /**
     * Adds a triad of measurement samples.
     * Values are expressed in measurement default unit (m/s^2 for acceleration, rad/s for
     * angular speed or T for magnetic flux density).
     *
     * @param valueX x coordinate of measurement to be added and processed.
     * @param valueY y coordinate of measurement to be added and processed.
     * @param valueZ z coordinate of measurement to be added and processed.
     * @return true if provided measurement instance has been processed, false if it has
     * been ignored.
     * @throws LockedException if estimator is currently running.
     */
    public boolean addTriad(
            final double valueX, final double valueY, final double valueZ)
            throws LockedException {

<span class="fc bfc" id="L760" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L761">            throw new LockedException();</span>
        }

<span class="fc" id="L764">        mRunning = true;</span>

<span class="fc bfc" id="L766" title="All 4 branches covered.">        if (mLastTriad == null &amp;&amp; mListener != null) {</span>
            //noinspection unchecked
<span class="fc" id="L768">            mListener.onStart((E)this);</span>
        }

        // compute averages
<span class="fc" id="L772">        final double tmp = (double) mNumberOfProcessedSamples / (double) mNumberOfProcessedSamplesPlusOne;</span>
<span class="fc" id="L773">        mAvgX = mAvgX * tmp + valueX / (double) mNumberOfProcessedSamplesPlusOne;</span>
<span class="fc" id="L774">        mAvgY = mAvgY * tmp + valueY / (double) mNumberOfProcessedSamplesPlusOne;</span>
<span class="fc" id="L775">        mAvgZ = mAvgZ * tmp + valueZ / (double) mNumberOfProcessedSamplesPlusOne;</span>

        // compute variances
<span class="fc" id="L778">        final double diffX = valueX - mAvgX;</span>
<span class="fc" id="L779">        final double diffY = valueY - mAvgY;</span>
<span class="fc" id="L780">        final double diffZ = valueZ - mAvgZ;</span>
<span class="fc" id="L781">        final double diffX2 = diffX * diffX;</span>
<span class="fc" id="L782">        final double diffY2 = diffY * diffY;</span>
<span class="fc" id="L783">        final double diffZ2 = diffZ * diffZ;</span>

<span class="fc" id="L785">        mVarianceX = mVarianceX * tmp + diffX2 / (double) mNumberOfProcessedSamplesPlusOne;</span>
<span class="fc" id="L786">        mVarianceY = mVarianceY * tmp + diffY2 / (double) mNumberOfProcessedSamplesPlusOne;</span>
<span class="fc" id="L787">        mVarianceZ = mVarianceZ * tmp + diffZ2 / (double) mNumberOfProcessedSamplesPlusOne;</span>

<span class="fc bfc" id="L789" title="All 2 branches covered.">        if (mLastTriad == null) {</span>
<span class="fc" id="L790">            mLastTriad = createTriad(valueX, valueY, valueZ, getDefaultUnit());</span>
        } else {
<span class="fc" id="L792">            mLastTriad.setValueCoordinatesAndUnit(valueX, valueY, valueZ, getDefaultUnit());</span>
        }

<span class="fc" id="L795">        mNumberOfProcessedSamples++;</span>
<span class="fc" id="L796">        mNumberOfProcessedSamplesPlusOne++;</span>

<span class="fc bfc" id="L798" title="All 2 branches covered.">        if (mListener != null) {</span>
            //noinspection unchecked
<span class="fc" id="L800">            mListener.onTriadAdded((E) this);</span>
        }

<span class="fc" id="L803">        mRunning = false;</span>

<span class="fc" id="L805">        return true;</span>
    }

    /**
     * Adds a triad of measurement samples.
     *
     * @param triad measurement triad to be added and processed.
     * @return true if provided measurement instance has been processed, false if it has
     * been ignored.
     * @throws LockedException if estimator is currently running.
     */
    public boolean addTriad(final T triad) throws LockedException {
<span class="fc" id="L817">        return addTriad(</span>
<span class="fc" id="L818">                convertToDefaultUnit(triad.getValueX(), triad.getUnit()),</span>
<span class="fc" id="L819">                convertToDefaultUnit(triad.getValueY(), triad.getUnit()),</span>
<span class="fc" id="L820">                convertToDefaultUnit(triad.getValueZ(), triad.getUnit()));</span>
    }

    /**
     * Adds a triad of measurement samples.
     *
     * @param valueX x coordinate of measurement to be added and processed.
     * @param valueY y coordinate of measurement to be added and processed.
     * @param valueZ z coordinate of measurement to be added and processed.
     * @return true if provided measurement instance has been processed, false if it has
     * been ignored.
     * @throws LockedException if estimator is currently running.
     */
    public boolean addTriad(final M valueX, final M valueY, final M valueZ)
            throws LockedException {
<span class="fc" id="L835">        return addTriad(</span>
<span class="fc" id="L836">                convertToDefaultUnit(valueX.getValue().doubleValue(), valueX.getUnit()),</span>
<span class="fc" id="L837">                convertToDefaultUnit(valueY.getValue().doubleValue(), valueY.getUnit()),</span>
<span class="fc" id="L838">                convertToDefaultUnit(valueZ.getValue().doubleValue(), valueZ.getUnit()));</span>
    }

    /**
     * Resets current estimator.
     *
     * @return true if estimator was successfully reset, false if no reset was needed.
     * @throws LockedException if estimator is currently running.
     */
    public boolean reset() throws LockedException {
<span class="fc bfc" id="L848" title="All 2 branches covered.">        if (mRunning) {</span>
<span class="fc" id="L849">            throw new LockedException();</span>
        }

<span class="pc bpc" id="L852" title="1 of 2 branches missed.">        if (mNumberOfProcessedSamples == 0) {</span>
<span class="nc" id="L853">            return false;</span>
        }

<span class="fc" id="L856">        mRunning = true;</span>
<span class="fc" id="L857">        mLastTriad = null;</span>
<span class="fc" id="L858">        mAvgX = 0.0;</span>
<span class="fc" id="L859">        mAvgY = 0.0;</span>
<span class="fc" id="L860">        mAvgZ = 0.0;</span>
<span class="fc" id="L861">        mVarianceX = 0.0;</span>
<span class="fc" id="L862">        mVarianceY = 0.0;</span>
<span class="fc" id="L863">        mVarianceZ = 0.0;</span>
<span class="fc" id="L864">        mNumberOfProcessedSamples = 0;</span>
<span class="fc" id="L865">        mNumberOfProcessedSamplesPlusOne = 1;</span>

<span class="fc bfc" id="L867" title="All 2 branches covered.">        if (mListener != null) {</span>
            //noinspection unchecked
<span class="fc" id="L869">            mListener.onReset((E) this);</span>
        }

<span class="fc" id="L872">        mRunning = false;</span>

<span class="fc" id="L874">        return true;</span>
    }

    /**
     * Creates a triad with provided values and unit.
     *
     * @param valueX x coordinate value.
     * @param valueY y coordinate value.
     * @param valueZ z coordinate value.
     * @param unit   unit.
     * @return created triad.
     */
    protected abstract T createTriad(
            final double valueX, final double valueY, final double valueZ, final U unit);

    /**
     * Creates a triad with provided values.
     *
     * @param valueX x coordinate value.
     * @param valueY y coordinate value.
     * @param valueZ z coordinate value.
     * @return created triad.
     */
    protected abstract T createTriad(final M valueX, final M valueY, final M valueZ);

    /**
     * Gets default unit for a measurement.
     *
     * @return default unit for a measurement.
     */
    protected abstract U getDefaultUnit();

    /**
     * Creates a measurement with provided value and unit.
     *
     * @param value value to be set.
     * @param unit  unit to be set.
     * @return created measurement.
     */
    protected abstract M createMeasurement(final double value, final U unit);

    /**
     * Converts provided value and unit into default unit.
     *
     * @param value measurement value to be converted.
     * @param unit unit of measurement value to be converted.
     * @return converted value.
     */
    protected abstract double convertToDefaultUnit(final double value, final U unit);
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>