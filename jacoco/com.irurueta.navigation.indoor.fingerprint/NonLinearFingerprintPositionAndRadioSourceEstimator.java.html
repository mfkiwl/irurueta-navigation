<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>NonLinearFingerprintPositionAndRadioSourceEstimator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.irurueta:irurueta-navigation</a> &gt; <a href="index.source.html" class="el_package">com.irurueta.navigation.indoor.fingerprint</a> &gt; <span class="el_source">NonLinearFingerprintPositionAndRadioSourceEstimator.java</span></div><h1>NonLinearFingerprintPositionAndRadioSourceEstimator.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2019 Alberto Irurueta Carro (alberto@irurueta.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.irurueta.navigation.indoor.fingerprint;

import com.irurueta.algebra.AlgebraException;
import com.irurueta.algebra.Matrix;
import com.irurueta.geometry.Point;
import com.irurueta.geometry.Point2D;
import com.irurueta.geometry.Point3D;
import com.irurueta.navigation.LockedException;
import com.irurueta.navigation.NotReadyException;
import com.irurueta.navigation.indoor.*;
import com.irurueta.numerical.NumericalException;
import com.irurueta.numerical.fitting.FittingException;
import com.irurueta.numerical.fitting.LevenbergMarquardtMultiDimensionFitter;
import com.irurueta.numerical.fitting.LevenbergMarquardtMultiDimensionFunctionEvaluator;

import java.util.*;

/**
 * Base class for position and radio source estimators based only on located
 * fingerprints containing RSSI readings.
 * All implementations of this class estimate the position of a new fingerprint
 * and the position of all radio sources associated to fingerprints whose location
 * is known.
 * All implementations solve the problem in a non linear way using Levenberg-Marquardt
 * algorithm.
 */
@SuppressWarnings(&quot;WeakerAccess&quot;)
public abstract class NonLinearFingerprintPositionAndRadioSourceEstimator&lt;P extends Point&gt; extends
        FingerprintPositionAndRadioSourceEstimator&lt;P&gt; {

    /**
     * Default RSSI standard deviation assumed for provided fingerprints as a fallback
     * when none can be determined.
     */
    public static final double FALLBACK_RSSI_STANDARD_DEVIATION = 1e-3;

    /**
     * Indicates that by default measured RSSI standard deviation of closest fingerprint
     * must be propagated into measured RSSI reading variance at unknown location.
     */
    public static final boolean DEFAULT_PROPAGATE_FINGERPRINT_RSSI_STANDARD_DEVIATION = true;

    /**
     * Indicates that by default path-loss exponent standard deviation of radio source
     * must be propagated into measured RSSI reading variance at unknown location.
     */
    public static final boolean DEFAULT_PROPAGATE_PATHLOSS_EXPONENT_STANDARD_DEVIATION = true;

    /**
     * Indicates that by default covariance of closest fingerprint position must be
     * propagated into measured RSSI reading variance at unknown location.
     */
    public static final boolean DEFAULT_PROPAGATE_FINGERPRINT_POSITION_COVARIANCE = true;

    /**
     * Indicates that by default covariance of radio source position must be propagated
     * into measured RSSI reading variance at unknown location.
     */
    public static final boolean DEFAULT_PROPAGATE_RADIO_SOURCE_POSITION_COVARIANCE = true;

    /**
     * Small value to be used as machine precision.
     */
    private static final double TINY = 1e-12;

    /**
     * Initial sources whose location is known.
     * If provided, their location will be used as initial values, but
     * after executing this estimator they will be refined.
     */
    protected List&lt;? extends RadioSourceLocated&lt;P&gt;&gt; mInitialLocatedSources;

    /**
     * Initial position to start the estimation.
     * This should be a value close to the expected solution.
     * If no value is provided, the average position among all selected nearest
     * located fingerprints will be used.
     */
    private P mInitialPosition;

    /**
     * Indicates whether path loss exponent of provided sources must be used when
     * available (if true), or if fallback path loss exponent must be used instead.
     */
<span class="fc" id="L100">    protected boolean mUseSourcesPathLossExponentWhenAvailable = true;</span>

    /**
     * RSSI standard deviation fallback value to use when none can be
     * determined from provided readings. This fallback value is only used if
     * no variance is propagated or the resulting value is too small to allow
     * convergence to a solution.
     */
<span class="fc" id="L108">    private double mFallbackRssiStandardDeviation =</span>
            FALLBACK_RSSI_STANDARD_DEVIATION;

    /**
     * Indicates whether measured RSSI standard deviation of closest fingerprint must
     * be propagated into measured RSSI reading variance at unknown location.
     */
<span class="fc" id="L115">    private boolean mPropagateFingerprintRssiStandardDeviation =</span>
            DEFAULT_PROPAGATE_FINGERPRINT_RSSI_STANDARD_DEVIATION;

    /**
     * Indicates whether path-loss exponent standard deviation of radio source must
     * be propagated into measured RSSI reading variance at unknown location.
     */
<span class="fc" id="L122">    private boolean mPropagatePathlossExponentStandardDeviation =</span>
            DEFAULT_PROPAGATE_PATHLOSS_EXPONENT_STANDARD_DEVIATION;

    /**
     * Indicates whether covariance of closest fingerprint position must be
     * propagated into measured RSSI reading variance at unknown location.
     */
<span class="fc" id="L129">    private boolean mPropagateFingerprintPositionCovariance =</span>
            DEFAULT_PROPAGATE_FINGERPRINT_POSITION_COVARIANCE;

    /**
     * Indicates whether covariance of radio source position must be propagated
     * into measured RSSI reading variance at unknown location.
     */
<span class="fc" id="L136">    private boolean mPropagateRadioSourcePositionCovariance =</span>
            DEFAULT_PROPAGATE_RADIO_SOURCE_POSITION_COVARIANCE;

    /**
     * Levenberg-Marquardt fitter to find a non-linear solution.
     */
<span class="fc" id="L142">    private LevenbergMarquardtMultiDimensionFitter mFitter = new LevenbergMarquardtMultiDimensionFitter();</span>

    /**
     * Estimated covariance matrix for estimated non-located fingerprint position and
     * estimated located radio sources position.
     */
    private Matrix mCovariance;

    /**
     * Covariance of estimated position for non-located fingerprint.
     */
    private Matrix mEstimatedPositionCovariance;

    /**
     * Estimated chi square value.
     */
    private double mChiSq;

    /**
     * Constructor.
     */
<span class="fc" id="L163">    public NonLinearFingerprintPositionAndRadioSourceEstimator() { }</span>

    /**
     * Constructor.
     * @param listener listener in charge of handling events.
     */
    public NonLinearFingerprintPositionAndRadioSourceEstimator(
            FingerprintPositionAndRadioSourceEstimatorListener&lt;P&gt; listener) {
<span class="fc" id="L171">        super(listener);</span>
<span class="fc" id="L172">    }</span>

    /**
     * Constructor.
     * @param locatedFingerprints located fingerprints containing RSSI readings.
     * @param fingerprint fingerprint containing readings at an unknown location
     *                    for provided located fingerprints.
     * @throws IllegalArgumentException if either non located fingerprint or located
     * fingerprints are null.
     */
    public NonLinearFingerprintPositionAndRadioSourceEstimator(
            List&lt;? extends RssiFingerprintLocated&lt;? extends RadioSource,
            ? extends RssiReading&lt;? extends RadioSource&gt;, P&gt;&gt; locatedFingerprints,
            RssiFingerprint&lt;? extends RadioSource,
            ? extends RssiReading&lt;? extends RadioSource&gt;&gt; fingerprint) {
<span class="fc" id="L187">        super(locatedFingerprints, fingerprint);</span>
<span class="fc" id="L188">    }</span>

    /**
     * Constructor.
     * @param locatedFingerprints located fingerprints containing RSSI readings.
     * @param fingerprint fingerprint containing readings at an unknown location
     *                    for provided located fingerprints.
     * @param listener listener in charge of handling events.
     * @throws IllegalArgumentException if either non located fingerprint or located
     * fingerprints are null.
     */
    public NonLinearFingerprintPositionAndRadioSourceEstimator(
            List&lt;? extends RssiFingerprintLocated&lt;? extends RadioSource,
            ? extends RssiReading&lt;? extends RadioSource&gt;, P&gt;&gt; locatedFingerprints,
            RssiFingerprint&lt;? extends RadioSource,
            ? extends RssiReading&lt;? extends RadioSource&gt;&gt; fingerprint,
            FingerprintPositionAndRadioSourceEstimatorListener&lt;P&gt; listener) {
<span class="fc" id="L205">        super(locatedFingerprints, fingerprint, listener);</span>
<span class="fc" id="L206">    }</span>

    /**
     * Constructor.
     * @param locatedFingerprints located fingerprints containing RSSI readings.
     * @param fingerprint fingerprint containing readings at an unknown location
     *                    for provided located fingerprints.
     * @param initialPosition initial position to be assumed on non located fingerprint or
     *                        null if unknown.
     * @throws IllegalArgumentException if either non located fingerprint or located
     * fingerprints are null.
     */
    public NonLinearFingerprintPositionAndRadioSourceEstimator(
            List&lt;? extends RssiFingerprintLocated&lt;? extends RadioSource,
            ? extends RssiReading&lt;? extends RadioSource&gt;, P&gt;&gt; locatedFingerprints,
            RssiFingerprint&lt;? extends RadioSource,
            ? extends RssiReading&lt;? extends RadioSource&gt;&gt; fingerprint,
            P initialPosition) {
<span class="fc" id="L224">        super(locatedFingerprints, fingerprint);</span>
<span class="fc" id="L225">        mInitialPosition = initialPosition;</span>
<span class="fc" id="L226">    }</span>

    /**
     * Constructor.
     * @param locatedFingerprints located fingerprints containing RSSI readings.
     * @param fingerprint fingerprint containing readings at an unknown location
     *                    for provided located fingerprints.
     * @param initialPosition initial position to be assumed on non located fingerprint or
     *                        null if unknown.
     * @param listener listener in charge of handling events.
     * @throws IllegalArgumentException if either non located fingerprint or located
     * fingerprints are null.
     */
    public NonLinearFingerprintPositionAndRadioSourceEstimator(
            List&lt;? extends RssiFingerprintLocated&lt;? extends RadioSource,
            ? extends RssiReading&lt;? extends RadioSource&gt;, P&gt;&gt; locatedFingerprints,
            RssiFingerprint&lt;? extends RadioSource,
            ? extends RssiReading&lt;? extends RadioSource&gt;&gt; fingerprint,
            P initialPosition,
            FingerprintPositionAndRadioSourceEstimatorListener&lt;P&gt; listener) {
<span class="fc" id="L246">        super(locatedFingerprints, fingerprint, listener);</span>
<span class="fc" id="L247">        mInitialPosition = initialPosition;</span>
<span class="fc" id="L248">    }</span>

    /**
     * Constructor.
     * @param locatedFingerprints located fingerprints containing RSSI readings.
     * @param fingerprint fingerprint containing readings at an unknown location
     *                    for provided located fingerprints.
     * @param initialLocatedSources sources containing initial location to be refined or null
     *                              if unknown.
     * @throws IllegalArgumentException if either non located fingerprint or located
     * fingerprints are null.
     */
    public NonLinearFingerprintPositionAndRadioSourceEstimator(
            List&lt;? extends RssiFingerprintLocated&lt;? extends RadioSource,
            ? extends RssiReading&lt;? extends RadioSource&gt;, P&gt;&gt; locatedFingerprints,
            RssiFingerprint&lt;? extends RadioSource,
            ? extends RssiReading&lt;? extends RadioSource&gt;&gt; fingerprint,
            List&lt;? extends RadioSourceLocated&lt;P&gt;&gt; initialLocatedSources) {
<span class="fc" id="L266">        super(locatedFingerprints, fingerprint);</span>
<span class="fc" id="L267">        mInitialLocatedSources = initialLocatedSources;</span>
<span class="fc" id="L268">    }</span>

    /**
     * Constructor.
     * @param locatedFingerprints located fingerprints containing RSSI readings.
     * @param fingerprint fingerprint containing readings at an unknown location
     *                    for provided located fingerprints.
     * @param initialLocatedSources sources containing initial location to be refined or null
     *                              if unknown.
     * @param listener listener in charge of handling events.
     * @throws IllegalArgumentException if either non located fingerprint or located
     * fingerprints are null.
     */
    public NonLinearFingerprintPositionAndRadioSourceEstimator(List&lt;? extends RssiFingerprintLocated&lt;? extends RadioSource,
            ? extends RssiReading&lt;? extends RadioSource&gt;, P&gt;&gt; locatedFingerprints,
            RssiFingerprint&lt;? extends RadioSource,
            ? extends RssiReading&lt;? extends RadioSource&gt;&gt; fingerprint,
            List&lt;? extends RadioSourceLocated&lt;P&gt;&gt; initialLocatedSources,
            FingerprintPositionAndRadioSourceEstimatorListener&lt;P&gt; listener) {
<span class="fc" id="L287">        super(locatedFingerprints, fingerprint, listener);</span>
<span class="fc" id="L288">        mInitialLocatedSources = initialLocatedSources;</span>
<span class="fc" id="L289">    }</span>

    /**
     * Constructor.
     * @param locatedFingerprints located fingerprints containing RSSI readings.
     * @param fingerprint fingerprint containing readings at an unknown location
     *                    for provided located fingerprints.
     * @param initialPosition initial position to be assumed on non located fingerprint or
     *                        null if unknown.
     * @param initialLocatedSources sources containing initial location to be refined or null
     *                              if unknown.
     * @throws IllegalArgumentException if either non located fingerprint or located
     * fingerprints are null.
     */
    public NonLinearFingerprintPositionAndRadioSourceEstimator(List&lt;? extends RssiFingerprintLocated&lt;? extends RadioSource,
            ? extends RssiReading&lt;? extends RadioSource&gt;, P&gt;&gt; locatedFingerprints,
            RssiFingerprint&lt;? extends RadioSource,
            ? extends RssiReading&lt;? extends RadioSource&gt;&gt; fingerprint,
            P initialPosition,
            List&lt;? extends RadioSourceLocated&lt;P&gt;&gt; initialLocatedSources) {
<span class="fc" id="L309">        this(locatedFingerprints, fingerprint, initialPosition);</span>
<span class="fc" id="L310">        mInitialLocatedSources = initialLocatedSources;</span>
<span class="fc" id="L311">    }</span>

    /**
     * Constructor.
     * @param locatedFingerprints located fingerprints containing RSSI readings.
     * @param fingerprint fingerprint containing readings at an unknown location
     *                    for provided located fingerprints.
     * @param initialPosition initial position to be assumed on non located fingerprint or
     *                        null if unknown.
     * @param initialLocatedSources sources containing initial location to be refined or null
     *                              if unknown.
     * @param listener listener in charge of handling events.
     * @throws IllegalArgumentException if either non located fingerprint or located
     * fingerprints are null.
     */
    public NonLinearFingerprintPositionAndRadioSourceEstimator(List&lt;? extends RssiFingerprintLocated&lt;? extends RadioSource,
            ? extends RssiReading&lt;? extends RadioSource&gt;, P&gt;&gt; locatedFingerprints,
            RssiFingerprint&lt;? extends RadioSource,
            ? extends RssiReading&lt;? extends RadioSource&gt;&gt; fingerprint,
            P initialPosition,
            List&lt;? extends RadioSourceLocated&lt;P&gt;&gt; initialLocatedSources,
            FingerprintPositionAndRadioSourceEstimatorListener&lt;P&gt; listener) {
<span class="fc" id="L333">        this(locatedFingerprints, fingerprint, initialPosition, listener);</span>
<span class="fc" id="L334">        mInitialLocatedSources = initialLocatedSources;</span>
<span class="fc" id="L335">    }</span>

    /**
     * Gets initial radio sources whose location is known.
     * @return initial radio sources.
     */
    public List&lt;? extends RadioSourceLocated&lt;P&gt;&gt; getInitialLocatedSources() {
<span class="fc" id="L342">        return mInitialLocatedSources;</span>
    }

    /**
     * Sets initial radio sources whose location is known.
     * @param initialLocatedSources initial radio sources.
     * @throws LockedException if estimator is locked.
     */
    public void setInitialLocatedSources(
            List&lt;? extends RadioSourceLocated&lt;P&gt;&gt; initialLocatedSources)
            throws LockedException  {
<span class="fc bfc" id="L353" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L354">            throw new LockedException();</span>
        }

<span class="fc" id="L357">        mInitialLocatedSources = initialLocatedSources;</span>
<span class="fc" id="L358">    }</span>

    /**
     * Gets initial position to start the solving algorithm.
     * This should be a value close to the expected solution.
     * If no value is provided, the average position among all selected nearest
     * located fingerprints will be used.
     * @return initial position to start the solving algorithm or null.
     */
    public P getInitialPosition() {
<span class="fc" id="L368">        return mInitialPosition;</span>
    }

    /**
     * Sets initial position to start the solving algorithm.
     * This should be a value close to the expected solution.
     * If no value is provided, the average position among all selected nearest
     * located fingerprints will be used.
     * @param initialPosition initial position to start the solving algorithm or null.
     * @throws LockedException if estimator is locked.
     */
    public void setInitialPosition(P initialPosition) throws LockedException {
<span class="fc bfc" id="L380" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L381">            throw new LockedException();</span>
        }

<span class="fc" id="L384">        mInitialPosition = initialPosition;</span>
<span class="fc" id="L385">    }</span>

    /**
     * Gets estimated covariance matrix for estimated non-located fingerprint position
     * and estimated located radio sources position.
     * @return estimated covariance matrix for estimated non-located fingerprint
     * position and estimated located radio sources position.
     */
    public Matrix getCovariance() {
<span class="fc" id="L394">        return mCovariance;</span>
    }

    /**
     * Gets covariance of estimated position for non-located fingerprint.
     * @return covariance of estimated position for non-located fingerprint.
     */
    public Matrix getEstimatedPositionCovariance() {
<span class="fc" id="L402">        return mEstimatedPositionCovariance;</span>
    }

    /**
     * Gets estimated chi square value.
     * @return estimated chi square value.
     */
    public double getChiSq() {
<span class="fc" id="L410">        return mChiSq;</span>
    }

    /**
     * Indicates whether path loss exponent of provided sources must be used when
     * available (if true), or if fallback path loss exponent must be used instead.
     * @return true to use path loss exponent of provided sources when available,
     * false otherwise.
     */
    public boolean getUseSourcesPathLossExponentWhenAvailable() {
<span class="fc" id="L420">        return mUseSourcesPathLossExponentWhenAvailable;</span>
    }

    /**
     * Specifies whether path loss exponent of provided sources must be used when
     * available (if true), or if fallback path loss exponent must be used instead.
     * @param useSourcesPathLossExponentWhenAvailable true to use path loss exponent of
     *                                                provided sources when available,
     *                                                false otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setUseSourcesPathLossExponentWhenAvailable(
            boolean useSourcesPathLossExponentWhenAvailable) throws LockedException {
<span class="fc bfc" id="L433" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L434">            throw new LockedException();</span>
        }
<span class="fc" id="L436">        mUseSourcesPathLossExponentWhenAvailable =</span>
                useSourcesPathLossExponentWhenAvailable;
<span class="fc" id="L438">    }</span>

    /**
     * Gets RSSI standard deviation fallback value to use when none can be
     * determined from provided readings.
     * @return RSSI standard deviation fallback.
     */
    public double getFallbackRssiStandardDeviation() {
<span class="fc" id="L446">        return mFallbackRssiStandardDeviation;</span>
    }

    /**
     * Sets RSSI standard deviation fallback value to use when none can be
     * determined from provided readings.
     * @param fallbackRssiStandardDeviation RSSI standard deviation fallback
     * @throws LockedException if estimator is locked.
     * @throws IllegalArgumentException if provided value is smaller than
     * {@link #TINY}.
     */
    public void setFallbackRssiStandardDeviation(
            double fallbackRssiStandardDeviation) throws LockedException {
<span class="fc bfc" id="L459" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L460">            throw new LockedException();</span>
        }
<span class="pc bpc" id="L462" title="1 of 2 branches missed.">        if (fallbackRssiStandardDeviation &lt; TINY) {</span>
<span class="nc" id="L463">            throw new IllegalArgumentException();</span>
        }
<span class="fc" id="L465">        mFallbackRssiStandardDeviation = fallbackRssiStandardDeviation;</span>
<span class="fc" id="L466">    }</span>

    /**
     * Indicates whether measured RSSI standard deviation of closest fingerprint must be
     * propagated into measured RSSI reading variance at unknown location.
     * @return true to propagate RSSI standard deviation of closest fingerprint,
     * false otherwise.
     */
    public boolean isFingerprintRssiStandardDeviationPropagated() {
<span class="fc" id="L475">        return mPropagateFingerprintRssiStandardDeviation;</span>
    }

    /**
     * Specifies whether measured RSSI standard deviation of closest fingerprint must be
     * propagated into measured RSSI reading variance at unknown location.
     * @param propagateFingerprintRssiStandardDeviation true to propagate RSSI standard
     *                                                  deviation of closest fingerprint,
     *                                                  false otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setFingerprintRssiStandardDeviationPropagated(
            boolean propagateFingerprintRssiStandardDeviation) throws LockedException {
<span class="fc bfc" id="L488" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L489">            throw new LockedException();</span>
        }
<span class="fc" id="L491">        mPropagateFingerprintRssiStandardDeviation =</span>
                propagateFingerprintRssiStandardDeviation;
<span class="fc" id="L493">    }</span>

    /**
     * Indicates whether path-loss exponent standard deviation of radio source must be
     * propagated into measured RSSI reading variance at unknown location.
     * @return true to propagate  path-loss exponent standard deviation of radio source,
     * false otherwise.
     */
    public boolean isPathlossExponentStandardDeviationPropagated() {
<span class="fc" id="L502">        return mPropagatePathlossExponentStandardDeviation;</span>
    }

    /**
     * Specifies whether path-loss exponent standard deviation of radio source must be
     * propagated into measured RSSI reading variance at unknown location.
     * @param propagatePathlossExponentStandardDeviation true to propagate path-loss
     *                                                   exponent standard deviation of
     *                                                   radio source, false otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setPathlossExponentStandardDeviationPropagated(
            boolean propagatePathlossExponentStandardDeviation) throws LockedException {
<span class="fc bfc" id="L515" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L516">            throw new LockedException();</span>
        }
<span class="fc" id="L518">        mPropagatePathlossExponentStandardDeviation =</span>
                propagatePathlossExponentStandardDeviation;
<span class="fc" id="L520">    }</span>

    /**
     * Indicates whether covariance of closest fingerprint position must be propagated
     * into measured RSSI reading variance at unknown location.
     * @return true to propagate fingerprint position covariance, false otherwise.
     */
    public boolean isFingerprintPositionCovariancePropagated() {
<span class="fc" id="L528">        return mPropagateFingerprintPositionCovariance;</span>
    }

    /**
     * Specifies whether covariance of closest fingerprint position must be propagated
     * into measured RSSI reading variance at unknown location.
     * @param propagateFingerprintPositionCovariance true to propagate fingerprint
     *                                               position covariance, false otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setFingerprintPositionCovariancePropagated(
            boolean propagateFingerprintPositionCovariance) throws LockedException {
<span class="fc bfc" id="L540" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L541">            throw new LockedException();</span>
        }
<span class="fc" id="L543">        mPropagateFingerprintPositionCovariance =</span>
                propagateFingerprintPositionCovariance;
<span class="fc" id="L545">    }</span>

    /**
     * Indicates whether covariance of radio source position must be propagated into
     * measured RSSI reading variance at unknown location.
     * @return true to propagate radio source position covariance, false otherwise.
     */
    public boolean isRadioSourcePositionCovariancePropagated() {
<span class="fc" id="L553">        return mPropagateRadioSourcePositionCovariance;</span>
    }

    /**
     * Specifies whether covariance of radio source position must be propagated into
     * measured RSSI reading variance at unknown location.
     * @param propagateRadioSourcePositionCovariance true to propagate radio source
     *                                               position covariance, false otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setRadioSourcePositionCovariancePropagated(
            boolean propagateRadioSourcePositionCovariance) throws LockedException {
<span class="fc bfc" id="L565" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L566">            throw new LockedException();</span>
        }
<span class="fc" id="L568">        mPropagateRadioSourcePositionCovariance =</span>
                propagateRadioSourcePositionCovariance;
<span class="fc" id="L570">    }</span>

    /**
     * Estimates position and radio sources based on provided located radio sources and readings of
     * such radio sources at an unknown location.
     * @throws LockedException if estimator is locked.
     * @throws NotReadyException if estimator is not ready.
     * @throws FingerprintEstimationException if estimation fails for some other reason.
     */
    @Override
    @SuppressWarnings(&quot;Duplicates&quot;)
    public void estimate() throws LockedException, NotReadyException,
            FingerprintEstimationException {

<span class="pc bpc" id="L584" title="1 of 2 branches missed.">        if (!isReady()) {</span>
<span class="nc" id="L585">            throw new NotReadyException();</span>
        }
<span class="fc bfc" id="L587" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L588">            throw new LockedException();</span>
        }

        try {
<span class="fc" id="L592">            mLocked = true;</span>

<span class="pc bpc" id="L594" title="1 of 2 branches missed.">            if (mListener != null) {</span>
<span class="fc" id="L595">                mListener.onEstimateStart(this);</span>
            }

<span class="fc" id="L598">            RadioSourceNoMeanKNearestFinder&lt;P, RadioSource&gt; noMeanfinder = null;</span>
<span class="fc" id="L599">            RadioSourceKNearestFinder&lt;P, RadioSource&gt; finder = null;</span>
<span class="pc bpc" id="L600" title="1 of 2 branches missed.">            if (mUseNoMeanNearestFingerprintFinder) {</span>
                //noinspection unchecked
<span class="fc" id="L602">                noMeanfinder = new RadioSourceNoMeanKNearestFinder&lt;&gt;(</span>
                        (Collection&lt;? extends RssiFingerprintLocated&lt;RadioSource,
                                RssiReading&lt;RadioSource&gt;, P&gt;&gt;)mLocatedFingerprints);
            } else {
                //noinspection unchecked
<span class="nc" id="L607">                finder = new RadioSourceKNearestFinder&lt;&gt;(</span>
                        (Collection&lt;? extends RssiFingerprintLocated&lt;RadioSource,
                                RssiReading&lt;RadioSource&gt;, P&gt;&gt;)mLocatedFingerprints);
            }

<span class="fc" id="L612">            mEstimatedPositionCoordinates = null;</span>
<span class="fc" id="L613">            mCovariance = null;</span>
<span class="fc" id="L614">            mEstimatedPositionCovariance = null;</span>
<span class="fc" id="L615">            mNearestFingerprints = null;</span>
<span class="fc" id="L616">            mEstimatedLocatedSources = null;</span>

<span class="fc" id="L618">            int min = Math.max(1, mMinNearestFingerprints);</span>
<span class="pc bpc" id="L619" title="1 of 2 branches missed.">            int max = mMaxNearestFingerprints &lt; 0 ?</span>
<span class="fc" id="L620">                    mLocatedFingerprints.size() :</span>
<span class="pc" id="L621">                    Math.min(mMaxNearestFingerprints, mLocatedFingerprints.size());</span>
<span class="fc bfc" id="L622" title="All 2 branches covered.">            for (int k = min; k &lt;= max; k++) {</span>
<span class="pc bpc" id="L623" title="1 of 2 branches missed.">                if (noMeanfinder != null) {</span>
                    //noinspection unchecked
<span class="fc" id="L625">                    mNearestFingerprints = noMeanfinder.findKNearestTo(</span>
                            (RssiFingerprint&lt;RadioSource, RssiReading&lt;RadioSource&gt;&gt;) mFingerprint, k);
                } else {
                    //noinspection unchecked
<span class="nc" id="L629">                    mNearestFingerprints = finder.findKNearestTo(</span>
                            (RssiFingerprint&lt;RadioSource, RssiReading&lt;RadioSource&gt;&gt;) mFingerprint, k);
                }

                //Demonstration in 2D:
                //--------------------

                //The expression of received power expressed in dBm's is:
                //k = (c/(4*pi*f))
                //Pr = Pte*k^n / d^n

                //where c is the speed of light, pi is 3.14159..., f is the frequency of the radio source,
                //Pte is the equivalent transmitted power by the radio source, n is the path-loss exponent
                // (typically 2.0), and d is the distance from a point to the location of the radio source.

                //Hence:
                //Pr(dBm) = 10*log(Pte*k^n/d^n) = 10*n*log(k) + 10*log(Pte) - 10*n*log(d) =
                //          10*n*log(k) + 10*log(Pte) - 5*n*log(d^2)

                //where d^2 = dia^2 = (xi - xa)^2 + (yi - ya)^2 is the squared distance between
                //fingerprint and unknown point pi = (xi, yi) and
                //radio source a = a,b... M
                //10*n*log(k) is constant for a given radio source &quot;a&quot;, and
                //Pte is the equivalent transmitted power of radio source &quot;a&quot;.

                //We assume that the 2 former terms are constant and known for a given radio source
                //K = 10*n*log(k) + 10*log(Pte), and the only unknown term is
                //the latter one depending on the distance of the
                //measuring point and the radio source.

                //Hence for a given radio source &quot;a&quot; at unknown location &quot;i&quot;:
                //Pr(pi) = K - 5*n*log((xi - xa)^2 + (yi - ya)^2)

                //we assume that a known located fingerprint is located at p1 = (x1, y1),
                //Both readings Pr(pi) and Pr(p1) belong to the same radio source &quot;a&quot;, hence
                //K term is the same.

                //Pr(p1) = K - 5*n*log((x1 - xa)^2 + (y1 - ya)^2)

                //where d1a^2 = (x1 - xa)^2 + (y1 - ya)^2 is the squared distance between
                //fingerprint 1 and radio source 2

                //To remove possible bias effects on readings, we consider the difference of received
                //power for fingerprint &quot;1&quot; and radio source &quot;a&quot; as:

                //Prdiff1a = Pr(pi) - Pr(p1) = (K - 5*n*log(dia^2)) - (K - 5*n*log(d1a^2)) =
                //  = 5*n*log(d1a^2) - 5*n*log(dia^2)

                //where both d1a^2 and dia^2 are unknown, because location pi=(xi,yi) and pa=(xa,ya) are unknown.
                //Now we have no dependencies on the amount of transmitted power of each radio source
                //contained on constant term K, and we only depend on squared distances d1a^2 and dia^2.

                //Consequently, the difference of received power for fingerprint &quot;2&quot; and radio source &quot;a&quot; is:
                //Prdiff2a = 5*n*log(d2a^2) - 5*n*log(dia^2)

                //the difference of received power for fingerprint &quot;1&quot; and radio source &quot;b&quot; is:
                //Prdiff1b = 5*n*log(d1b^2) - 5*n*log(dib^2)

                //and so on.

                //we want to find unknown location pi, and location of radio source pa, pb,... pM so that Prdiff
                //errors are minimized in LMSE (Least Mean Square Error) terms.

                //Assuming that we have M radio sources and N fingerprints, we have
                //y = [Prdiff1a Prdiff2a Prdiff1b Prdiff2b ... PrdiffNa PrdiffNb ... PrdiffNM]

                //and the unknowns to be found are:
                //x = [xi yi xa ya xb yb ... xM yM], which are the location of the unknown fingerprint
                //pi = (xi, yi) and the locations of the radio sources a, b ... M that we want to find pa = (xa, ya),
                //pb = (xb, yb) ... pM = (xM, yM)

                try {
<span class="fc" id="L701">                    List&lt;RadioSource&gt; sourcesToBeEstimated = setupFitter();</span>
<span class="fc bfc" id="L702" title="All 2 branches covered.">                    if (mMinNearestFingerprints &lt; 0) {</span>
                        //if no limit is set in minimum value, then a minimum of
                        //dims * (1 + numSources) is used
<span class="fc" id="L705">                        int numSources = sourcesToBeEstimated.size();</span>
<span class="fc" id="L706">                        int dims = getNumberOfDimensions();</span>
<span class="fc" id="L707">                        int minNearest = dims * (1 + numSources);</span>
<span class="fc bfc" id="L708" title="All 2 branches covered.">                        if (k &lt; minNearest) {</span>
<span class="fc" id="L709">                            continue;</span>
                        }
                    }

<span class="fc" id="L713">                    mFitter.fit();</span>

                    //estimated position
<span class="fc" id="L716">                    double[] a = mFitter.getA();</span>
<span class="fc" id="L717">                    mCovariance = mFitter.getCovar();</span>
<span class="fc" id="L718">                    mChiSq = mFitter.getChisq();</span>

<span class="fc" id="L720">                    int dims = getNumberOfDimensions();</span>

                    //obtain estimated position coordinates and covariance
<span class="fc" id="L723">                    mEstimatedPositionCoordinates = new double[dims];</span>
<span class="fc" id="L724">                    System.arraycopy(a, 0, mEstimatedPositionCoordinates,</span>
                            0, dims);

<span class="fc" id="L727">                    int dimsMinusOne = dims - 1;</span>
<span class="fc" id="L728">                    mEstimatedPositionCovariance = mCovariance.getSubmatrix(0, 0,</span>
                            dimsMinusOne, dimsMinusOne);

                    //obtain radio sources estimated positions and covariance
<span class="fc" id="L732">                    int totalSources = sourcesToBeEstimated.size();</span>
<span class="fc" id="L733">                    mEstimatedLocatedSources = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L734" title="All 2 branches covered.">                    for (int j = 0; j &lt; totalSources; j++) {</span>
<span class="fc" id="L735">                        P sourcePosition = createPoint();</span>

<span class="fc" id="L737">                        int start = dims * (1 + j);</span>
<span class="fc" id="L738">                        int end = start + dimsMinusOne;</span>
<span class="fc bfc" id="L739" title="All 2 branches covered.">                        for(int i = 0; i &lt; dims; i++) {</span>
<span class="fc" id="L740">                            sourcePosition.setInhomogeneousCoordinate(i, a[start + i]);</span>
                        }

<span class="fc" id="L743">                        Matrix sourceCovariance = mCovariance.getSubmatrix(</span>
                                start, start, end, end);

<span class="fc" id="L746">                        RadioSource source = sourcesToBeEstimated.get(j);</span>
<span class="fc" id="L747">                        mEstimatedLocatedSources.add(</span>
<span class="fc" id="L748">                                createRadioSource(source, sourcePosition,</span>
                                        sourceCovariance));
                    }

                    //a solution was found so we exit loop
<span class="fc" id="L753">                    break;</span>
<span class="fc" id="L754">                } catch (NumericalException e) {</span>
                    //solution could not be found with current data
                    //Iterate to use additional nearby fingerprints
<span class="fc" id="L757">                    mEstimatedPositionCoordinates = null;</span>
<span class="fc" id="L758">                    mCovariance = null;</span>
<span class="fc" id="L759">                    mEstimatedPositionCovariance = null;</span>
<span class="fc" id="L760">                    mEstimatedLocatedSources = null;</span>
                }
            }

<span class="pc bpc" id="L764" title="1 of 4 branches missed.">            if (mEstimatedPositionCoordinates == null ||</span>
                    mEstimatedLocatedSources == null) {
                //no position could be estimated
<span class="fc" id="L767">                throw new FingerprintEstimationException();</span>
            }

<span class="pc bpc" id="L770" title="1 of 2 branches missed.">            if (mListener != null) {</span>
<span class="fc" id="L771">                mListener.onEstimateEnd(this);</span>
            }
        } finally {
<span class="fc" id="L774">            mLocked = false;</span>
        }
<span class="fc" id="L776">    }</span>

    /**
     * Propagates provided variances into RSSI differences.
     * @param pathlossExponent path-loss exponent.
     * @param fingerprintPosition position of closest located fingerprint.
     * @param radioSourcePosition radio source position associated to fingerprint reading.
     * @param estimatedPosition position to be estimated. Usually this is equal to the
     *                          initial position used by a non linear algorithm.
     * @param pathlossExponentVariance variance of path-loss exponent or null if unknown.
     * @param fingerprintPositionCovariance covariance of fingerprint position or null if
     *                                      unknown.
     * @param radioSourcePositionCovariance covariance of radio source position or null if
     *                                      unknown.
     * @return variance of RSSI difference measured at non located fingerprint reading.
     */
    protected abstract Double propagateVariances(double pathlossExponent,
            P fingerprintPosition, P radioSourcePosition, P estimatedPosition,
            Double pathlossExponentVariance, Matrix fingerprintPositionCovariance,
            Matrix radioSourcePositionCovariance);

    /**
     * Creates a located radio source from provided radio source, position and
     * covariance.
     * @param source radio source.
     * @param sourcePosition radio source position.
     * @param sourceCovariance radio source position covariance.
     * @return located radio source.
     */
    private RadioSourceLocated&lt;P&gt; createRadioSource(RadioSource source,
            P sourcePosition, Matrix sourceCovariance) {

<span class="fc" id="L808">        int dims = getNumberOfDimensions();</span>

<span class="fc bfc" id="L810" title="All 2 branches covered.">        switch (source.getType()) {</span>
            case BEACON:
<span class="fc" id="L812">                Beacon beacon = (Beacon)source;</span>
<span class="fc bfc" id="L813" title="All 2 branches covered.">                if (dims == Point2D.POINT2D_INHOMOGENEOUS_COORDINATES_LENGTH) {</span>
                    //2D

                    //noinspection unchecked
<span class="fc" id="L817">                    return (RadioSourceLocated&lt;P&gt;)new BeaconLocated2D(</span>
<span class="fc" id="L818">                            beacon.getIdentifiers(), beacon.getTransmittedPower(),</span>
<span class="fc" id="L819">                            beacon.getFrequency(), beacon.getBluetoothAddress(),</span>
<span class="fc" id="L820">                            beacon.getBeaconTypeCode(), beacon.getManufacturer(),</span>
<span class="fc" id="L821">                            beacon.getServiceUuid(), beacon.getBluetoothName(),</span>
                            (Point2D) sourcePosition, sourceCovariance);
                } else {
                    //3D

                    //noinspection unchecked
<span class="fc" id="L827">                    return (RadioSourceLocated&lt;P&gt;)new BeaconLocated3D(</span>
<span class="fc" id="L828">                            beacon.getIdentifiers(), beacon.getTransmittedPower(),</span>
<span class="fc" id="L829">                            beacon.getFrequency(), beacon.getBluetoothAddress(),</span>
<span class="fc" id="L830">                            beacon.getBeaconTypeCode(), beacon.getManufacturer(),</span>
<span class="fc" id="L831">                            beacon.getServiceUuid(), beacon.getBluetoothName(),</span>
                            (Point3D) sourcePosition, sourceCovariance);
                }
            case WIFI_ACCESS_POINT:
            default:
<span class="fc" id="L836">                WifiAccessPoint accessPoint = (WifiAccessPoint)source;</span>
<span class="fc bfc" id="L837" title="All 2 branches covered.">                if (dims == Point2D.POINT2D_INHOMOGENEOUS_COORDINATES_LENGTH) {</span>
                    //2D

                    //noinspection unchecked
<span class="fc" id="L841">                    return (RadioSourceLocated&lt;P&gt;)new WifiAccessPointLocated2D(</span>
<span class="fc" id="L842">                            accessPoint.getBssid(), accessPoint.getFrequency(),</span>
<span class="fc" id="L843">                            accessPoint.getSsid(), (Point2D) sourcePosition,</span>
                            sourceCovariance);
                } else {
                    //3D

                    //noinspection unchecked
<span class="fc" id="L849">                    return (RadioSourceLocated&lt;P&gt;)new WifiAccessPointLocated3D(</span>
<span class="fc" id="L850">                            accessPoint.getBssid(), accessPoint.getFrequency(),</span>
<span class="fc" id="L851">                            accessPoint.getSsid(), (Point3D) sourcePosition,</span>
                            sourceCovariance);
                }
        }

    }

    /**
     * Builds data required to solve the problem.
     * This method takes into account current nearest fingerprints and discards those
     * readings belonging to radio sources not having enough data to be estimated.
     * @param allPowerDiffs list of received power differences of RSSI readings between a
     *                      located fingerprint and an unknown fingerprint for a given radio
     *                      source.
     * @param allFingerprintPositions positions of all located fingerprints being taken into
     *                                account.
     * @param allInitialSourcesPositions initial positions of all radio sources to be taken
     *                                   into account. If initial located sources where provided,
     *                                   their positions will be used, otherwise the centroid of
     *                                   all located fingerprints associated to a radio source will
     *                                   be used as initial position.
     * @param allSourcesToBeEstimated all radio sources that will be estimated.
     * @param allSourcesIndices indices indicating the position radio source being used
     *                          within the list of sources for current reading.
     * @param allPathLossExponents list of path loss exponents.
     * @param allStandardDeviations list of standard deviations for readings being used.
     * @param nearestFingerprintsCentroid centroid of nearest fingerprints being taken into account.
     */
    @SuppressWarnings(&quot;Duplicates&quot;)
    private void buildData(List&lt;Double&gt; allPowerDiffs,
                           List&lt;P&gt; allFingerprintPositions,
                           List&lt;P&gt; allInitialSourcesPositions,
                           List&lt;RadioSource&gt; allSourcesToBeEstimated,
                           List&lt;Integer&gt; allSourcesIndices,
                           List&lt;Double&gt; allPathLossExponents,
                           List&lt;Double&gt; allStandardDeviations,
                           P nearestFingerprintsCentroid) {

<span class="fc" id="L889">        int dims = getNumberOfDimensions();</span>
<span class="fc" id="L890">        int num = 0;</span>
<span class="fc" id="L891">        double[] centroidCoords = new double[dims];</span>
        for (RssiFingerprintLocated&lt;? extends RadioSource,
<span class="fc bfc" id="L893" title="All 2 branches covered.">                ? extends RssiReading&lt;? extends RadioSource&gt;, P&gt; fingerprint : mNearestFingerprints) {</span>
<span class="fc" id="L894">            P position = fingerprint.getPosition();</span>
<span class="pc bpc" id="L895" title="1 of 2 branches missed.">            if (position == null) {</span>
<span class="nc" id="L896">                continue;</span>
            }

<span class="fc bfc" id="L899" title="All 2 branches covered.">            for (int i = 0; i &lt; dims; i++) {</span>
<span class="fc" id="L900">                centroidCoords[i] += position.getInhomogeneousCoordinate(i);</span>
            }
<span class="fc" id="L902">            num++;</span>
<span class="fc" id="L903">        }</span>

<span class="fc bfc" id="L905" title="All 2 branches covered.">        for(int i = 0; i &lt; dims; i++) {</span>
<span class="fc" id="L906">            centroidCoords[i] /= (double)num;</span>
<span class="fc" id="L907">            nearestFingerprintsCentroid.setInhomogeneousCoordinate(i, centroidCoords[i]);</span>
        }

        //maps to keep cached in memory computed values to speed up computations
<span class="fc" id="L911">        HashMap&lt;RadioSource, Integer&gt; numReadingsMap = new HashMap&lt;&gt;();</span>
<span class="fc" id="L912">        HashMap&lt;RadioSource, P&gt; centroidsMap = new HashMap&lt;&gt;();</span>

        for (RssiFingerprintLocated&lt;RadioSource, RssiReading&lt;RadioSource&gt;, P&gt; locatedFingerprint :
<span class="fc bfc" id="L915" title="All 2 branches covered.">                mNearestFingerprints) {</span>

<span class="fc" id="L917">            List&lt;RssiReading&lt;RadioSource&gt;&gt; locatedReadings =</span>
<span class="fc" id="L918">                    locatedFingerprint.getReadings();</span>
<span class="pc bpc" id="L919" title="1 of 2 branches missed.">            if (locatedReadings == null) {</span>
<span class="nc" id="L920">                continue;</span>
            }

<span class="fc" id="L923">            P fingerprintPosition = locatedFingerprint.getPosition();</span>
<span class="fc" id="L924">            Matrix fingerprintPositionCovariance = locatedFingerprint.</span>
<span class="fc" id="L925">                    getPositionCovariance();</span>

<span class="fc bfc" id="L927" title="All 2 branches covered.">            for (RssiReading&lt;RadioSource&gt; locatedReading : locatedReadings) {</span>
<span class="fc" id="L928">                RadioSource source = locatedReading.getSource();</span>

                //obtain the total number of readings available for this source and
                //the centroid of all located fingerprints containing readings for
                //such source
                int numReadings;
<span class="fc bfc" id="L934" title="All 2 branches covered.">                if (!numReadingsMap.containsKey(source)) {</span>
<span class="fc" id="L935">                    numReadings = totalReadingsForSource(source, mNearestFingerprints, null);</span>
<span class="fc" id="L936">                    numReadingsMap.put(source, numReadings);</span>
                } else {
<span class="fc" id="L938">                    numReadings = numReadingsMap.get(source);</span>
                }

<span class="fc bfc" id="L941" title="All 2 branches covered.">                if (numReadings &lt; dims) {</span>
<span class="fc" id="L942">                    continue;</span>
                }

                P centroid;
<span class="fc bfc" id="L946" title="All 2 branches covered.">                if (!centroidsMap.containsKey(source)) {</span>
<span class="fc" id="L947">                    centroid = createPoint();</span>

                    //noinspection unchecked
<span class="fc" id="L950">                    totalReadingsForSource(source,</span>
                            (List&lt;RssiFingerprintLocated&lt;RadioSource, RssiReading&lt;RadioSource&gt;, P&gt;&gt;) mLocatedFingerprints,
                            centroid);

<span class="fc" id="L954">                    centroidsMap.put(source, centroid);</span>
                } else {
<span class="fc" id="L956">                    centroid = centroidsMap.get(source);</span>
                }

                //find within the list of located sources (if available) the source
                //of current located fingerprint
                @SuppressWarnings(&quot;SuspiciousMethodCalls&quot;)
<span class="fc bfc" id="L962" title="All 2 branches covered.">                int pos = mInitialLocatedSources != null ?</span>
<span class="fc" id="L963">                        mInitialLocatedSources.indexOf(source) : -1;</span>

<span class="fc" id="L965">                double pathLossExponent = mPathLossExponent;</span>
<span class="fc" id="L966">                Double pathLossExponentVariance = null;</span>
<span class="pc bpc" id="L967" title="1 of 4 branches missed.">                if (mUseSourcesPathLossExponentWhenAvailable &amp;&amp;</span>
                        source instanceof RadioSourceWithPower) {
<span class="fc" id="L969">                    RadioSourceWithPower sourceWithPower = (RadioSourceWithPower)source;</span>
<span class="fc" id="L970">                    pathLossExponent = sourceWithPower.getPathLossExponent();</span>
<span class="fc" id="L971">                    Double std = sourceWithPower.getPathLossExponentStandardDeviation();</span>
<span class="fc bfc" id="L972" title="All 2 branches covered.">                    pathLossExponentVariance = std != null ? std * std : null;</span>
                }


                P sourcePosition;
<span class="fc" id="L977">                Matrix sourcePositionCovariance = null;</span>
<span class="fc bfc" id="L978" title="All 2 branches covered.">                if (pos &lt; 0) {</span>
                    //located source is not available, so we use centroid
<span class="fc" id="L980">                    sourcePosition = centroid;</span>
                } else {
<span class="fc" id="L982">                    RadioSourceLocated&lt;P&gt; locatedSource = mInitialLocatedSources.get(pos);</span>
<span class="fc" id="L983">                    sourcePosition = locatedSource.getPosition();</span>

<span class="pc bpc" id="L985" title="1 of 6 branches missed.">                    if (mUseSourcesPathLossExponentWhenAvailable &amp;&amp;</span>
                            locatedSource instanceof RadioSourceWithPower &amp;&amp;
                            pathLossExponentVariance == null) {
<span class="fc" id="L988">                        RadioSourceWithPower locatedSourceWithPower =</span>
                                (RadioSourceWithPower)locatedSource;
<span class="fc" id="L990">                        pathLossExponent = locatedSourceWithPower.getPathLossExponent();</span>
<span class="fc" id="L991">                        Double std = locatedSourceWithPower.</span>
<span class="fc" id="L992">                                getPathLossExponentStandardDeviation();</span>
<span class="pc bpc" id="L993" title="1 of 2 branches missed.">                        pathLossExponentVariance = std != null ? std * std : null;</span>
                    }

<span class="fc" id="L996">                    sourcePositionCovariance = locatedSource.getPositionCovariance();</span>
                }

                int sourceIndex;
<span class="fc bfc" id="L1000" title="All 2 branches covered.">                if (!allSourcesToBeEstimated.contains(source)) {</span>
<span class="fc" id="L1001">                    sourceIndex = allSourcesToBeEstimated.size();</span>

<span class="fc" id="L1003">                    allSourcesToBeEstimated.add(source);</span>
<span class="fc" id="L1004">                    allInitialSourcesPositions.add(sourcePosition);</span>
                } else {
<span class="fc" id="L1006">                    sourceIndex = allSourcesToBeEstimated.indexOf(source);</span>
                }


<span class="fc" id="L1010">                double locatedRssi = locatedReading.getRssi();</span>

<span class="fc" id="L1012">                Double locatedRssiStd = locatedReading.getRssiStandardDeviation();</span>
<span class="fc bfc" id="L1013" title="All 2 branches covered.">                Double locatedRssiVariance = locatedRssiStd != null ?</span>
<span class="fc" id="L1014">                        locatedRssiStd * locatedRssiStd : null;</span>

<span class="fc" id="L1016">                List&lt;? extends RssiReading&lt;? extends RadioSource&gt;&gt; readings =</span>
<span class="fc" id="L1017">                        mFingerprint.getReadings();</span>
<span class="fc bfc" id="L1018" title="All 2 branches covered.">                for (RssiReading&lt;? extends RadioSource&gt; reading : readings) {</span>
<span class="pc bpc" id="L1019" title="1 of 2 branches missed.">                    if (reading.getSource() == null ||</span>
<span class="fc bfc" id="L1020" title="All 2 branches covered.">                            !reading.getSource().equals(source)) {</span>
<span class="fc" id="L1021">                        continue;</span>
                    }

                    //only take into account reading for matching sources on located
                    //and non-located readings
<span class="fc" id="L1026">                    double rssi = reading.getRssi();</span>

<span class="fc" id="L1028">                    double powerDiff = rssi - locatedRssi;</span>

<span class="fc" id="L1030">                    Double standardDeviation = null;</span>
<span class="pc bpc" id="L1031" title="5 of 6 branches missed.">                    if (mPropagatePathlossExponentStandardDeviation ||</span>
                            mPropagateFingerprintPositionCovariance ||
                            mPropagateRadioSourcePositionCovariance) {

                        //compute initial position
<span class="fc bfc" id="L1036" title="All 2 branches covered.">                        P initialPosition = mInitialPosition != null ?</span>
<span class="fc" id="L1037">                                mInitialPosition : nearestFingerprintsCentroid;</span>

<span class="fc" id="L1039">                        Double variance = propagateVariances(pathLossExponent,</span>
                                fingerprintPosition, sourcePosition, initialPosition,
<span class="pc bpc" id="L1041" title="1 of 2 branches missed.">                                mPropagatePathlossExponentStandardDeviation ? pathLossExponentVariance : null,</span>
<span class="pc bpc" id="L1042" title="1 of 2 branches missed.">                                mPropagateFingerprintPositionCovariance ? fingerprintPositionCovariance : null,</span>
<span class="pc bpc" id="L1043" title="1 of 2 branches missed.">                                mPropagateRadioSourcePositionCovariance ? sourcePositionCovariance : null);</span>
<span class="pc bpc" id="L1044" title="1 of 2 branches missed.">                        if (variance != null) {</span>
<span class="fc" id="L1045">                            standardDeviation = Math.sqrt(variance);</span>
                        }
                    }

<span class="pc bpc" id="L1049" title="1 of 2 branches missed.">                    if (standardDeviation == null) {</span>
<span class="nc" id="L1050">                        standardDeviation = reading.getRssiStandardDeviation();</span>
                    }

<span class="pc bpc" id="L1053" title="1 of 2 branches missed.">                    if (mPropagateFingerprintRssiStandardDeviation) {</span>
<span class="pc bpc" id="L1054" title="1 of 2 branches missed.">                        if (standardDeviation != null &amp;&amp;</span>
<span class="pc bpc" id="L1055" title="1 of 2 branches missed.">                                reading.getRssiStandardDeviation() != null){</span>
                            //consider propagated variance and reading variance independent, so we
                            //sum them both
<span class="nc" id="L1058">                            standardDeviation = standardDeviation * standardDeviation +</span>
<span class="nc" id="L1059">                                    reading.getRssiStandardDeviation() * reading.getRssiStandardDeviation();</span>
<span class="nc" id="L1060">                            standardDeviation = Math.sqrt(standardDeviation);</span>
                        }

<span class="pc bpc" id="L1063" title="1 of 4 branches missed.">                        if (locatedRssiVariance != null &amp;&amp; standardDeviation != null) {</span>
                            //consider propagated variance and located reading variance
                            //independent, so we sum them both
<span class="fc" id="L1066">                            standardDeviation = standardDeviation * standardDeviation +</span>
<span class="fc" id="L1067">                                    locatedRssiVariance;</span>
<span class="fc" id="L1068">                            standardDeviation = Math.sqrt(standardDeviation);</span>
                        }
                    }

<span class="pc bpc" id="L1072" title="1 of 4 branches missed.">                    if (standardDeviation == null || standardDeviation &lt; TINY) {</span>
<span class="fc" id="L1073">                        standardDeviation = mFallbackRssiStandardDeviation;</span>
                    }

<span class="fc" id="L1076">                    allPowerDiffs.add(powerDiff);</span>
<span class="fc" id="L1077">                    allFingerprintPositions.add(fingerprintPosition);</span>
<span class="fc" id="L1078">                    allSourcesIndices.add(sourceIndex);</span>
<span class="fc" id="L1079">                    allPathLossExponents.add(pathLossExponent);</span>
<span class="fc" id="L1080">                    allStandardDeviations.add(standardDeviation);</span>
<span class="fc" id="L1081">                }</span>
<span class="fc" id="L1082">            }</span>
<span class="fc" id="L1083">        }</span>
<span class="fc" id="L1084">    }</span>

    /**
     * Setups fitter to solve positions.
     * @return list of radio sources whose location will be estimated.
     * @throws FittingException if Levenberg-Marquardt fitting fails.
     */
    @SuppressWarnings(&quot;Duplicates&quot;)
    private List&lt;RadioSource&gt; setupFitter() throws FittingException {
        //build lists of data
<span class="fc" id="L1094">        final List&lt;Double&gt; allPowerDiffs = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L1095">        final List&lt;P&gt; allFingerprintPositions = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L1096">        final List&lt;P&gt; allInitialSourcesPositions = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L1097">        final List&lt;RadioSource&gt; allSourcesToBeEstimated = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L1098">        final List&lt;Integer&gt; allSourcesIndices = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L1099">        final List&lt;Double&gt; allPathLossExponents = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L1100">        final List&lt;Double&gt; allStandardDeviations = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L1101">        final P nearestFingerprintsCentroid = createPoint();</span>
<span class="fc" id="L1102">        buildData(allPowerDiffs, allFingerprintPositions, allInitialSourcesPositions,</span>
                allSourcesToBeEstimated, allSourcesIndices, allPathLossExponents,
                allStandardDeviations, nearestFingerprintsCentroid);

<span class="fc" id="L1106">        final int totalReadings = allPowerDiffs.size();</span>
<span class="fc" id="L1107">        final int totalSources = allSourcesToBeEstimated.size();</span>
<span class="fc" id="L1108">        final int dims = getNumberOfDimensions();</span>
<span class="fc" id="L1109">        final int n = 1 + dims;</span>

<span class="fc" id="L1111">        mFitter.setFunctionEvaluator(new LevenbergMarquardtMultiDimensionFunctionEvaluator() {</span>
            @Override
            public int getNumberOfDimensions() {
<span class="fc" id="L1114">                return n;</span>
            }

            @Override
            public double[] createInitialParametersArray() {
<span class="fc" id="L1119">                double[] initial = new double[dims * (totalSources + 1)];</span>

<span class="fc bfc" id="L1121" title="All 2 branches covered.">                if (mInitialPosition == null) {</span>
                    //use centroid of nearest fingerprints as initial value
<span class="fc bfc" id="L1123" title="All 2 branches covered.">                    for (int i = 0; i &lt; dims; i++) {</span>
<span class="fc" id="L1124">                        initial[i] = nearestFingerprintsCentroid.getInhomogeneousCoordinate(i);</span>
                    }
                } else {
                    //use provided initial position
<span class="fc bfc" id="L1128" title="All 2 branches covered.">                    for(int i = 0; i &lt; dims; i++) {</span>
<span class="fc" id="L1129">                        initial[i] = mInitialPosition.getInhomogeneousCoordinate(i);</span>
                    }
                }

<span class="fc" id="L1133">                int pos = dims;</span>
<span class="fc bfc" id="L1134" title="All 2 branches covered.">                for (int j = 0; j &lt; totalSources; j++) {</span>
<span class="fc" id="L1135">                    P initialSourcePosition = allInitialSourcesPositions.get(j);</span>
<span class="fc bfc" id="L1136" title="All 2 branches covered.">                    for (int i = 0; i &lt; dims; i++) {</span>
<span class="fc" id="L1137">                        initial[pos] = initialSourcePosition.</span>
<span class="fc" id="L1138">                                getInhomogeneousCoordinate(i);</span>
<span class="fc" id="L1139">                        pos++;</span>
                    }
                }

<span class="fc" id="L1143">                return initial;</span>
            }

            @Override
            public double evaluate(int i, double[] point, double[] params, double[] derivatives) {

                //For 2D:
                //-------

                //Prdiff1a = Pr(pi) - Pr(p1) = 5*n*log(d1a^2) - 5*n*log(dia^2) =
                //  = 5*n*log((x1 - xa)^2 + (y1 - ya)^2) - 5*n*log((xi - xa)^2 + (yi - ya)^2)

                //derivatives respect parameters being estimated (xi,yi,xa,ya...,xM,yM)
                //for unknown point pi = (xi, yi)
                //diff(Prdiff1a)/diff(xi) = -5*n/(log(10)*((xi - xa)^2 + (yi - ya)^2))*2*(xi - xa)
                //  = -10*n*(xi - xa)/(log(10)*((xi - xa)^2 + (yi - ya)^2))
                //  = -10*n*(xi - xa)/(log(10)*dia^2)

                //diff(Prdiff1a)/diff(yi) = -5*n/(log(10)*((xi - xa)^2 + (yi - ya)^2))*2*(yi - ya)
                //  = -10*n*(yi - ya)/(log(10)*((xi - xa)^2 + (yi - ya)^2))
                //  = -10*n*(yi - ya)/(log(10)*dia^2)

                //for same radio source pa=(xa,ya)
                //diff(Prdiff1a)/diff(xa) = 5*n/(log(10)*((x1 - xa)^2 + (y1 - ya)^2))*-2*(x1 - xa) -5*n/(log(10)*((xi - xa)^2 + (yi - ya)^2))*-2*(xi - xa) =
                //  = -10*n*(x1 - xa)/(log(10)*((x1 - xa)^2 + (y1 - ya)^2)) + 10*n*(xi - xa)/(log(10)*((xi - xa)^2 + (yi - ya)^2))
                //  = 10*n*(-(x1 - xa)/(log(10)*d1a^2) + (xi - xa)/(log(10)*dia^2))

                //diff(Prdiff1a)/diff(ya) = 5*n/(log(10)*((x1 - xa)^2 + (y1 - ya)^2))*-2*(y1 - ya) -5*n/(log(10)*((xi - xa)^2 + (yi - ya)^2))*-2*(yi - ya) =
                //  = -10*n*(y1 - ya)/(log(10)*((x1 - xa)^2 + (y1 - ya)^2)) + 10*n*(yi - ya)/(log(10)*((xi - xa)^2 + (yi - ya)^2))
                //  = 10*n*(-(y1 - ya)/(log(10)*d1a^2) + (xi - xa)/(log(10)*dia^2))

                //for other radio source pb=(xb,yb)
                //diff(Prdiff1a)/diff(xb) = diff(Prdiff1a)/diff(yb) = 0

                //For 3D:
                //-------

                //Prdiff1a = Pr(pi) - Pr(p1) = 5*n*log(d1a^2) - 5*n*log(dia^2) =
                //  = 5*n*log((x1 - xa)^2 + (y1 - ya)^2 + (z1 - za)^2) - 5*n*log((xi - xa)^2 + (yi - ya)^2 + (zi - za)^2)

                //derivatives respect parameters being estimated (xi,yi,zi,xa,ya,za...,xM,yM,zM)
                //for unknown point pi = (xi, yi,zi)
                //diff(Prdiff1a)/diff(xi) = -5*n/(log(10)*((xi - xa)^2 + (yi - ya)^2 + (zi - za)^2))*2*(xi - xa)
                //  = -10*n*(xi - xa)/(log(10)*((xi - xa)^2 + (yi - ya)^2) + (zi - za)^2))
                //  = -10*n*(xi - xa)/(log(10)*dia^2)

                //diff(Prdiff1a)/diff(yi) = -5*n/(log(10)*((xi - xa)^2 + (yi - ya)^2 + (zi - za)^2))*2*(yi - ya)
                //  = -10*n*(yi - ya)/(log(10)*((xi - xa)^2 + (yi - ya)^2 + (zi - za)^2))
                //  = -10*n*(yi - ya)/(log(10)*dia^2)

                //diff(Prdiff1a)/diff(zi) = -5*n/(log(10)*((xi - xa)^2 + (yi - ya)^2 + (zi - za)^2))*2*(zi - za)
                //  = -10*n*(zi - za)/(log(10)*((xi - xa)^2 + (yi - ya)^2 + (zi - za)^2))
                //  = -10*n*(zi - za)/(log(10)*dia^2)

                //for same radio source pa=(xa,ya)
                //diff(Prdiff1a)/diff(xa) = 5*n/(log(10)*((x1 - xa)^2 + (y1 - ya)^2 + (z1 - za)^2))*-2*(x1 - xa) -5*n/(log(10)*((xi - xa)^2 + (yi - ya)^2 + (zi - za)^2))*-2*(xi - xa) =
                //  = -10*n*(x1 - xa)/(log(10)*((x1 - xa)^2 + (y1 - ya)^2 + (z1 - za)^2)) + 10*n*(xi - xa)/(log(10)*((xi - xa)^2 + (yi - ya)^2 + (zi - za)^2)) =
                //  = 10*n*(-(x1 -xa)/(log(10)*d1a^2) + (xi - xa)/(log(10)*dia^2))

                //diff(Prdiff1a)/diff(ya) = 5*n/(log(10)*((x1 - xa)^2 + (y1 - ya)^2 + (z1 - za)^2))*-2*(y1 - ya) -5*n/(log(10)*((xi - xa)^2 + (yi - ya)^2 + (zi - za)^2))*-2*(yi - ya) =
                //  = -10*n*(y1 - ya)/(log(10)*((x1 - xa)^2 + (y1 - ya)^2 + (z1 - za)^2)) + 10*n*(yi - ya)/(log(10)*((xi - xa)^2 + (yi - ya)^2 + (zi - za)^2)) =
                //  = 10*n(-(y1 - ya)/(log(10)*d1a^2) + (xi - xa)/(log(10)*dia^2))

                //diff(Prdiff1a)/diff(za) = 5*n/(log(10)*((x1 - xa)^2 + (y1 - ya)^2 + (z1 - za)^2))*-2*(z1 - za) -5*n/(log(10)*((xi - xa)^2 + (yi - ya)^2 + (zi - za)^2))*-2*(zi - za) =
                //  = -10*n*(z1 - za)/(log(10)*((x1 - xa)^2 + (y1 - ya)^2 + (z1 - za)^2)) + 10*n*(zi - za)/(log(10)*((xi - xa)^2 + (yi - ya)^2 + (zi - za)^2)) =
                //  = 10*n(-(z1 - za)/(log(10)*d1a^2) + (zi - za)/(log(10)*dia^2))

                //for other radio source pb=(xb,yb)
                //diff(Prdiff1a)/diff(xb) = diff(Prdiff1a)/diff(yb) = 0

<span class="fc" id="L1213">                int dims = NonLinearFingerprintPositionAndRadioSourceEstimator.this.</span>
<span class="fc" id="L1214">                        getNumberOfDimensions();</span>

                //path loss exponent
<span class="fc" id="L1217">                double n = point[0];</span>

<span class="fc" id="L1219">                double ln10 = Math.log(10.0);</span>

<span class="fc" id="L1221">                int sourceIndex = allSourcesIndices.get(i);</span>
<span class="fc" id="L1222">                int start = dims * (1 + sourceIndex);</span>

                //d1a^2, d2a^2, ...
<span class="fc" id="L1225">                double distanceFingerprint2 = 0.0;</span>

                //dia^2, dib^2, ...
<span class="fc" id="L1228">                double distancePoint2 = 0.0;</span>
<span class="fc bfc" id="L1229" title="All 2 branches covered.">                for (int j = 0; j &lt; dims; j++) {</span>
                    //fingerprint coordinate p1=(x1,y1,z1), ...
<span class="fc" id="L1231">                    double fingerprintCoord = point[1 + j];</span>

                    //unknown point &quot;pi&quot; coordinate
<span class="fc" id="L1234">                    double pointCoord = params[j];</span>

                    //radio source coordinate pa=(xa,ya,za), ...
<span class="fc" id="L1237">                    double sourceCoord = params[start + j];</span>

                    //x1 - xa, y1 - ya, ...
<span class="fc" id="L1240">                    double diffFingerprint = fingerprintCoord - sourceCoord;</span>

                    //xi - xa, yi - ya, ...
<span class="fc" id="L1243">                    double diffPoint = pointCoord - sourceCoord;</span>

<span class="fc" id="L1245">                    double diffFingerprint2 = diffFingerprint * diffFingerprint;</span>
<span class="fc" id="L1246">                    double diffPoint2 = diffPoint * diffPoint;</span>

<span class="fc" id="L1248">                    distanceFingerprint2 += diffFingerprint2;</span>
<span class="fc" id="L1249">                    distancePoint2 += diffPoint2;</span>
                }

<span class="fc" id="L1252">                distanceFingerprint2 = Math.max(distanceFingerprint2, TINY);</span>
<span class="fc" id="L1253">                distancePoint2 = Math.max(distancePoint2, TINY);</span>

<span class="fc" id="L1255">                double result = 5*n*(Math.log10(distanceFingerprint2) -</span>
<span class="fc" id="L1256">                        Math.log10(distancePoint2));</span>


                //we clear derivatives array to ensure that derivatives respect other
                //radio sources are zero
<span class="fc" id="L1261">                Arrays.fill(derivatives, 0.0);</span>

<span class="fc bfc" id="L1263" title="All 2 branches covered.">                for(int j = 0; j &lt; dims; j++) {</span>
                    //fingerprint coordinate p1=(x1,y1,z1), ...
<span class="fc" id="L1265">                    double fingerprintCoord = point[1 + j];</span>

                    //unknown point &quot;pi&quot; coordinate
<span class="fc" id="L1268">                    double pointCoord = params[j];</span>

                    //radio source coordinate pa=(xa,ya,za), ...
<span class="fc" id="L1271">                    double sourceCoord = params[start + j];</span>

                    //x1 - xa, y1 - ya, ...
<span class="fc" id="L1274">                    double diffFingerprint = fingerprintCoord - sourceCoord;</span>

                    //xi - xa, yi - ya, ...
<span class="fc" id="L1277">                    double diffPoint = pointCoord - sourceCoord;</span>


                    //Example: diff(Prdiff1a)/diff(xi) =  -10*n*(xi - xa)/(log(10)*dia^2)
<span class="fc" id="L1281">                    double derivativePointCoord = -10.0 * n * diffPoint / (ln10 * distancePoint2);</span>

                    //Example: diff(Prdiff1a)/diff(xa) = 10*n*(-(x1 - xa)/(log(10)*d1a^2) + (xi - xa)/(log(10)*dia^2)) =
                    //  -10*n*(x1 - xa)/(log(10)*d1a^2) - diff(Prdiff1a)/diff(xi)
<span class="fc" id="L1285">                    double derivativeSameRadioSourceCoord =</span>
                            -10.0 * n * diffFingerprint / (ln10 * distanceFingerprint2)
                            - derivativePointCoord;

                    //derivatives respect point pi = (xi, yi, zi)
<span class="fc" id="L1290">                    derivatives[j] = derivativePointCoord;</span>

                    //derivatives respect same radio source pa = (xa, ya, za)
<span class="fc" id="L1293">                    derivatives[dims * (1 + sourceIndex) + j] = derivativeSameRadioSourceCoord;</span>
                }

<span class="fc" id="L1296">                return result;</span>
            }
        });

        try {
            //In 2D we know that for fingerprint &quot;1&quot; and radio source &quot;a&quot;:
            //Prdiff1a = Pr(pi) - Pr(p1) = 5*n*log(d1a^2) - 5*n*log(dia^2) =
            //  = 5*n*log((x1 - xa)^2 + (y1 - ya)^2) - 5*n*log((xi - xa)^2 + (yi - ya)^2)

            //Therefore x must have 1 + dims columns (for path-loss n and fingerprint position (x1,y1)

<span class="fc" id="L1307">            Matrix x = new Matrix(totalReadings, n);</span>
<span class="fc" id="L1308">            double[] y = new double[totalReadings];</span>
<span class="fc" id="L1309">            double[] standardDeviations = new double[totalReadings];</span>
<span class="fc bfc" id="L1310" title="All 2 branches covered.">            for (int i = 0; i &lt; totalReadings; i++) {</span>
                //path loss exponent
<span class="fc" id="L1312">                x.setElementAt(i, 0, allPathLossExponents.get(i));</span>

<span class="fc" id="L1314">                P fingerprintPosition = allFingerprintPositions.get(i);</span>
<span class="fc" id="L1315">                int col = 1;</span>
<span class="fc bfc" id="L1316" title="All 2 branches covered.">                for (int j = 0; j &lt; dims; j++) {</span>
<span class="fc" id="L1317">                    x.setElementAt(i, col,</span>
<span class="fc" id="L1318">                            fingerprintPosition.getInhomogeneousCoordinate(j));</span>
<span class="fc" id="L1319">                    col++;</span>
                }

<span class="fc" id="L1322">                y[i] = allPowerDiffs.get(i);</span>

<span class="fc" id="L1324">                standardDeviations[i] = allStandardDeviations.get(i);</span>
            }

<span class="fc" id="L1327">            mFitter.setInputData(x, y, standardDeviations);</span>

<span class="fc" id="L1329">            return allSourcesToBeEstimated;</span>
<span class="fc" id="L1330">        } catch (AlgebraException e) {</span>
<span class="fc" id="L1331">            throw new FittingException(e);</span>
        }
    }

    /**
     * Gets the total number of readings associated to provided radio source.
     * This method uses only current nearest fingerprints.
     * @param source radio source to be checked
     * @param centroid centroid to be computed.
     * @param fingerprints fingerprints where search is made.
     * @return total number of readings associated to provided radio source.
     */
    private int totalReadingsForSource(RadioSource source,
            List&lt;RssiFingerprintLocated&lt;RadioSource, RssiReading&lt;RadioSource&gt;, P&gt;&gt; fingerprints,
            P centroid) {
<span class="pc bpc" id="L1346" title="1 of 2 branches missed.">        if (source == null) {</span>
<span class="nc" id="L1347">            return 0;</span>
        }

<span class="fc" id="L1350">        int dims = getNumberOfDimensions();</span>

<span class="fc" id="L1352">        int result = 0;</span>
<span class="fc bfc" id="L1353" title="All 2 branches covered.">        double[] centroidCoords = centroid != null ?</span>
<span class="fc" id="L1354">                new double[dims] : null;</span>

<span class="fc bfc" id="L1356" title="All 2 branches covered.">        for (RssiFingerprintLocated&lt;RadioSource, RssiReading&lt;RadioSource&gt;, P&gt; fingerprint : fingerprints) {</span>
<span class="fc" id="L1357">            List&lt;RssiReading&lt;RadioSource&gt;&gt; readings = fingerprint.getReadings();</span>
<span class="pc bpc" id="L1358" title="1 of 2 branches missed.">            if (readings == null) {</span>
<span class="nc" id="L1359">                continue;</span>
            }

<span class="fc" id="L1362">            P fingerprintPosition = fingerprint.getPosition();</span>

<span class="fc bfc" id="L1364" title="All 2 branches covered.">            for(RssiReading&lt;RadioSource&gt; reading : readings) {</span>
<span class="fc" id="L1365">                RadioSource readingSource = reading.getSource();</span>
<span class="pc bpc" id="L1366" title="1 of 4 branches missed.">                if (readingSource != null &amp;&amp; readingSource.equals(source)) {</span>
<span class="fc" id="L1367">                    result++;</span>

<span class="fc bfc" id="L1369" title="All 2 branches covered.">                    if (centroid != null) {</span>
<span class="fc bfc" id="L1370" title="All 2 branches covered.">                        for (int i = 0; i &lt; dims; i++) {</span>
<span class="fc" id="L1371">                            double coord = fingerprintPosition.getInhomogeneousCoordinate(i);</span>
<span class="fc" id="L1372">                            centroidCoords[i] += coord;</span>
                        }
                    }
                }
<span class="fc" id="L1376">            }</span>
<span class="fc" id="L1377">        }</span>

<span class="fc bfc" id="L1379" title="All 2 branches covered.">        if (centroid != null) {</span>
<span class="fc bfc" id="L1380" title="All 2 branches covered.">            for (int i = 0; i &lt; dims; i++) {</span>
<span class="fc" id="L1381">                centroidCoords[i] /= (double) result;</span>
<span class="fc" id="L1382">                centroid.setInhomogeneousCoordinate(i, centroidCoords[i]);</span>
            }
        }

<span class="fc" id="L1386">        return result;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>