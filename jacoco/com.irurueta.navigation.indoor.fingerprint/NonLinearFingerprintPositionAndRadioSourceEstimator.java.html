<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>NonLinearFingerprintPositionAndRadioSourceEstimator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.irurueta:irurueta-navigation</a> &gt; <a href="index.source.html" class="el_package">com.irurueta.navigation.indoor.fingerprint</a> &gt; <span class="el_source">NonLinearFingerprintPositionAndRadioSourceEstimator.java</span></div><h1>NonLinearFingerprintPositionAndRadioSourceEstimator.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2019 Alberto Irurueta Carro (alberto@irurueta.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.irurueta.navigation.indoor.fingerprint;

import com.irurueta.algebra.AlgebraException;
import com.irurueta.algebra.Matrix;
import com.irurueta.geometry.Point;
import com.irurueta.geometry.Point2D;
import com.irurueta.geometry.Point3D;
import com.irurueta.navigation.LockedException;
import com.irurueta.navigation.NotReadyException;
import com.irurueta.navigation.indoor.*;
import com.irurueta.numerical.NumericalException;
import com.irurueta.numerical.fitting.FittingException;
import com.irurueta.numerical.fitting.LevenbergMarquardtMultiDimensionFitter;
import com.irurueta.numerical.fitting.LevenbergMarquardtMultiDimensionFunctionEvaluator;

import java.util.*;

/**
 * Base class for position and radio source estimators based only on located
 * fingerprints containing RSSI readings.
 * All implementations of this class estimate the position of a new fingerprint
 * and the position of all radio sources associated to fingerprints whose location
 * is known.
 * All implementations solve the problem in a non linear way using Levenberg-Marquardt
 * algorithm.
 */
@SuppressWarnings(&quot;WeakerAccess&quot;)
public abstract class NonLinearFingerprintPositionAndRadioSourceEstimator&lt;P extends Point&lt;?&gt;&gt; extends
        FingerprintPositionAndRadioSourceEstimator&lt;P&gt; {

    /**
     * Default RSSI standard deviation assumed for provided fingerprints as a fallback
     * when none can be determined.
     */
    public static final double FALLBACK_RSSI_STANDARD_DEVIATION = 1e-3;

    /**
     * Indicates that by default measured RSSI standard deviation of closest fingerprint
     * must be propagated into measured RSSI reading variance at unknown location.
     */
    public static final boolean DEFAULT_PROPAGATE_FINGERPRINT_RSSI_STANDARD_DEVIATION = true;

    /**
     * Indicates that by default path-loss exponent standard deviation of radio source
     * must be propagated into measured RSSI reading variance at unknown location.
     */
    public static final boolean DEFAULT_PROPAGATE_PATHLOSS_EXPONENT_STANDARD_DEVIATION = true;

    /**
     * Indicates that by default covariance of closest fingerprint position must be
     * propagated into measured RSSI reading variance at unknown location.
     */
    public static final boolean DEFAULT_PROPAGATE_FINGERPRINT_POSITION_COVARIANCE = true;

    /**
     * Indicates that by default covariance of radio source position must be propagated
     * into measured RSSI reading variance at unknown location.
     */
    public static final boolean DEFAULT_PROPAGATE_RADIO_SOURCE_POSITION_COVARIANCE = true;

    /**
     * Small value to be used as machine precision.
     */
    private static final double TINY = 1e-12;

    /**
     * Initial sources whose location is known.
     * If provided, their location will be used as initial values, but
     * after executing this estimator they will be refined.
     */
    protected List&lt;? extends RadioSourceLocated&lt;P&gt;&gt; mInitialLocatedSources;

    /**
     * Initial position to start the estimation.
     * This should be a value close to the expected solution.
     * If no value is provided, the average position among all selected nearest
     * located fingerprints will be used.
     */
    private P mInitialPosition;

    /**
     * Indicates whether path loss exponent of provided sources must be used when
     * available (if true), or if fallback path loss exponent must be used instead.
     */
<span class="fc" id="L100">    protected boolean mUseSourcesPathLossExponentWhenAvailable = true;</span>

    /**
     * RSSI standard deviation fallback value to use when none can be
     * determined from provided readings. This fallback value is only used if
     * no variance is propagated or the resulting value is too small to allow
     * convergence to a solution.
     */
<span class="fc" id="L108">    private double mFallbackRssiStandardDeviation =</span>
            FALLBACK_RSSI_STANDARD_DEVIATION;

    /**
     * Indicates whether measured RSSI standard deviation of closest fingerprint must
     * be propagated into measured RSSI reading variance at unknown location.
     */
<span class="fc" id="L115">    private boolean mPropagateFingerprintRssiStandardDeviation =</span>
            DEFAULT_PROPAGATE_FINGERPRINT_RSSI_STANDARD_DEVIATION;

    /**
     * Indicates whether path-loss exponent standard deviation of radio source must
     * be propagated into measured RSSI reading variance at unknown location.
     */
<span class="fc" id="L122">    private boolean mPropagatePathlossExponentStandardDeviation =</span>
            DEFAULT_PROPAGATE_PATHLOSS_EXPONENT_STANDARD_DEVIATION;

    /**
     * Indicates whether covariance of closest fingerprint position must be
     * propagated into measured RSSI reading variance at unknown location.
     */
<span class="fc" id="L129">    private boolean mPropagateFingerprintPositionCovariance =</span>
            DEFAULT_PROPAGATE_FINGERPRINT_POSITION_COVARIANCE;

    /**
     * Indicates whether covariance of radio source position must be propagated
     * into measured RSSI reading variance at unknown location.
     */
<span class="fc" id="L136">    private boolean mPropagateRadioSourcePositionCovariance =</span>
            DEFAULT_PROPAGATE_RADIO_SOURCE_POSITION_COVARIANCE;

    /**
     * Levenberg-Marquardt fitter to find a non-linear solution.
     */
<span class="fc" id="L142">    private final LevenbergMarquardtMultiDimensionFitter mFitter = new LevenbergMarquardtMultiDimensionFitter();</span>

    /**
     * Estimated covariance matrix for estimated non-located fingerprint position and
     * estimated located radio sources position.
     */
    private Matrix mCovariance;

    /**
     * Covariance of estimated position for non-located fingerprint.
     */
    private Matrix mEstimatedPositionCovariance;

    /**
     * Estimated chi square value.
     */
    private double mChiSq;

    /**
     * Constructor.
     */
<span class="fc" id="L163">    public NonLinearFingerprintPositionAndRadioSourceEstimator() {</span>
<span class="fc" id="L164">    }</span>

    /**
     * Constructor.
     *
     * @param listener listener in charge of handling events.
     */
    public NonLinearFingerprintPositionAndRadioSourceEstimator(
            final FingerprintPositionAndRadioSourceEstimatorListener&lt;P&gt; listener) {
<span class="fc" id="L173">        super(listener);</span>
<span class="fc" id="L174">    }</span>

    /**
     * Constructor.
     *
     * @param locatedFingerprints located fingerprints containing RSSI readings.
     * @param fingerprint         fingerprint containing readings at an unknown location
     *                            for provided located fingerprints.
     * @throws IllegalArgumentException if either non located fingerprint or located
     *                                  fingerprints are null.
     */
    public NonLinearFingerprintPositionAndRadioSourceEstimator(
            final List&lt;? extends RssiFingerprintLocated&lt;? extends RadioSource,
                    ? extends RssiReading&lt;? extends RadioSource&gt;, P&gt;&gt; locatedFingerprints,
            final RssiFingerprint&lt;? extends RadioSource,
                    ? extends RssiReading&lt;? extends RadioSource&gt;&gt; fingerprint) {
<span class="fc" id="L190">        super(locatedFingerprints, fingerprint);</span>
<span class="fc" id="L191">    }</span>

    /**
     * Constructor.
     *
     * @param locatedFingerprints located fingerprints containing RSSI readings.
     * @param fingerprint         fingerprint containing readings at an unknown location
     *                            for provided located fingerprints.
     * @param listener            listener in charge of handling events.
     * @throws IllegalArgumentException if either non located fingerprint or located
     *                                  fingerprints are null.
     */
    public NonLinearFingerprintPositionAndRadioSourceEstimator(
            final List&lt;? extends RssiFingerprintLocated&lt;? extends RadioSource,
                    ? extends RssiReading&lt;? extends RadioSource&gt;, P&gt;&gt; locatedFingerprints,
            final RssiFingerprint&lt;? extends RadioSource,
                    ? extends RssiReading&lt;? extends RadioSource&gt;&gt; fingerprint,
            final FingerprintPositionAndRadioSourceEstimatorListener&lt;P&gt; listener) {
<span class="fc" id="L209">        super(locatedFingerprints, fingerprint, listener);</span>
<span class="fc" id="L210">    }</span>

    /**
     * Constructor.
     *
     * @param locatedFingerprints located fingerprints containing RSSI readings.
     * @param fingerprint         fingerprint containing readings at an unknown location
     *                            for provided located fingerprints.
     * @param initialPosition     initial position to be assumed on non located fingerprint or
     *                            null if unknown.
     * @throws IllegalArgumentException if either non located fingerprint or located
     *                                  fingerprints are null.
     */
    public NonLinearFingerprintPositionAndRadioSourceEstimator(
            final List&lt;? extends RssiFingerprintLocated&lt;? extends RadioSource,
                    ? extends RssiReading&lt;? extends RadioSource&gt;, P&gt;&gt; locatedFingerprints,
            final RssiFingerprint&lt;? extends RadioSource,
                    ? extends RssiReading&lt;? extends RadioSource&gt;&gt; fingerprint,
            final P initialPosition) {
<span class="fc" id="L229">        super(locatedFingerprints, fingerprint);</span>
<span class="fc" id="L230">        mInitialPosition = initialPosition;</span>
<span class="fc" id="L231">    }</span>

    /**
     * Constructor.
     *
     * @param locatedFingerprints located fingerprints containing RSSI readings.
     * @param fingerprint         fingerprint containing readings at an unknown location
     *                            for provided located fingerprints.
     * @param initialPosition     initial position to be assumed on non located fingerprint or
     *                            null if unknown.
     * @param listener            listener in charge of handling events.
     * @throws IllegalArgumentException if either non located fingerprint or located
     *                                  fingerprints are null.
     */
    public NonLinearFingerprintPositionAndRadioSourceEstimator(
            final List&lt;? extends RssiFingerprintLocated&lt;? extends RadioSource,
                    ? extends RssiReading&lt;? extends RadioSource&gt;, P&gt;&gt; locatedFingerprints,
            final RssiFingerprint&lt;? extends RadioSource,
                    ? extends RssiReading&lt;? extends RadioSource&gt;&gt; fingerprint,
            final P initialPosition,
            final FingerprintPositionAndRadioSourceEstimatorListener&lt;P&gt; listener) {
<span class="fc" id="L252">        super(locatedFingerprints, fingerprint, listener);</span>
<span class="fc" id="L253">        mInitialPosition = initialPosition;</span>
<span class="fc" id="L254">    }</span>

    /**
     * Constructor.
     *
     * @param locatedFingerprints   located fingerprints containing RSSI readings.
     * @param fingerprint           fingerprint containing readings at an unknown location
     *                              for provided located fingerprints.
     * @param initialLocatedSources sources containing initial location to be refined or null
     *                              if unknown.
     * @throws IllegalArgumentException if either non located fingerprint or located
     *                                  fingerprints are null.
     */
    public NonLinearFingerprintPositionAndRadioSourceEstimator(
            final List&lt;? extends RssiFingerprintLocated&lt;? extends RadioSource,
                    ? extends RssiReading&lt;? extends RadioSource&gt;, P&gt;&gt; locatedFingerprints,
            final RssiFingerprint&lt;? extends RadioSource,
                    ? extends RssiReading&lt;? extends RadioSource&gt;&gt; fingerprint,
            final List&lt;? extends RadioSourceLocated&lt;P&gt;&gt; initialLocatedSources) {
<span class="fc" id="L273">        super(locatedFingerprints, fingerprint);</span>
<span class="fc" id="L274">        mInitialLocatedSources = initialLocatedSources;</span>
<span class="fc" id="L275">    }</span>

    /**
     * Constructor.
     *
     * @param locatedFingerprints   located fingerprints containing RSSI readings.
     * @param fingerprint           fingerprint containing readings at an unknown location
     *                              for provided located fingerprints.
     * @param initialLocatedSources sources containing initial location to be refined or null
     *                              if unknown.
     * @param listener              listener in charge of handling events.
     * @throws IllegalArgumentException if either non located fingerprint or located
     *                                  fingerprints are null.
     */
    public NonLinearFingerprintPositionAndRadioSourceEstimator(
            final List&lt;? extends RssiFingerprintLocated&lt;? extends RadioSource,
                    ? extends RssiReading&lt;? extends RadioSource&gt;, P&gt;&gt; locatedFingerprints,
            final RssiFingerprint&lt;? extends RadioSource,
                    ? extends RssiReading&lt;? extends RadioSource&gt;&gt; fingerprint,
            final List&lt;? extends RadioSourceLocated&lt;P&gt;&gt; initialLocatedSources,
            final FingerprintPositionAndRadioSourceEstimatorListener&lt;P&gt; listener) {
<span class="fc" id="L296">        super(locatedFingerprints, fingerprint, listener);</span>
<span class="fc" id="L297">        mInitialLocatedSources = initialLocatedSources;</span>
<span class="fc" id="L298">    }</span>

    /**
     * Constructor.
     *
     * @param locatedFingerprints   located fingerprints containing RSSI readings.
     * @param fingerprint           fingerprint containing readings at an unknown location
     *                              for provided located fingerprints.
     * @param initialPosition       initial position to be assumed on non located fingerprint or
     *                              null if unknown.
     * @param initialLocatedSources sources containing initial location to be refined or null
     *                              if unknown.
     * @throws IllegalArgumentException if either non located fingerprint or located
     *                                  fingerprints are null.
     */
    public NonLinearFingerprintPositionAndRadioSourceEstimator(
            final List&lt;? extends RssiFingerprintLocated&lt;? extends RadioSource,
                    ? extends RssiReading&lt;? extends RadioSource&gt;, P&gt;&gt; locatedFingerprints,
            final RssiFingerprint&lt;? extends RadioSource,
                    ? extends RssiReading&lt;? extends RadioSource&gt;&gt; fingerprint,
            final P initialPosition,
            final List&lt;? extends RadioSourceLocated&lt;P&gt;&gt; initialLocatedSources) {
<span class="fc" id="L320">        this(locatedFingerprints, fingerprint, initialPosition);</span>
<span class="fc" id="L321">        mInitialLocatedSources = initialLocatedSources;</span>
<span class="fc" id="L322">    }</span>

    /**
     * Constructor.
     *
     * @param locatedFingerprints   located fingerprints containing RSSI readings.
     * @param fingerprint           fingerprint containing readings at an unknown location
     *                              for provided located fingerprints.
     * @param initialPosition       initial position to be assumed on non located fingerprint or
     *                              null if unknown.
     * @param initialLocatedSources sources containing initial location to be refined or null
     *                              if unknown.
     * @param listener              listener in charge of handling events.
     * @throws IllegalArgumentException if either non located fingerprint or located
     *                                  fingerprints are null.
     */
    public NonLinearFingerprintPositionAndRadioSourceEstimator(
            final List&lt;? extends RssiFingerprintLocated&lt;? extends RadioSource,
                    ? extends RssiReading&lt;? extends RadioSource&gt;, P&gt;&gt; locatedFingerprints,
            final RssiFingerprint&lt;? extends RadioSource,
                    ? extends RssiReading&lt;? extends RadioSource&gt;&gt; fingerprint,
            final P initialPosition,
            final List&lt;? extends RadioSourceLocated&lt;P&gt;&gt; initialLocatedSources,
            final FingerprintPositionAndRadioSourceEstimatorListener&lt;P&gt; listener) {
<span class="fc" id="L346">        this(locatedFingerprints, fingerprint, initialPosition, listener);</span>
<span class="fc" id="L347">        mInitialLocatedSources = initialLocatedSources;</span>
<span class="fc" id="L348">    }</span>

    /**
     * Gets initial radio sources whose location is known.
     *
     * @return initial radio sources.
     */
    public List&lt;? extends RadioSourceLocated&lt;P&gt;&gt; getInitialLocatedSources() {
<span class="fc" id="L356">        return mInitialLocatedSources;</span>
    }

    /**
     * Sets initial radio sources whose location is known.
     *
     * @param initialLocatedSources initial radio sources.
     * @throws LockedException if estimator is locked.
     */
    public void setInitialLocatedSources(
            final List&lt;? extends RadioSourceLocated&lt;P&gt;&gt; initialLocatedSources)
            throws LockedException {
<span class="fc bfc" id="L368" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L369">            throw new LockedException();</span>
        }

<span class="fc" id="L372">        mInitialLocatedSources = initialLocatedSources;</span>
<span class="fc" id="L373">    }</span>

    /**
     * Gets initial position to start the solving algorithm.
     * This should be a value close to the expected solution.
     * If no value is provided, the average position among all selected nearest
     * located fingerprints will be used.
     *
     * @return initial position to start the solving algorithm or null.
     */
    public P getInitialPosition() {
<span class="fc" id="L384">        return mInitialPosition;</span>
    }

    /**
     * Sets initial position to start the solving algorithm.
     * This should be a value close to the expected solution.
     * If no value is provided, the average position among all selected nearest
     * located fingerprints will be used.
     *
     * @param initialPosition initial position to start the solving algorithm or null.
     * @throws LockedException if estimator is locked.
     */
    public void setInitialPosition(final P initialPosition) throws LockedException {
<span class="fc bfc" id="L397" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L398">            throw new LockedException();</span>
        }

<span class="fc" id="L401">        mInitialPosition = initialPosition;</span>
<span class="fc" id="L402">    }</span>

    /**
     * Gets estimated covariance matrix for estimated non-located fingerprint position
     * and estimated located radio sources position.
     *
     * @return estimated covariance matrix for estimated non-located fingerprint
     * position and estimated located radio sources position.
     */
    public Matrix getCovariance() {
<span class="fc" id="L412">        return mCovariance;</span>
    }

    /**
     * Gets covariance of estimated position for non-located fingerprint.
     *
     * @return covariance of estimated position for non-located fingerprint.
     */
    public Matrix getEstimatedPositionCovariance() {
<span class="fc" id="L421">        return mEstimatedPositionCovariance;</span>
    }

    /**
     * Gets estimated chi square value.
     *
     * @return estimated chi square value.
     */
    public double getChiSq() {
<span class="fc" id="L430">        return mChiSq;</span>
    }

    /**
     * Indicates whether path loss exponent of provided sources must be used when
     * available (if true), or if fallback path loss exponent must be used instead.
     *
     * @return true to use path loss exponent of provided sources when available,
     * false otherwise.
     */
    public boolean getUseSourcesPathLossExponentWhenAvailable() {
<span class="fc" id="L441">        return mUseSourcesPathLossExponentWhenAvailable;</span>
    }

    /**
     * Specifies whether path loss exponent of provided sources must be used when
     * available (if true), or if fallback path loss exponent must be used instead.
     *
     * @param useSourcesPathLossExponentWhenAvailable true to use path loss exponent of
     *                                                provided sources when available,
     *                                                false otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setUseSourcesPathLossExponentWhenAvailable(
            final boolean useSourcesPathLossExponentWhenAvailable) throws LockedException {
<span class="fc bfc" id="L455" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L456">            throw new LockedException();</span>
        }
<span class="fc" id="L458">        mUseSourcesPathLossExponentWhenAvailable =</span>
                useSourcesPathLossExponentWhenAvailable;
<span class="fc" id="L460">    }</span>

    /**
     * Gets RSSI standard deviation fallback value to use when none can be
     * determined from provided readings.
     *
     * @return RSSI standard deviation fallback.
     */
    public double getFallbackRssiStandardDeviation() {
<span class="fc" id="L469">        return mFallbackRssiStandardDeviation;</span>
    }

    /**
     * Sets RSSI standard deviation fallback value to use when none can be
     * determined from provided readings.
     *
     * @param fallbackRssiStandardDeviation RSSI standard deviation fallback
     * @throws LockedException          if estimator is locked.
     * @throws IllegalArgumentException if provided value is smaller than
     *                                  {@link #TINY}.
     */
    public void setFallbackRssiStandardDeviation(
            final double fallbackRssiStandardDeviation) throws LockedException {
<span class="fc bfc" id="L483" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L484">            throw new LockedException();</span>
        }
<span class="pc bpc" id="L486" title="1 of 2 branches missed.">        if (fallbackRssiStandardDeviation &lt; TINY) {</span>
<span class="nc" id="L487">            throw new IllegalArgumentException();</span>
        }
<span class="fc" id="L489">        mFallbackRssiStandardDeviation = fallbackRssiStandardDeviation;</span>
<span class="fc" id="L490">    }</span>

    /**
     * Indicates whether measured RSSI standard deviation of closest fingerprint must be
     * propagated into measured RSSI reading variance at unknown location.
     *
     * @return true to propagate RSSI standard deviation of closest fingerprint,
     * false otherwise.
     */
    public boolean isFingerprintRssiStandardDeviationPropagated() {
<span class="fc" id="L500">        return mPropagateFingerprintRssiStandardDeviation;</span>
    }

    /**
     * Specifies whether measured RSSI standard deviation of closest fingerprint must be
     * propagated into measured RSSI reading variance at unknown location.
     *
     * @param propagateFingerprintRssiStandardDeviation true to propagate RSSI standard
     *                                                  deviation of closest fingerprint,
     *                                                  false otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setFingerprintRssiStandardDeviationPropagated(
            final boolean propagateFingerprintRssiStandardDeviation) throws LockedException {
<span class="fc bfc" id="L514" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L515">            throw new LockedException();</span>
        }
<span class="fc" id="L517">        mPropagateFingerprintRssiStandardDeviation =</span>
                propagateFingerprintRssiStandardDeviation;
<span class="fc" id="L519">    }</span>

    /**
     * Indicates whether path-loss exponent standard deviation of radio source must be
     * propagated into measured RSSI reading variance at unknown location.
     *
     * @return true to propagate  path-loss exponent standard deviation of radio source,
     * false otherwise.
     */
    public boolean isPathlossExponentStandardDeviationPropagated() {
<span class="fc" id="L529">        return mPropagatePathlossExponentStandardDeviation;</span>
    }

    /**
     * Specifies whether path-loss exponent standard deviation of radio source must be
     * propagated into measured RSSI reading variance at unknown location.
     *
     * @param propagatePathlossExponentStandardDeviation true to propagate path-loss
     *                                                   exponent standard deviation of
     *                                                   radio source, false otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setPathlossExponentStandardDeviationPropagated(
            final boolean propagatePathlossExponentStandardDeviation) throws LockedException {
<span class="fc bfc" id="L543" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L544">            throw new LockedException();</span>
        }
<span class="fc" id="L546">        mPropagatePathlossExponentStandardDeviation =</span>
                propagatePathlossExponentStandardDeviation;
<span class="fc" id="L548">    }</span>

    /**
     * Indicates whether covariance of closest fingerprint position must be propagated
     * into measured RSSI reading variance at unknown location.
     *
     * @return true to propagate fingerprint position covariance, false otherwise.
     */
    public boolean isFingerprintPositionCovariancePropagated() {
<span class="fc" id="L557">        return mPropagateFingerprintPositionCovariance;</span>
    }

    /**
     * Specifies whether covariance of closest fingerprint position must be propagated
     * into measured RSSI reading variance at unknown location.
     *
     * @param propagateFingerprintPositionCovariance true to propagate fingerprint
     *                                               position covariance, false otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setFingerprintPositionCovariancePropagated(
            final boolean propagateFingerprintPositionCovariance) throws LockedException {
<span class="fc bfc" id="L570" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L571">            throw new LockedException();</span>
        }
<span class="fc" id="L573">        mPropagateFingerprintPositionCovariance =</span>
                propagateFingerprintPositionCovariance;
<span class="fc" id="L575">    }</span>

    /**
     * Indicates whether covariance of radio source position must be propagated into
     * measured RSSI reading variance at unknown location.
     *
     * @return true to propagate radio source position covariance, false otherwise.
     */
    public boolean isRadioSourcePositionCovariancePropagated() {
<span class="fc" id="L584">        return mPropagateRadioSourcePositionCovariance;</span>
    }

    /**
     * Specifies whether covariance of radio source position must be propagated into
     * measured RSSI reading variance at unknown location.
     *
     * @param propagateRadioSourcePositionCovariance true to propagate radio source
     *                                               position covariance, false otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setRadioSourcePositionCovariancePropagated(
            final boolean propagateRadioSourcePositionCovariance) throws LockedException {
<span class="fc bfc" id="L597" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L598">            throw new LockedException();</span>
        }
<span class="fc" id="L600">        mPropagateRadioSourcePositionCovariance =</span>
                propagateRadioSourcePositionCovariance;
<span class="fc" id="L602">    }</span>

    /**
     * Estimates position and radio sources based on provided located radio sources and readings of
     * such radio sources at an unknown location.
     *
     * @throws LockedException                if estimator is locked.
     * @throws NotReadyException              if estimator is not ready.
     * @throws FingerprintEstimationException if estimation fails for some other reason.
     */
    @Override
    @SuppressWarnings(&quot;Duplicates&quot;)
    public void estimate() throws LockedException, NotReadyException,
            FingerprintEstimationException {

<span class="pc bpc" id="L617" title="1 of 2 branches missed.">        if (!isReady()) {</span>
<span class="nc" id="L618">            throw new NotReadyException();</span>
        }
<span class="fc bfc" id="L620" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L621">            throw new LockedException();</span>
        }

        try {
<span class="fc" id="L625">            mLocked = true;</span>

<span class="pc bpc" id="L627" title="1 of 2 branches missed.">            if (mListener != null) {</span>
<span class="fc" id="L628">                mListener.onEstimateStart(this);</span>
            }

<span class="fc" id="L631">            RadioSourceNoMeanKNearestFinder&lt;P, RadioSource&gt; noMeanfinder = null;</span>
<span class="fc" id="L632">            RadioSourceKNearestFinder&lt;P, RadioSource&gt; finder = null;</span>
<span class="pc bpc" id="L633" title="1 of 2 branches missed.">            if (mUseNoMeanNearestFingerprintFinder) {</span>
                //noinspection unchecked
<span class="fc" id="L635">                noMeanfinder = new RadioSourceNoMeanKNearestFinder&lt;&gt;(</span>
                        (Collection&lt;? extends RssiFingerprintLocated&lt;RadioSource,
                                RssiReading&lt;RadioSource&gt;, P&gt;&gt;) mLocatedFingerprints);
            } else {
                //noinspection unchecked
<span class="nc" id="L640">                finder = new RadioSourceKNearestFinder&lt;&gt;(</span>
                        (Collection&lt;? extends RssiFingerprintLocated&lt;RadioSource,
                                RssiReading&lt;RadioSource&gt;, P&gt;&gt;) mLocatedFingerprints);
            }

<span class="fc" id="L645">            mEstimatedPositionCoordinates = null;</span>
<span class="fc" id="L646">            mCovariance = null;</span>
<span class="fc" id="L647">            mEstimatedPositionCovariance = null;</span>
<span class="fc" id="L648">            mNearestFingerprints = null;</span>
<span class="fc" id="L649">            mEstimatedLocatedSources = null;</span>

<span class="fc" id="L651">            final int min = Math.max(1, mMinNearestFingerprints);</span>
<span class="pc bpc" id="L652" title="1 of 2 branches missed.">            final int max = mMaxNearestFingerprints &lt; 0 ?</span>
<span class="fc" id="L653">                    mLocatedFingerprints.size() :</span>
<span class="pc" id="L654">                    Math.min(mMaxNearestFingerprints, mLocatedFingerprints.size());</span>
<span class="fc bfc" id="L655" title="All 2 branches covered.">            for (int k = min; k &lt;= max; k++) {</span>
<span class="pc bpc" id="L656" title="1 of 2 branches missed.">                if (noMeanfinder != null) {</span>
                    //noinspection unchecked
<span class="fc" id="L658">                    mNearestFingerprints = noMeanfinder.findKNearestTo(</span>
                            (RssiFingerprint&lt;RadioSource, RssiReading&lt;RadioSource&gt;&gt;) mFingerprint, k);
                } else {
                    //noinspection unchecked
<span class="nc" id="L662">                    mNearestFingerprints = finder.findKNearestTo(</span>
                            (RssiFingerprint&lt;RadioSource, RssiReading&lt;RadioSource&gt;&gt;) mFingerprint, k);
                }

                //Demonstration in 2D:
                //--------------------

                //The expression of received power expressed in dBm's is:
                //k = (c/(4*pi*f))
                //Pr = Pte*k^n / d^n

                //where c is the speed of light, pi is 3.14159..., f is the frequency of the radio source,
                //Pte is the equivalent transmitted power by the radio source, n is the path-loss exponent
                // (typically 2.0), and d is the distance from a point to the location of the radio source.

                //Hence:
                //Pr(dBm) = 10*log(Pte*k^n/d^n) = 10*n*log(k) + 10*log(Pte) - 10*n*log(d) =
                //          10*n*log(k) + 10*log(Pte) - 5*n*log(d^2)

                //where d^2 = dia^2 = (xi - xa)^2 + (yi - ya)^2 is the squared distance between
                //fingerprint and unknown point pi = (xi, yi) and
                //radio source a = a,b... M
                //10*n*log(k) is constant for a given radio source &quot;a&quot;, and
                //Pte is the equivalent transmitted power of radio source &quot;a&quot;.

                //We assume that the 2 former terms are constant and known for a given radio source
                //K = 10*n*log(k) + 10*log(Pte), and the only unknown term is
                //the latter one depending on the distance of the
                //measuring point and the radio source.

                //Hence for a given radio source &quot;a&quot; at unknown location &quot;i&quot;:
                //Pr(pi) = K - 5*n*log((xi - xa)^2 + (yi - ya)^2)

                //we assume that a known located fingerprint is located at p1 = (x1, y1),
                //Both readings Pr(pi) and Pr(p1) belong to the same radio source &quot;a&quot;, hence
                //K term is the same.

                //Pr(p1) = K - 5*n*log((x1 - xa)^2 + (y1 - ya)^2)

                //where d1a^2 = (x1 - xa)^2 + (y1 - ya)^2 is the squared distance between
                //fingerprint 1 and radio source 2

                //To remove possible bias effects on readings, we consider the difference of received
                //power for fingerprint &quot;1&quot; and radio source &quot;a&quot; as:

                //Prdiff1a = Pr(pi) - Pr(p1) = (K - 5*n*log(dia^2)) - (K - 5*n*log(d1a^2)) =
                //  = 5*n*log(d1a^2) - 5*n*log(dia^2)

                //where both d1a^2 and dia^2 are unknown, because location pi=(xi,yi) and pa=(xa,ya) are unknown.
                //Now we have no dependencies on the amount of transmitted power of each radio source
                //contained on constant term K, and we only depend on squared distances d1a^2 and dia^2.

                //Consequently, the difference of received power for fingerprint &quot;2&quot; and radio source &quot;a&quot; is:
                //Prdiff2a = 5*n*log(d2a^2) - 5*n*log(dia^2)

                //the difference of received power for fingerprint &quot;1&quot; and radio source &quot;b&quot; is:
                //Prdiff1b = 5*n*log(d1b^2) - 5*n*log(dib^2)

                //and so on.

                //we want to find unknown location pi, and location of radio source pa, pb,... pM so that Prdiff
                //errors are minimized in LMSE (Least Mean Square Error) terms.

                //Assuming that we have M radio sources and N fingerprints, we have
                //y = [Prdiff1a Prdiff2a Prdiff1b Prdiff2b ... PrdiffNa PrdiffNb ... PrdiffNM]

                //and the unknowns to be found are:
                //x = [xi yi xa ya xb yb ... xM yM], which are the location of the unknown fingerprint
                //pi = (xi, yi) and the locations of the radio sources a, b ... M that we want to find pa = (xa, ya),
                //pb = (xb, yb) ... pM = (xM, yM)

                try {
<span class="fc" id="L734">                    final List&lt;RadioSource&gt; sourcesToBeEstimated = setupFitter();</span>
<span class="fc bfc" id="L735" title="All 2 branches covered.">                    if (mMinNearestFingerprints &lt; 0) {</span>
                        //if no limit is set in minimum value, then a minimum of
                        //dims * (1 + numSources) is used
<span class="fc" id="L738">                        final int numSources = sourcesToBeEstimated.size();</span>
<span class="fc" id="L739">                        final int dims = getNumberOfDimensions();</span>
<span class="fc" id="L740">                        final int minNearest = dims * (1 + numSources);</span>
<span class="fc bfc" id="L741" title="All 2 branches covered.">                        if (k &lt; minNearest) {</span>
<span class="fc" id="L742">                            continue;</span>
                        }
                    }

<span class="fc" id="L746">                    mFitter.fit();</span>

                    //estimated position
<span class="fc" id="L749">                    final double[] a = mFitter.getA();</span>
<span class="fc" id="L750">                    mCovariance = mFitter.getCovar();</span>
<span class="fc" id="L751">                    mChiSq = mFitter.getChisq();</span>

<span class="fc" id="L753">                    final int dims = getNumberOfDimensions();</span>

                    //obtain estimated position coordinates and covariance
<span class="fc" id="L756">                    mEstimatedPositionCoordinates = new double[dims];</span>
<span class="fc" id="L757">                    System.arraycopy(a, 0, mEstimatedPositionCoordinates,</span>
                            0, dims);

<span class="fc" id="L760">                    final int dimsMinusOne = dims - 1;</span>
<span class="fc" id="L761">                    mEstimatedPositionCovariance = mCovariance.getSubmatrix(0, 0,</span>
                            dimsMinusOne, dimsMinusOne);

                    //obtain radio sources estimated positions and covariance
<span class="fc" id="L765">                    final int totalSources = sourcesToBeEstimated.size();</span>
<span class="fc" id="L766">                    mEstimatedLocatedSources = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L767" title="All 2 branches covered.">                    for (int j = 0; j &lt; totalSources; j++) {</span>
<span class="fc" id="L768">                        final P sourcePosition = createPoint();</span>

<span class="fc" id="L770">                        final int start = dims * (1 + j);</span>
<span class="fc" id="L771">                        final int end = start + dimsMinusOne;</span>
<span class="fc bfc" id="L772" title="All 2 branches covered.">                        for (int i = 0; i &lt; dims; i++) {</span>
<span class="fc" id="L773">                            sourcePosition.setInhomogeneousCoordinate(i, a[start + i]);</span>
                        }

<span class="fc" id="L776">                        final Matrix sourceCovariance = mCovariance.getSubmatrix(</span>
                                start, start, end, end);

<span class="fc" id="L779">                        final RadioSource source = sourcesToBeEstimated.get(j);</span>
<span class="fc" id="L780">                        mEstimatedLocatedSources.add(</span>
<span class="fc" id="L781">                                createRadioSource(source, sourcePosition,</span>
                                        sourceCovariance));
                    }

                    //a solution was found so we exit loop
<span class="fc" id="L786">                    break;</span>
<span class="fc" id="L787">                } catch (final NumericalException e) {</span>
                    //solution could not be found with current data
                    //Iterate to use additional nearby fingerprints
<span class="fc" id="L790">                    mEstimatedPositionCoordinates = null;</span>
<span class="fc" id="L791">                    mCovariance = null;</span>
<span class="fc" id="L792">                    mEstimatedPositionCovariance = null;</span>
<span class="fc" id="L793">                    mEstimatedLocatedSources = null;</span>
                }
            }

<span class="pc bpc" id="L797" title="1 of 4 branches missed.">            if (mEstimatedPositionCoordinates == null ||</span>
                    mEstimatedLocatedSources == null) {
                //no position could be estimated
<span class="fc" id="L800">                throw new FingerprintEstimationException();</span>
            }

<span class="pc bpc" id="L803" title="1 of 2 branches missed.">            if (mListener != null) {</span>
<span class="fc" id="L804">                mListener.onEstimateEnd(this);</span>
            }
        } finally {
<span class="fc" id="L807">            mLocked = false;</span>
        }
<span class="fc" id="L809">    }</span>

    /**
     * Propagates provided variances into RSSI differences.
     *
     * @param pathlossExponent              path-loss exponent.
     * @param fingerprintPosition           position of closest located fingerprint.
     * @param radioSourcePosition           radio source position associated to fingerprint reading.
     * @param estimatedPosition             position to be estimated. Usually this is equal to the
     *                                      initial position used by a non linear algorithm.
     * @param pathlossExponentVariance      variance of path-loss exponent or null if unknown.
     * @param fingerprintPositionCovariance covariance of fingerprint position or null if
     *                                      unknown.
     * @param radioSourcePositionCovariance covariance of radio source position or null if
     *                                      unknown.
     * @return variance of RSSI difference measured at non located fingerprint reading.
     */
    protected abstract Double propagateVariances(
            final double pathlossExponent, final P fingerprintPosition,
            final P radioSourcePosition, final P estimatedPosition,
            final Double pathlossExponentVariance,
            final Matrix fingerprintPositionCovariance,
            final Matrix radioSourcePositionCovariance);

    /**
     * Creates a located radio source from provided radio source, position and
     * covariance.
     *
     * @param source           radio source.
     * @param sourcePosition   radio source position.
     * @param sourceCovariance radio source position covariance.
     * @return located radio source.
     */
    private RadioSourceLocated&lt;P&gt; createRadioSource(
            final RadioSource source, final P sourcePosition,
            final Matrix sourceCovariance) {

<span class="fc" id="L846">        final int dims = getNumberOfDimensions();</span>

<span class="fc bfc" id="L848" title="All 2 branches covered.">        switch (source.getType()) {</span>
            case BEACON:
<span class="fc" id="L850">                final Beacon beacon = (Beacon) source;</span>
<span class="fc bfc" id="L851" title="All 2 branches covered.">                if (dims == Point2D.POINT2D_INHOMOGENEOUS_COORDINATES_LENGTH) {</span>
                    //2D

                    //noinspection unchecked
<span class="fc" id="L855">                    return (RadioSourceLocated&lt;P&gt;) new BeaconLocated2D(</span>
<span class="fc" id="L856">                            beacon.getIdentifiers(), beacon.getTransmittedPower(),</span>
<span class="fc" id="L857">                            beacon.getFrequency(), beacon.getBluetoothAddress(),</span>
<span class="fc" id="L858">                            beacon.getBeaconTypeCode(), beacon.getManufacturer(),</span>
<span class="fc" id="L859">                            beacon.getServiceUuid(), beacon.getBluetoothName(),</span>
                            (Point2D) sourcePosition, sourceCovariance);
                } else {
                    //3D

                    //noinspection unchecked
<span class="fc" id="L865">                    return (RadioSourceLocated&lt;P&gt;) new BeaconLocated3D(</span>
<span class="fc" id="L866">                            beacon.getIdentifiers(), beacon.getTransmittedPower(),</span>
<span class="fc" id="L867">                            beacon.getFrequency(), beacon.getBluetoothAddress(),</span>
<span class="fc" id="L868">                            beacon.getBeaconTypeCode(), beacon.getManufacturer(),</span>
<span class="fc" id="L869">                            beacon.getServiceUuid(), beacon.getBluetoothName(),</span>
                            (Point3D) sourcePosition, sourceCovariance);
                }
            case WIFI_ACCESS_POINT:
            default:
<span class="fc" id="L874">                final WifiAccessPoint accessPoint = (WifiAccessPoint) source;</span>
<span class="fc bfc" id="L875" title="All 2 branches covered.">                if (dims == Point2D.POINT2D_INHOMOGENEOUS_COORDINATES_LENGTH) {</span>
                    //2D

                    //noinspection unchecked
<span class="fc" id="L879">                    return (RadioSourceLocated&lt;P&gt;) new WifiAccessPointLocated2D(</span>
<span class="fc" id="L880">                            accessPoint.getBssid(), accessPoint.getFrequency(),</span>
<span class="fc" id="L881">                            accessPoint.getSsid(), (Point2D) sourcePosition,</span>
                            sourceCovariance);
                } else {
                    //3D

                    //noinspection unchecked
<span class="fc" id="L887">                    return (RadioSourceLocated&lt;P&gt;) new WifiAccessPointLocated3D(</span>
<span class="fc" id="L888">                            accessPoint.getBssid(), accessPoint.getFrequency(),</span>
<span class="fc" id="L889">                            accessPoint.getSsid(), (Point3D) sourcePosition,</span>
                            sourceCovariance);
                }
        }

    }

    /**
     * Builds data required to solve the problem.
     * This method takes into account current nearest fingerprints and discards those
     * readings belonging to radio sources not having enough data to be estimated.
     *
     * @param allPowerDiffs               list of received power differences of RSSI readings between a
     *                                    located fingerprint and an unknown fingerprint for a given radio
     *                                    source.
     * @param allFingerprintPositions     positions of all located fingerprints being taken into
     *                                    account.
     * @param allInitialSourcesPositions  initial positions of all radio sources to be taken
     *                                    into account. If initial located sources where provided,
     *                                    their positions will be used, otherwise the centroid of
     *                                    all located fingerprints associated to a radio source will
     *                                    be used as initial position.
     * @param allSourcesToBeEstimated     all radio sources that will be estimated.
     * @param allSourcesIndices           indices indicating the position radio source being used
     *                                    within the list of sources for current reading.
     * @param allPathLossExponents        list of path loss exponents.
     * @param allStandardDeviations       list of standard deviations for readings being used.
     * @param nearestFingerprintsCentroid centroid of nearest fingerprints being taken into account.
     */
    @SuppressWarnings(&quot;Duplicates&quot;)
    private void buildData(
            final List&lt;Double&gt; allPowerDiffs,
            final List&lt;P&gt; allFingerprintPositions,
            final List&lt;P&gt; allInitialSourcesPositions,
            final List&lt;RadioSource&gt; allSourcesToBeEstimated,
            final List&lt;Integer&gt; allSourcesIndices,
            final List&lt;Double&gt; allPathLossExponents,
            final List&lt;Double&gt; allStandardDeviations,
            final P nearestFingerprintsCentroid) {

<span class="fc" id="L929">        final int dims = getNumberOfDimensions();</span>
<span class="fc" id="L930">        int num = 0;</span>
<span class="fc" id="L931">        final double[] centroidCoords = new double[dims];</span>
        for (final RssiFingerprintLocated&lt;? extends RadioSource,
<span class="fc bfc" id="L933" title="All 2 branches covered.">                ? extends RssiReading&lt;? extends RadioSource&gt;, P&gt; fingerprint : mNearestFingerprints) {</span>
<span class="fc" id="L934">            final P position = fingerprint.getPosition();</span>
<span class="pc bpc" id="L935" title="1 of 2 branches missed.">            if (position == null) {</span>
<span class="nc" id="L936">                continue;</span>
            }

<span class="fc bfc" id="L939" title="All 2 branches covered.">            for (int i = 0; i &lt; dims; i++) {</span>
<span class="fc" id="L940">                centroidCoords[i] += position.getInhomogeneousCoordinate(i);</span>
            }
<span class="fc" id="L942">            num++;</span>
<span class="fc" id="L943">        }</span>

<span class="fc bfc" id="L945" title="All 2 branches covered.">        for (int i = 0; i &lt; dims; i++) {</span>
<span class="fc" id="L946">            centroidCoords[i] /= num;</span>
<span class="fc" id="L947">            nearestFingerprintsCentroid.setInhomogeneousCoordinate(i, centroidCoords[i]);</span>
        }

        //maps to keep cached in memory computed values to speed up computations
<span class="fc" id="L951">        final HashMap&lt;RadioSource, Integer&gt; numReadingsMap = new HashMap&lt;&gt;();</span>
<span class="fc" id="L952">        final HashMap&lt;RadioSource, P&gt; centroidsMap = new HashMap&lt;&gt;();</span>

        for (final RssiFingerprintLocated&lt;RadioSource, RssiReading&lt;RadioSource&gt;, P&gt; locatedFingerprint :
<span class="fc bfc" id="L955" title="All 2 branches covered.">                mNearestFingerprints) {</span>

<span class="fc" id="L957">            final List&lt;RssiReading&lt;RadioSource&gt;&gt; locatedReadings =</span>
<span class="fc" id="L958">                    locatedFingerprint.getReadings();</span>
<span class="pc bpc" id="L959" title="1 of 2 branches missed.">            if (locatedReadings == null) {</span>
<span class="nc" id="L960">                continue;</span>
            }

<span class="fc" id="L963">            final P fingerprintPosition = locatedFingerprint.getPosition();</span>
<span class="fc" id="L964">            final Matrix fingerprintPositionCovariance = locatedFingerprint.</span>
<span class="fc" id="L965">                    getPositionCovariance();</span>

<span class="fc bfc" id="L967" title="All 2 branches covered.">            for (final RssiReading&lt;RadioSource&gt; locatedReading : locatedReadings) {</span>
<span class="fc" id="L968">                final RadioSource source = locatedReading.getSource();</span>

                //obtain the total number of readings available for this source and
                //the centroid of all located fingerprints containing readings for
                //such source
                final int numReadings;
<span class="fc bfc" id="L974" title="All 2 branches covered.">                if (!numReadingsMap.containsKey(source)) {</span>
<span class="fc" id="L975">                    numReadings = totalReadingsForSource(source, mNearestFingerprints, null);</span>
<span class="fc" id="L976">                    numReadingsMap.put(source, numReadings);</span>
                } else {
<span class="fc" id="L978">                    numReadings = numReadingsMap.get(source);</span>
                }

<span class="fc bfc" id="L981" title="All 2 branches covered.">                if (numReadings &lt; dims) {</span>
<span class="fc" id="L982">                    continue;</span>
                }

                final P centroid;
<span class="fc bfc" id="L986" title="All 2 branches covered.">                if (!centroidsMap.containsKey(source)) {</span>
<span class="fc" id="L987">                    centroid = createPoint();</span>

                    //noinspection unchecked
<span class="fc" id="L990">                    totalReadingsForSource(source,</span>
                            (List&lt;RssiFingerprintLocated&lt;RadioSource, RssiReading&lt;RadioSource&gt;, P&gt;&gt;) mLocatedFingerprints,
                            centroid);

<span class="fc" id="L994">                    centroidsMap.put(source, centroid);</span>
                } else {
<span class="fc" id="L996">                    centroid = centroidsMap.get(source);</span>
                }

                //find within the list of located sources (if available) the source
                //of current located fingerprint
<span class="fc bfc" id="L1001" title="All 2 branches covered.">                @SuppressWarnings(&quot;SuspiciousMethodCalls&quot;) final int pos = mInitialLocatedSources != null ?</span>
<span class="fc" id="L1002">                        mInitialLocatedSources.indexOf(source) : -1;</span>

<span class="fc" id="L1004">                double pathLossExponent = mPathLossExponent;</span>
<span class="fc" id="L1005">                Double pathLossExponentVariance = null;</span>
<span class="pc bpc" id="L1006" title="1 of 4 branches missed.">                if (mUseSourcesPathLossExponentWhenAvailable &amp;&amp;</span>
                        source instanceof RadioSourceWithPower) {
<span class="fc" id="L1008">                    RadioSourceWithPower sourceWithPower = (RadioSourceWithPower) source;</span>
<span class="fc" id="L1009">                    pathLossExponent = sourceWithPower.getPathLossExponent();</span>
<span class="fc" id="L1010">                    final Double std = sourceWithPower.getPathLossExponentStandardDeviation();</span>
<span class="fc bfc" id="L1011" title="All 2 branches covered.">                    pathLossExponentVariance = std != null ? std * std : null;</span>
                }


                final P sourcePosition;
<span class="fc" id="L1016">                Matrix sourcePositionCovariance = null;</span>
<span class="fc bfc" id="L1017" title="All 2 branches covered.">                if (pos &lt; 0) {</span>
                    //located source is not available, so we use centroid
<span class="fc" id="L1019">                    sourcePosition = centroid;</span>
                } else {
<span class="fc" id="L1021">                    final RadioSourceLocated&lt;P&gt; locatedSource = mInitialLocatedSources.get(pos);</span>
<span class="fc" id="L1022">                    sourcePosition = locatedSource.getPosition();</span>

<span class="pc bpc" id="L1024" title="1 of 6 branches missed.">                    if (mUseSourcesPathLossExponentWhenAvailable &amp;&amp;</span>
                            locatedSource instanceof RadioSourceWithPower &amp;&amp;
                            pathLossExponentVariance == null) {
<span class="fc" id="L1027">                        final RadioSourceWithPower locatedSourceWithPower =</span>
                                (RadioSourceWithPower) locatedSource;
<span class="fc" id="L1029">                        pathLossExponent = locatedSourceWithPower.getPathLossExponent();</span>
<span class="fc" id="L1030">                        final Double std = locatedSourceWithPower.</span>
<span class="fc" id="L1031">                                getPathLossExponentStandardDeviation();</span>
<span class="pc bpc" id="L1032" title="1 of 2 branches missed.">                        pathLossExponentVariance = std != null ? std * std : null;</span>
                    }

<span class="fc" id="L1035">                    sourcePositionCovariance = locatedSource.getPositionCovariance();</span>
                }

                final int sourceIndex;
<span class="fc bfc" id="L1039" title="All 2 branches covered.">                if (!allSourcesToBeEstimated.contains(source)) {</span>
<span class="fc" id="L1040">                    sourceIndex = allSourcesToBeEstimated.size();</span>

<span class="fc" id="L1042">                    allSourcesToBeEstimated.add(source);</span>
<span class="fc" id="L1043">                    allInitialSourcesPositions.add(sourcePosition);</span>
                } else {
<span class="fc" id="L1045">                    sourceIndex = allSourcesToBeEstimated.indexOf(source);</span>
                }


<span class="fc" id="L1049">                final double locatedRssi = locatedReading.getRssi();</span>

<span class="fc" id="L1051">                final Double locatedRssiStd = locatedReading.getRssiStandardDeviation();</span>
<span class="fc bfc" id="L1052" title="All 2 branches covered.">                final Double locatedRssiVariance = locatedRssiStd != null ?</span>
<span class="fc" id="L1053">                        locatedRssiStd * locatedRssiStd : null;</span>

<span class="fc" id="L1055">                final List&lt;? extends RssiReading&lt;? extends RadioSource&gt;&gt; readings =</span>
<span class="fc" id="L1056">                        mFingerprint.getReadings();</span>
<span class="fc bfc" id="L1057" title="All 2 branches covered.">                for (final RssiReading&lt;? extends RadioSource&gt; reading : readings) {</span>
<span class="pc bpc" id="L1058" title="1 of 2 branches missed.">                    if (reading.getSource() == null ||</span>
<span class="fc bfc" id="L1059" title="All 2 branches covered.">                            !reading.getSource().equals(source)) {</span>
<span class="fc" id="L1060">                        continue;</span>
                    }

                    //only take into account reading for matching sources on located
                    //and non-located readings
<span class="fc" id="L1065">                    final double rssi = reading.getRssi();</span>

<span class="fc" id="L1067">                    final double powerDiff = rssi - locatedRssi;</span>

<span class="fc" id="L1069">                    Double standardDeviation = null;</span>
<span class="pc bpc" id="L1070" title="5 of 6 branches missed.">                    if (mPropagatePathlossExponentStandardDeviation ||</span>
                            mPropagateFingerprintPositionCovariance ||
                            mPropagateRadioSourcePositionCovariance) {

                        //compute initial position
<span class="fc bfc" id="L1075" title="All 2 branches covered.">                        final P initialPosition = mInitialPosition != null ?</span>
<span class="fc" id="L1076">                                mInitialPosition : nearestFingerprintsCentroid;</span>

<span class="fc" id="L1078">                        final Double variance = propagateVariances(pathLossExponent,</span>
                                fingerprintPosition, sourcePosition, initialPosition,
<span class="pc bpc" id="L1080" title="1 of 2 branches missed.">                                mPropagatePathlossExponentStandardDeviation ? pathLossExponentVariance : null,</span>
<span class="pc bpc" id="L1081" title="1 of 2 branches missed.">                                mPropagateFingerprintPositionCovariance ? fingerprintPositionCovariance : null,</span>
<span class="pc bpc" id="L1082" title="1 of 2 branches missed.">                                mPropagateRadioSourcePositionCovariance ? sourcePositionCovariance : null);</span>
<span class="pc bpc" id="L1083" title="1 of 2 branches missed.">                        if (variance != null) {</span>
<span class="fc" id="L1084">                            standardDeviation = Math.sqrt(variance);</span>
                        }
                    }

<span class="pc bpc" id="L1088" title="1 of 2 branches missed.">                    if (standardDeviation == null) {</span>
<span class="nc" id="L1089">                        standardDeviation = reading.getRssiStandardDeviation();</span>
                    }

<span class="pc bpc" id="L1092" title="1 of 2 branches missed.">                    if (mPropagateFingerprintRssiStandardDeviation) {</span>
<span class="pc bpc" id="L1093" title="1 of 2 branches missed.">                        if (standardDeviation != null &amp;&amp;</span>
<span class="pc bpc" id="L1094" title="1 of 2 branches missed.">                                reading.getRssiStandardDeviation() != null) {</span>
                            //consider propagated variance and reading variance independent, so we
                            //sum them both
<span class="nc" id="L1097">                            standardDeviation = standardDeviation * standardDeviation +</span>
<span class="nc" id="L1098">                                    reading.getRssiStandardDeviation() * reading.getRssiStandardDeviation();</span>
<span class="nc" id="L1099">                            standardDeviation = Math.sqrt(standardDeviation);</span>
                        }

<span class="pc bpc" id="L1102" title="1 of 4 branches missed.">                        if (locatedRssiVariance != null &amp;&amp; standardDeviation != null) {</span>
                            //consider propagated variance and located reading variance
                            //independent, so we sum them both
<span class="fc" id="L1105">                            standardDeviation = standardDeviation * standardDeviation +</span>
<span class="fc" id="L1106">                                    locatedRssiVariance;</span>
<span class="fc" id="L1107">                            standardDeviation = Math.sqrt(standardDeviation);</span>
                        }
                    }

<span class="pc bpc" id="L1111" title="1 of 4 branches missed.">                    if (standardDeviation == null || standardDeviation &lt; TINY) {</span>
<span class="fc" id="L1112">                        standardDeviation = mFallbackRssiStandardDeviation;</span>
                    }

<span class="fc" id="L1115">                    allPowerDiffs.add(powerDiff);</span>
<span class="fc" id="L1116">                    allFingerprintPositions.add(fingerprintPosition);</span>
<span class="fc" id="L1117">                    allSourcesIndices.add(sourceIndex);</span>
<span class="fc" id="L1118">                    allPathLossExponents.add(pathLossExponent);</span>
<span class="fc" id="L1119">                    allStandardDeviations.add(standardDeviation);</span>
<span class="fc" id="L1120">                }</span>
<span class="fc" id="L1121">            }</span>
<span class="fc" id="L1122">        }</span>
<span class="fc" id="L1123">    }</span>

    /**
     * Setups fitter to solve positions.
     *
     * @return list of radio sources whose location will be estimated.
     * @throws FittingException if Levenberg-Marquardt fitting fails.
     */
    @SuppressWarnings(&quot;Duplicates&quot;)
    private List&lt;RadioSource&gt; setupFitter() throws FittingException {
        //build lists of data
<span class="fc" id="L1134">        final List&lt;Double&gt; allPowerDiffs = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L1135">        final List&lt;P&gt; allFingerprintPositions = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L1136">        final List&lt;P&gt; allInitialSourcesPositions = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L1137">        final List&lt;RadioSource&gt; allSourcesToBeEstimated = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L1138">        final List&lt;Integer&gt; allSourcesIndices = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L1139">        final List&lt;Double&gt; allPathLossExponents = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L1140">        final List&lt;Double&gt; allStandardDeviations = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L1141">        final P nearestFingerprintsCentroid = createPoint();</span>
<span class="fc" id="L1142">        buildData(allPowerDiffs, allFingerprintPositions, allInitialSourcesPositions,</span>
                allSourcesToBeEstimated, allSourcesIndices, allPathLossExponents,
                allStandardDeviations, nearestFingerprintsCentroid);

<span class="fc" id="L1146">        final int totalReadings = allPowerDiffs.size();</span>
<span class="fc" id="L1147">        final int totalSources = allSourcesToBeEstimated.size();</span>
<span class="fc" id="L1148">        final int dims = getNumberOfDimensions();</span>
<span class="fc" id="L1149">        final int n = 1 + dims;</span>

<span class="fc" id="L1151">        mFitter.setFunctionEvaluator(new LevenbergMarquardtMultiDimensionFunctionEvaluator() {</span>
            @Override
            public int getNumberOfDimensions() {
<span class="fc" id="L1154">                return n;</span>
            }

            @Override
            public double[] createInitialParametersArray() {
<span class="fc" id="L1159">                final double[] initial = new double[dims * (totalSources + 1)];</span>

<span class="fc bfc" id="L1161" title="All 2 branches covered.">                if (mInitialPosition == null) {</span>
                    //use centroid of nearest fingerprints as initial value
<span class="fc bfc" id="L1163" title="All 2 branches covered.">                    for (int i = 0; i &lt; dims; i++) {</span>
<span class="fc" id="L1164">                        initial[i] = nearestFingerprintsCentroid.getInhomogeneousCoordinate(i);</span>
                    }
                } else {
                    //use provided initial position
<span class="fc bfc" id="L1168" title="All 2 branches covered.">                    for (int i = 0; i &lt; dims; i++) {</span>
<span class="fc" id="L1169">                        initial[i] = mInitialPosition.getInhomogeneousCoordinate(i);</span>
                    }
                }

<span class="fc" id="L1173">                int pos = dims;</span>
<span class="fc bfc" id="L1174" title="All 2 branches covered.">                for (int j = 0; j &lt; totalSources; j++) {</span>
<span class="fc" id="L1175">                    final P initialSourcePosition = allInitialSourcesPositions.get(j);</span>
<span class="fc bfc" id="L1176" title="All 2 branches covered.">                    for (int i = 0; i &lt; dims; i++) {</span>
<span class="fc" id="L1177">                        initial[pos] = initialSourcePosition.</span>
<span class="fc" id="L1178">                                getInhomogeneousCoordinate(i);</span>
<span class="fc" id="L1179">                        pos++;</span>
                    }
                }

<span class="fc" id="L1183">                return initial;</span>
            }

            @Override
            public double evaluate(
                    final int i, final double[] point, final double[] params,
                    final double[] derivatives) {

                //For 2D:
                //-------

                //Prdiff1a = Pr(pi) - Pr(p1) = 5*n*log(d1a^2) - 5*n*log(dia^2) =
                //  = 5*n*log((x1 - xa)^2 + (y1 - ya)^2) - 5*n*log((xi - xa)^2 + (yi - ya)^2)

                //derivatives respect parameters being estimated (xi,yi,xa,ya...,xM,yM)
                //for unknown point pi = (xi, yi)
                //diff(Prdiff1a)/diff(xi) = -5*n/(log(10)*((xi - xa)^2 + (yi - ya)^2))*2*(xi - xa)
                //  = -10*n*(xi - xa)/(log(10)*((xi - xa)^2 + (yi - ya)^2))
                //  = -10*n*(xi - xa)/(log(10)*dia^2)

                //diff(Prdiff1a)/diff(yi) = -5*n/(log(10)*((xi - xa)^2 + (yi - ya)^2))*2*(yi - ya)
                //  = -10*n*(yi - ya)/(log(10)*((xi - xa)^2 + (yi - ya)^2))
                //  = -10*n*(yi - ya)/(log(10)*dia^2)

                //for same radio source pa=(xa,ya)
                //diff(Prdiff1a)/diff(xa) = 5*n/(log(10)*((x1 - xa)^2 + (y1 - ya)^2))*-2*(x1 - xa) -5*n/(log(10)*((xi - xa)^2 + (yi - ya)^2))*-2*(xi - xa) =
                //  = -10*n*(x1 - xa)/(log(10)*((x1 - xa)^2 + (y1 - ya)^2)) + 10*n*(xi - xa)/(log(10)*((xi - xa)^2 + (yi - ya)^2))
                //  = 10*n*(-(x1 - xa)/(log(10)*d1a^2) + (xi - xa)/(log(10)*dia^2))

                //diff(Prdiff1a)/diff(ya) = 5*n/(log(10)*((x1 - xa)^2 + (y1 - ya)^2))*-2*(y1 - ya) -5*n/(log(10)*((xi - xa)^2 + (yi - ya)^2))*-2*(yi - ya) =
                //  = -10*n*(y1 - ya)/(log(10)*((x1 - xa)^2 + (y1 - ya)^2)) + 10*n*(yi - ya)/(log(10)*((xi - xa)^2 + (yi - ya)^2))
                //  = 10*n*(-(y1 - ya)/(log(10)*d1a^2) + (xi - xa)/(log(10)*dia^2))

                //for other radio source pb=(xb,yb)
                //diff(Prdiff1a)/diff(xb) = diff(Prdiff1a)/diff(yb) = 0

                //For 3D:
                //-------

                //Prdiff1a = Pr(pi) - Pr(p1) = 5*n*log(d1a^2) - 5*n*log(dia^2) =
                //  = 5*n*log((x1 - xa)^2 + (y1 - ya)^2 + (z1 - za)^2) - 5*n*log((xi - xa)^2 + (yi - ya)^2 + (zi - za)^2)

                //derivatives respect parameters being estimated (xi,yi,zi,xa,ya,za...,xM,yM,zM)
                //for unknown point pi = (xi, yi,zi)
                //diff(Prdiff1a)/diff(xi) = -5*n/(log(10)*((xi - xa)^2 + (yi - ya)^2 + (zi - za)^2))*2*(xi - xa)
                //  = -10*n*(xi - xa)/(log(10)*((xi - xa)^2 + (yi - ya)^2) + (zi - za)^2))
                //  = -10*n*(xi - xa)/(log(10)*dia^2)

                //diff(Prdiff1a)/diff(yi) = -5*n/(log(10)*((xi - xa)^2 + (yi - ya)^2 + (zi - za)^2))*2*(yi - ya)
                //  = -10*n*(yi - ya)/(log(10)*((xi - xa)^2 + (yi - ya)^2 + (zi - za)^2))
                //  = -10*n*(yi - ya)/(log(10)*dia^2)

                //diff(Prdiff1a)/diff(zi) = -5*n/(log(10)*((xi - xa)^2 + (yi - ya)^2 + (zi - za)^2))*2*(zi - za)
                //  = -10*n*(zi - za)/(log(10)*((xi - xa)^2 + (yi - ya)^2 + (zi - za)^2))
                //  = -10*n*(zi - za)/(log(10)*dia^2)

                //for same radio source pa=(xa,ya)
                //diff(Prdiff1a)/diff(xa) = 5*n/(log(10)*((x1 - xa)^2 + (y1 - ya)^2 + (z1 - za)^2))*-2*(x1 - xa) -5*n/(log(10)*((xi - xa)^2 + (yi - ya)^2 + (zi - za)^2))*-2*(xi - xa) =
                //  = -10*n*(x1 - xa)/(log(10)*((x1 - xa)^2 + (y1 - ya)^2 + (z1 - za)^2)) + 10*n*(xi - xa)/(log(10)*((xi - xa)^2 + (yi - ya)^2 + (zi - za)^2)) =
                //  = 10*n*(-(x1 -xa)/(log(10)*d1a^2) + (xi - xa)/(log(10)*dia^2))

                //diff(Prdiff1a)/diff(ya) = 5*n/(log(10)*((x1 - xa)^2 + (y1 - ya)^2 + (z1 - za)^2))*-2*(y1 - ya) -5*n/(log(10)*((xi - xa)^2 + (yi - ya)^2 + (zi - za)^2))*-2*(yi - ya) =
                //  = -10*n*(y1 - ya)/(log(10)*((x1 - xa)^2 + (y1 - ya)^2 + (z1 - za)^2)) + 10*n*(yi - ya)/(log(10)*((xi - xa)^2 + (yi - ya)^2 + (zi - za)^2)) =
                //  = 10*n(-(y1 - ya)/(log(10)*d1a^2) + (xi - xa)/(log(10)*dia^2))

                //diff(Prdiff1a)/diff(za) = 5*n/(log(10)*((x1 - xa)^2 + (y1 - ya)^2 + (z1 - za)^2))*-2*(z1 - za) -5*n/(log(10)*((xi - xa)^2 + (yi - ya)^2 + (zi - za)^2))*-2*(zi - za) =
                //  = -10*n*(z1 - za)/(log(10)*((x1 - xa)^2 + (y1 - ya)^2 + (z1 - za)^2)) + 10*n*(zi - za)/(log(10)*((xi - xa)^2 + (yi - ya)^2 + (zi - za)^2)) =
                //  = 10*n(-(z1 - za)/(log(10)*d1a^2) + (zi - za)/(log(10)*dia^2))

                //for other radio source pb=(xb,yb)
                //diff(Prdiff1a)/diff(xb) = diff(Prdiff1a)/diff(yb) = 0

<span class="fc" id="L1255">                final int dims = NonLinearFingerprintPositionAndRadioSourceEstimator.this.</span>
<span class="fc" id="L1256">                        getNumberOfDimensions();</span>

                //path loss exponent
<span class="fc" id="L1259">                final double n = point[0];</span>

<span class="fc" id="L1261">                final double ln10 = Math.log(10.0);</span>

<span class="fc" id="L1263">                final int sourceIndex = allSourcesIndices.get(i);</span>
<span class="fc" id="L1264">                final int start = dims * (1 + sourceIndex);</span>

                //d1a^2, d2a^2, ...
<span class="fc" id="L1267">                double distanceFingerprint2 = 0.0;</span>

                //dia^2, dib^2, ...
<span class="fc" id="L1270">                double distancePoint2 = 0.0;</span>
<span class="fc bfc" id="L1271" title="All 2 branches covered.">                for (int j = 0; j &lt; dims; j++) {</span>
                    //fingerprint coordinate p1=(x1,y1,z1), ...
<span class="fc" id="L1273">                    final double fingerprintCoord = point[1 + j];</span>

                    //unknown point &quot;pi&quot; coordinate
<span class="fc" id="L1276">                    final double pointCoord = params[j];</span>

                    //radio source coordinate pa=(xa,ya,za), ...
<span class="fc" id="L1279">                    final double sourceCoord = params[start + j];</span>

                    //x1 - xa, y1 - ya, ...
<span class="fc" id="L1282">                    final double diffFingerprint = fingerprintCoord - sourceCoord;</span>

                    //xi - xa, yi - ya, ...
<span class="fc" id="L1285">                    final double diffPoint = pointCoord - sourceCoord;</span>

<span class="fc" id="L1287">                    final double diffFingerprint2 = diffFingerprint * diffFingerprint;</span>
<span class="fc" id="L1288">                    final double diffPoint2 = diffPoint * diffPoint;</span>

<span class="fc" id="L1290">                    distanceFingerprint2 += diffFingerprint2;</span>
<span class="fc" id="L1291">                    distancePoint2 += diffPoint2;</span>
                }

<span class="fc" id="L1294">                distanceFingerprint2 = Math.max(distanceFingerprint2, TINY);</span>
<span class="fc" id="L1295">                distancePoint2 = Math.max(distancePoint2, TINY);</span>

<span class="fc" id="L1297">                final double result = 5 * n * (Math.log10(distanceFingerprint2) -</span>
<span class="fc" id="L1298">                        Math.log10(distancePoint2));</span>


                //we clear derivatives array to ensure that derivatives respect other
                //radio sources are zero
<span class="fc" id="L1303">                Arrays.fill(derivatives, 0.0);</span>

<span class="fc bfc" id="L1305" title="All 2 branches covered.">                for (int j = 0; j &lt; dims; j++) {</span>
                    //fingerprint coordinate p1=(x1,y1,z1), ...
<span class="fc" id="L1307">                    final double fingerprintCoord = point[1 + j];</span>

                    //unknown point &quot;pi&quot; coordinate
<span class="fc" id="L1310">                    final double pointCoord = params[j];</span>

                    //radio source coordinate pa=(xa,ya,za), ...
<span class="fc" id="L1313">                    final double sourceCoord = params[start + j];</span>

                    //x1 - xa, y1 - ya, ...
<span class="fc" id="L1316">                    final double diffFingerprint = fingerprintCoord - sourceCoord;</span>

                    //xi - xa, yi - ya, ...
<span class="fc" id="L1319">                    final double diffPoint = pointCoord - sourceCoord;</span>


                    //Example: diff(Prdiff1a)/diff(xi) =  -10*n*(xi - xa)/(log(10)*dia^2)
<span class="fc" id="L1323">                    final double derivativePointCoord = -10.0 * n * diffPoint / (ln10 * distancePoint2);</span>

                    //Example: diff(Prdiff1a)/diff(xa) = 10*n*(-(x1 - xa)/(log(10)*d1a^2) + (xi - xa)/(log(10)*dia^2)) =
                    //  -10*n*(x1 - xa)/(log(10)*d1a^2) - diff(Prdiff1a)/diff(xi)
<span class="fc" id="L1327">                    final double derivativeSameRadioSourceCoord =</span>
                            -10.0 * n * diffFingerprint / (ln10 * distanceFingerprint2)
                                    - derivativePointCoord;

                    //derivatives respect point pi = (xi, yi, zi)
<span class="fc" id="L1332">                    derivatives[j] = derivativePointCoord;</span>

                    //derivatives respect same radio source pa = (xa, ya, za)
<span class="fc" id="L1335">                    derivatives[dims * (1 + sourceIndex) + j] = derivativeSameRadioSourceCoord;</span>
                }

<span class="fc" id="L1338">                return result;</span>
            }
        });

        try {
            //In 2D we know that for fingerprint &quot;1&quot; and radio source &quot;a&quot;:
            //Prdiff1a = Pr(pi) - Pr(p1) = 5*n*log(d1a^2) - 5*n*log(dia^2) =
            //  = 5*n*log((x1 - xa)^2 + (y1 - ya)^2) - 5*n*log((xi - xa)^2 + (yi - ya)^2)

            //Therefore x must have 1 + dims columns (for path-loss n and fingerprint position (x1,y1)

<span class="fc" id="L1349">            final Matrix x = new Matrix(totalReadings, n);</span>
<span class="fc" id="L1350">            final double[] y = new double[totalReadings];</span>
<span class="fc" id="L1351">            final double[] standardDeviations = new double[totalReadings];</span>
<span class="fc bfc" id="L1352" title="All 2 branches covered.">            for (int i = 0; i &lt; totalReadings; i++) {</span>
                //path loss exponent
<span class="fc" id="L1354">                x.setElementAt(i, 0, allPathLossExponents.get(i));</span>

<span class="fc" id="L1356">                final P fingerprintPosition = allFingerprintPositions.get(i);</span>
<span class="fc" id="L1357">                int col = 1;</span>
<span class="fc bfc" id="L1358" title="All 2 branches covered.">                for (int j = 0; j &lt; dims; j++) {</span>
<span class="fc" id="L1359">                    x.setElementAt(i, col,</span>
<span class="fc" id="L1360">                            fingerprintPosition.getInhomogeneousCoordinate(j));</span>
<span class="fc" id="L1361">                    col++;</span>
                }

<span class="fc" id="L1364">                y[i] = allPowerDiffs.get(i);</span>

<span class="fc" id="L1366">                standardDeviations[i] = allStandardDeviations.get(i);</span>
            }

<span class="fc" id="L1369">            mFitter.setInputData(x, y, standardDeviations);</span>

<span class="fc" id="L1371">            return allSourcesToBeEstimated;</span>
<span class="fc" id="L1372">        } catch (final AlgebraException e) {</span>
<span class="fc" id="L1373">            throw new FittingException(e);</span>
        }
    }

    /**
     * Gets the total number of readings associated to provided radio source.
     * This method uses only current nearest fingerprints.
     *
     * @param source       radio source to be checked
     * @param centroid     centroid to be computed.
     * @param fingerprints fingerprints where search is made.
     * @return total number of readings associated to provided radio source.
     */
    private int totalReadingsForSource(
            final RadioSource source,
            final List&lt;RssiFingerprintLocated&lt;RadioSource, RssiReading&lt;RadioSource&gt;, P&gt;&gt; fingerprints,
            final P centroid) {
<span class="pc bpc" id="L1390" title="1 of 2 branches missed.">        if (source == null) {</span>
<span class="nc" id="L1391">            return 0;</span>
        }

<span class="fc" id="L1394">        final int dims = getNumberOfDimensions();</span>

<span class="fc" id="L1396">        int result = 0;</span>
<span class="fc bfc" id="L1397" title="All 2 branches covered.">        final double[] centroidCoords = centroid != null ?</span>
<span class="fc" id="L1398">                new double[dims] : null;</span>

<span class="fc bfc" id="L1400" title="All 2 branches covered.">        for (final RssiFingerprintLocated&lt;RadioSource, RssiReading&lt;RadioSource&gt;, P&gt; fingerprint : fingerprints) {</span>
<span class="fc" id="L1401">            final List&lt;RssiReading&lt;RadioSource&gt;&gt; readings = fingerprint.getReadings();</span>
<span class="pc bpc" id="L1402" title="1 of 2 branches missed.">            if (readings == null) {</span>
<span class="nc" id="L1403">                continue;</span>
            }

<span class="fc" id="L1406">            final P fingerprintPosition = fingerprint.getPosition();</span>

<span class="fc bfc" id="L1408" title="All 2 branches covered.">            for (final RssiReading&lt;RadioSource&gt; reading : readings) {</span>
<span class="fc" id="L1409">                final RadioSource readingSource = reading.getSource();</span>
<span class="pc bpc" id="L1410" title="1 of 4 branches missed.">                if (readingSource != null &amp;&amp; readingSource.equals(source)) {</span>
<span class="fc" id="L1411">                    result++;</span>

<span class="fc bfc" id="L1413" title="All 2 branches covered.">                    if (centroid != null) {</span>
<span class="fc bfc" id="L1414" title="All 2 branches covered.">                        for (int i = 0; i &lt; dims; i++) {</span>
<span class="fc" id="L1415">                            final double coord = fingerprintPosition.getInhomogeneousCoordinate(i);</span>
<span class="fc" id="L1416">                            centroidCoords[i] += coord;</span>
                        }
                    }
                }
<span class="fc" id="L1420">            }</span>
<span class="fc" id="L1421">        }</span>

<span class="fc bfc" id="L1423" title="All 2 branches covered.">        if (centroid != null) {</span>
<span class="fc bfc" id="L1424" title="All 2 branches covered.">            for (int i = 0; i &lt; dims; i++) {</span>
<span class="fc" id="L1425">                centroidCoords[i] /= result;</span>
<span class="fc" id="L1426">                centroid.setInhomogeneousCoordinate(i, centroidCoords[i]);</span>
            }
        }

<span class="fc" id="L1430">        return result;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>