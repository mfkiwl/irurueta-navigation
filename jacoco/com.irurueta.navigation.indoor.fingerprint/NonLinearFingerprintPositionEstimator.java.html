<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>NonLinearFingerprintPositionEstimator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.irurueta:irurueta-navigation</a> &gt; <a href="index.source.html" class="el_package">com.irurueta.navigation.indoor.fingerprint</a> &gt; <span class="el_source">NonLinearFingerprintPositionEstimator.java</span></div><h1>NonLinearFingerprintPositionEstimator.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2018 Alberto Irurueta Carro (alberto@irurueta.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.irurueta.navigation.indoor.fingerprint;

import com.irurueta.algebra.AlgebraException;
import com.irurueta.algebra.Matrix;
import com.irurueta.geometry.Point;
import com.irurueta.navigation.LockedException;
import com.irurueta.navigation.NotReadyException;
import com.irurueta.navigation.indoor.*;
import com.irurueta.numerical.EvaluationException;
import com.irurueta.numerical.NumericalException;
import com.irurueta.numerical.fitting.FittingException;
import com.irurueta.numerical.fitting.LevenbergMarquardtMultiDimensionFitter;
import com.irurueta.numerical.fitting.LevenbergMarquardtMultiDimensionFunctionEvaluator;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;

/**
 * Base class for position estimators based on located fingerprints containing only
 * RSSI readings and having as well prior knowledge of the location of radio sources
 * associated to those readings.
 * This implementation uses a Taylor approximation over provided located
 * fingerprints to determine an approximate position for a non-located fingerprint using
 * a non-linear solving algorithm.
 * An initial position can be provided as a starting point to solve the position,
 * otherwise the average point of selected nearest fingerprints is used as a starting
 * point.
 *
 * @param &lt;P&gt; a {@link Point} type.
 */
@SuppressWarnings(&quot;WeakerAccess&quot;)
public abstract class NonLinearFingerprintPositionEstimator&lt;P extends Point&lt;?&gt;&gt; extends
        FingerprintPositionEstimator&lt;P&gt; {

    /**
     * Default RSSI standard deviation assumed for provided fingerprints as a fallback
     * when none can be determined.
     */
    public static final double FALLBACK_RSSI_STANDARD_DEVIATION = 1.0;

    /**
     * Indicates that by default measured RSSI standard deviation of closest fingerprint
     * must be propagated into measured RSSI reading variance at unknown location.
     */
    public static final boolean DEFAULT_PROPAGATE_FINGERPRINT_RSSI_STANDARD_DEVIATION = true;

    /**
     * Indicates that by default path-loss exponent standard deviation of radio source
     * must be propagated into measured RSSI reading variance at unknown location.
     */
    public static final boolean DEFAULT_PROPAGATE_PATHLOSS_EXPONENT_STANDARD_DEVIATION = true;

    /**
     * Indicates that by default covariance of closest fingerprint position must be
     * propagated into measured RSSI reading variance at unknown location.
     */
    public static final boolean DEFAULT_PROPAGATE_FINGERPRINT_POSITION_COVARIANCE = true;

    /**
     * Indicates that by default covariance of radio source position must be propagated
     * into measured RSSI reading variance at unknown location.
     */
    public static final boolean DEFAULT_PROPAGATE_RADIO_SOURCE_POSITION_COVARIANCE = true;

    /**
     * Default type to be used when none is provided.
     */
<span class="fc" id="L84">    public static final NonLinearFingerprintPositionEstimatorType DEFAULT_TYPE =</span>
            NonLinearFingerprintPositionEstimatorType.THIRD_ORDER;

    /**
     * Small value to be used as the minimum allowed RSSI standard deviations. A value
     * larger than this must be provided to allow convergence to a solution
     */
    public static final double TINY_RSSI_STD = 1e-12;

    /**
     * Initial position to start the solving algorithm.
     * This should be a value close to the expected solution.
     * If no value is provided, the average position among all selected nearest
     * located fingerprints will be used.
     */
    private P mInitialPosition;

    /**
     * RSSI standard deviation fallback value to use when none can be
     * determined from provided readings. This fallback value is only used if
     * no variance is propagated or the resulting value is too small to allow
     * convergence to a solution.
     */
<span class="fc" id="L107">    private double mFallbackRssiStandardDeviation =</span>
            FALLBACK_RSSI_STANDARD_DEVIATION;

    /**
     * Indicates whether measured RSSI standard deviation of closest fingerprint must
     * be propagated into measured RSSI reading variance at unknown location.
     */
<span class="fc" id="L114">    private boolean mPropagateFingerprintRssiStandardDeviation =</span>
            DEFAULT_PROPAGATE_FINGERPRINT_RSSI_STANDARD_DEVIATION;

    /**
     * Indicates whether path-loss exponent standard deviation of radio source must
     * be propagated into measured RSSI reading variance at unknown location.
     */
<span class="fc" id="L121">    private boolean mPropagatePathlossExponentStandardDeviation =</span>
            DEFAULT_PROPAGATE_PATHLOSS_EXPONENT_STANDARD_DEVIATION;

    /**
     * Indicates whether covariance of closest fingerprint position must be
     * propagated into measured RSSI reading variance at unknown location.
     */
<span class="fc" id="L128">    private boolean mPropagateFingerprintPositionCovariance =</span>
            DEFAULT_PROPAGATE_FINGERPRINT_POSITION_COVARIANCE;

    /**
     * Indicates whether covariance of radio source position must be propagated
     * into measured RSSI reading variance at unknown location.
     */
<span class="fc" id="L135">    private boolean mPropagateRadioSourcePositionCovariance =</span>
            DEFAULT_PROPAGATE_RADIO_SOURCE_POSITION_COVARIANCE;

    /**
     * Levenberg-Marquardt fitter to find a non-linear solution.
     */
<span class="fc" id="L141">    private final LevenbergMarquardtMultiDimensionFitter mFitter = new LevenbergMarquardtMultiDimensionFitter();</span>

    /**
     * Estimated covariance matrix for estimated position.
     */
    private Matrix mCovariance;

    /**
     * Estimated chi square value.
     */
    private double mChiSq;

    /**
     * Constructor.
     */
<span class="fc" id="L156">    public NonLinearFingerprintPositionEstimator() {</span>
<span class="fc" id="L157">    }</span>

    /**
     * Constructor.
     *
     * @param listener listener in charge of handling events.
     */
    public NonLinearFingerprintPositionEstimator(
            final FingerprintPositionEstimatorListener&lt;P&gt; listener) {
<span class="fc" id="L166">        super(listener);</span>
<span class="fc" id="L167">    }</span>

    /**
     * Constructor.
     *
     * @param locatedFingerprints located fingerprints containing RSSI readings.
     * @param fingerprint         fingerprint containing readings at an unknown location
     *                            for provided located fingerprints.
     * @param sources             located radio sources.
     * @throws IllegalArgumentException if provided non located fingerprint is null,
     *                                  located fingerprints value is null or there are not enough fingerprints or
     *                                  readings within provided fingerprints (for 2D position estimation at least 2
     *                                  located total readings are required among all fingerprints, for example 2
     *                                  readings are required in a single fingerprint, or at least 2 fingerprints at
     *                                  different locations containing a single reading are required. For 3D position
     *                                  estimation 3 located total readings are required among all fingerprints).
     */
    public NonLinearFingerprintPositionEstimator(
            final List&lt;? extends RssiFingerprintLocated&lt;? extends RadioSource,
                    ? extends RssiReading&lt;? extends RadioSource&gt;, P&gt;&gt; locatedFingerprints,
            final RssiFingerprint&lt;? extends RadioSource,
                    ? extends RssiReading&lt;? extends RadioSource&gt;&gt; fingerprint,
            final List&lt;? extends RadioSourceLocated&lt;P&gt;&gt; sources) {
<span class="fc" id="L190">        super(locatedFingerprints, fingerprint, sources);</span>
<span class="fc" id="L191">    }</span>

    /**
     * Constructor.
     *
     * @param locatedFingerprints located fingerprints containing RSSI readings.
     * @param fingerprint         fingerprint containing readings at an unknown location
     *                            for provided located fingerprints.
     * @param sources             located radio sources.
     * @param listener            listener in charge of handling events.
     * @throws IllegalArgumentException if provided non located fingerprint is null,
     *                                  located fingerprints value is null or there are not enough fingerprints or
     *                                  readings within provided fingerprints (for 2D position estimation at least 2
     *                                  located total readings are required among all fingerprints, for example 2
     *                                  readings are required in a single fingerprint, or at least 2 fingerprints at
     *                                  different locations containing a single reading are required. For 3D position
     *                                  estimation 3 located total readings are required among all fingerprints).
     */
    public NonLinearFingerprintPositionEstimator(
            final List&lt;? extends RssiFingerprintLocated&lt;? extends RadioSource,
                    ? extends RssiReading&lt;? extends RadioSource&gt;, P&gt;&gt; locatedFingerprints,
            final RssiFingerprint&lt;? extends RadioSource,
                    ? extends RssiReading&lt;? extends RadioSource&gt;&gt; fingerprint,
            final List&lt;? extends RadioSourceLocated&lt;P&gt;&gt; sources,
            final FingerprintPositionEstimatorListener&lt;P&gt; listener) {
<span class="fc" id="L216">        super(locatedFingerprints, fingerprint, sources, listener);</span>
<span class="fc" id="L217">    }</span>

    /**
     * Constructor.
     *
     * @param locatedFingerprints located fingerprints containing RSSI readings.
     * @param fingerprint         fingerprint containing readings at an unknown location
     *                            for provided located fingerprints.
     * @param sources             located radio sources.
     * @param initialPosition     initial position to start the solving algorithm or null.
     * @throws IllegalArgumentException if provided non located fingerprint is null,
     *                                  located fingerprints value is null or there are not enough fingerprints or
     *                                  readings within provided fingerprints (for 2D position estimation at least 2
     *                                  located total readings are required among all fingerprints, for example 2
     *                                  readings are required in a single fingerprint, or at least 2 fingerprints at
     *                                  different locations containing a single reading are required. For 3D position
     *                                  estimation 3 located total readings are required among all fingerprints).
     */
    public NonLinearFingerprintPositionEstimator(
            final List&lt;? extends RssiFingerprintLocated&lt;? extends RadioSource,
                    ? extends RssiReading&lt;? extends RadioSource&gt;, P&gt;&gt; locatedFingerprints,
            final RssiFingerprint&lt;? extends RadioSource,
                    ? extends RssiReading&lt;? extends RadioSource&gt;&gt; fingerprint,
            final List&lt;? extends RadioSourceLocated&lt;P&gt;&gt; sources, P initialPosition) {
<span class="fc" id="L241">        super(locatedFingerprints, fingerprint, sources);</span>
<span class="fc" id="L242">        mInitialPosition = initialPosition;</span>
<span class="fc" id="L243">    }</span>

    /**
     * Constructor.
     *
     * @param locatedFingerprints located fingerprints containing RSSI readings.
     * @param fingerprint         fingerprint containing readings at an unknown location
     *                            for provided located fingerprints.
     * @param sources             located radio sources.
     * @param initialPosition     initial position to start the solving algorithm or null.
     * @param listener            listener in charge of handling events.
     * @throws IllegalArgumentException if provided non located fingerprint is null,
     *                                  located fingerprints value is null or there are not enough fingerprints or
     *                                  readings within provided fingerprints (for 2D position estimation at least 2
     *                                  located total readings are required among all fingerprints, for example 2
     *                                  readings are required in a single fingerprint, or at least 2 fingerprints at
     *                                  different locations containing a single reading are required. For 3D position
     *                                  estimation 3 located total readings are required among all fingerprints).
     */
    public NonLinearFingerprintPositionEstimator(
            final List&lt;? extends RssiFingerprintLocated&lt;? extends RadioSource,
                    ? extends RssiReading&lt;? extends RadioSource&gt;, P&gt;&gt; locatedFingerprints,
            final RssiFingerprint&lt;? extends RadioSource,
                    ? extends RssiReading&lt;? extends RadioSource&gt;&gt; fingerprint,
            final List&lt;? extends RadioSourceLocated&lt;P&gt;&gt; sources, P initialPosition,
            final FingerprintPositionEstimatorListener&lt;P&gt; listener) {
<span class="fc" id="L269">        super(locatedFingerprints, fingerprint, sources, listener);</span>
<span class="fc" id="L270">        mInitialPosition = initialPosition;</span>
<span class="fc" id="L271">    }</span>

    /**
     * Gets initial position to start the solving algorithm.
     * This should be a value close to the expected solution.
     * If no value is provided, the average position among all selected nearest
     * located fingerprints will be used.
     *
     * @return initial position to start the solving algorithm or null.
     */
    public P getInitialPosition() {
<span class="fc" id="L282">        return mInitialPosition;</span>
    }

    /**
     * Sets initial position to start the solving algorithm.
     * This should be a value close to the expected solution.
     * If no value is provided, the average position among all selected nearest
     * located fingerprints will be used.
     *
     * @param initialPosition initial position to start the solving algorithm or null.
     * @throws LockedException if estimator is locked.
     */
    public void setInitialPosition(final P initialPosition) throws LockedException {
<span class="fc bfc" id="L295" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L296">            throw new LockedException();</span>
        }

<span class="fc" id="L299">        mInitialPosition = initialPosition;</span>
<span class="fc" id="L300">    }</span>

    /**
     * Gets RSSI standard deviation fallback value to use when none can be
     * determined from provided readings.
     *
     * @return RSSI standard deviation fallback.
     */
    public double getFallbackRssiStandardDeviation() {
<span class="fc" id="L309">        return mFallbackRssiStandardDeviation;</span>
    }

    /**
     * Sets RSSI standard deviation fallback value to use when none can be
     * determined from provided readings.
     *
     * @param fallbackRssiStandardDeviation RSSI standard deviation fallback
     * @throws LockedException          if estimator is locked.
     * @throws IllegalArgumentException if provided value is smaller than
     *                                  {@link #TINY_RSSI_STD}.
     */
    public void setFallbackRssiStandardDeviation(
            final double fallbackRssiStandardDeviation) throws LockedException {
<span class="fc bfc" id="L323" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L324">            throw new LockedException();</span>
        }
<span class="pc bpc" id="L326" title="1 of 2 branches missed.">        if (fallbackRssiStandardDeviation &lt; TINY_RSSI_STD) {</span>
<span class="nc" id="L327">            throw new IllegalArgumentException();</span>
        }
<span class="fc" id="L329">        mFallbackRssiStandardDeviation = fallbackRssiStandardDeviation;</span>
<span class="fc" id="L330">    }</span>

    /**
     * Indicates whether measured RSSI standard deviation of closest fingerprint must be
     * propagated into measured RSSI reading variance at unknown location.
     *
     * @return true to propagate RSSI standard deviation of closest fingerprint,
     * false otherwise.
     */
    public boolean isFingerprintRssiStandardDeviationPropagated() {
<span class="fc" id="L340">        return mPropagateFingerprintRssiStandardDeviation;</span>
    }

    /**
     * Specifies whether measured RSSI standard deviation of closest fingerprint must be
     * propagated into measured RSSI reading variance at unknown location.
     *
     * @param propagateFingerprintRssiStandardDeviation true to propagate RSSI standard
     *                                                  deviation of closest fingerprint,
     *                                                  false otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setFingerprintRssiStandardDeviationPropagated(
            final boolean propagateFingerprintRssiStandardDeviation) throws LockedException {
<span class="fc bfc" id="L354" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L355">            throw new LockedException();</span>
        }
<span class="fc" id="L357">        mPropagateFingerprintRssiStandardDeviation =</span>
                propagateFingerprintRssiStandardDeviation;
<span class="fc" id="L359">    }</span>

    /**
     * Indicates whether path-loss exponent standard deviation of radio source must be
     * propagated into measured RSSI reading variance at unknown location.
     *
     * @return true to propagate  path-loss exponent standard deviation of radio source,
     * false otherwise.
     */
    public boolean isPathlossExponentStandardDeviationPropagated() {
<span class="fc" id="L369">        return mPropagatePathlossExponentStandardDeviation;</span>
    }

    /**
     * Specifies whether path-loss exponent standard deviation of radio source must be
     * propagated into measured RSSI reading variance at unknown location.
     *
     * @param propagatePathlossExponentStandardDeviation true to propagate path-loss
     *                                                   exponent standard deviation of
     *                                                   radio source, false otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setPathlossExponentStandardDeviationPropagated(
            final boolean propagatePathlossExponentStandardDeviation) throws LockedException {
<span class="fc bfc" id="L383" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L384">            throw new LockedException();</span>
        }
<span class="fc" id="L386">        mPropagatePathlossExponentStandardDeviation =</span>
                propagatePathlossExponentStandardDeviation;
<span class="fc" id="L388">    }</span>

    /**
     * Indicates whether covariance of closest fingerprint position must be propagated
     * into measured RSSI reading variance at unknown location.
     *
     * @return true to propagate fingerprint position covariance, false otherwise.
     */
    public boolean isFingerprintPositionCovariancePropagated() {
<span class="fc" id="L397">        return mPropagateFingerprintPositionCovariance;</span>
    }

    /**
     * Specifies whether covariance of closest fingerprint position must be propagated
     * into measured RSSI reading variance at unknown location.
     *
     * @param propagateFingerprintPositionCovariance true to propagate fingerprint
     *                                               position covariance, false otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setFingerprintPositionCovariancePropagated(
            final boolean propagateFingerprintPositionCovariance) throws LockedException {
<span class="fc bfc" id="L410" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L411">            throw new LockedException();</span>
        }
<span class="fc" id="L413">        mPropagateFingerprintPositionCovariance =</span>
                propagateFingerprintPositionCovariance;
<span class="fc" id="L415">    }</span>

    /**
     * Indicates whether covariance of radio source position must be propagated into
     * measured RSSI reading variance at unknown location.
     *
     * @return true to propagate radio source position covariance, false otherwise.
     */
    public boolean isRadioSourcePositionCovariancePropagated() {
<span class="fc" id="L424">        return mPropagateRadioSourcePositionCovariance;</span>
    }

    /**
     * Specifies whether covariance of radio source position must be propagated into
     * measured RSSI reading variance at unknown location.
     *
     * @param propagateRadioSourcePositionCovariance true to propagate radio source
     *                                               position covariance, false otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setRadioSourcePositionCovariancePropagated(
            final boolean propagateRadioSourcePositionCovariance) throws LockedException {
<span class="fc bfc" id="L437" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L438">            throw new LockedException();</span>
        }
<span class="fc" id="L440">        mPropagateRadioSourcePositionCovariance =</span>
                propagateRadioSourcePositionCovariance;
<span class="fc" id="L442">    }</span>

    /**
     * Gets estimated covariance matrix for estimated position.
     *
     * @return estimated covariance matrix for estimated position.
     */
    public Matrix getCovariance() {
<span class="fc" id="L450">        return mCovariance;</span>
    }

    /**
     * Gets estimated chi square value.
     *
     * @return estimated chi square value.
     */
    public double getChiSq() {
<span class="fc" id="L459">        return mChiSq;</span>
    }

    /**
     * Estimates position based on provided located radio sources and readings of such radio sources at
     * an unknown location.
     *
     * @throws LockedException                if estimator is locked.
     * @throws NotReadyException              if estimator is not ready.
     * @throws FingerprintEstimationException if estimation fails for some other reason.
     */
    @Override
    @SuppressWarnings(&quot;Duplicates&quot;)
    public void estimate() throws LockedException, NotReadyException,
            FingerprintEstimationException {

<span class="pc bpc" id="L475" title="1 of 2 branches missed.">        if (!isReady()) {</span>
<span class="nc" id="L476">            throw new NotReadyException();</span>
        }
<span class="fc bfc" id="L478" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L479">            throw new LockedException();</span>
        }

        try {
<span class="fc" id="L483">            mLocked = true;</span>

<span class="pc bpc" id="L485" title="1 of 2 branches missed.">            if (mListener != null) {</span>
<span class="fc" id="L486">                mListener.onEstimateStart(this);</span>
            }

<span class="fc" id="L489">            RadioSourceNoMeanKNearestFinder&lt;P, RadioSource&gt; noMeanfinder = null;</span>
<span class="fc" id="L490">            RadioSourceKNearestFinder&lt;P, RadioSource&gt; finder = null;</span>
<span class="fc bfc" id="L491" title="All 2 branches covered.">            if (mUseNoMeanNearestFingerprintFinder) {</span>
                //noinspection unchecked
<span class="fc" id="L493">                noMeanfinder = new RadioSourceNoMeanKNearestFinder&lt;&gt;(</span>
                        (Collection&lt;? extends RssiFingerprintLocated&lt;RadioSource,
                                RssiReading&lt;RadioSource&gt;, P&gt;&gt;) mLocatedFingerprints);
            } else {
                //noinspection unchecked
<span class="fc" id="L498">                finder = new RadioSourceKNearestFinder&lt;&gt;(</span>
                        (Collection&lt;? extends RssiFingerprintLocated&lt;RadioSource,
                                RssiReading&lt;RadioSource&gt;, P&gt;&gt;) mLocatedFingerprints);
            }

<span class="fc" id="L503">            mEstimatedPositionCoordinates = null;</span>
<span class="fc" id="L504">            mCovariance = null;</span>
<span class="fc" id="L505">            mNearestFingerprints = null;</span>

<span class="pc bpc" id="L507" title="1 of 2 branches missed.">            final int max = mMaxNearestFingerprints &lt; 0 ?</span>
<span class="fc" id="L508">                    mLocatedFingerprints.size() :</span>
<span class="pc" id="L509">                    Math.min(mMaxNearestFingerprints, mLocatedFingerprints.size());</span>
<span class="pc bpc" id="L510" title="1 of 2 branches missed.">            for (int k = mMinNearestFingerprints; k &lt;= max; k++) {</span>
<span class="fc bfc" id="L511" title="All 2 branches covered.">                if (noMeanfinder != null) {</span>
                    //noinspection unchecked
<span class="fc" id="L513">                    mNearestFingerprints = noMeanfinder.findKNearestTo(</span>
                            (RssiFingerprint&lt;RadioSource, RssiReading&lt;RadioSource&gt;&gt;) mFingerprint, k);
                } else {
                    //noinspection unchecked
<span class="fc" id="L517">                    mNearestFingerprints = finder.findKNearestTo(</span>
                            (RssiFingerprint&lt;RadioSource, RssiReading&lt;RadioSource&gt;&gt;) mFingerprint, k);
                }

                //Demonstration in 2D:
                //--------------------
                //Taylor series expansion can be expressed as:
                //f(x) = f(a) + 1/1!*f'(a)*(x - a) + 1/2!*f''(a)*(x - a)^2 + ...

                //where f'(x) is the derivative of f respect x, which can also be expressed as:
                //f'(x) = diff(f(x))/diff(x)

                //and f'(a) is the derivative of f respect x evaluated at a, which can be expressed
                //as f'(a) = diff(f(a))/diff(x)

                //consequently f''(a) is the second derivative respect x evaluated at a, which can
                //be expressed as:
                //f''(x) = diff(f(x))/diff(x^2)

                //and:
                //f''(a) = diff(f(a))/diff(x^2)

                //Received power expressed in dBm is:
                //k = (c/(4*pi*f))
                //Pr = Pte*k^n / d^n

                //where c is the speed of light, pi is 3.14159..., f is the frequency of the radio source,
                //Pte is the equivalent transmitted power by the radio source, n is the path-loss exponent
                // (typically 2.0), and d is the distance from a point to the location of the radio source.

                //Hence:
                //Pr(dBm) = 10*log(Pte*k^n/d^n) = 10*n*log(k) + 10*log(Pte) - 10*n*log(d) =
                //          10*n*log(k) + 10*log(Pte) - 5*n*log(d^2)

                //The former 2 terms are constant, and only the last term depends on distance

                //Hence, assuming the constant K = 10*n*log(k) + Pte(dBm), where Pte(dBm) = 10*log(Pte),
                //assuming that transmitted power by the radio source Pte is known (so that K is also known),
                //and assuming that the location of the radio source is known and it is located at pa = (xa, ya)
                //so that d^2 = (x - xa)^2 + (y - ya)^2 then the received power at an unknown point pi = (xi, yi) is:

                //Pr(pi) = Pr(xi,yi) = K - 5*n*log(d^2) = K - 5*n*log((xi - xa)^2 + (yi - ya)^2)

                //Suppose that received power at point p1=(x1,y1) is known on a located fingerprint
                //containing readings Pr(p1).

                //Then, for an unknown point pi=(xi,yi) close to fingerprint 1 located at p1 where we
                //have measured received power Pr(pi), we can get the following second-order Taylor
                //approximation:

                //Pr(pi) ~ Pr(p1) + JPr(p1)*(pi - p1) + 1/2*(pi - p1)^T*HPr(p1)*(pi - p1) + ...

                //where JPr(p1) is the Jacobian of Pr evaluated at p1. Since Pr is a multivariate function
                //with scalar result, the Jacobian has size 1x2 and is equal to the gradient.
                //HPr(p1) is the Hessian matrix evaluated at p1, which is a symmetric matrix of size 2x2,
                //and (pi-p1)^T is the transposed vector of (pi-p1)

                //Hence, the Jacobian at any point p=(x,y) is equal to:
                //JPr(p = (x,y)) = [diff(Pr(x,y))/diff(x)   diff(Pr(x,y))/diff(y)]

                //And the Hessian matrix is equal to
                //HPr(p = (x,y)) =  [diff(Pr(x,y))/diff(x^2)    diff(Pr(x,y))/diff(x*y)]
                //                  [diff(Pr(x,y))/diff(x*y)    diff(Pr(x,y))/diff(y^2)]

                //where the first order derivatives of Pr(p = (x,y)) are:
                //diff(Pr(x,y))/diff(x) = -5*n/(ln(10)*((x - xa)^2 + (y - ya)^2)*2*(x - xa)
                //diff(Pr(x,y))/diff(x) = -10*n*(x - xa)/(ln(10)*((x - xa)^2 + (y - ya)^2))

                //diff(Pr(x,y))/diff(y) = -5*n/(ln(10)*((x - xa)^2 + (y - ya)^2)*2*(y - ya)
                //diff(Pr(x,y))/diff(y) = -10*n*(y - ya)/(ln(10)*((x - xa)^2 + (y - ya)^2))

                //If we evaluate first order derivatives at p1 = (x1,y1), we get:
                //diff(Pr(p1))/diff(x) = -10*n*(x1 - xa)/(ln(10)*((x1 - xa)^2 + (y1 - ya)^2))
                //diff(Pr(p1))/diff(y) = -10*n*(y1 - ya)/(ln(10)*((x1 - xa)^2 + (y1 - ya)^2))

                //where square distance from fingerprint 1 to radio source a can be expressed as:
                //d1a^2 = (x1 - xa)^2 + (y1 - ya)^2

                //where both the fingerprint and radio source positions are known, and hence d1a is known.

                //Then first order derivatives can be expressed as:
                //diff(Pr(p1))/diff(x) = -10*n*(x1 - xa)/(ln(10)*d1a^2)
                //diff(Pr(p1))/diff(y) = -10*n*(y1 - ya)/(ln(10)*d1a^2)

                //To obtain second order derivatives we take into account that:
                //(f(x)/g(x))' = (f'(x)*g(x) - f(x)*g'(x))/g(x)^2

                //hence, second order derivatives of Pr(p = (x,y)) are:
                //diff(Pr(x,y))/diff(x^2) = -10*n/ln(10)*(1*((x - xa)^2 + (y - ya)^2) - (x - xa)*2*(x - xa)) / ((x - xa)^2 + (y - ya)^2)^2
                //diff(Pr(x,y))/diff(x^2) = -10*n*((y - ya)^2 - (x - xa)^2)/(ln(10)*((x - xa)^2 + (y - ya)^2)^2)

                //diff(Pr(x,y))/diff(y^2) = -10*n/ln(10)*(1*((x - xa)^2 + (y - ya)^2) - (y - ya)*2*(y - ya)) / ((x - xa)^2 + (y - ya)^2)^2
                //diff(Pr(x,y))/diff(y^2) = -10*n*((x - xa)^2 - (y - ya)^2)/(ln(10)*((x - xa)^2 + (y - ya)^2)^2)

                //diff(Pr(x,y))/diff(x*y) = -10*n/ln(10)*(0*((x - xa)^2 + (y - ya)^2) - (x - xa)*2*(y - ya))/((x - xa)^2 + (y - ya)^2)^2
                //diff(Pr(x,y))/diff(x*y) = 20*n*((x - xa)*(y - ya))/(ln(10)*((x - xa)^2 + (y - ya)^2)^2)

                //If we evaluate second order derivatives at p1 = (x1,y1), we get:
                //diff(Pr(p1))/diff(x^2) = -10*n*((y1 - ya)^2 - (x1 - xa)^2))/(ln(10)*((x1 - xa)^2 + (y1 - ya)^2)^2)
                //diff(Pr(p1))/diff(y^2) = -10*n*((x1 - xa)^2 - (y1 - ya)^2)/(ln(10)*((x1 - xa)^2 + (y1 - ya)^2)^2)
                //diff(Pr(p1))/diff(x*y) = 20*n*(x1 - xa)*(y1 - ya)/(ln(10)*((x1 - xa)^2 + (y1 - ya)^2)^2)

                //and expressing the second order derivatives in terms of distance between
                //fingerprint 1 and radio source a d1a, we get:
                //diff(Pr(p1))/diff(x^2) = -10*n*((y1 - ya)^2 - (x1 - xa)^2))/(ln(10)*d1a^4)
                //diff(Pr(p1))/diff(y^2) = -10*n*((x1 - xa)^2 - (y1 - ya)^2)/(ln(10)*d1a^4)
                //diff(Pr(p1))/diff(x*y) = 20*n*(x1 - xa)*(y1 - ya)/(ln(10)*d1a^4)

                //Hence, second order Taylor expansion can be expressed as:
                //Pr(pi) = Pr(p1) + diff(Pr(p1))/diff(x)*(xi - x1) + diff(Pr(p1))/diff(y)*(yi - y1) +
                //1/2*diff(Pr(p1))/diff(x^2)*(xi - x1)^2 + 1/2*diff(Pr(p1))/diff(y^2)*(yi - y1)^2 +
                //diff(Pr(p1))/diff(x*y)*(xi - x1)*(yi - y1)

                //Pr(pi) = Pr(p1) - 10*n*(x1 - xa)/(ln(10)*d1a^2)*(xi - x1) -10*n*(y1 - ya)/(ln(10)*d1a^2)*(yi - y1)
                //- 5*n*((y1 - ya)^2 - (x1 - xa)^2)/(ln(10)*d1a^4)*(xi - x1)^2
                //- 5*n*((x1 - xa)^2 - (y1 - ya)^2)/(ln(10)*d1a^4)*(yi - y1)^2 +
                //20*n*(x1 - xa)*(y1 - ya)/(ln(10)*d1a^4))*(xi - x1)*(yi - y1)

                //The equation above can be solved using a non-linear fitter such as Levenberg-Marquardt


                //Demonstration in 3D:
                //--------------------
                //Taylor series expansion can be expressed as:
                //f(x) = f(a) + 1/1!*f'(a)*(x - a) + 1/2!*f''(a)*(x - a)^2 + ...

                //where f'(x) is the derivative of f respect x, which can also be expressed as:
                //f'(x) = diff(f(x))/diff(x)

                //and f'(a) is the derivative of f respect x evaluated at a, which can be expressed
                //as f'(a) = diff(f(a))/diff(x)

                //consequently f''(a) is the second derivative respect x evaluated at a, which can
                //be expressed as:
                //f''(x) = diff(f(x))/diff(x^2)

                //and:
                //f''(a) = diff(f(a))/diff(x^2)

                //Received power expressed in dBm is:
                //k = (c/(4*pi*f))
                //Pr = Pte*k^n / d^n

                //where c is the speed of light, pi is 3.14159..., f is the frequency of the radio source,
                //Pte is the equivalent transmitted power by the radio source, n is the path-loss exponent
                // (typically 2.0), and d is the distance from a point to the location of the radio source.

                //Hence:
                //Pr(dBm) = 10*log(Pte*k^n/d^n) = 10*n*log(k) + 10*log(Pte) - 10*n*log(d) =
                //          10*n*log(k) + 10*log(Pte) - 5*n*log(d^2)

                //The former 2 terms are constant, and only the last term depends on distance

                //Hence, assuming the constant K = 10*n*log(k) + Pte(dBm), where Pte(dBm) = 10*log(Pte),
                //assuming that transmitted power by the radio source Pte is known (so that K is also known),
                //and assuming that the location of the radio source is known and it is located at pa = (xa, ya, za)
                //so that d^2 = (x - xa)^2 + (y - ya)^2 + (z - za)^2 then the received power at an unknown point
                //pi = (xi, yi, zi) is:

                //Pr(pi) = Pr(xi,yi,zi) = K - 5*n*log(d^2) = K - 5*n*log((xi - xa)^2 + (yi - ya)^2 + (zi - za)^2)

                //Suppose that received power at point p1=(x1,y1,z1) is known on a located fingerprint
                //containing readings Pr(p1).

                //Then, for an unknown point pi=(xi,yi,zi) close to fingerprint 1 located at p1 where we
                //have measured received power Pr(pi), we can get the following second-order Taylor
                //approximation:

                //Pr(pi) ~ Pr(p1) + JPtr(p1)*(pi - p1) + 1/2*(pi - p1)^T*HPr(p1)*(pi - p1) + ...

                //where JPr(p1) is the Jacobian of Pr evaluated at p1. Since Pr is a multivariate function
                //with scalar result, the Jacobian has size 1x3 and is equal to the gradient.
                //HPtr(p1) is the Hessian matrix evaluated at p1, which is a symmetric matrix of size 3x3,
                //and (pi-p1)^T is the transposed vector of (pi-p1)

                //Hence, the Jacobian at any point p=(x,y,z) is equal to:
                //JPr(p = (x,y,z)) = [diff(Pr(x,y,z))/diff(x)     diff(Pr(x,y,z))/diff(y)     diff(Pr(x,y,z))/diff(z)]

                //And the Hessian matrix is equal to
                //HPr(p = (x,y,z)) = [diff(Pr(x,y,z))/diff(x^2)    diff(Pr(x,y,z))/diff(x*y)     diff(Pr(x,y,z))/diff(x*z)]
                //                   [diff(Pr(x,y,z))/diff(x*y)    diff(Pr(x,y,z))/diff(y^2)     diff(Pr(x,y,z))/diff(y*z)]
                //                   [diff(Pr(x,y,z))/diff(x*z)    diff(Pr(x,y,z))/diff(y*z)     diff(Pr(x,y,z))/diff(z^2)]

                //where the first order derivatives of Pr(p = (x,y)) are:
                //diff(Pr(x,y,z))/diff(x) = -5*n/(ln(10)*((x - xa)^2 + (y - ya)^2 + (z - za)^2)*2*(x - xa)
                //diff(Pr(x,y,z))/diff(x) = -10*n*(x - xa)/(ln(10)*((x - xa)^2 + (y - ya)^2 + (z - za)^2))

                //diff(Pr(x,y,z))/diff(y) = -5*n/(ln(10)*((x - xa)^2 + (y - ya)^2 + (z - za)^2)*2*(y - ya)
                //diff(Pr(x,y,z))/diff(y) = -10*n*(y - ya)/(ln(10)*((x - xa)^2 + (y - ya)^2 + (z - za)^2))

                //diff(Pr(x,y,z))/diff(z) = -5*n/(ln(10)*((x - xa)^2 + (y - ya)^2 + (z - za)^2)*2*(z - za)
                //diff(Pr(x,y,z))/diff(z) = -10*n*(z - za)/(ln(10)*((x - xa)^2 + (y - ya)^2 + (z - za)^2))

                //If we evaluate derivatives at p1 = (x1,y1,z1), we get:
                //diff(Pr(p1))/diff(x) = -10*n*(x1 - xa)/(ln(10)*((x1 - xa)^2 + (y1 - ya)^2 + (z1 - za)^2))
                //diff(Pr(p1))/diff(y) = -10*n*(y1 - ya)/(ln(10)*((x1 - xa)^2 + (y1 - ya)^2 + (z1 - za)^2))
                //diff(Pr(p1))/diff(z) = -10*n*(z1 - za)/(ln(10)*((x1 - xa)^2 + (y1 - ya)^2 + (z1 - za)^2))

                //where square distance from fingerprint 1 to radio source a can be expressed as:
                //d1a^2 = (x1 - xa)^2 + (y1 - ya)^2 + (z1 - za)^2

                //where both the fingerprint and radio source positions are known, and hence d1a is known.

                //Then first order derivatives can be expressed as:
                //diff(Pr(p1))/diff(x) = -10*n*(x1 - xa)/(ln(10)*d1a^2)
                //diff(Pr(p1))/diff(y) = -10*n*(y1 - ya)/(ln(10)*d1a^2)
                //diff(Pr(p1))/diff(z) = -10*n*(z1 - za)/(ln(10)*d1a^2)

                //To obtain second order derivatives we take into account that:
                //(f(x)/g(x))' = (f'(x)*g(x) - f(x)*g'(x))/g(x)^2

                //hence, second order derivatives of Pr(p = (x,y,z)) are:
                //diff(Pr(x,y,z))/diff(x^2) = -10*n/ln(10)*(1*((x - xa)^2 + (y - ya)^2 + (z - za)^2) - (x - xa)*2*(x - xa))/((x - xa)^2 + (y - ya)^2 + (z - za)^2)^2
                //diff(Pr(x,y,z))/diff(x^2) = -10*n*((y - ya)^2 + (z - za)^2 - (x - xa)^2)/(ln(10)*((x - xa)^2 + (y - ya)^2 + (z - za)^2)^2)

                //diff(Pr(x,y,z))/diff(y^2) = -10*n/ln(10)*(1*((x - xa)^2 + (y - ya)^2 + (z - za)^2) - (y - ya)*2*(y - ya))/((x - xa)^2 + (y - ya)^2 + (z - za)^2)^2
                //diff(Pr(x,y,z))/diff(y^2) = -10*n*((x - xa)^2 - (y - ya)^2 + (z - za)^2)/(ln(10)*((x - xa)^2 + (y - ya)^2 + (z - za)^2)^2)

                //diff(Pr(x,y,z))/diff(z^2) = -10*n/ln(10)*(1*((x - xa)^2 + (y - ya)^2 + (z - za)^2) - (z - za)*2*(z - za))/((x - xa)^2 + (y - ya)^2 + (z - za)^2)^2
                //diff(Pr(x,y,z))/diff(z^2) = -10*n*((x - xa)^2 + (y - ya)^2 - (z - za)^2)/(ln(10)*((x - xa)^2 + (y - ya)^2 + (z - za)^2)^2)

                //diff(Pr(x,y,z))/diff(x*y) = -10*n/ln(10)*(0*((x - xa)^2 + (y - ya)^2 + (z - za)^2) - (x - xa)*2*(y - ya))/((x - xa)^2 + (y - ya)^2 + (z - za)^2)^2
                //diff(Pr(x,y,z))/diff(x*y) = 20*n*(x - xa)*(y - ya)/(ln(10)*((x - xa)^2 + (y - ya)^2 + (z - za)^2)^2)

                //diff(Pr(x,y,z))/diff(x*z) = -10*n/ln(10)*(0*((x - xa)^2 + (y - ya)^2 + (z - za)^2) - (x - xa)*2*(z - za))/((x - xa)^2 + (y - ya)^2 + (z - za)^2)^2
                //diff(Pr(x,y,z))/diff(x*z) = 20*n*(x - xa)*(z - za)/(ln(10)*((x - xa)^2 + (y - ya)^2 + (z - za)^2)^2)

                //diff(Pr(x,y,z))/diff(y*z) = -10*n/ln(10)*(0*((x - xa)^2 + (y - ya)^2 + (z - za)^2) - (y - ya)*2*(z - za))/((x - xa)^2 + (y - ya)^2 + (z - za)^2)^2
                //diff(Pr(x,y,z))/diff(y*z) = 20*n*(y - ya)*(z - za)/(ln(10)*((x - xa)^2 + (y - ya)^2 + (z - za)^2)^2)

                //If we evaluate second order derivatives at p1 = (x1,y1,z1), we get:
                //diff(Pr(p1))/diff(x^2) = -10*n*((y1 - ya)^2 + (z1 - za)^2 - (x1 - xa)^2)/(ln(10)*((x1 - xa)^2 + (y1 - ya)^2 + (z1 - za)^2)^2)
                //diff(Pr(p1))/diff(y^2) = -10*n*((x1 - xa)^2 - (y1 - ya)^2 + (z1 - za)^2)/(ln(10)*((x1 - xa)^2 + (y1 - ya)^2 + (z1 - za)^2)^2)
                //diff(Pr(p1))/diff(z^2) = -10*n*((x1 - xa)^2 + (y1 - ya)^2 - (z1 - za)^2)/(ln(10)*((x1 - xa)^2 + (y1 - ya)^2 + (z1 - za)^2)^2)
                //diff(Pr(p1))/diff(x*y) = 20*n*(x1 - xa)*(y1 - ya)/(ln(10)*((x1 - xa)^2 + (y1 - ya)^2 + (z1 - za)^2)^2)
                //diff(Pr(p1))/diff(x*z) = 20*n*(x1 - xa)*(z1 - za)/(ln(10)*((x1 - xa)^2 + (y1 - ya)^2 + (z1 - za)^2)^2)
                //diff(Pr(p1))/diff(y*z) = 20*n*(y1 - ya)*(z1 - za)/(ln(10)*((x1 - xa)^2 + (y1 - ya)^2 + (z1 - za)^2)^2)

                //and expressing the second order derivatives in terms of distance between
                //fingerprint 1 and radio source a d1a, we get:
                //diff(Pr(p1))/diff(x^2) = -10*n*((y1 - ya)^2 + (z1 - za)^2 - (x1 - xa)^2)/(ln(10)*d1a^4)
                //diff(Pr(p1))/diff(y^2) = -10*n*((x1 - xa)^2 - (y1 - ya)^2 + (z1 - za)^2)/(ln(10)*d1a^4)
                //diff(Pr(p1))/diff(z^2) = -10*n*((x1 - xa)^2 + (y1 - ya)^2 - (z1 - za)^2)/(ln(10)*d1a^4)
                //diff(Pr(p1))/diff(x*y) = 20*n*(x1 - xa)*(y1 - ya)/(ln(10)*d1a^4)
                //diff(Pr(p1))/diff(x*z) = 20*n*(x1 - xa)*(z1 - za)/(ln(10)*d1a^4)
                //diff(Pr(p1))/diff(y*z) = 20*n*(y1 - ya)*(z1 - za)/(ln(10)*d1a^4)

                //Hence, second order Taylor expansion can be expressed as:
                //Pr(pi) = Pr(p1) + diff(Pr(p1))/diff(x)*(x - x1) +
                //      diff(Pr(p1))/diff(y)*(y - y1) +
                //      diff(Pr(p1))/diff(z)*(z - z1) +
                //	    1/2*diff(Pr(p1))/diff(x^2)*(x - x1)^2 +
                //	    1/2*diff(Pr(p1))/diff(y^2)*(y - y1)^2 +
                //	    1/2*diff(Pr(p1))/diff(z^2)*(z - z1)^2 +
                //	    diff(Pr(p1))/diff(x*y)*(x - x1)*(y - y1) +
                //	    diff(Pr(p1))/diff(y*z)*(y - y1)*(z - z1) +
                //	    diff(Pr(p1))/diff(x*z)*(x - x1)*(z - z1)

                //Pr(pi) = Pr(p1) - 10*n*(x1 - xa)/(ln(10)*d1a^2)*(xi -x1)
                //      - 10*n*(y1 - ya)/(ln(10)*d1a^2)*(yi - y1)
                //      - 10*n*(z1 - za)/(ln(10)*d1a^2)*(zi - z1)
                //      - 5*n*((y1 - ya)^2 + (z1 - za)^2) - (x1 - xa)^2)/(ln(10)*d1a^4)*(xi - x1)^2
                //      - 5*n*((x1 - xa)^2 - (y1 - ya)^2 + (z1 - za)^2))/(ln(10)*d1a^4)*(yi - y1)^2
                //      - 5*n*((x1 - xa)^2 + (y1 - ya)^2 - (z1 - za)^2))/(ln(10)*d1a^4)*(zi - z1)^2
                //      + 20*n*(x1 - xa)*(y1 - ya)/(ln(10)*d1a^4)*(xi - x1)*(yi - y1)
                //      + 20*n*(y1 - ya)*(z1 - za)/(ln(10)*d1a^4)*(yi - y1)*(zi - z1)
                //      + 20*n*(x1 - xa)*(z1 - za)/(ln(10)*d1a^4)*(xi - x1)*(zi - z1)

                //The equation above can be solved using a non-linear fitter such as Levenberg-Marquardt
                try {
<span class="fc" id="L787">                    setupFitter();</span>

<span class="fc" id="L789">                    mFitter.fit();</span>

                    //estimated position
<span class="fc" id="L792">                    mEstimatedPositionCoordinates = mFitter.getA();</span>
<span class="fc" id="L793">                    mCovariance = mFitter.getCovar();</span>
<span class="fc" id="L794">                    mChiSq = mFitter.getChisq();</span>

                    //a solution was found so we exit loop
<span class="fc" id="L797">                    break;</span>
<span class="fc" id="L798">                } catch (NumericalException e) {</span>
                    //solution could not be found with current data
                    //Iterate to use additinal nearby fingerprints
<span class="fc" id="L801">                    mEstimatedPositionCoordinates = null;</span>
<span class="fc" id="L802">                    mCovariance = null;</span>
<span class="fc" id="L803">                    mNearestFingerprints = null;</span>
                }
            }

<span class="pc bpc" id="L807" title="1 of 2 branches missed.">            if (mEstimatedPositionCoordinates == null) {</span>
                //no solution could be found
<span class="nc" id="L809">                throw new FingerprintEstimationException();</span>
            }

<span class="pc bpc" id="L812" title="1 of 2 branches missed.">            if (mListener != null) {</span>
<span class="fc" id="L813">                mListener.onEstimateEnd(this);</span>
            }
        } finally {
<span class="fc" id="L816">            mLocked = false;</span>
        }
<span class="fc" id="L818">    }</span>

    /**
     * Gets type of position estimator.
     *
     * @return type of position estimator.
     */
    public abstract NonLinearFingerprintPositionEstimatorType getType();

    /**
     * Evaluates a non-linear multi dimension function at provided point using
     * provided parameters and returns its evaluation and derivatives of the
     * function respect the function parameters.
     *
     * @param i           number of sample being evaluated.
     * @param point       point where function will be evaluated.
     * @param params      initial parameters estimation to be tried. These will
     *                    change as the Levenberg-Marquard algorithm iterates to the best solution.
     *                    These are used as input parameters along with point to evaluate function.
     * @param derivatives partial derivatives of the function respect to each
     *                    provided parameter.
     * @return function evaluation at provided point.
     * @throws EvaluationException raised if something failed during the evaluation.
     */
    protected abstract double evaluate(
            final int i, final double[] point, final double[] params,
            final double[] derivatives) throws EvaluationException;

    /**
     * Propagates provided variances into RSSI variance of non-located fingerprint
     * reading.
     *
     * @param fingerprintRssi               closest located fingerprint reading RSSI expressed in dBm's.
     * @param pathlossExponent              path-loss exponent.
     * @param fingerprintPosition           position of closest located fingerprint.
     * @param radioSourcePosition           radio source position associated to fingerprint reading.
     * @param estimatedPosition             position to be estimated. Usually this is equal to the
     *                                      initial position used by a non linear algorithm.
     * @param fingerprintRssiVariance       variance of fingerprint RSSI or null if unknown.
     * @param pathlossExponentVariance      variance of path-loss exponent or null if unknown.
     * @param fingerprintPositionCovariance covariance of fingerprint position or null if
     *                                      unknown.
     * @param radioSourcePositionCovariance covariance of radio source position or null if
     *                                      unknown.
     * @return variance of RSSI measured at non located fingerprint reading.
     */
    protected abstract Double propagateVariances(
            final double fingerprintRssi, final double pathlossExponent,
            final P fingerprintPosition, final P radioSourcePosition,
            final P estimatedPosition, final Double fingerprintRssiVariance,
            final Double pathlossExponentVariance,
            final Matrix fingerprintPositionCovariance,
            final Matrix radioSourcePositionCovariance);

    /**
     * Builds data required to solve the problem.
     *
     * @param allReceivedPower        list of received powers for readings at unknown positions.
     * @param allFingerprintPower     list of power readings at fingerprint positions.
     * @param allFingerprintPositions list of fingerprint positions.
     * @param allSourcesPositions     list of radio sources positions.
     * @param allPathLossExponents    list of path loss exponents.
     * @param allStandardDeviations   list of standard deviations for readings being used.
     */
    @SuppressWarnings(&quot;Duplicates&quot;)
    private void buildData(
            final List&lt;Double&gt; allReceivedPower,
            final List&lt;Double&gt; allFingerprintPower,
            final List&lt;P&gt; allFingerprintPositions,
            final List&lt;P&gt; allSourcesPositions,
            final List&lt;Double&gt; allPathLossExponents,
            final List&lt;Double&gt; allStandardDeviations) {
        for (final RssiFingerprintLocated&lt;RadioSource, RssiReading&lt;RadioSource&gt;, P&gt; locatedFingerprint :
<span class="fc bfc" id="L891" title="All 2 branches covered.">                mNearestFingerprints) {</span>

<span class="fc" id="L893">            final List&lt;RssiReading&lt;RadioSource&gt;&gt; locatedReadings =</span>
<span class="fc" id="L894">                    locatedFingerprint.getReadings();</span>
<span class="pc bpc" id="L895" title="1 of 2 branches missed.">            if (locatedReadings == null) {</span>
<span class="nc" id="L896">                continue;</span>
            }

<span class="fc" id="L899">            final P fingerprintPosition = locatedFingerprint.getPosition();</span>
<span class="fc" id="L900">            final Matrix fingerprintPositionCovariance = locatedFingerprint.</span>
<span class="fc" id="L901">                    getPositionCovariance();</span>

<span class="fc" id="L903">            double locatedMeanRssi = 0.0;</span>
<span class="fc" id="L904">            double meanRssi = 0.0;</span>
<span class="fc bfc" id="L905" title="All 2 branches covered.">            if (mRemoveMeansFromFingerprintReadings) {</span>
<span class="fc" id="L906">                locatedMeanRssi = locatedFingerprint.getMeanRssi();</span>
            }

<span class="fc bfc" id="L909" title="All 2 branches covered.">            for (final RssiReading&lt;RadioSource&gt; locatedReading : locatedReadings) {</span>
<span class="fc" id="L910">                final RadioSource source = locatedReading.getSource();</span>

                //find within the list of located sources the source of
                //current located fingerprint reading.
                //Radio sources are compared by their id
                //regardless of them being located or not
                @SuppressWarnings(&quot;SuspiciousMethodCalls&quot;)
<span class="fc" id="L917">                final int pos = mSources.indexOf(source);</span>
<span class="pc bpc" id="L918" title="1 of 2 branches missed.">                if (pos &lt; 0) {</span>
<span class="nc" id="L919">                    continue;</span>
                }

<span class="fc" id="L922">                final RadioSourceLocated&lt;P&gt; locatedSource = mSources.get(pos);</span>
<span class="fc" id="L923">                double pathLossExponent = mPathLossExponent;</span>
<span class="fc" id="L924">                Double pathLossExponentVariance = null;</span>
<span class="pc bpc" id="L925" title="1 of 4 branches missed.">                if (mUseSourcesPathLossExponentWhenAvailable &amp;&amp;</span>
                        locatedSource instanceof RadioSourceWithPower) {
<span class="fc" id="L927">                    final RadioSourceWithPower locatedSourceWithPower =</span>
                            (RadioSourceWithPower) locatedSource;
<span class="fc" id="L929">                    pathLossExponent = locatedSourceWithPower.getPathLossExponent();</span>
<span class="fc" id="L930">                    final Double std = locatedSourceWithPower.</span>
<span class="fc" id="L931">                            getPathLossExponentStandardDeviation();</span>
<span class="fc bfc" id="L932" title="All 2 branches covered.">                    pathLossExponentVariance = std != null ? std * std : null;</span>
                }

<span class="fc" id="L935">                final P sourcePosition = locatedSource.getPosition();</span>
<span class="fc" id="L936">                final Matrix sourcePositionCovariance = locatedSource.getPositionCovariance();</span>
<span class="fc" id="L937">                double locatedRssi = locatedReading.getRssi();</span>
<span class="fc" id="L938">                locatedRssi -= locatedMeanRssi;</span>

<span class="fc" id="L940">                final Double locatedRssiStd = locatedReading.getRssiStandardDeviation();</span>
<span class="fc bfc" id="L941" title="All 2 branches covered.">                final Double locatedRssiVariance = locatedRssiStd != null ?</span>
<span class="fc" id="L942">                        locatedRssiStd * locatedRssiStd : null;</span>
<span class="fc bfc" id="L943" title="All 2 branches covered.">                if (mRemoveMeansFromFingerprintReadings) {</span>
<span class="fc" id="L944">                    meanRssi = mFingerprint.getMeanRssi();</span>
                }

<span class="fc" id="L947">                final List&lt;? extends RssiReading&lt;? extends RadioSource&gt;&gt; readings =</span>
<span class="fc" id="L948">                        mFingerprint.getReadings();</span>
<span class="fc bfc" id="L949" title="All 2 branches covered.">                for (final RssiReading&lt;? extends RadioSource&gt; reading : readings) {</span>
<span class="pc bpc" id="L950" title="1 of 2 branches missed.">                    if (reading.getSource() == null ||</span>
<span class="fc bfc" id="L951" title="All 2 branches covered.">                            !reading.getSource().equals(locatedSource)) {</span>
<span class="fc" id="L952">                        continue;</span>
                    }

                    //only take into account reading for matching sources on located and
                    //non-located readings
<span class="fc" id="L957">                    double rssi = reading.getRssi();</span>
<span class="fc" id="L958">                    rssi -= meanRssi;</span>

<span class="fc" id="L960">                    Double standardDeviation = null;</span>
<span class="pc bpc" id="L961" title="7 of 8 branches missed.">                    if (mPropagateFingerprintRssiStandardDeviation ||</span>
                            mPropagatePathlossExponentStandardDeviation ||
                            mPropagateFingerprintPositionCovariance ||
                            mPropagateRadioSourcePositionCovariance) {

                        //compute initial position
<span class="fc bfc" id="L967" title="All 2 branches covered.">                        final P initialPosition = mInitialPosition != null ?</span>
<span class="fc" id="L968">                                mInitialPosition : fingerprintPosition;</span>

<span class="fc" id="L970">                        final Double variance = propagateVariances(locatedRssi,</span>
                                pathLossExponent, fingerprintPosition, sourcePosition,
                                initialPosition,
<span class="pc bpc" id="L973" title="1 of 2 branches missed.">                                mPropagateFingerprintRssiStandardDeviation ? locatedRssiVariance : null,</span>
<span class="pc bpc" id="L974" title="1 of 2 branches missed.">                                mPropagatePathlossExponentStandardDeviation ? pathLossExponentVariance : null,</span>
<span class="pc bpc" id="L975" title="1 of 2 branches missed.">                                mPropagateFingerprintPositionCovariance ? fingerprintPositionCovariance : null,</span>
<span class="pc bpc" id="L976" title="1 of 2 branches missed.">                                mPropagateRadioSourcePositionCovariance ? sourcePositionCovariance : null);</span>
<span class="pc bpc" id="L977" title="1 of 2 branches missed.">                        if (variance != null) {</span>
<span class="fc" id="L978">                            standardDeviation = Math.sqrt(variance);</span>
                        }
                    }

<span class="pc bpc" id="L982" title="1 of 2 branches missed.">                    if (standardDeviation == null) {</span>
<span class="nc" id="L983">                        standardDeviation = reading.getRssiStandardDeviation();</span>
<span class="pc bpc" id="L984" title="1 of 2 branches missed.">                    } else if (reading.getRssiStandardDeviation() != null) {</span>
                        //consider propagated variance and reading variance independent, so we
                        //sum them both
<span class="nc" id="L987">                        standardDeviation = standardDeviation * standardDeviation +</span>
<span class="nc" id="L988">                                reading.getRssiStandardDeviation() * reading.getRssiStandardDeviation();</span>
<span class="nc" id="L989">                        standardDeviation = Math.sqrt(standardDeviation);</span>
                    }

<span class="pc bpc" id="L992" title="1 of 4 branches missed.">                    if (standardDeviation == null || standardDeviation &lt; TINY_RSSI_STD) {</span>
<span class="fc" id="L993">                        standardDeviation = mFallbackRssiStandardDeviation;</span>
                    }

<span class="fc" id="L996">                    allReceivedPower.add(rssi);</span>
<span class="fc" id="L997">                    allFingerprintPower.add(locatedRssi);</span>
<span class="fc" id="L998">                    allFingerprintPositions.add(fingerprintPosition);</span>
<span class="fc" id="L999">                    allSourcesPositions.add(sourcePosition);</span>
<span class="fc" id="L1000">                    allPathLossExponents.add(pathLossExponent);</span>
<span class="fc" id="L1001">                    allStandardDeviations.add(standardDeviation);</span>
<span class="fc" id="L1002">                }</span>
<span class="fc" id="L1003">            }</span>
<span class="fc" id="L1004">        }</span>
<span class="fc" id="L1005">    }</span>

    /**
     * Setups fitter to solve position.
     *
     * @throws FittingException if Levenberg-Marquardt fitting fails.
     */
    @SuppressWarnings(&quot;Duplicates&quot;)
    private void setupFitter() throws FittingException {
        //build lists of data
<span class="fc" id="L1015">        final List&lt;Double&gt; allReceivedPower = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L1016">        final List&lt;Double&gt; allFingerprintPower = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L1017">        final List&lt;P&gt; allFingerprintPositions = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L1018">        final List&lt;P&gt; allSourcesPosition = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L1019">        final List&lt;Double&gt; allPathLossExponents = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L1020">        final List&lt;Double&gt; allStandardDeviations = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L1021">        buildData(allReceivedPower, allFingerprintPower,</span>
                allFingerprintPositions, allSourcesPosition, allPathLossExponents,
                allStandardDeviations);

<span class="fc" id="L1025">        final int totalReadings = allReceivedPower.size();</span>
<span class="fc" id="L1026">        final int dims = getNumberOfDimensions();</span>
<span class="fc" id="L1027">        final int n = 2 + 2 * dims;</span>

<span class="fc" id="L1029">        mFitter.setFunctionEvaluator(new LevenbergMarquardtMultiDimensionFunctionEvaluator() {</span>
            @Override
            public int getNumberOfDimensions() {
<span class="fc" id="L1032">                return n;</span>
            }

            @Override
            public double[] createInitialParametersArray() {

<span class="fc" id="L1038">                final double[] initial = new double[dims];</span>

<span class="fc bfc" id="L1040" title="All 2 branches covered.">                if (mInitialPosition == null) {</span>
                    //use centroid of nearest fingerprints as initial value
<span class="fc" id="L1042">                    int num = 0;</span>
                    for (final RssiFingerprintLocated&lt;? extends RadioSource,
<span class="fc bfc" id="L1044" title="All 2 branches covered.">                            ? extends RssiReading&lt;? extends RadioSource&gt;, P&gt; fingerprint : mNearestFingerprints) {</span>
<span class="fc" id="L1045">                        final P position = fingerprint.getPosition();</span>
<span class="pc bpc" id="L1046" title="1 of 2 branches missed.">                        if (position == null) {</span>
<span class="nc" id="L1047">                            continue;</span>
                        }

<span class="fc bfc" id="L1050" title="All 2 branches covered.">                        for (int i = 0; i &lt; dims; i++) {</span>
<span class="fc" id="L1051">                            initial[i] += position.getInhomogeneousCoordinate(i);</span>
                        }
<span class="fc" id="L1053">                        num++;</span>
<span class="fc" id="L1054">                    }</span>

<span class="fc bfc" id="L1056" title="All 2 branches covered.">                    for (int i = 0; i &lt; dims; i++) {</span>
<span class="fc" id="L1057">                        initial[i] /= num;</span>
                    }
<span class="fc" id="L1059">                } else {</span>
                    //use provided initial position
<span class="fc bfc" id="L1061" title="All 2 branches covered.">                    for (int i = 0; i &lt; dims; i++) {</span>
<span class="fc" id="L1062">                        initial[i] = mInitialPosition.getInhomogeneousCoordinate(i);</span>
                    }
                }
<span class="fc" id="L1065">                return initial;</span>
            }

            @Override
            public double evaluate(
                    final int i, final double[] point, final double[] params,
                    final double[] derivatives) throws EvaluationException {
<span class="fc" id="L1072">                return NonLinearFingerprintPositionEstimator.this.evaluate(i, point, params, derivatives);</span>
            }
        });

        try {
<span class="fc" id="L1077">            final Matrix x = new Matrix(totalReadings, n);</span>
<span class="fc" id="L1078">            final double[] y = new double[totalReadings];</span>
<span class="fc" id="L1079">            final double[] standardDeviations = new double[totalReadings];</span>
<span class="fc bfc" id="L1080" title="All 2 branches covered.">            for (int i = 0; i &lt; totalReadings; i++) {</span>
                //fingerprint power Pr(p1)
<span class="fc" id="L1082">                x.setElementAt(i, 0, allFingerprintPower.get(i));</span>
<span class="fc bfc" id="L1083" title="All 2 branches covered.">                for (int j = 0; j &lt; dims; j++) {</span>
<span class="fc" id="L1084">                    x.setElementAt(i, j + 1,</span>
<span class="fc" id="L1085">                            allFingerprintPositions.get(i).getInhomogeneousCoordinate(j));</span>
<span class="fc" id="L1086">                    x.setElementAt(i, j + 1 + dims,</span>
<span class="fc" id="L1087">                            allSourcesPosition.get(i).getInhomogeneousCoordinate(j));</span>
                }
<span class="fc" id="L1089">                x.setElementAt(i, 1 + 2 * dims, allPathLossExponents.get(i));</span>

<span class="fc" id="L1091">                y[i] = allReceivedPower.get(i);</span>

<span class="fc" id="L1093">                standardDeviations[i] = allStandardDeviations.get(i);</span>
            }

<span class="fc" id="L1096">            mFitter.setInputData(x, y, standardDeviations);</span>
<span class="nc" id="L1097">        } catch (final AlgebraException e) {</span>
<span class="nc" id="L1098">            throw new FittingException(e);</span>
<span class="fc" id="L1099">        }</span>
<span class="fc" id="L1100">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>