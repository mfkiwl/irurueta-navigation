<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>NonLinearFingerprintPositionEstimator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.irurueta:irurueta-navigation</a> &gt; <a href="index.source.html" class="el_package">com.irurueta.navigation.indoor.fingerprint</a> &gt; <span class="el_source">NonLinearFingerprintPositionEstimator.java</span></div><h1>NonLinearFingerprintPositionEstimator.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2018 Alberto Irurueta Carro (alberto@irurueta.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.irurueta.navigation.indoor.fingerprint;

import com.irurueta.algebra.AlgebraException;
import com.irurueta.algebra.Matrix;
import com.irurueta.geometry.Point;
import com.irurueta.navigation.LockedException;
import com.irurueta.navigation.NotReadyException;
import com.irurueta.navigation.indoor.*;
import com.irurueta.numerical.EvaluationException;
import com.irurueta.numerical.NumericalException;
import com.irurueta.numerical.fitting.FittingException;
import com.irurueta.numerical.fitting.LevenbergMarquardtMultiDimensionFitter;
import com.irurueta.numerical.fitting.LevenbergMarquardtMultiDimensionFunctionEvaluator;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;

/**
 * Base class for position estimators based on located fingerprints containing only
 * RSSI readings and having as well prior knowledge of the location of radio sources
 * associated to those readings.
 * This implementation uses a Taylor approximation over provided located
 * fingerprints to determine an approximate position for a non-located fingerprint using
 * a non-linear solving algorithm.
 * An initial position can be provided as a starting point to solve the position,
 * otherwise the average point of selected nearest fingerprints is used as a starting
 * point.
 * @param &lt;P&gt; a {@link Point} type.
 */
@SuppressWarnings(&quot;WeakerAccess&quot;)
public abstract class NonLinearFingerprintPositionEstimator&lt;P extends Point&lt;?&gt;&gt; extends
        FingerprintPositionEstimator&lt;P&gt; {

    /**
     * Default RSSI standard deviation assumed for provided fingerprints as a fallback
     * when none can be determined.
     */
    public static final double FALLBACK_RSSI_STANDARD_DEVIATION = 1.0;

    /**
     * Indicates that by default measured RSSI standard deviation of closest fingerprint
     * must be propagated into measured RSSI reading variance at unknown location.
     */
    public static final boolean DEFAULT_PROPAGATE_FINGERPRINT_RSSI_STANDARD_DEVIATION = true;

    /**
     * Indicates that by default path-loss exponent standard deviation of radio source
     * must be propagated into measured RSSI reading variance at unknown location.
     */
    public static final boolean DEFAULT_PROPAGATE_PATHLOSS_EXPONENT_STANDARD_DEVIATION = true;

    /**
     * Indicates that by default covariance of closest fingerprint position must be
     * propagated into measured RSSI reading variance at unknown location.
     */
    public static final boolean DEFAULT_PROPAGATE_FINGERPRINT_POSITION_COVARIANCE = true;

    /**
     * Indicates that by default covariance of radio source position must be propagated
     * into measured RSSI reading variance at unknown location.
     */
    public static final boolean DEFAULT_PROPAGATE_RADIO_SOURCE_POSITION_COVARIANCE = true;

    /**
     * Default type to be used when none is provided.
     */
<span class="fc" id="L83">    public static final NonLinearFingerprintPositionEstimatorType DEFAULT_TYPE =</span>
            NonLinearFingerprintPositionEstimatorType.THIRD_ORDER;

    /**
     * Small value to be used as the minimum allowed RSSI standard deviations. A value
     * larger than this must be provided to allow convergence to a solution
     */
    public static final double TINY_RSSI_STD = 1e-12;

    /**
     * Initial position to start the solving algorithm.
     * This should be a value close to the expected solution.
     * If no value is provided, the average position among all selected nearest
     * located fingerprints will be used.
     */
    private P mInitialPosition;

    /**
     * RSSI standard deviation fallback value to use when none can be
     * determined from provided readings. This fallback value is only used if
     * no variance is propagated or the resulting value is too small to allow
     * convergence to a solution.
     */
<span class="fc" id="L106">    private double mFallbackRssiStandardDeviation =</span>
            FALLBACK_RSSI_STANDARD_DEVIATION;

    /**
     * Indicates whether measured RSSI standard deviation of closest fingerprint must
     * be propagated into measured RSSI reading variance at unknown location.
     */
<span class="fc" id="L113">    private boolean mPropagateFingerprintRssiStandardDeviation =</span>
            DEFAULT_PROPAGATE_FINGERPRINT_RSSI_STANDARD_DEVIATION;

    /**
     * Indicates whether path-loss exponent standard deviation of radio source must
     * be propagated into measured RSSI reading variance at unknown location.
     */
<span class="fc" id="L120">    private boolean mPropagatePathlossExponentStandardDeviation =</span>
            DEFAULT_PROPAGATE_PATHLOSS_EXPONENT_STANDARD_DEVIATION;

    /**
     * Indicates whether covariance of closest fingerprint position must be
     * propagated into measured RSSI reading variance at unknown location.
     */
<span class="fc" id="L127">    private boolean mPropagateFingerprintPositionCovariance =</span>
            DEFAULT_PROPAGATE_FINGERPRINT_POSITION_COVARIANCE;

    /**
     * Indicates whether covariance of radio source position must be propagated
     * into measured RSSI reading variance at unknown location.
     */
<span class="fc" id="L134">    private boolean mPropagateRadioSourcePositionCovariance =</span>
            DEFAULT_PROPAGATE_RADIO_SOURCE_POSITION_COVARIANCE;

    /**
     * Levenberg-Marquardt fitter to find a non-linear solution.
     */
<span class="fc" id="L140">    private LevenbergMarquardtMultiDimensionFitter mFitter = new LevenbergMarquardtMultiDimensionFitter();</span>

    /**
     * Estimated covariance matrix for estimated position.
     */
    private Matrix mCovariance;

    /**
     * Estimated chi square value.
     */
    private double mChiSq;

    /**
     * Constructor.
     */
<span class="fc" id="L155">    public NonLinearFingerprintPositionEstimator() { }</span>

    /**
     * Constructor.
     * @param listener listener in charge of handling events.
     */
    public NonLinearFingerprintPositionEstimator(
            FingerprintPositionEstimatorListener&lt;P&gt; listener) {
<span class="fc" id="L163">        super(listener);</span>
<span class="fc" id="L164">    }</span>

    /**
     * Constructor.
     * @param locatedFingerprints located fingerprints containing RSSI readings.
     * @param fingerprint fingerprint containing readings at an unknown location
     *                    for provided located fingerprints.
     * @param sources located radio sources.
     * @throws IllegalArgumentException if provided non located fingerprint is null,
     * located fingerprints value is null or there are not enough fingerprints or
     * readings within provided fingerprints (for 2D position estimation at least 2
     * located total readings are required among all fingerprints, for example 2
     * readings are required in a single fingerprint, or at least 2 fingerprints at
     * different locations containing a single reading are required. For 3D position
     * estimation 3 located total readings are required among all fingerprints).
     */
    public NonLinearFingerprintPositionEstimator(List&lt;? extends RssiFingerprintLocated&lt;? extends RadioSource,
            ? extends RssiReading&lt;? extends RadioSource&gt;, P&gt;&gt; locatedFingerprints,
            RssiFingerprint&lt;? extends RadioSource,
            ? extends RssiReading&lt;? extends RadioSource&gt;&gt; fingerprint,
            List&lt;? extends RadioSourceLocated&lt;P&gt;&gt; sources) {
<span class="fc" id="L185">        super(locatedFingerprints, fingerprint, sources);</span>
<span class="fc" id="L186">    }</span>

    /**
     * Constructor.
     * @param locatedFingerprints located fingerprints containing RSSI readings.
     * @param fingerprint fingerprint containing readings at an unknown location
     *                    for provided located fingerprints.
     * @param sources located radio sources.
     * @param listener listener in charge of handling events.
     * @throws IllegalArgumentException if provided non located fingerprint is null,
     * located fingerprints value is null or there are not enough fingerprints or
     * readings within provided fingerprints (for 2D position estimation at least 2
     * located total readings are required among all fingerprints, for example 2
     * readings are required in a single fingerprint, or at least 2 fingerprints at
     * different locations containing a single reading are required. For 3D position
     * estimation 3 located total readings are required among all fingerprints).
     */
    public NonLinearFingerprintPositionEstimator(
            List&lt;? extends RssiFingerprintLocated&lt;? extends RadioSource,
            ? extends RssiReading&lt;? extends RadioSource&gt;, P&gt;&gt; locatedFingerprints,
            RssiFingerprint&lt;? extends RadioSource,
            ? extends RssiReading&lt;? extends RadioSource&gt;&gt; fingerprint,
            List&lt;? extends RadioSourceLocated&lt;P&gt;&gt; sources,
            FingerprintPositionEstimatorListener&lt;P&gt; listener) {
<span class="fc" id="L210">        super(locatedFingerprints, fingerprint, sources, listener);</span>
<span class="fc" id="L211">    }</span>

    /**
     * Constructor.
     * @param locatedFingerprints located fingerprints containing RSSI readings.
     * @param fingerprint fingerprint containing readings at an unknown location
     *                    for provided located fingerprints.
     * @param sources located radio sources.
     * @param initialPosition initial position to start the solving algorithm or null.
     * @throws IllegalArgumentException if provided non located fingerprint is null,
     * located fingerprints value is null or there are not enough fingerprints or
     * readings within provided fingerprints (for 2D position estimation at least 2
     * located total readings are required among all fingerprints, for example 2
     * readings are required in a single fingerprint, or at least 2 fingerprints at
     * different locations containing a single reading are required. For 3D position
     * estimation 3 located total readings are required among all fingerprints).
     */
    public NonLinearFingerprintPositionEstimator(
            List&lt;? extends RssiFingerprintLocated&lt;? extends RadioSource,
            ? extends RssiReading&lt;? extends RadioSource&gt;, P&gt;&gt; locatedFingerprints,
            RssiFingerprint&lt;? extends RadioSource,
            ? extends RssiReading&lt;? extends RadioSource&gt;&gt; fingerprint,
            List&lt;? extends RadioSourceLocated&lt;P&gt;&gt; sources, P initialPosition) {
<span class="fc" id="L234">        super(locatedFingerprints, fingerprint, sources);</span>
<span class="fc" id="L235">        mInitialPosition = initialPosition;</span>
<span class="fc" id="L236">    }</span>

    /**
     * Constructor.
     * @param locatedFingerprints located fingerprints containing RSSI readings.
     * @param fingerprint fingerprint containing readings at an unknown location
     *                    for provided located fingerprints.
     * @param sources located radio sources.
     * @param initialPosition initial position to start the solving algorithm or null.
     * @param listener listener in charge of handling events.
     * @throws IllegalArgumentException if provided non located fingerprint is null,
     * located fingerprints value is null or there are not enough fingerprints or
     * readings within provided fingerprints (for 2D position estimation at least 2
     * located total readings are required among all fingerprints, for example 2
     * readings are required in a single fingerprint, or at least 2 fingerprints at
     * different locations containing a single reading are required. For 3D position
     * estimation 3 located total readings are required among all fingerprints).
     */
    public NonLinearFingerprintPositionEstimator(
            List&lt;? extends RssiFingerprintLocated&lt;? extends RadioSource,
            ? extends RssiReading&lt;? extends RadioSource&gt;, P&gt;&gt; locatedFingerprints,
            RssiFingerprint&lt;? extends RadioSource,
            ? extends RssiReading&lt;? extends RadioSource&gt;&gt; fingerprint,
            List&lt;? extends RadioSourceLocated&lt;P&gt;&gt; sources, P initialPosition,
            FingerprintPositionEstimatorListener&lt;P&gt; listener) {
<span class="fc" id="L261">        super(locatedFingerprints, fingerprint, sources, listener);</span>
<span class="fc" id="L262">        mInitialPosition = initialPosition;</span>
<span class="fc" id="L263">    }</span>

    /**
     * Gets initial position to start the solving algorithm.
     * This should be a value close to the expected solution.
     * If no value is provided, the average position among all selected nearest
     * located fingerprints will be used.
     * @return initial position to start the solving algorithm or null.
     */
    public P getInitialPosition() {
<span class="fc" id="L273">        return mInitialPosition;</span>
    }

    /**
     * Sets initial position to start the solving algorithm.
     * This should be a value close to the expected solution.
     * If no value is provided, the average position among all selected nearest
     * located fingerprints will be used.
     * @param initialPosition initial position to start the solving algorithm or null.
     * @throws LockedException if estimator is locked.
     */
    public void setInitialPosition(P initialPosition) throws LockedException {
<span class="fc bfc" id="L285" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L286">            throw new LockedException();</span>
        }

<span class="fc" id="L289">        mInitialPosition = initialPosition;</span>
<span class="fc" id="L290">    }</span>

    /**
     * Gets RSSI standard deviation fallback value to use when none can be
     * determined from provided readings.
     * @return RSSI standard deviation fallback.
     */
    public double getFallbackRssiStandardDeviation() {
<span class="fc" id="L298">        return mFallbackRssiStandardDeviation;</span>
    }

    /**
     * Sets RSSI standard deviation fallback value to use when none can be
     * determined from provided readings.
     * @param fallbackRssiStandardDeviation RSSI standard deviation fallback
     * @throws LockedException if estimator is locked.
     * @throws IllegalArgumentException if provided value is smaller than
     * {@link #TINY_RSSI_STD}.
     */
    public void setFallbackRssiStandardDeviation(
            double fallbackRssiStandardDeviation) throws LockedException {
<span class="fc bfc" id="L311" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L312">            throw new LockedException();</span>
        }
<span class="pc bpc" id="L314" title="1 of 2 branches missed.">        if (fallbackRssiStandardDeviation &lt; TINY_RSSI_STD) {</span>
<span class="nc" id="L315">            throw new IllegalArgumentException();</span>
        }
<span class="fc" id="L317">        mFallbackRssiStandardDeviation = fallbackRssiStandardDeviation;</span>
<span class="fc" id="L318">    }</span>

    /**
     * Indicates whether measured RSSI standard deviation of closest fingerprint must be
     * propagated into measured RSSI reading variance at unknown location.
     * @return true to propagate RSSI standard deviation of closest fingerprint,
     * false otherwise.
     */
    public boolean isFingerprintRssiStandardDeviationPropagated() {
<span class="fc" id="L327">        return mPropagateFingerprintRssiStandardDeviation;</span>
    }

    /**
     * Specifies whether measured RSSI standard deviation of closest fingerprint must be
     * propagated into measured RSSI reading variance at unknown location.
     * @param propagateFingerprintRssiStandardDeviation true to propagate RSSI standard
     *                                                  deviation of closest fingerprint,
     *                                                  false otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setFingerprintRssiStandardDeviationPropagated(
            boolean propagateFingerprintRssiStandardDeviation) throws LockedException {
<span class="fc bfc" id="L340" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L341">            throw new LockedException();</span>
        }
<span class="fc" id="L343">        mPropagateFingerprintRssiStandardDeviation =</span>
                propagateFingerprintRssiStandardDeviation;
<span class="fc" id="L345">    }</span>

    /**
     * Indicates whether path-loss exponent standard deviation of radio source must be
     * propagated into measured RSSI reading variance at unknown location.
     * @return true to propagate  path-loss exponent standard deviation of radio source,
     * false otherwise.
     */
    public boolean isPathlossExponentStandardDeviationPropagated() {
<span class="fc" id="L354">        return mPropagatePathlossExponentStandardDeviation;</span>
    }

    /**
     * Specifies whether path-loss exponent standard deviation of radio source must be
     * propagated into measured RSSI reading variance at unknown location.
     * @param propagatePathlossExponentStandardDeviation true to propagate path-loss
     *                                                   exponent standard deviation of
     *                                                   radio source, false otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setPathlossExponentStandardDeviationPropagated(
            boolean propagatePathlossExponentStandardDeviation) throws LockedException {
<span class="fc bfc" id="L367" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L368">            throw new LockedException();</span>
        }
<span class="fc" id="L370">        mPropagatePathlossExponentStandardDeviation =</span>
                propagatePathlossExponentStandardDeviation;
<span class="fc" id="L372">    }</span>

    /**
     * Indicates whether covariance of closest fingerprint position must be propagated
     * into measured RSSI reading variance at unknown location.
     * @return true to propagate fingerprint position covariance, false otherwise.
     */
    public boolean isFingerprintPositionCovariancePropagated() {
<span class="fc" id="L380">        return mPropagateFingerprintPositionCovariance;</span>
    }

    /**
     * Specifies whether covariance of closest fingerprint position must be propagated
     * into measured RSSI reading variance at unknown location.
     * @param propagateFingerprintPositionCovariance true to propagate fingerprint
     *                                               position covariance, false otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setFingerprintPositionCovariancePropagated(
            boolean propagateFingerprintPositionCovariance) throws LockedException {
<span class="fc bfc" id="L392" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L393">            throw new LockedException();</span>
        }
<span class="fc" id="L395">        mPropagateFingerprintPositionCovariance =</span>
                propagateFingerprintPositionCovariance;
<span class="fc" id="L397">    }</span>

    /**
     * Indicates whether covariance of radio source position must be propagated into
     * measured RSSI reading variance at unknown location.
     * @return true to propagate radio source position covariance, false otherwise.
     */
    public boolean isRadioSourcePositionCovariancePropagated() {
<span class="fc" id="L405">        return mPropagateRadioSourcePositionCovariance;</span>
    }

    /**
     * Specifies whether covariance of radio source position must be propagated into
     * measured RSSI reading variance at unknown location.
     * @param propagateRadioSourcePositionCovariance true to propagate radio source
     *                                               position covariance, false otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setRadioSourcePositionCovariancePropagated(
            boolean propagateRadioSourcePositionCovariance) throws LockedException {
<span class="fc bfc" id="L417" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L418">            throw new LockedException();</span>
        }
<span class="fc" id="L420">        mPropagateRadioSourcePositionCovariance =</span>
                propagateRadioSourcePositionCovariance;
<span class="fc" id="L422">    }</span>

    /**
     * Gets estimated covariance matrix for estimated position.
     * @return estimated covariance matrix for estimated position.
     */
    public Matrix getCovariance() {
<span class="fc" id="L429">        return mCovariance;</span>
    }

    /**
     * Gets estimated chi square value.
     * @return estimated chi square value.
     */
    public double getChiSq() {
<span class="fc" id="L437">        return mChiSq;</span>
    }

    /**
     * Estimates position based on provided located radio sources and readings of such radio sources at
     * an unknown location.
     * @throws LockedException if estimator is locked.
     * @throws NotReadyException if estimator is not ready.
     * @throws FingerprintEstimationException if estimation fails for some other reason.
     */
    @Override
    @SuppressWarnings(&quot;Duplicates&quot;)
    public void estimate() throws LockedException, NotReadyException,
            FingerprintEstimationException {

<span class="pc bpc" id="L452" title="1 of 2 branches missed.">        if (!isReady()) {</span>
<span class="nc" id="L453">            throw new NotReadyException();</span>
        }
<span class="fc bfc" id="L455" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L456">            throw new LockedException();</span>
        }

        try {
<span class="fc" id="L460">            mLocked = true;</span>

<span class="pc bpc" id="L462" title="1 of 2 branches missed.">            if (mListener != null) {</span>
<span class="fc" id="L463">                mListener.onEstimateStart(this);</span>
            }

<span class="fc" id="L466">            RadioSourceNoMeanKNearestFinder&lt;P, RadioSource&gt; noMeanfinder = null;</span>
<span class="fc" id="L467">            RadioSourceKNearestFinder&lt;P, RadioSource&gt; finder = null;</span>
<span class="fc bfc" id="L468" title="All 2 branches covered.">            if (mUseNoMeanNearestFingerprintFinder) {</span>
                //noinspection unchecked
<span class="fc" id="L470">                noMeanfinder = new RadioSourceNoMeanKNearestFinder&lt;&gt;(</span>
                        (Collection&lt;? extends RssiFingerprintLocated&lt;RadioSource,
                                RssiReading&lt;RadioSource&gt;, P&gt;&gt;)mLocatedFingerprints);
            } else {
                //noinspection unchecked
<span class="fc" id="L475">                finder = new RadioSourceKNearestFinder&lt;&gt;(</span>
                        (Collection&lt;? extends RssiFingerprintLocated&lt;RadioSource,
                                RssiReading&lt;RadioSource&gt;, P&gt;&gt;)mLocatedFingerprints);
            }

<span class="fc" id="L480">            mEstimatedPositionCoordinates = null;</span>
<span class="fc" id="L481">            mCovariance = null;</span>
<span class="fc" id="L482">            mNearestFingerprints = null;</span>

<span class="pc bpc" id="L484" title="1 of 2 branches missed.">            int max = mMaxNearestFingerprints &lt; 0 ?</span>
<span class="fc" id="L485">                    mLocatedFingerprints.size() :</span>
<span class="pc" id="L486">                    Math.min(mMaxNearestFingerprints, mLocatedFingerprints.size());</span>
<span class="pc bpc" id="L487" title="1 of 2 branches missed.">            for (int k = mMinNearestFingerprints; k &lt;= max; k++) {</span>
<span class="fc bfc" id="L488" title="All 2 branches covered.">                if (noMeanfinder != null) {</span>
                    //noinspection unchecked
<span class="fc" id="L490">                    mNearestFingerprints = noMeanfinder.findKNearestTo(</span>
                            (RssiFingerprint&lt;RadioSource, RssiReading&lt;RadioSource&gt;&gt;) mFingerprint, k);
                } else {
                    //noinspection unchecked
<span class="fc" id="L494">                    mNearestFingerprints = finder.findKNearestTo(</span>
                            (RssiFingerprint&lt;RadioSource, RssiReading&lt;RadioSource&gt;&gt;) mFingerprint, k);
                }

                //Demonstration in 2D:
                //--------------------
                //Taylor series expansion can be expressed as:
                //f(x) = f(a) + 1/1!*f'(a)*(x - a) + 1/2!*f''(a)*(x - a)^2 + ...

                //where f'(x) is the derivative of f respect x, which can also be expressed as:
                //f'(x) = diff(f(x))/diff(x)

                //and f'(a) is the derivative of f respect x evaluated at a, which can be expressed
                //as f'(a) = diff(f(a))/diff(x)

                //consequently f''(a) is the second derivative respect x evaluated at a, which can
                //be expressed as:
                //f''(x) = diff(f(x))/diff(x^2)

                //and:
                //f''(a) = diff(f(a))/diff(x^2)

                //Received power expressed in dBm is:
                //k = (c/(4*pi*f))
                //Pr = Pte*k^n / d^n

                //where c is the speed of light, pi is 3.14159..., f is the frequency of the radio source,
                //Pte is the equivalent transmitted power by the radio source, n is the path-loss exponent
                // (typically 2.0), and d is the distance from a point to the location of the radio source.

                //Hence:
                //Pr(dBm) = 10*log(Pte*k^n/d^n) = 10*n*log(k) + 10*log(Pte) - 10*n*log(d) =
                //          10*n*log(k) + 10*log(Pte) - 5*n*log(d^2)

                //The former 2 terms are constant, and only the last term depends on distance

                //Hence, assuming the constant K = 10*n*log(k) + Pte(dBm), where Pte(dBm) = 10*log(Pte),
                //assuming that transmitted power by the radio source Pte is known (so that K is also known),
                //and assuming that the location of the radio source is known and it is located at pa = (xa, ya)
                //so that d^2 = (x - xa)^2 + (y - ya)^2 then the received power at an unknown point pi = (xi, yi) is:

                //Pr(pi) = Pr(xi,yi) = K - 5*n*log(d^2) = K - 5*n*log((xi - xa)^2 + (yi - ya)^2)

                //Suppose that received power at point p1=(x1,y1) is known on a located fingerprint
                //containing readings Pr(p1).

                //Then, for an unknown point pi=(xi,yi) close to fingerprint 1 located at p1 where we
                //have measured received power Pr(pi), we can get the following second-order Taylor
                //approximation:

                //Pr(pi) ~ Pr(p1) + JPr(p1)*(pi - p1) + 1/2*(pi - p1)^T*HPr(p1)*(pi - p1) + ...

                //where JPr(p1) is the Jacobian of Pr evaluated at p1. Since Pr is a multivariate function
                //with scalar result, the Jacobian has size 1x2 and is equal to the gradient.
                //HPr(p1) is the Hessian matrix evaluated at p1, which is a symmetric matrix of size 2x2,
                //and (pi-p1)^T is the transposed vector of (pi-p1)

                //Hence, the Jacobian at any point p=(x,y) is equal to:
                //JPr(p = (x,y)) = [diff(Pr(x,y))/diff(x)   diff(Pr(x,y))/diff(y)]

                //And the Hessian matrix is equal to
                //HPr(p = (x,y)) =  [diff(Pr(x,y))/diff(x^2)    diff(Pr(x,y))/diff(x*y)]
                //                  [diff(Pr(x,y))/diff(x*y)    diff(Pr(x,y))/diff(y^2)]

                //where the first order derivatives of Pr(p = (x,y)) are:
                //diff(Pr(x,y))/diff(x) = -5*n/(ln(10)*((x - xa)^2 + (y - ya)^2)*2*(x - xa)
                //diff(Pr(x,y))/diff(x) = -10*n*(x - xa)/(ln(10)*((x - xa)^2 + (y - ya)^2))

                //diff(Pr(x,y))/diff(y) = -5*n/(ln(10)*((x - xa)^2 + (y - ya)^2)*2*(y - ya)
                //diff(Pr(x,y))/diff(y) = -10*n*(y - ya)/(ln(10)*((x - xa)^2 + (y - ya)^2))

                //If we evaluate first order derivatives at p1 = (x1,y1), we get:
                //diff(Pr(p1))/diff(x) = -10*n*(x1 - xa)/(ln(10)*((x1 - xa)^2 + (y1 - ya)^2))
                //diff(Pr(p1))/diff(y) = -10*n*(y1 - ya)/(ln(10)*((x1 - xa)^2 + (y1 - ya)^2))

                //where square distance from fingerprint 1 to radio source a can be expressed as:
                //d1a^2 = (x1 - xa)^2 + (y1 - ya)^2

                //where both the fingerprint and radio source positions are known, and hence d1a is known.

                //Then first order derivatives can be expressed as:
                //diff(Pr(p1))/diff(x) = -10*n*(x1 - xa)/(ln(10)*d1a^2)
                //diff(Pr(p1))/diff(y) = -10*n*(y1 - ya)/(ln(10)*d1a^2)

                //To obtain second order derivatives we take into account that:
                //(f(x)/g(x))' = (f'(x)*g(x) - f(x)*g'(x))/g(x)^2

                //hence, second order derivatives of Pr(p = (x,y)) are:
                //diff(Pr(x,y))/diff(x^2) = -10*n/ln(10)*(1*((x - xa)^2 + (y - ya)^2) - (x - xa)*2*(x - xa)) / ((x - xa)^2 + (y - ya)^2)^2
                //diff(Pr(x,y))/diff(x^2) = -10*n*((y - ya)^2 - (x - xa)^2)/(ln(10)*((x - xa)^2 + (y - ya)^2)^2)

                //diff(Pr(x,y))/diff(y^2) = -10*n/ln(10)*(1*((x - xa)^2 + (y - ya)^2) - (y - ya)*2*(y - ya)) / ((x - xa)^2 + (y - ya)^2)^2
                //diff(Pr(x,y))/diff(y^2) = -10*n*((x - xa)^2 - (y - ya)^2)/(ln(10)*((x - xa)^2 + (y - ya)^2)^2)

                //diff(Pr(x,y))/diff(x*y) = -10*n/ln(10)*(0*((x - xa)^2 + (y - ya)^2) - (x - xa)*2*(y - ya))/((x - xa)^2 + (y - ya)^2)^2
                //diff(Pr(x,y))/diff(x*y) = 20*n*((x - xa)*(y - ya))/(ln(10)*((x - xa)^2 + (y - ya)^2)^2)

                //If we evaluate second order derivatives at p1 = (x1,y1), we get:
                //diff(Pr(p1))/diff(x^2) = -10*n*((y1 - ya)^2 - (x1 - xa)^2))/(ln(10)*((x1 - xa)^2 + (y1 - ya)^2)^2)
                //diff(Pr(p1))/diff(y^2) = -10*n*((x1 - xa)^2 - (y1 - ya)^2)/(ln(10)*((x1 - xa)^2 + (y1 - ya)^2)^2)
                //diff(Pr(p1))/diff(x*y) = 20*n*(x1 - xa)*(y1 - ya)/(ln(10)*((x1 - xa)^2 + (y1 - ya)^2)^2)

                //and expressing the second order derivatives in terms of distance between
                //fingerprint 1 and radio source a d1a, we get:
                //diff(Pr(p1))/diff(x^2) = -10*n*((y1 - ya)^2 - (x1 - xa)^2))/(ln(10)*d1a^4)
                //diff(Pr(p1))/diff(y^2) = -10*n*((x1 - xa)^2 - (y1 - ya)^2)/(ln(10)*d1a^4)
                //diff(Pr(p1))/diff(x*y) = 20*n*(x1 - xa)*(y1 - ya)/(ln(10)*d1a^4)

                //Hence, second order Taylor expansion can be expressed as:
                //Pr(pi) = Pr(p1) + diff(Pr(p1))/diff(x)*(xi - x1) + diff(Pr(p1))/diff(y)*(yi - y1) +
                //1/2*diff(Pr(p1))/diff(x^2)*(xi - x1)^2 + 1/2*diff(Pr(p1))/diff(y^2)*(yi - y1)^2 +
                //diff(Pr(p1))/diff(x*y)*(xi - x1)*(yi - y1)

                //Pr(pi) = Pr(p1) - 10*n*(x1 - xa)/(ln(10)*d1a^2)*(xi - x1) -10*n*(y1 - ya)/(ln(10)*d1a^2)*(yi - y1)
                //- 5*n*((y1 - ya)^2 - (x1 - xa)^2)/(ln(10)*d1a^4)*(xi - x1)^2
                //- 5*n*((x1 - xa)^2 - (y1 - ya)^2)/(ln(10)*d1a^4)*(yi - y1)^2 +
                //20*n*(x1 - xa)*(y1 - ya)/(ln(10)*d1a^4))*(xi - x1)*(yi - y1)

                //The equation above can be solved using a non-linear fitter such as Levenberg-Marquardt


                //Demonstration in 3D:
                //--------------------
                //Taylor series expansion can be expressed as:
                //f(x) = f(a) + 1/1!*f'(a)*(x - a) + 1/2!*f''(a)*(x - a)^2 + ...

                //where f'(x) is the derivative of f respect x, which can also be expressed as:
                //f'(x) = diff(f(x))/diff(x)

                //and f'(a) is the derivative of f respect x evaluated at a, which can be expressed
                //as f'(a) = diff(f(a))/diff(x)

                //consequently f''(a) is the second derivative respect x evaluated at a, which can
                //be expressed as:
                //f''(x) = diff(f(x))/diff(x^2)

                //and:
                //f''(a) = diff(f(a))/diff(x^2)

                //Received power expressed in dBm is:
                //k = (c/(4*pi*f))
                //Pr = Pte*k^n / d^n

                //where c is the speed of light, pi is 3.14159..., f is the frequency of the radio source,
                //Pte is the equivalent transmitted power by the radio source, n is the path-loss exponent
                // (typically 2.0), and d is the distance from a point to the location of the radio source.

                //Hence:
                //Pr(dBm) = 10*log(Pte*k^n/d^n) = 10*n*log(k) + 10*log(Pte) - 10*n*log(d) =
                //          10*n*log(k) + 10*log(Pte) - 5*n*log(d^2)

                //The former 2 terms are constant, and only the last term depends on distance

                //Hence, assuming the constant K = 10*n*log(k) + Pte(dBm), where Pte(dBm) = 10*log(Pte),
                //assuming that transmitted power by the radio source Pte is known (so that K is also known),
                //and assuming that the location of the radio source is known and it is located at pa = (xa, ya, za)
                //so that d^2 = (x - xa)^2 + (y - ya)^2 + (z - za)^2 then the received power at an unknown point
                //pi = (xi, yi, zi) is:

                //Pr(pi) = Pr(xi,yi,zi) = K - 5*n*log(d^2) = K - 5*n*log((xi - xa)^2 + (yi - ya)^2 + (zi - za)^2)

                //Suppose that received power at point p1=(x1,y1,z1) is known on a located fingerprint
                //containing readings Pr(p1).

                //Then, for an unknown point pi=(xi,yi,zi) close to fingerprint 1 located at p1 where we
                //have measured received power Pr(pi), we can get the following second-order Taylor
                //approximation:

                //Pr(pi) ~ Pr(p1) + JPtr(p1)*(pi - p1) + 1/2*(pi - p1)^T*HPr(p1)*(pi - p1) + ...

                //where JPr(p1) is the Jacobian of Pr evaluated at p1. Since Pr is a multivariate function
                //with scalar result, the Jacobian has size 1x3 and is equal to the gradient.
                //HPtr(p1) is the Hessian matrix evaluated at p1, which is a symmetric matrix of size 3x3,
                //and (pi-p1)^T is the transposed vector of (pi-p1)

                //Hence, the Jacobian at any point p=(x,y,z) is equal to:
                //JPr(p = (x,y,z)) = [diff(Pr(x,y,z))/diff(x)     diff(Pr(x,y,z))/diff(y)     diff(Pr(x,y,z))/diff(z)]

                //And the Hessian matrix is equal to
                //HPr(p = (x,y,z)) = [diff(Pr(x,y,z))/diff(x^2)    diff(Pr(x,y,z))/diff(x*y)     diff(Pr(x,y,z))/diff(x*z)]
                //                   [diff(Pr(x,y,z))/diff(x*y)    diff(Pr(x,y,z))/diff(y^2)     diff(Pr(x,y,z))/diff(y*z)]
                //                   [diff(Pr(x,y,z))/diff(x*z)    diff(Pr(x,y,z))/diff(y*z)     diff(Pr(x,y,z))/diff(z^2)]

                //where the first order derivatives of Pr(p = (x,y)) are:
                //diff(Pr(x,y,z))/diff(x) = -5*n/(ln(10)*((x - xa)^2 + (y - ya)^2 + (z - za)^2)*2*(x - xa)
                //diff(Pr(x,y,z))/diff(x) = -10*n*(x - xa)/(ln(10)*((x - xa)^2 + (y - ya)^2 + (z - za)^2))

                //diff(Pr(x,y,z))/diff(y) = -5*n/(ln(10)*((x - xa)^2 + (y - ya)^2 + (z - za)^2)*2*(y - ya)
                //diff(Pr(x,y,z))/diff(y) = -10*n*(y - ya)/(ln(10)*((x - xa)^2 + (y - ya)^2 + (z - za)^2))

                //diff(Pr(x,y,z))/diff(z) = -5*n/(ln(10)*((x - xa)^2 + (y - ya)^2 + (z - za)^2)*2*(z - za)
                //diff(Pr(x,y,z))/diff(z) = -10*n*(z - za)/(ln(10)*((x - xa)^2 + (y - ya)^2 + (z - za)^2))

                //If we evaluate derivatives at p1 = (x1,y1,z1), we get:
                //diff(Pr(p1))/diff(x) = -10*n*(x1 - xa)/(ln(10)*((x1 - xa)^2 + (y1 - ya)^2 + (z1 - za)^2))
                //diff(Pr(p1))/diff(y) = -10*n*(y1 - ya)/(ln(10)*((x1 - xa)^2 + (y1 - ya)^2 + (z1 - za)^2))
                //diff(Pr(p1))/diff(z) = -10*n*(z1 - za)/(ln(10)*((x1 - xa)^2 + (y1 - ya)^2 + (z1 - za)^2))

                //where square distance from fingerprint 1 to radio source a can be expressed as:
                //d1a^2 = (x1 - xa)^2 + (y1 - ya)^2 + (z1 - za)^2

                //where both the fingerprint and radio source positions are known, and hence d1a is known.

                //Then first order derivatives can be expressed as:
                //diff(Pr(p1))/diff(x) = -10*n*(x1 - xa)/(ln(10)*d1a^2)
                //diff(Pr(p1))/diff(y) = -10*n*(y1 - ya)/(ln(10)*d1a^2)
                //diff(Pr(p1))/diff(z) = -10*n*(z1 - za)/(ln(10)*d1a^2)

                //To obtain second order derivatives we take into account that:
                //(f(x)/g(x))' = (f'(x)*g(x) - f(x)*g'(x))/g(x)^2

                //hence, second order derivatives of Pr(p = (x,y,z)) are:
                //diff(Pr(x,y,z))/diff(x^2) = -10*n/ln(10)*(1*((x - xa)^2 + (y - ya)^2 + (z - za)^2) - (x - xa)*2*(x - xa))/((x - xa)^2 + (y - ya)^2 + (z - za)^2)^2
                //diff(Pr(x,y,z))/diff(x^2) = -10*n*((y - ya)^2 + (z - za)^2 - (x - xa)^2)/(ln(10)*((x - xa)^2 + (y - ya)^2 + (z - za)^2)^2)

                //diff(Pr(x,y,z))/diff(y^2) = -10*n/ln(10)*(1*((x - xa)^2 + (y - ya)^2 + (z - za)^2) - (y - ya)*2*(y - ya))/((x - xa)^2 + (y - ya)^2 + (z - za)^2)^2
                //diff(Pr(x,y,z))/diff(y^2) = -10*n*((x - xa)^2 - (y - ya)^2 + (z - za)^2)/(ln(10)*((x - xa)^2 + (y - ya)^2 + (z - za)^2)^2)

                //diff(Pr(x,y,z))/diff(z^2) = -10*n/ln(10)*(1*((x - xa)^2 + (y - ya)^2 + (z - za)^2) - (z - za)*2*(z - za))/((x - xa)^2 + (y - ya)^2 + (z - za)^2)^2
                //diff(Pr(x,y,z))/diff(z^2) = -10*n*((x - xa)^2 + (y - ya)^2 - (z - za)^2)/(ln(10)*((x - xa)^2 + (y - ya)^2 + (z - za)^2)^2)

                //diff(Pr(x,y,z))/diff(x*y) = -10*n/ln(10)*(0*((x - xa)^2 + (y - ya)^2 + (z - za)^2) - (x - xa)*2*(y - ya))/((x - xa)^2 + (y - ya)^2 + (z - za)^2)^2
                //diff(Pr(x,y,z))/diff(x*y) = 20*n*(x - xa)*(y - ya)/(ln(10)*((x - xa)^2 + (y - ya)^2 + (z - za)^2)^2)

                //diff(Pr(x,y,z))/diff(x*z) = -10*n/ln(10)*(0*((x - xa)^2 + (y - ya)^2 + (z - za)^2) - (x - xa)*2*(z - za))/((x - xa)^2 + (y - ya)^2 + (z - za)^2)^2
                //diff(Pr(x,y,z))/diff(x*z) = 20*n*(x - xa)*(z - za)/(ln(10)*((x - xa)^2 + (y - ya)^2 + (z - za)^2)^2)

                //diff(Pr(x,y,z))/diff(y*z) = -10*n/ln(10)*(0*((x - xa)^2 + (y - ya)^2 + (z - za)^2) - (y - ya)*2*(z - za))/((x - xa)^2 + (y - ya)^2 + (z - za)^2)^2
                //diff(Pr(x,y,z))/diff(y*z) = 20*n*(y - ya)*(z - za)/(ln(10)*((x - xa)^2 + (y - ya)^2 + (z - za)^2)^2)

                //If we evaluate second order derivatives at p1 = (x1,y1,z1), we get:
                //diff(Pr(p1))/diff(x^2) = -10*n*((y1 - ya)^2 + (z1 - za)^2 - (x1 - xa)^2)/(ln(10)*((x1 - xa)^2 + (y1 - ya)^2 + (z1 - za)^2)^2)
                //diff(Pr(p1))/diff(y^2) = -10*n*((x1 - xa)^2 - (y1 - ya)^2 + (z1 - za)^2)/(ln(10)*((x1 - xa)^2 + (y1 - ya)^2 + (z1 - za)^2)^2)
                //diff(Pr(p1))/diff(z^2) = -10*n*((x1 - xa)^2 + (y1 - ya)^2 - (z1 - za)^2)/(ln(10)*((x1 - xa)^2 + (y1 - ya)^2 + (z1 - za)^2)^2)
                //diff(Pr(p1))/diff(x*y) = 20*n*(x1 - xa)*(y1 - ya)/(ln(10)*((x1 - xa)^2 + (y1 - ya)^2 + (z1 - za)^2)^2)
                //diff(Pr(p1))/diff(x*z) = 20*n*(x1 - xa)*(z1 - za)/(ln(10)*((x1 - xa)^2 + (y1 - ya)^2 + (z1 - za)^2)^2)
                //diff(Pr(p1))/diff(y*z) = 20*n*(y1 - ya)*(z1 - za)/(ln(10)*((x1 - xa)^2 + (y1 - ya)^2 + (z1 - za)^2)^2)

                //and expressing the second order derivatives in terms of distance between
                //fingerprint 1 and radio source a d1a, we get:
                //diff(Pr(p1))/diff(x^2) = -10*n*((y1 - ya)^2 + (z1 - za)^2 - (x1 - xa)^2)/(ln(10)*d1a^4)
                //diff(Pr(p1))/diff(y^2) = -10*n*((x1 - xa)^2 - (y1 - ya)^2 + (z1 - za)^2)/(ln(10)*d1a^4)
                //diff(Pr(p1))/diff(z^2) = -10*n*((x1 - xa)^2 + (y1 - ya)^2 - (z1 - za)^2)/(ln(10)*d1a^4)
                //diff(Pr(p1))/diff(x*y) = 20*n*(x1 - xa)*(y1 - ya)/(ln(10)*d1a^4)
                //diff(Pr(p1))/diff(x*z) = 20*n*(x1 - xa)*(z1 - za)/(ln(10)*d1a^4)
                //diff(Pr(p1))/diff(y*z) = 20*n*(y1 - ya)*(z1 - za)/(ln(10)*d1a^4)

                //Hence, second order Taylor expansion can be expressed as:
                //Pr(pi) = Pr(p1) + diff(Pr(p1))/diff(x)*(x - x1) +
                //      diff(Pr(p1))/diff(y)*(y - y1) +
                //      diff(Pr(p1))/diff(z)*(z - z1) +
                //	    1/2*diff(Pr(p1))/diff(x^2)*(x - x1)^2 +
                //	    1/2*diff(Pr(p1))/diff(y^2)*(y - y1)^2 +
                //	    1/2*diff(Pr(p1))/diff(z^2)*(z - z1)^2 +
                //	    diff(Pr(p1))/diff(x*y)*(x - x1)*(y - y1) +
                //	    diff(Pr(p1))/diff(y*z)*(y - y1)*(z - z1) +
                //	    diff(Pr(p1))/diff(x*z)*(x - x1)*(z - z1)

                //Pr(pi) = Pr(p1) - 10*n*(x1 - xa)/(ln(10)*d1a^2)*(xi -x1)
                //      - 10*n*(y1 - ya)/(ln(10)*d1a^2)*(yi - y1)
                //      - 10*n*(z1 - za)/(ln(10)*d1a^2)*(zi - z1)
                //      - 5*n*((y1 - ya)^2 + (z1 - za)^2) - (x1 - xa)^2)/(ln(10)*d1a^4)*(xi - x1)^2
                //      - 5*n*((x1 - xa)^2 - (y1 - ya)^2 + (z1 - za)^2))/(ln(10)*d1a^4)*(yi - y1)^2
                //      - 5*n*((x1 - xa)^2 + (y1 - ya)^2 - (z1 - za)^2))/(ln(10)*d1a^4)*(zi - z1)^2
                //      + 20*n*(x1 - xa)*(y1 - ya)/(ln(10)*d1a^4)*(xi - x1)*(yi - y1)
                //      + 20*n*(y1 - ya)*(z1 - za)/(ln(10)*d1a^4)*(yi - y1)*(zi - z1)
                //      + 20*n*(x1 - xa)*(z1 - za)/(ln(10)*d1a^4)*(xi - x1)*(zi - z1)

                //The equation above can be solved using a non-linear fitter such as Levenberg-Marquardt
                try {
<span class="fc" id="L764">                    setupFitter();</span>

<span class="fc" id="L766">                    mFitter.fit();</span>

                    //estimated position
<span class="fc" id="L769">                    mEstimatedPositionCoordinates = mFitter.getA();</span>
<span class="fc" id="L770">                    mCovariance = mFitter.getCovar();</span>
<span class="fc" id="L771">                    mChiSq = mFitter.getChisq();</span>

                    //a solution was found so we exit loop
<span class="fc" id="L774">                    break;</span>
<span class="fc" id="L775">                } catch (NumericalException e) {</span>
                    //solution could not be found with current data
                    //Iterate to use additinal nearby fingerprints
<span class="fc" id="L778">                    mEstimatedPositionCoordinates = null;</span>
<span class="fc" id="L779">                    mCovariance = null;</span>
<span class="fc" id="L780">                    mNearestFingerprints = null;</span>
                }
            }

<span class="pc bpc" id="L784" title="1 of 2 branches missed.">            if (mEstimatedPositionCoordinates == null) {</span>
                //no solution could be found
<span class="nc" id="L786">                throw new FingerprintEstimationException();</span>
            }

<span class="pc bpc" id="L789" title="1 of 2 branches missed.">            if (mListener != null) {</span>
<span class="fc" id="L790">                mListener.onEstimateEnd(this);</span>
            }
        } finally {
<span class="fc" id="L793">            mLocked = false;</span>
        }
<span class="fc" id="L795">    }</span>

    /**
     * Gets type of position estimator.
     * @return type of position estimator.
     */
    public abstract NonLinearFingerprintPositionEstimatorType getType();

    /**
     * Evaluates a non-linear multi dimension function at provided point using
     * provided parameters and returns its evaluation and derivatives of the
     * function respect the function parameters.
     * @param i number of sample being evaluated.
     * @param point point where function will be evaluated.
     * @param params initial parameters estimation to be tried. These will
     * change as the Levenberg-Marquard algorithm iterates to the best solution.
     * These are used as input parameters along with point to evaluate function.
     * @param derivatives partial derivatives of the function respect to each
     * provided parameter.
     * @return function evaluation at provided point.
     * @throws EvaluationException raised if something failed during the evaluation.
     */
    protected abstract double evaluate(int i, double[] point, double[] params,
            double[] derivatives) throws EvaluationException;

    /**
     * Propagates provided variances into RSSI variance of non-located fingerprint
     * reading.
     * @param fingerprintRssi closest located fingerprint reading RSSI expressed in dBm's.
     * @param pathlossExponent path-loss exponent.
     * @param fingerprintPosition position of closest located fingerprint.
     * @param radioSourcePosition radio source position associated to fingerprint reading.
     * @param estimatedPosition position to be estimated. Usually this is equal to the
     *                          initial position used by a non linear algorithm.
     * @param fingerprintRssiVariance variance of fingerprint RSSI or null if unknown.
     * @param pathlossExponentVariance variance of path-loss exponent or null if unknown.
     * @param fingerprintPositionCovariance covariance of fingerprint position or null if
     *                                      unknown.
     * @param radioSourcePositionCovariance covariance of radio source position or null if
     *                                      unknown.
     * @return variance of RSSI measured at non located fingerprint reading.
     */
    protected abstract Double propagateVariances(double fingerprintRssi,
            double pathlossExponent, P fingerprintPosition, P radioSourcePosition,
            P estimatedPosition, Double fingerprintRssiVariance,
            Double pathlossExponentVariance, Matrix fingerprintPositionCovariance,
            Matrix radioSourcePositionCovariance);

    /**
     * Builds data required to solve the problem.
     * @param allReceivedPower list of received powers for readings at unknown positions.
     * @param allFingerprintPower list of power readings at fingerprint positions.
     * @param allFingerprintPositions list of fingerprint positions.
     * @param allSourcesPositions list of radio sources positions.
     * @param allPathLossExponents list of path loss exponents.
     * @param allStandardDeviations list of standard deviations for readings being used.
     */
    @SuppressWarnings(&quot;Duplicates&quot;)
    private void buildData(List&lt;Double&gt; allReceivedPower,
                           List&lt;Double&gt; allFingerprintPower,
                           List&lt;P&gt; allFingerprintPositions,
                           List&lt;P&gt; allSourcesPositions,
                           List&lt;Double&gt; allPathLossExponents,
                           List&lt;Double&gt; allStandardDeviations) {
        for (RssiFingerprintLocated&lt;RadioSource, RssiReading&lt;RadioSource&gt;, P&gt; locatedFingerprint :
<span class="fc bfc" id="L860" title="All 2 branches covered.">                mNearestFingerprints) {</span>

<span class="fc" id="L862">            List&lt;RssiReading&lt;RadioSource&gt;&gt; locatedReadings =</span>
<span class="fc" id="L863">                    locatedFingerprint.getReadings();</span>
<span class="pc bpc" id="L864" title="1 of 2 branches missed.">            if (locatedReadings == null) {</span>
<span class="nc" id="L865">                continue;</span>
            }

<span class="fc" id="L868">            P fingerprintPosition = locatedFingerprint.getPosition();</span>
<span class="fc" id="L869">            Matrix fingerprintPositionCovariance = locatedFingerprint.</span>
<span class="fc" id="L870">                    getPositionCovariance();</span>

<span class="fc" id="L872">            double locatedMeanRssi = 0.0;</span>
<span class="fc" id="L873">            double meanRssi = 0.0;</span>
<span class="fc bfc" id="L874" title="All 2 branches covered.">            if (mRemoveMeansFromFingerprintReadings) {</span>
<span class="fc" id="L875">                locatedMeanRssi = locatedFingerprint.getMeanRssi();</span>
            }

<span class="fc bfc" id="L878" title="All 2 branches covered.">            for (RssiReading&lt;RadioSource&gt; locatedReading : locatedReadings) {</span>
<span class="fc" id="L879">                RadioSource source = locatedReading.getSource();</span>

                //find within the list of located sources the source of
                //current located fingerprint reading.
                //Radio sources are compared by their id
                //regardless of them being located or not
                @SuppressWarnings(&quot;SuspiciousMethodCalls&quot;)
<span class="fc" id="L886">                int pos = mSources.indexOf(source);</span>
<span class="pc bpc" id="L887" title="1 of 2 branches missed.">                if (pos &lt; 0) {</span>
<span class="nc" id="L888">                    continue;</span>
                }

<span class="fc" id="L891">                RadioSourceLocated&lt;P&gt; locatedSource = mSources.get(pos);</span>
<span class="fc" id="L892">                double pathLossExponent = mPathLossExponent;</span>
<span class="fc" id="L893">                Double pathLossExponentVariance = null;</span>
<span class="pc bpc" id="L894" title="1 of 4 branches missed.">                if (mUseSourcesPathLossExponentWhenAvailable &amp;&amp;</span>
                        locatedSource instanceof RadioSourceWithPower) {
<span class="fc" id="L896">                    RadioSourceWithPower locatedSourceWithPower =</span>
                            (RadioSourceWithPower)locatedSource;
<span class="fc" id="L898">                    pathLossExponent = locatedSourceWithPower.getPathLossExponent();</span>
<span class="fc" id="L899">                    Double std = locatedSourceWithPower.</span>
<span class="fc" id="L900">                            getPathLossExponentStandardDeviation();</span>
<span class="fc bfc" id="L901" title="All 2 branches covered.">                    pathLossExponentVariance = std != null ? std * std : null;</span>
                }

<span class="fc" id="L904">                P sourcePosition = locatedSource.getPosition();</span>
<span class="fc" id="L905">                Matrix sourcePositionCovariance = locatedSource.getPositionCovariance();</span>
<span class="fc" id="L906">                double locatedRssi = locatedReading.getRssi();</span>
<span class="fc" id="L907">                locatedRssi -= locatedMeanRssi;</span>

<span class="fc" id="L909">                Double locatedRssiStd = locatedReading.getRssiStandardDeviation();</span>
<span class="fc bfc" id="L910" title="All 2 branches covered.">                Double locatedRssiVariance = locatedRssiStd != null ?</span>
<span class="fc" id="L911">                        locatedRssiStd * locatedRssiStd : null;</span>
<span class="fc bfc" id="L912" title="All 2 branches covered.">                if (mRemoveMeansFromFingerprintReadings) {</span>
<span class="fc" id="L913">                    meanRssi = mFingerprint.getMeanRssi();</span>
                }

<span class="fc" id="L916">                List&lt;? extends RssiReading&lt;? extends RadioSource&gt;&gt; readings =</span>
<span class="fc" id="L917">                        mFingerprint.getReadings();</span>
<span class="fc bfc" id="L918" title="All 2 branches covered.">                for (RssiReading&lt;? extends RadioSource&gt; reading : readings) {</span>
<span class="pc bpc" id="L919" title="1 of 2 branches missed.">                    if (reading.getSource() == null ||</span>
<span class="fc bfc" id="L920" title="All 2 branches covered.">                            !reading.getSource().equals(locatedSource)) {</span>
<span class="fc" id="L921">                        continue;</span>
                    }

                    //only take into account reading for matching sources on located and
                    //non-located readings
<span class="fc" id="L926">                    double rssi = reading.getRssi();</span>
<span class="fc" id="L927">                    rssi -= meanRssi;</span>

<span class="fc" id="L929">                    Double standardDeviation = null;</span>
<span class="pc bpc" id="L930" title="7 of 8 branches missed.">                    if (mPropagateFingerprintRssiStandardDeviation ||</span>
                            mPropagatePathlossExponentStandardDeviation ||
                            mPropagateFingerprintPositionCovariance ||
                            mPropagateRadioSourcePositionCovariance) {

                        //compute initial position
<span class="fc bfc" id="L936" title="All 2 branches covered.">                        P initialPosition = mInitialPosition != null ?</span>
<span class="fc" id="L937">                                mInitialPosition : fingerprintPosition;</span>

<span class="fc" id="L939">                        Double variance = propagateVariances(locatedRssi,</span>
                                pathLossExponent, fingerprintPosition, sourcePosition,
                                initialPosition,
<span class="pc bpc" id="L942" title="1 of 2 branches missed.">                                mPropagateFingerprintRssiStandardDeviation ? locatedRssiVariance : null,</span>
<span class="pc bpc" id="L943" title="1 of 2 branches missed.">                                mPropagatePathlossExponentStandardDeviation ? pathLossExponentVariance : null,</span>
<span class="pc bpc" id="L944" title="1 of 2 branches missed.">                                mPropagateFingerprintPositionCovariance ? fingerprintPositionCovariance : null,</span>
<span class="pc bpc" id="L945" title="1 of 2 branches missed.">                                mPropagateRadioSourcePositionCovariance ? sourcePositionCovariance : null);</span>
<span class="pc bpc" id="L946" title="1 of 2 branches missed.">                        if (variance != null) {</span>
<span class="fc" id="L947">                            standardDeviation = Math.sqrt(variance);</span>
                        }
                    }

<span class="pc bpc" id="L951" title="1 of 2 branches missed.">                    if (standardDeviation == null) {</span>
<span class="nc" id="L952">                        standardDeviation = reading.getRssiStandardDeviation();</span>
<span class="pc bpc" id="L953" title="1 of 2 branches missed.">                    } else if (reading.getRssiStandardDeviation() != null) {</span>
                        //consider propagated variance and reading variance independent, so we
                        //sum them both
<span class="nc" id="L956">                        standardDeviation = standardDeviation * standardDeviation +</span>
<span class="nc" id="L957">                                reading.getRssiStandardDeviation() * reading.getRssiStandardDeviation();</span>
<span class="nc" id="L958">                        standardDeviation = Math.sqrt(standardDeviation);</span>
                    }

<span class="pc bpc" id="L961" title="1 of 4 branches missed.">                    if (standardDeviation == null || standardDeviation &lt; TINY_RSSI_STD) {</span>
<span class="fc" id="L962">                        standardDeviation = mFallbackRssiStandardDeviation;</span>
                    }

<span class="fc" id="L965">                    allReceivedPower.add(rssi);</span>
<span class="fc" id="L966">                    allFingerprintPower.add(locatedRssi);</span>
<span class="fc" id="L967">                    allFingerprintPositions.add(fingerprintPosition);</span>
<span class="fc" id="L968">                    allSourcesPositions.add(sourcePosition);</span>
<span class="fc" id="L969">                    allPathLossExponents.add(pathLossExponent);</span>
<span class="fc" id="L970">                    allStandardDeviations.add(standardDeviation);</span>
<span class="fc" id="L971">                }</span>
<span class="fc" id="L972">            }</span>
<span class="fc" id="L973">        }</span>
<span class="fc" id="L974">    }</span>

    /**
     * Setups fitter to solve position.
     * @throws FittingException if Levenberg-Marquardt fitting fails.
     */
    @SuppressWarnings(&quot;Duplicates&quot;)
    private void setupFitter() throws FittingException {
        //build lists of data
<span class="fc" id="L983">        final List&lt;Double&gt; allReceivedPower = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L984">        final List&lt;Double&gt; allFingerprintPower = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L985">        final List&lt;P&gt; allFingerprintPositions = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L986">        final List&lt;P&gt; allSourcesPosition = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L987">        final List&lt;Double&gt; allPathLossExponents = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L988">        final List&lt;Double&gt; allStandardDeviations = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L989">        buildData(allReceivedPower, allFingerprintPower,</span>
                allFingerprintPositions, allSourcesPosition, allPathLossExponents,
                allStandardDeviations);

<span class="fc" id="L993">        final int totalReadings = allReceivedPower.size();</span>
<span class="fc" id="L994">        final int dims = getNumberOfDimensions();</span>
<span class="fc" id="L995">        final int n = 2 + 2*dims;</span>

<span class="fc" id="L997">        mFitter.setFunctionEvaluator(new LevenbergMarquardtMultiDimensionFunctionEvaluator() {</span>
            @Override
            public int getNumberOfDimensions() {
<span class="fc" id="L1000">                return n;</span>
            }

            @Override
            public double[] createInitialParametersArray() {

<span class="fc" id="L1006">                double[] initial = new double[dims];</span>

<span class="fc bfc" id="L1008" title="All 2 branches covered.">                if (mInitialPosition == null) {</span>
                    //use centroid of nearest fingerprints as initial value
<span class="fc" id="L1010">                    int num = 0;</span>
                    for (RssiFingerprintLocated&lt;? extends RadioSource,
<span class="fc bfc" id="L1012" title="All 2 branches covered.">                            ? extends RssiReading&lt;? extends RadioSource&gt;, P&gt; fingerprint : mNearestFingerprints) {</span>
<span class="fc" id="L1013">                        P position = fingerprint.getPosition();</span>
<span class="pc bpc" id="L1014" title="1 of 2 branches missed.">                        if (position == null) {</span>
<span class="nc" id="L1015">                            continue;</span>
                        }

<span class="fc bfc" id="L1018" title="All 2 branches covered.">                        for (int i = 0; i &lt; dims; i++) {</span>
<span class="fc" id="L1019">                            initial[i] += position.getInhomogeneousCoordinate(i);</span>
                        }
<span class="fc" id="L1021">                        num++;</span>
<span class="fc" id="L1022">                    }</span>

<span class="fc bfc" id="L1024" title="All 2 branches covered.">                    for(int i = 0; i &lt; dims; i++) {</span>
<span class="fc" id="L1025">                        initial[i] /= num;</span>
                    }
<span class="fc" id="L1027">                } else {</span>
                    //use provided initial position
<span class="fc bfc" id="L1029" title="All 2 branches covered.">                    for(int i = 0; i &lt; dims; i++) {</span>
<span class="fc" id="L1030">                        initial[i] = mInitialPosition.getInhomogeneousCoordinate(i);</span>
                    }
                }
<span class="fc" id="L1033">                return initial;</span>
            }

            @Override
            public double evaluate(int i, double[] point, double[] params, double[] derivatives)
                    throws EvaluationException {
<span class="fc" id="L1039">                return NonLinearFingerprintPositionEstimator.this.evaluate(i, point, params, derivatives);</span>
            }
        });

        try {
<span class="fc" id="L1044">            Matrix x = new Matrix(totalReadings, n);</span>
<span class="fc" id="L1045">            double[] y = new double[totalReadings];</span>
<span class="fc" id="L1046">            double[] standardDeviations = new double[totalReadings];</span>
<span class="fc bfc" id="L1047" title="All 2 branches covered.">            for (int i = 0; i &lt; totalReadings; i++) {</span>
                //fingerprint power Pr(p1)
<span class="fc" id="L1049">                x.setElementAt(i, 0, allFingerprintPower.get(i));</span>
<span class="fc bfc" id="L1050" title="All 2 branches covered.">                for (int j = 0; j &lt; dims; j++) {</span>
<span class="fc" id="L1051">                    x.setElementAt(i, j + 1,</span>
<span class="fc" id="L1052">                            allFingerprintPositions.get(i).getInhomogeneousCoordinate(j));</span>
<span class="fc" id="L1053">                    x.setElementAt(i, j + 1 + dims,</span>
<span class="fc" id="L1054">                            allSourcesPosition.get(i).getInhomogeneousCoordinate(j));</span>
                }
<span class="fc" id="L1056">                x.setElementAt(i, 1 + 2*dims, allPathLossExponents.get(i));</span>

<span class="fc" id="L1058">                y[i] = allReceivedPower.get(i);</span>

<span class="fc" id="L1060">                standardDeviations[i] = allStandardDeviations.get(i);</span>
            }

<span class="fc" id="L1063">            mFitter.setInputData(x, y, standardDeviations);</span>
<span class="nc" id="L1064">        } catch (AlgebraException e) {</span>
<span class="nc" id="L1065">            throw new FittingException(e);</span>
<span class="fc" id="L1066">        }</span>
<span class="fc" id="L1067">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>