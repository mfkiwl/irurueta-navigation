<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GeoMath.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.irurueta:irurueta-navigation</a> &gt; <a href="index.source.html" class="el_package">com.irurueta.navigation.geodesic</a> &gt; <span class="el_source">GeoMath.java</span></div><h1>GeoMath.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2018 Alberto Irurueta Carro (alberto@irurueta.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.irurueta.navigation.geodesic;

/**
 * Defines mathematical functions and constants.
 * Based on net.sf.geographiclib library.
 */
@SuppressWarnings(&quot;WeakerAccess&quot;)
public class GeoMath {

    /**
     * Number of binary digits in the fraction of double precision number.
     * This is equivalent to C++'s {@code numeric_limits&lt;double&gt;::digits}.
     */
    public static final int DIGITS = 53;

    /**
     * Equivalent to C++'s {@code numeric_limits&lt;double&gt;::epsilon()}. This is equal to
     * 0.5^(DIGITS - 1).
     */
<span class="fc" id="L35">    public static final double EPSILON = Math.ulp(1.0);</span>

    /**
     * Equivalent to C++'s {@code numeric_limits&lt;double&gt;::min()}. This is equal to 0.5^1022.
     */
    public static final double MIN = Double.MIN_NORMAL;

    /**
     * Constructor.
     * Prevents instantiation.
     */
    private GeoMath() { }

    /**
     * Square a number.
     * @param x the argument.
     * @return &lt;i&gt;x&lt;/i&gt;&lt;sup&gt;2&lt;/sup&gt;.
     */
    public static double sq(double x) {
<span class="fc" id="L54">        return x * x;</span>
    }

    /**
     * The hypotenuse function avoiding underflow and overflow. This is equivalent
     * to {@link Math#hypot(double, double)}.
     * @param x the first argument.
     * @param y the second argument.
     * @return sqrt(&lt;i&gt;x&lt;/i&gt;&lt;sup&gt;2&lt;/sup&gt; + &lt;i&gt;y&lt;/i&gt;&lt;sup&gt;2&lt;/sup&gt;).
     */
    public static double hypot(double x, double y) {
<span class="fc" id="L65">        x = Math.abs(x);</span>
<span class="fc" id="L66">        y = Math.abs(y);</span>

<span class="fc" id="L68">        double a = Math.max(x, y);</span>
<span class="fc bfc" id="L69" title="All 2 branches covered.">        double b = Math.min(x, y) / (a != 0 ? a : 1);</span>
<span class="fc" id="L70">        return a * Math.sqrt(1 + b * b);</span>
        //For an alternative method see
        //C. Moler and D. Morrisin (1983) https://doi.org/10.1147/rd.276.0577
        //and A. A. Dubrulle (1983) https://doi.org/10.1147/rd.276.0582
    }

    /**
     * log(1 + &lt;i&gt;x&lt;/i&gt;) accurate near &lt;i&gt;x&lt;/i&gt; = 0. This is equivalent to {@link Math#log1p(double)}.
     * &lt;p&gt;
     *     This is taken from D.Goldberg,
     *     &lt;a href=&quot;https://doi.org/10.1145/103162.103163&quot;&gt;What every computer scientist should
     *     know about floating-point arithmetic&lt;/a&gt; (1991),
     *     Theorem 4. See also, N. J. Higham, Accuracy and Stability of Numerical Algorithms, 2nd Edition
     *     (SIAM, 2002), Answer to Problem 1.5, p 528.
     * &lt;/p&gt;
     * @param x the argument.
     * @return log(1 + &lt;i&gt;x&lt;/i&gt;).
     */
    public static double log1p(double x) {
<span class="fc" id="L89">        double y = 1 + x;</span>
<span class="fc" id="L90">        double z = y - 1;</span>
        //Here's the explanation for this magic: y = 1 + z, exactly, and z approx x, thus log(y)/z
        //(which is nearly constant near z = 0) returns a good approximation to the true log(1 + x)/x.
        //The multiplication of x * (log(y)/z) introduces little additional error.
<span class="fc bfc" id="L94" title="All 2 branches covered.">        return z == 0 ? x : x * Math.log(y) / z;</span>
    }

    /**
     * The inverse hyperbolic tangent function. This is defined in terms of {@link GeoMath#log1p(double)} in order
     * to maintain accuracy near &lt;i&gt;x&lt;/i&gt; = 0.
     * In addition, the odd parity of the function is enforced.
     *
     * @param x the argument.
     * @return atanh(&lt;i&gt;x&lt;/i&gt;).
     */
    public static double atanh(double x) {
<span class="fc" id="L106">        double y = Math.abs(x); //Enforce odd parity</span>
<span class="fc" id="L107">        y = Math.log1p(2 * y / (1 - y)) / 2;</span>
<span class="fc bfc" id="L108" title="All 2 branches covered.">        return x &lt; 0 ? -y : y;</span>
    }

    /**
     * Copy the sign. This is equivalent to {@link Math#copySign(double, double)}
     * @param x gives the magnitude of the result.
     * @param y gives the sign of the result.
     * @return value with the magnitude of &lt;i&gt;x&lt;/i&gt; and with the sign of &lt;i&gt;y&lt;/i&gt;.
     */
    public static double copysign(double x, double y) {
<span class="fc bfc" id="L118" title="All 4 branches covered.">        return Math.abs(x) * (y &lt; 0 || y == 0 ? -1 : 1);</span>
    }

    /**
     * The cube root function. This is equivalent to {@link Math#cbrt(double)}.
     * @param x the argument.
     * @return the real cube root of &lt;i&gt;x&lt;/i&gt;.
     */
    public static double cbrt(double x) {
<span class="fc" id="L127">        double y = Math.pow(Math.abs(x), 1/3.0); //Return the real cube root</span>
<span class="pc bpc" id="L128" title="1 of 2 branches missed.">        return x &lt; 0 ? -y : y;</span>
    }

    /**
     * Normalizes sinus and cosinus.
     * @param sinx sinus of x.
     * @param cosx cosinus of x.
     * @return normalized values.
     * @throws IllegalArgumentException if provided sinus and cosinus values have zero
     * norm.
     */
    public static Pair norm(double sinx, double cosx) throws IllegalArgumentException {
<span class="fc" id="L140">        double r = hypot(sinx, cosx);</span>
<span class="fc bfc" id="L141" title="All 2 branches covered.">        if (r == 0.0) {</span>
<span class="fc" id="L142">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L145">        return new Pair(sinx / r, cosx / r);</span>
    }

    /**
     * The error-free sum of two numbers.
     * See D.E. Knuth, TAOCP, Vol 2, 4.2.2, Theorem B.
     * @param u the first number in the sum.
     * @param v the second number in the sum.
     * @return Pair(&lt;i&gt;s&lt;/i&gt;, &lt;i&gt;t&lt;/i&gt;) with &lt;i&gt;s&lt;/i&gt; = round(&lt;i&gt;u&lt;/i&gt; +
     * &lt;i&gt;v&lt;/i&gt;) and &lt;i&gt;t&lt;/i&gt; = &lt;i&gt;u&lt;/i&gt; + &lt;i&gt;v&lt;/i&gt; - &lt;i&gt;s&lt;/i&gt;.
     */
    public static Pair sum(double u, double v) {
<span class="fc" id="L157">        double s = u + v;</span>
<span class="fc" id="L158">        double up = s - v;</span>
<span class="fc" id="L159">        double vpp = s - up;</span>
<span class="fc" id="L160">        up -= u;</span>
<span class="fc" id="L161">        vpp -= v;</span>
<span class="fc" id="L162">        double t = -(up + vpp);</span>
        //u + v = s + t = round(u + v) + t
<span class="fc" id="L164">        return new Pair(s, t);</span>
    }

    /**
     * Evaluate a polynomial.
     *
     * Evaluate &lt;i&gt;y&lt;/i&gt; = &amp;sum;&lt;sub&gt;&lt;i&gt;n&lt;/i&gt;=0..&lt;i&gt;n&lt;/i&gt;&lt;/sub&gt;
     * &lt;i&gt;p&lt;/i&gt;&lt;sub&gt;&lt;i&gt;s&lt;/i&gt;+&lt;i&gt;n&lt;/i&gt;&lt;/sub&gt;
     * &lt;i&gt;x&lt;/i&gt;&lt;sup&gt;&lt;i&gt;n&lt;/i&gt;&amp;minus;&lt;i&gt;n&lt;/i&gt;&lt;/sup&gt;.
     * Return 0 if &lt;i&gt;n&lt;/i&gt; &amp;lt; 0.
     * Return &lt;i&gt;p&lt;/i&gt;&lt;sub&gt;&lt;i&gt;s&lt;/i&gt;&lt;/sub&gt;, if &lt;i&gt;n&lt;/i&gt; = 0 (even if &lt;i&gt;x&lt;/i&gt; is
     * infinite or a nan). The evaluation uses Horner's method.
     * This is equivalent to {@link com.irurueta.numerical.polynomials.Polynomial#evaluate(double)}.
     * @param n the order of the polynomial.
     * @param p the coefficient array (of size &lt;i&gt;n&lt;/i&gt; + &lt;i&gt;s&lt;/i&gt; + 1 or more).
     * @param s starting index of the array.
     * @param x the variable.
     * @return the value of the polynomial.
     */
    public static double polyval(int n, double[] p, int s, double x) {
<span class="pc bpc" id="L184" title="1 of 2 branches missed.">        double y = n &lt; 0 ? 0 : p[s++];</span>
<span class="fc bfc" id="L185" title="All 2 branches covered.">        while (--n &gt;= 0) y = y * x + p[s++];</span>
<span class="fc" id="L186">        return y;</span>
    }

    /**
     * Makes the smallest gap in x = 1 / 16 - nextafter(1/16, 0) = 1/2^57 for reals = 0.7 pm on the earth if x is an
     * angle in degrees. (This is about 1000 times more resolution than we get with angles around 90 degrees.). We use
     * this to avoid having to deal with near singular cases when x is non-zero but tiny (e.g. 1.0e-200). This converts
     * -0 to +0; however tiny negative numbers get converted to -0.
     * @param x value to be converted
     * @return rounded value.
     */
    public static double angRound(double x) {
<span class="fc" id="L198">        final double z = 1/16.0;</span>
<span class="fc bfc" id="L199" title="All 2 branches covered.">        if (x == 0) {</span>
<span class="fc" id="L200">            return 0;</span>
        }

<span class="fc" id="L203">        double y = Math.abs(x);</span>
        //The compiler mustn't &quot;simplify&quot; z - (z - y) to y
<span class="fc bfc" id="L205" title="All 2 branches covered.">        y = y &lt; z ? z - (z - y) : y;</span>
<span class="fc bfc" id="L206" title="All 2 branches covered.">        return x &lt; 0 ? -y : y;</span>
    }

    /**
     * Normalizes an angle (restricted input range).
     * The range of &lt;i&gt;x&lt;/i&gt; is unrestricted.
     * @param x the angle in degrees.
     * @return the angle reduced to the range [&amp;minus;180&amp;deg;, 180&amp;deg;).
     */
    public static double angNormalize(double x) {
<span class="fc" id="L216">        x = x % 360.0;</span>
<span class="fc bfc" id="L217" title="All 2 branches covered.">        if (x &lt;= -180 ) {</span>
<span class="fc" id="L218">            return x + 360;</span>
        } else {
<span class="fc bfc" id="L220" title="All 2 branches covered.">            return x &lt;= 180 ? x : x - 360;</span>
        }
    }

    /**
     * Normalizes latitude.
     * @param x the angle in degrees.
     * @return x if it is in the range [&amp;minus;90&amp;deg;, 90&amp;deg;], otherwise return NaN.
     */
    public static double latFix(double x) {
<span class="fc bfc" id="L230" title="All 2 branches covered.">        return Math.abs(x) &gt; 90 ? Double.NaN : x;</span>
    }

    /**
     * The exact difference of two angles reduced to (&amp;minus;180&amp;deg;, 180&amp;deg;].
     * This computes &lt;i&gt;z&lt;/i&gt; = &lt;i&gt;y&lt;/i&gt; &amp;minus; &lt;i&gt;x&lt;/i&gt; exactly, reduced to (&amp;minus;180&amp;deg;, 180&amp;deg;]; and then sets
     * &lt;i&gt;z&lt;/i&gt; = &lt;i&gt;d&lt;/i&gt; + &lt;i&gt;e&lt;/i&gt; where &lt;i&gt;d&lt;/i&gt; is the nearest representable number to &lt;i&gt;z&lt;/i&gt; and &lt;i&gt;e&lt;/i&gt; is the
     * truncation error. If &lt;i&gt;d&lt;/i&gt; = &amp;minus;180, then &lt;i&gt;e&lt;/i&gt; &amp;gt; 0; If &lt;i&gt;d&lt;/i&gt; = 180, then &lt;i&gt;e&lt;/i&gt; &amp;le; 0.
     * @param x the first angle in degrees.
     * @param y the second angle in degrees.
     * @return Pair(&lt;i&gt;d&lt;/i&gt;, &lt;i&gt;e&lt;/i&gt;) with &lt;i&gt;d&lt;/i&gt; being the rounded difference and &lt;i&gt;e&lt;/i&gt; being the error.
     */
    public static Pair angDiff(double x, double y) {
        double d;
        double t;

        //noinspection all
<span class="fc" id="L247">        Pair r = sum(angNormalize(-x), angNormalize(y));</span>
<span class="fc" id="L248">        d = angNormalize(r.first);</span>
<span class="fc" id="L249">        t = r.second;</span>

<span class="fc bfc" id="L251" title="All 4 branches covered.">        return sum(d == 180 &amp;&amp; t &gt; 0 ? -180 : d, t);</span>
    }

    /**
     * Evaluate the sine and cosine function with the argument in degrees.
     * The results obey exactly the elementary properties of the trigonometric functions, e.g.
     * sin 9&amp;deg; = cos 81&amp;deg; = &amp;minus; sin 123456789&amp;deg;.
     * @param x in degrees.
     * @return Pair(&lt;i&gt;s&lt;/i&gt;, &lt;i&gt;t&lt;/i&gt;) with &lt;i&gt;s&lt;/i&gt; = sin(&lt;i&gt;x&lt;/i&gt; and &lt;i&gt;c&lt;/i&gt; = cos(&lt;i&gt;x&lt;/i&gt;).
     */
    public static Pair sincosd(double x) {
        //In order to minimize round-off errors, this function exactly reduces the argument to the range [-45, 45]
        // before converting it to radians.
        double r;
        int q;
<span class="fc" id="L266">        r = x % 360.0;</span>
<span class="fc" id="L267">        q = (int)Math.floor(r / 90 + 0.5);</span>
<span class="fc" id="L268">        r -= 90 * q;</span>
        //now abs(r) &lt;= 45
<span class="fc" id="L270">        r = Math.toRadians(r);</span>
        //Possibly could call the gnu extension sincos
<span class="fc" id="L272">        double s = Math.sin(r);</span>
<span class="fc" id="L273">        double c = Math.cos(r);</span>
        double sinx;
        double cosx;
<span class="fc bfc" id="L276" title="All 4 branches covered.">        switch (q &amp; 3) {</span>
            case 0:
<span class="fc" id="L278">                sinx = s;</span>
<span class="fc" id="L279">                cosx = c;</span>
<span class="fc" id="L280">                break;</span>
            case 1:
<span class="fc" id="L282">                sinx = c;</span>
<span class="fc" id="L283">                cosx = -s;</span>
<span class="fc" id="L284">                break;</span>
            case 2:
<span class="fc" id="L286">                sinx = -s;</span>
<span class="fc" id="L287">                cosx = -c;</span>
<span class="fc" id="L288">                break;</span>
            default:
                //case 3
<span class="fc" id="L291">                sinx = -c;</span>
<span class="fc" id="L292">                cosx = s;</span>
        }
<span class="fc bfc" id="L294" title="All 2 branches covered.">        if (x != 0) {</span>
<span class="fc" id="L295">            sinx += 0.0;</span>
<span class="fc" id="L296">            cosx += 0.0;</span>
        }
<span class="fc" id="L298">        return new Pair(sinx, cosx);</span>
    }

    /**
     * Evaluate the atan2 function with the result in degrees.
     * The result is in the range (&amp;minus;180&amp;deg; 180&amp;deg;]. N.B.,
     * atan2d(&amp;plusmn;0, &amp;minus;1) = +180&amp;deg;; atan2d(&amp;minus;&amp;epsilon;,&amp;minus;1) = &amp;minus;180&amp;deg;, for &amp;epsilon;
     * positive and tiny; atan2d(&amp;plusmn;0, 1) = +plusmn;0&amp;deg;.
     * @param y the sine of the angle.
     * @param x the cosine of the angle.
     * @return atan2(&lt;i&gt;y&lt;/i&gt;, &lt;i&gt;x&lt;/i&gt;) in degrees.
     */
    public static double atan2d(double y, double x) {
        //In order to minimize round-off errors, this function rearranges the arguments so that result of atan2 is in
        // the range [-pi/4, pi/4] before converting it to degrees and mapping the result to the correct quadrant.
<span class="fc" id="L313">        int q = 0;</span>
<span class="fc bfc" id="L314" title="All 2 branches covered.">        if (Math.abs(y) &gt; Math.abs(x)) {</span>
            double t;
<span class="fc" id="L316">            t = x;</span>
            //noinspection all
<span class="fc" id="L318">            x = y;</span>
<span class="fc" id="L319">            y = t;</span>
<span class="fc" id="L320">            q = 2;</span>
        }
<span class="fc bfc" id="L322" title="All 2 branches covered.">        if (x &lt; 0) {</span>
<span class="fc" id="L323">            x = -x;</span>
<span class="fc" id="L324">            ++q;</span>
        }
        //here x &gt;= 0 and x &gt;= abs(y), so angle is in [-pi/4, pi/4]
<span class="fc" id="L327">        double ang = Math.toDegrees(Math.atan2(y, x));</span>
<span class="fc bfc" id="L328" title="All 4 branches covered.">        switch (q) {</span>
            //Note that atan2d(-0.0, 1.0) will return -0. However, we expect that atan2d will not be called with y = -0.
            //If need be, include case 0: ang = 0 + ang; break
            //and handle mpfr as in angRound.
            case 1:
<span class="fc bfc" id="L333" title="All 2 branches covered.">                ang = (y &gt;= 0 ? 180 : -180) - ang;</span>
<span class="fc" id="L334">                break;</span>
            case 2:
<span class="fc" id="L336">                ang = 90 - ang;</span>
<span class="fc" id="L337">                break;</span>
            case 3:
<span class="fc" id="L339">                ang = -90 + ang;</span>
<span class="fc" id="L340">                break;</span>
            default:
                break;
        }
<span class="fc" id="L344">        return ang;</span>
    }

    /**
     * Test for finiteness.
     * @param x the argument.
     * @return true if number is finite, false if NaN or infinite.
     */
    public static boolean isFinite(double x) {
<span class="fc bfc" id="L353" title="All 2 branches covered.">        return Math.abs(x) &lt;= Double.MAX_VALUE;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>