<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- Generated by Apache Maven Doxia Site Renderer 1.8.1 from org.apache.maven.plugins:maven-pmd-plugin:3.10.0:cpd at 2019-11-17 -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>com.irurueta:irurueta-navigation &#x2013; CPD Results</title>
    <style type="text/css" media="all">
      @import url("./css/maven-base.css");
      @import url("./css/maven-theme.css");
      @import url("./css/site.css");
    </style>
    <link rel="stylesheet" href="./css/print.css" type="text/css" media="print" />
    <meta http-equiv="Content-Language" content="en" />
    
  </head>
  <body class="composite">
    <div id="banner">
<div id="bannerLeft">
com.irurueta:irurueta-navigation
</div>
      <div class="clear">
        <hr/>
      </div>
    </div>
    <div id="breadcrumbs">
      <div class="xleft">
        <span id="publishDate">Last Published: 2019-11-17</span>
          &nbsp;| <span id="projectVersion">Version: 1.0-SNAPSHOT</span>
      </div>
      <div class="xright"><a href="./" title="com.irurueta:irurueta-navigation">com.irurueta:irurueta-navigation</a>      </div>
      <div class="clear">
        <hr/>
      </div>
    </div>
    <div id="leftColumn">
      <div id="navcolumn">
       <h5>Project Documentation</h5>
    <ul>
     <li class="collapsed"><a href="project-info.html" title="Project Information">Project Information</a></li>
     <li class="expanded"><a href="project-reports.html" title="Project Reports">Project Reports</a>
      <ul>
       <li class="none"><a href="apidocs/index.html" title="Javadoc">Javadoc</a></li>
       <li class="none"><a href="testapidocs/index.html" title="Test Javadoc">Test Javadoc</a></li>
       <li class="none"><a href="surefire-report.html" title="Surefire Report">Surefire Report</a></li>
       <li class="none"><a href="checkstyle.html" title="Checkstyle">Checkstyle</a></li>
       <li class="none"><a href="findbugs.html" title="FindBugs">FindBugs</a></li>
       <li class="none"><strong>CPD</strong></li>
       <li class="none"><a href="pmd.html" title="PMD">PMD</a></li>
       <li class="none"><a href="xref/index.html" title="Source Xref">Source Xref</a></li>
       <li class="none"><a href="xref-test/index.html" title="Test Source Xref">Test Source Xref</a></li>
      </ul></li>
    </ul>
      <a href="http://maven.apache.org/" title="Built by Maven" class="poweredBy">
        <img class="poweredBy" alt="Built by Maven" src="./images/logos/maven-feather.png" />
      </a>
      </div>
    </div>
    <div id="bodyColumn">
      <div id="contentBox">
<div class="section">
<h2><a name="CPD_Results"></a>CPD Results</h2>
<p>The following document contains the results of PMD's  <a class="externalLink" href="http://pmd.sourceforge.net/cpd.html">CPD</a> 6.4.0.</p></div>
<div class="section">
<h2><a name="Duplications"></a>Duplications</h2>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/SequentialRobustMixedPositionEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/SequentialRobustMixedPositionEstimator.html#L714">714</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/SequentialRobustRangingAndRssiPositionEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/SequentialRobustRangingAndRssiPositionEstimator.html#L688">688</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>            SequentialRobustMixedPositionEstimatorListener&lt;P&gt; listener) {
        this(sourceQualityScores, fingerprintReadingQualityScores, sources,
                fingerprint);
        mListener = listener;
    }

    /**
     * Gets robust method used for robust position estimation using ranging data.
     *
     * @return robust method used for robust position estimation using ranging data.
     */
    public RobustEstimatorMethod getRangingRobustMethod() {
        return mRangingRobustMethod;
    }

    /**
     * Sets robust method for robust position estimation using ranging data.
     *
     * @param rangingRobustMethod   robust method used for robust position estimation
     *                              using ranging data.
     * @throws LockedException  if this instance is locked.
     */
    public void setRangingRobustMethod(RobustEstimatorMethod rangingRobustMethod)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }

        mRangingRobustMethod = rangingRobustMethod;
    }

    /**
     * Gets robust method used for coarse robust position estimation using RSSI data.
     *
     * @return robust method used for coarse robust position estimation using RSSI
     * data.
     */
    public RobustEstimatorMethod getRssiRobustMethod() {
        return mRssiRobustMethod;
    }

    /**
     * Sets robust method used for coarse robust position estimation using RSSI data.
     *
     * @param rssiRobustMethod  robust method used for coarse robust position estimation
     *                          using RSSI data.
     * @throws LockedException  if this instance is locked.
     */
    public void setRssiRobustMethod(RobustEstimatorMethod rssiRobustMethod)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }

        mRssiRobustMethod = rssiRobustMethod;
    }

    /**
     * Indicates whether located radio source position covariance is taken into account
     * (if available) to determine distance standard deviation for ranging measurements.
     * @return true to take into account radio source position covariance during ranging
     * position estimation, false otherwise.
     */
    public boolean isRangingRadioSourcePositionCovarianceUsed() {
        return mUseRangingRadioSourcePositionCovariance;
    }

    /**
     * Specifies whether located radio source position covariance is taken into account
     * (if available) to determine distance standard deviation for ranging measurements.
     * @param useRangingRadioSourcePositionCovariance   true to take into account radio
     *                                                  source position covariance during
     *                                                  ranging position estimation,
     *                                                  false otherwise.
     * @throws LockedException  if this instance is locked.
     */
    public void setRangingRadioSourcePositionCovarianceUsed(
            boolean useRangingRadioSourcePositionCovariance) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }

        mUseRangingRadioSourcePositionCovariance =
                useRangingRadioSourcePositionCovariance;
    }

    /**
     * Indicates whether located radio source position covariance is taken into account
     * (if available) to determine distance standard deviation for RSSI measurements.
     *
     * @return true to take into account radio source position covariance during RSSI
     * position estimation, false otherwise.
     */
    public boolean isRssiRadioSourcePositionCovarianceUsed() {
        return mUseRssiRadioSourcePositionCovariance;
    }

    /**
     * Specifies whether located radio source position covariance is taken into account
     * (if available) to determine distance standard deviation for RSSI measurements.
     * @param useRssiRadioSourcePositionCovariance  true to take into account radio
     *                                              source position covariance during
     *                                              RSSI position estimation, false
     *                                              otherwise.
     * @throws LockedException if this instance is locked.
     */
    public void setRssiRadioSourcePositionCovarianceUsed(
            boolean useRssiRadioSourcePositionCovariance) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }

        mUseRssiRadioSourcePositionCovariance = useRssiRadioSourcePositionCovariance;
    }

    /**
     * Indicates whether ranging readings are evenly distributed among radio sources
     * taking into account quality scores of both radio sources and ranging readings.
     *
     * @return true if ranging readings are evenly distributed among radio sources,
     * false otherwise.
     */
    public boolean isRangingReadingsEvenlyDistributed() {
        return mEvenlyDistributeRangingReadings;
    }

    /**
     * Specifies whether ranging readings are evenly distributed among radio sources
     * taking into account quality scores of both radio sources and ranging readings.
     *
     * @param evenlyDistributeRangingReadings   true if ranging readings are evenly
     *                                          distributed among radio sources, false
     *                                          otherwise.
     * @throws LockedException if this instance is locked.
     */
    public void setRangingReadingsEvenlyDistributed(
            boolean evenlyDistributeRangingReadings) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }

        mEvenlyDistributeRangingReadings = evenlyDistributeRangingReadings;
    }

    /**
     * Gets distance standard deviation fallback value to use when none can be
     * determined from provided RSSI measurements.
     *
     * @return distance standard deviation fallback value to use when none can be
     * determined from provided RSSI measurements.
     */
    public double getRssiFallbackDistanceStandardDeviation() {
        return mRssiFallbackDistanceStandardDeviation;
    }

    /**
     * Sets distance standard deviation fallback value to use when none can be
     * determined from provided RSSI measurements.
     *
     * @param rssiFallbackDistanceStandardDeviation distance standard deviation fallback
     *                                              value to use when none can be
     *                                              determined from provided RSSI
     *                                              measurements.
     * @throws LockedException if this instance is locked.
     */
    public void setRssiFallbackDistanceStandardDeviation(
            double rssiFallbackDistanceStandardDeviation) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mRssiFallbackDistanceStandardDeviation = rssiFallbackDistanceStandardDeviation;
    }

    /**
     * Gets distance standard deviation fallback value to use when none can be
     * determined from provided ranging measurements.
     *
     * @return distance standard deviation fallback value to use when none can be
     * determined from provided ranging measurements.
     */
    public double getRangingFallbackDistanceStandardDeviation() {
        return mRangingFallbackDistanceStandardDeviation;
    }

    /**
     * Sets distance standard deviation fallback value to use when none can be
     * determined from provided ranging measurements.
     *
     * @param rangingFallbackDistanceStandardDeviation  distance standard deviation
     *                                                  fallback value to use when none
     *                                                  can be determined from provided
     *                                                  ranging measurements.
     * @throws LockedException if this instance is locked.
     */
    public void setRangingFallbackDistanceStandardDeviation(
            double rangingFallbackDistanceStandardDeviation) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mRangingFallbackDistanceStandardDeviation =
                rangingFallbackDistanceStandardDeviation;
    }

    /**
     * Indicates whether RSSI readings are evenly distributed among radio sources
     * taking into account quality scores of both radio sources and RSSI readings.
     *
     * @return true if RSSI readings are evenly distributed among radio sources,
     * false otherwise.
     */
    public boolean isRssiReadingsEvenlyDistributed() {
        return mEvenlyDistributeRssiReadings;
    }

    /**
     * Specifies whether RSSI readings are evenly distributed among radio sources
     * taking into account quality scores of both radio sources and RSSI readings.
     *
     * @param evenlyDistributeRssiReadings  true if RSSI readings are evenly distributed
     *                                      among radio sources, false otherwise.
     * @throws LockedException if this instance is locked.
     */
    public void setRssiReadingsEvenlyDistributed(
            boolean evenlyDistributeRssiReadings) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }

        mEvenlyDistributeRssiReadings = evenlyDistributeRssiReadings;
    }

    /**
     * Gets amount of progress variation before notifying a progress change during
     * estimation.
     *
     * @return amount of progress variation before notifying a progress change during
     * estimation.
     */
    public float getProgressDelta() {
        return mProgressDelta;
    }

    /**
     * Sets amount of progress variation before notifying a progress change during
     * estimation.
     *
     * @param progressDelta amount of progress variation before notifying a progress
     *                      change during estimation.
     * @throws IllegalArgumentException if progress delta is less than zero or
     * greater than 1.
     * @throws LockedException          if this instance is locked.
     */
    public void setProgressDelta(float progressDelta) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (progressDelta &lt; MIN_PROGRESS_DELTA || progressDelta &gt; MAX_PROGRESS_DELTA) {
            throw new IllegalArgumentException();
        }
        mProgressDelta = progressDelta;
    }

    /**
     * Returns amount of confidence expressed as a value between 0.0 and 1.0 (which
     * is equivalent to 100%) for robust position estimation on ranging data. The
     * amount of confidence indicates the probability that the estimated result is
     * correct. Usually this value will be close to 1.0, but not exactly 1.0.
     *
     * @return amount of confidence for robust position estimation as a value between
     * 0.0 and 1.0.
     */
    public double getRangingConfidence() {
        return mRangingConfidence;
    }

    /**
     * Sets amount of confidence expressed as a value between 0.0 and 1.0 (which is
     * equivalent to 100%) for robust position estimation on ranging data. The amount
     * of confidence indicates the probability that the estimated result is correct.
     * Usually this value will be close to 1.0, but not exactly 1.0.
     *
     * @param rangingConfidence confidence to be set for robust position estimation as
     *                          a value between 0.0 and 1.0.
     * @throws IllegalArgumentException if provided value is not between 0.0 and 1.0.
     * @throws LockedException          if estimator is locked.
     */
    public void setRangingConfidence(double rangingConfidence) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (rangingConfidence &lt; MIN_CONFIDENCE || rangingConfidence &gt; MAX_CONFIDENCE) {
            throw new IllegalArgumentException();
        }
        mRangingConfidence = rangingConfidence;
    }

    /**
     * Returns amount of confidence expressed as a value between 0.0 and 1.0 (which is
     * equivalent to 100%) for robust position estimation on RSSI data. The amount of
     * confidence indicates the probability that the estimated result is correct.
     * Usually this value will be close to 1.0, but not exactly 1.0.
     *
     * @return amount of confidence for robust position estimation as a value between
     * 0.0 and 1.0.
     */
    public double getRssiConfidence() {
        return mRssiConfidence;
    }

    /**
     * Sets amount of confidence expressed as a value between 0.0 and 1.0 (which is
     * equivalent to 100%) for robust position estimation on RSSI data. The amount
     * of confidence indicates the probability that the estimated result is correct.
     * Usually this value will be close to 1.0, but not exactly 1.0.
     *
     * @param rssiConfidence    amount of confidence for robust position estimation as
     *                          a value between 0.0 and 1.0.
     * @throws IllegalArgumentException if provided value is not between 0.0 and 1.0.
     * @throws LockedException          if estimator is locked.
     */
    public void setRssiConfidence(double rssiConfidence) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (rssiConfidence &lt; MIN_CONFIDENCE || rssiConfidence &gt; MAX_CONFIDENCE) {
            throw new IllegalArgumentException();
        }
        mRssiConfidence = rssiConfidence;
    }

    /**
     * Gets maximum allowed number of iterations for robust ranging position estimation.
     * When the maximum number of iterations is exceeded, an approximate result might
     * be available for retrieval.
     *
     * @return maximum allowed number of iterations for position estimation.
     */
    public int getRangingMaxIterations() {
        return mRangingMaxIterations;
    }

    /**
     * Sets maximum allowed number of iterations for robust ranging position
     * estimation.
     * When the maximum number of iterations is exceeded, an approximate result might
     * be available for retrieval.
     *
     * @param rangingMaxIterations  maximum allowed number of iterations to be set for
     *                              position estimation.
     * @throws IllegalArgumentException if provided value is less than 1.
     * @throws LockedException          if estimator is locked.
     */
    public void setRangingMaxIterations(int rangingMaxIterations)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (rangingMaxIterations &lt; MIN_ITERATIONS) {
            throw new IllegalArgumentException();
        }
        mRangingMaxIterations = rangingMaxIterations;
    }

    /**
     * Gets maximum allowed number of iterations for robust RSSI position estimation.
     * When the maximum number of iterations is exceeded, an approximate result might
     * be available for retrieval.
     *
     * @return maximum allowed number of iterations for position estimation.
     */
    public int getRssiMaxIterations() {
        return mRssiMaxIterations;
    }

    /**
     * Sets maximum allowed number of iterations for robust RSSI position estimation.
     * When the maximum number of iterations is exceeded, an approximate result might
     * be available for retrieval.
     *
     * @param rssiMaxIterations maximum allowed number of iterations to be set for
     *                          position estimation.
     * @throws IllegalArgumentException if provided value is less than 1.
     * @throws LockedException          if estimator is locked.
     */
    public void setRssiMaxIterations(int rssiMaxIterations) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (rssiMaxIterations &lt; MIN_ITERATIONS) {
            throw new IllegalArgumentException();
        }
        mRssiMaxIterations = rssiMaxIterations;
    }

    /**
     * Indicates whether result is refined using all found inliers.
     *
     * @return true if result is refined, false otherwise.
     */
    public boolean isResultRefined() {
        return mRefineResult;
    }

    /**
     * Specifies whether result is refined using all found inliers.
     *
     * @param refineResult true if result is refined, false otherwise.
     * @throws LockedException if this instance is locked.
     */
    public void setResultRefined(boolean refineResult) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }

        mRefineResult = refineResult;
    }

    /**
     * Indicates whether covariance must be kept after refining result.
     * This setting is only taken into account if result is refined.
     *
     * @return true if covariance must be kept after refining result, false otherwise.
     */
    public boolean isCovarianceKept() {
        return mKeepCovariance;
    }

    /**
     * Specifies whether covariance must be kept after refining result.
     * This setting is only taken into account if result is refined.
     *
     * @param keepCovariance true if covariance must be kept after refining result,
     *                       false otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setCovarianceKept(boolean keepCovariance) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mKeepCovariance = keepCovariance;
    }

    /**
     * Indicates whether a linear solver is used for preliminary solution estimation
     * using ranging measurements.
     * The result obtained on each preliminary solution might be later refined.
     *
     * @return true if a linear solver is used for preliminary solution estimation on
     * ranging readings.
     */
    public boolean isRangingLinearSolverUsed() {
        return mUseRangingLinearSolver;
    }

    /**
     * Specifies whether a linear solver is used for preliminary solution estimation
     * using ranging measurements.
     * The result obtained on each preliminary solution might be later refined.
     *
     * @param useRangingLinearSolver    true if a linear solver is used for preliminary
     *                                  solution estimation on ranging readings.
     * @throws LockedException if estimator is locked.
     */
    public void setRangingLinearSolverUsed(boolean useRangingLinearSolver)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mUseRangingLinearSolver = useRangingLinearSolver;
    }

    /**
     * Indicates whether a linear solver is used for preliminary solution estimation
     * using RSSI measurements.
     * The result obtained on each preliminary solution might be later refined.
     *
     * @return true if a linear solver is used for preliminary solution estimation on
     * RSSI readings.
     */
    public boolean isRssiLinearSolverUsed() {
        return mUseRssiLinearSolver;
    }

    /**
     * Specifies whether a linear solver is used for preliminary solution estimation
     * using RSSI measurements.
     * The result obtained on each preliminary solution might be later refined.
     *
     * @param useRssiLinearSolver   true if a linear solver is used for preliminary
     *                              solution estimation on RSSI readings.
     * @throws LockedException if estimator is locked.
     */
    public void setRssiLinearSolverUsed(boolean useRssiLinearSolver)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mUseRssiLinearSolver = useRssiLinearSolver;
    }

    /**
     * Indicates whether an homogeneous linear solver is used either to estimate
     * preliminary solutions or an initial solution for preliminary solutions that
     * will be later refined on the ranging fine estimation.
     *
     * @return true to use an homogeneous linear solver for preliminary solutions
     * during ranging fine position estimation.
     */
    public boolean isRangingHomogeneousLinearSolverUsed() {
        return mUseRangingHomogeneousLinearSolver;
    }

    /**
     * Specifies whether an homogeneous linear solver is used either to estimate
     * preliminary solutions or an initial solution for preliminary solutions that
     * will be later refined on the ranging fine estimation.
     *
     * @param useRangingHomogeneousLinearSolver true to use an homogeneous linear
     *                                          solver for preliminary solutions during
     *                                          ranging fine position estimation.
     * @throws LockedException if estimator is locked.
     */
    public void setRangingHomogeneousLinearSolverUsed(
            boolean useRangingHomogeneousLinearSolver) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mUseRangingHomogeneousLinearSolver = useRangingHomogeneousLinearSolver;
    }

    /**
     * Indicates whether an homogeneous linear solver is used either to estimate
     * preliminary solutions or an initial solution for preliminary solutions that
     * will be later refined on the RSSI coarse estimation.
     *
     * @return true to use an homogeneous linear solver for preliminary solutions
     * during RSSI coarse position estimation.
     */
    public boolean isRssiHomogeneousLinearSolverUsed() {
        return mUseRssiHomogeneousLinearSolver;
    }

    /**
     * Specifies whether an homogeneous linear solver is used either to estimate
     * preliminary solutions or an initial solution for preliminary solutions that
     * will be later refined on the RSSI coarse estimation.
     *
     * @param useRssiHomogeneousLinearSolver    true to use an homogeneous linear
     *                                          solver for preliminary solutions during
     *                                          RSSI fine position estimation.
     * @throws LockedException if estimator is locked.
     */
    public void setRssiHomogeneousLinearSolverUsed(
            boolean useRssiHomogeneousLinearSolver) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mUseRssiHomogeneousLinearSolver = useRssiHomogeneousLinearSolver;
    }

    /**
     * Indicates whether preliminary ranging solutions are refined after an initial
     * linear solution is found.
     * If no initial preliminary solution is found using a linear solver, a non
     * linear solver will be used regardless of this value using an average solution
     * as the initial value to be refined.
     *
     * @return true if preliminary ranging solutions must be refined after an initial
     * linear solution, false otherwise.
     */
    public boolean isRangingPreliminarySolutionRefined() {
        return mRefineRangingPreliminarySolutions;
    }

    /**
     * Specifies whether preliminary ranging solutions are refined after an initial
     * linear solution is found.
     * If no initial preliminary solution is found using a linear solver, a non
     * linear solver will be used regardless of this value using an average solution
     * as the initial value to be refined.
     *
     * @param refineRangingPreliminarySolutions true if preliminary ranging solutions
     *                                          must be refined after an initial linear
     *                                          solution, false otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setRangingPreliminarySolutionRefined(
            boolean refineRangingPreliminarySolutions) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mRefineRangingPreliminarySolutions = refineRangingPreliminarySolutions;
    }

    /**
     * Indicates whether preliminary RSSI solutions are refined after an initial
     * linear solution is found.
     * If no initial preliminary solution is found using a linear solver, a non
     * linear solver will be used regardless of this value using an average solution
     * as the initial value to be refined.
     *
     * @return true if preliminary RSSI solutions must be refined after an initial
     * linear solution, false otherwise.
     */
    public boolean isRssiPreliminarySolutionRefined() {
        return mRefineRssiPreliminarySolutions;
    }

    /**
     * Specifies whether preliminary RSSI solutions are refined after an initial
     * linear solution is found.
     * If no initial preliminary solution is found using a linear solver, a non
     * linear solver will be used regardless of this value using an average solution
     * as the initial value ot be refined.
     *
     * @param refineRssiPreliminarySolutions    true if preliminary RSSI solutions must
     *                                          be refined after an initial linear
     *                                          solution, false otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setRssiPreliminarySolutionRefined(
            boolean refineRssiPreliminarySolutions) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mRefineRssiPreliminarySolutions = refineRssiPreliminarySolutions;
    }

    /**
     * Gets size of subsets to be checked during ranging robust estimation.
     *
     * @return size of subsets to be checked during ranging robust estimation.
     */
    public int getRangingPreliminarySubsetSize() {
        return mRangingPreliminarySubsetSize;
    }

    /**
     * Sets size of subsets to be checked during ranging robust estimation.
     *
     * @param rangingPreliminarySubsetSize  size of subsets to be checked during
     *                                      ranging robust estimation.
     * @throws LockedException  if estimator is locked.
     * @throws IllegalArgumentException if provided value is less than {@link #getMinRequiredSources()}.
     */
    public void setRangingPreliminarySubsetSize(int rangingPreliminarySubsetSize)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (rangingPreliminarySubsetSize &lt; getMinRequiredSources()) {
            throw new IllegalArgumentException();
        }

        mRangingPreliminarySubsetSize = rangingPreliminarySubsetSize;
    }

    /**
     * Gets size of subsets to be checked during RSSI robust estimation.
     *
     * @return size of subsets to be checked during RSSI robust estimation.
     */
    public int getRssiPreliminarySubsetSize() {
        return mRssiPreliminarySubsetSize;
    }

    /**
     * Sets size of subsets to be checked during RSSI robust estimation.
     *
     * @param rssiPreliminarySubsetSize size of subsets to be checked during
     *                                  RSSI robust estimation.
     * @throws LockedException if estimator is locked.
     * @throws IllegalArgumentException if provided value is less than {@link #getMinRequiredSources()}.
     */
    public void setRssiPreliminarySubsetSize(int rssiPreliminarySubsetSize)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (rssiPreliminarySubsetSize &lt; getMinRequiredSources()) {
            throw new IllegalArgumentException();
        }

        mRssiPreliminarySubsetSize = rssiPreliminarySubsetSize;
    }

    /**
     * Gets threshold to determine when samples are inliers or not, used during robust
     * fine ranging position estimation.
     * If not defined, default threshold will be used.
     *
     * @return threshold for ranging estimation or null.
     */
    public Double getRangingThreshold() {
        return mRangingThreshold;
    }

    /**
     * Sets threshold to determine when samples are inliers or not, used during robust
     * fine ranging position estimation.
     * If not defined, default threshold will be used.
     *
     * @param rangingThreshold threshold for ranging estimation or null.
     * @throws LockedException if estimator is locked.
     */
    public void setRangingThreshold(Double rangingThreshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mRangingThreshold = rangingThreshold;
    }

    /**
     * Gets threshold to determine when samples are inliers or not, used during robust
     * coarse RSSI position estimation.
     * If not defined, default threshold will be used.
     *
     * @return threshold for RSSI estimation or null.
     */
    public Double getRssiThreshold() {
        return mRssiThreshold;
    }

    /**
     * Sets threshold to determine when samples are inliers or not, used during robust
     * coarse RSSI position estimation.
     * If not defined, default threshold will be used.
     *
     * @param rssiThreshold threshold for RSSI estimation or null.
     * @throws LockedException if estimator is locked.
     */
    public void setRssiThreshold(Double rssiThreshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mRssiThreshold = rssiThreshold;
    }

    /**
     * Gets located radio sources used for lateration.
     *
     * @return located radio sources used for lateration.
     */
    public List&lt;? extends RadioSourceLocated&lt;P&gt;&gt; getSources() {
        return mSources;
    }

    /**
     * Sets located radio sources used for lateration.
     *
     * @param sources   located radio sources used for lateration.
     * @throws LockedException          if estimator is locked.
     * @throws IllegalArgumentException if provided value is null or the number of
     *                                  provided sources is less than the required
     *                                  minimum.
     */
    public void setSources(List&lt;? extends RadioSourceLocated&lt;P&gt;&gt; sources)
            throws LockedException{
        if (isLocked()) {
            throw new LockedException();
        }

        internalSetSources(sources);
    }

    /**
     * Gets fingerprint containing readings at an unknown location for provided located
     * radio sources.
     *
     * @return fingerprint containing readings at an unknown location for provided
     * located radio sources.
     */
    public Fingerprint&lt;? extends RadioSource, ? extends Reading&lt;? extends RadioSource&gt;&gt; getFingerprint() {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/estimators/ECEFKinematicsEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/estimators/ECEFKinematicsEstimator.html#L1421">1421</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/estimators/ECIKinematicsEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/estimators/ECIKinematicsEstimator.html#L1306">1306</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                                          final ECEFFrame frame,
                                          final CoordinateTransformation oldC,
                                          final Speed oldVx, final Speed oldVy, final Speed oldVz,
                                          final BodyKinematics result) {
        estimateKinematics(timeInterval, frame, oldC,
                SpeedConverter.convert(oldVx.getValue().doubleValue(), oldVx.getUnit(), SpeedUnit.METERS_PER_SECOND),
                SpeedConverter.convert(oldVy.getValue().doubleValue(), oldVy.getUnit(), SpeedUnit.METERS_PER_SECOND),
                SpeedConverter.convert(oldVz.getValue().doubleValue(), oldVz.getUnit(), SpeedUnit.METERS_PER_SECOND),
                result);
    }

    /**
     * Estimates body kinematics (specific force applied to a body and its angular rates).
     *
     * @param timeInterval time interval between epochs expressed in seconds (s).
     * @param c            body-to-ECEF frame coordinate transformation matrix.
     * @param oldC         previous body-to-ECEF-frame coordinate transformation matrix.
     * @param vx           velocity of body frame x coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per
     *                     second (m/s).
     * @param vy           velocity of body frame y coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per
     *                     second (m/s).
     * @param vz           velocity of body frame z coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per
     *                     second (m/s).
     * @param oldVx        previous velocity of body frame x coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters
     *                     per second (m/s).
     * @param oldVy        previous velocity of body frame y coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters
     *                     per second (m/s).
     * @param oldVz        previous velocity of body frame z coordinate with respect ECEF
     *                     frame, resolved along EVEF-frame axes and expressed in meters
     *                     per second (m/s).
     * @param position     body position expressed in meters (m) with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param result       instance where body kinematics estimation will be stored.
     * @throws IllegalArgumentException if provided time interval is negative or coordinated transformation matrices
     *                                  are not ECEF frame valid.
     */
    public static void estimateKinematics(final double timeInterval,
                                          final CoordinateTransformation c,
                                          final CoordinateTransformation oldC,
                                          final double vx, final double vy, final double vz,
                                          final double oldVx, final double oldVy, final double oldVz,
                                          final Point3D position, final BodyKinematics result) {
        estimateKinematics(timeInterval, c, oldC, vx, vy, vz, oldVx, oldVy, oldVz,
                position.getInhomX(), position.getInhomY(), position.getInhomZ(), result);
    }

    /**
     * Estimates body kinematics (specific force applied to a body and its angular rates).
     *
     * @param timeInterval time interval between epochs.
     * @param c            body-to-ECEF frame coordinate transformation matrix.
     * @param oldC         previous body-to-ECEF-frame coordinate transformation matrix.
     * @param vx           velocity of body frame x coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per
     *                     second (m/s).
     * @param vy           velocity of body frame y coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per
     *                     second (m/s).
     * @param vz           velocity of body frame z coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per
     *                     second (m/s).
     * @param oldVx        previous velocity of body frame x coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters
     *                     per second (m/s).
     * @param oldVy        previous velocity of body frame y coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters
     *                     per second (m/s).
     * @param oldVz        previous velocity of body frame z coordinate with respect ECEF
     *                     frame, resolved along EVEF-frame axes and expressed in meters
     *                     per second (m/s).
     * @param position     body position expressed in meters (m) with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param result       instance where body kinematics estimation will be stored.
     * @throws IllegalArgumentException if provided time interval is negative or coordinated transformation matrices
     *                                  are not ECEF frame valid.
     */
    public static void estimateKinematics(final Time timeInterval,
                                          final CoordinateTransformation c,
                                          final CoordinateTransformation oldC,
                                          final double vx, final double vy, final double vz,
                                          final double oldVx, final double oldVy, final double oldVz,
                                          final Point3D position, final BodyKinematics result) {
        estimateKinematics(timeInterval, c, oldC, vx, vy, vz, oldVx, oldVy, oldVz,
                position.getInhomX(), position.getInhomY(), position.getInhomZ(), result);
    }

    /**
     * Estimates body kinematics (specific force applied to a body and its angular rates).
     *
     * @param timeInterval time interval between epochs expressed in seconds (s).
     * @param c            boy-to-ECEF frame coordinate transformation matrix.
     * @param oldC         previous body-to-ECEF-frame coordinate transformation matrix.
     * @param vx           velocity of body frame x coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param vy           velocity of body frame y coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param vz           velocity of body frame z coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param oldVx        previous velocity of body frame x coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldVy        previous velocity of body frame y coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldVz        previous velocity of body frame z coordinate with respect ECEF
     *                     frame, resolved along EVEF-frame axes.
     * @param position     body position expressed in meters (m) with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param result       instance where body kinematics estimation will be stored.
     * @throws IllegalArgumentException if provided time interval is negative or coordinated transformation matrices
     *                                  are not ECEF frame valid.
     */
    public static void estimateKinematics(final double timeInterval,
                                          final CoordinateTransformation c,
                                          final CoordinateTransformation oldC,
                                          final Speed vx, final Speed vy, final Speed vz,
                                          final Speed oldVx, final Speed oldVy, final Speed oldVz,
                                          final Point3D position, final BodyKinematics result) {
        estimateKinematics(timeInterval, c, oldC, vx, vy, vz, oldVx, oldVy, oldVz,
                position.getInhomX(), position.getInhomY(), position.getInhomZ(), result);
    }

    /**
     * Estimates body kinematics (specific force applied to a body and its angular rates).
     *
     * @param timeInterval time interval between epochs.
     * @param c            boy-to-ECEF frame coordinate transformation matrix.
     * @param oldC         previous body-to-ECEF-frame coordinate transformation matrix.
     * @param vx           velocity of body frame x coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param vy           velocity of body frame y coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param vz           velocity of body frame z coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param oldVx        previous velocity of body frame x coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldVy        previous velocity of body frame y coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldVz        previous velocity of body frame z coordinate with respect ECEF
     *                     frame, resolved along EVEF-frame axes.
     * @param position     body position expressed in meters (m) with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param result       instance where body kinematics estimation will be stored.
     * @throws IllegalArgumentException if provided time interval is negative or coordinated transformation matrices
     *                                  are not ECEF frame valid.
     */
    public static void estimateKinematics(final Time timeInterval,
                                          final CoordinateTransformation c,
                                          final CoordinateTransformation oldC,
                                          final Speed vx, final Speed vy, final Speed vz,
                                          final Speed oldVx, final Speed oldVy, final Speed oldVz,
                                          final Point3D position, final BodyKinematics result) {
        estimateKinematics(timeInterval, c, oldC, vx, vy, vz, oldVx, oldVy, oldVz,
                position.getInhomX(), position.getInhomY(), position.getInhomZ(), result);
    }

    /**
     * Estimates body kinematics (specific force applied to a body and its angular rates).
     *
     * @param timeInterval time interval between epochs expressed in seconds (s).
     * @param c            body-to-ECEF frame coordinate transformation matrix.
     * @param oldC         previous body-to-ECEF-frame coordinate transformation matrix.
     * @param vx           velocity of body frame x coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per
     *                     second (m/s).
     * @param vy           velocity of body frame y coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per
     *                     second (m/s).
     * @param vz           velocity of body frame z coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per
     *                     second (m/s).
     * @param oldVx        previous velocity of body frame x coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters
     *                     per second (m/s).
     * @param oldVy        previous velocity of body frame y coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters
     *                     per second (m/s).
     * @param oldVz        previous velocity of body frame z coordinate with respect ECEF
     *                     frame, resolved along EVEF-frame axes and expressed in meters
     *                     per second (m/s).
     * @param x            cartesian x coordinate of body position expressed in meters (m)
     *                     with respect ECEF frame, resolved along ECEF-frame axes.
     * @param y            cartesian y coordinate of body position expressed in meters (m)
     *                     with respect ECEF frame, resolved along ECEF-frame axes.
     * @param z            cartesian z coordinate of body position expressed in meters (m)
     *                     with respect ECEF frame, resolved along ECEF-frame axes.
     * @return a new body kinematics instance.
     * @throws IllegalArgumentException if provided time interval is negative or coordinated transformation matrices
     *                                  are not ECEF frame valid.
     */
    public static BodyKinematics estimateKinematicsAndReturnNew(final double timeInterval,
                                                                final CoordinateTransformation c,
                                                                final CoordinateTransformation oldC,
                                                                final double vx, final double vy, final double vz,
                                                                final double oldVx, final double oldVy, final double oldVz,
                                                                final double x, final double y, final double z) {
        final BodyKinematics result = new BodyKinematics();
        estimateKinematics(timeInterval, c, oldC, vx, vy, vz, oldVx, oldVy, oldVz,
                x, y, z, result);
        return result;
    }

    /**
     * Estimates body kinematics (specific force applied to a body and its angular rates).
     *
     * @param timeInterval time interval between.
     * @param c            body-to-ECEF frame coordinate transformation matrix.
     * @param oldC         previous body-to-ECEF-frame coordinate transformation matrix.
     * @param vx           velocity of body frame x coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per
     *                     second (m/s).
     * @param vy           velocity of body frame y coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per
     *                     second (m/s).
     * @param vz           velocity of body frame z coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per
     *                     second (m/s).
     * @param oldVx        previous velocity of body frame x coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters
     *                     per second (m/s).
     * @param oldVy        previous velocity of body frame y coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters
     *                     per second (m/s).
     * @param oldVz        previous velocity of body frame z coordinate with respect ECEF
     *                     frame, resolved along EVEF-frame axes and expressed in meters
     *                     per second (m/s).
     * @param x            cartesian x coordinate of body position expressed in meters (m)
     *                     with respect ECEF frame, resolved along ECEF-frame axes.
     * @param y            cartesian y coordinate of body position expressed in meters (m)
     *                     with respect ECEF frame, resolved along ECEF-frame axes.
     * @param z            cartesian z coordinate of body position expressed in meters (m)
     *                     with respect ECEF frame, resolved along ECEF-frame axes.
     * @return a new body kinematics instance.
     * @throws IllegalArgumentException if provided time interval is negative or coordinated transformation matrices
     *                                  are not ECEF frame valid.
     */
    public static BodyKinematics estimateKinematicsAndReturnNew(final Time timeInterval,
                                                                final CoordinateTransformation c,
                                                                final CoordinateTransformation oldC,
                                                                final double vx, final double vy, final double vz,
                                                                final double oldVx, final double oldVy, final double oldVz,
                                                                final double x, final double y, final double z) {
        final BodyKinematics result = new BodyKinematics();
        estimateKinematics(timeInterval, c, oldC, vx, vy, vz, oldVx, oldVy, oldVz,
                x, y, z, result);
        return result;
    }

    /**
     * Estimates body kinematics (specific force applied to a body and its angular rates).
     *
     * @param timeInterval time interval between epochs expressed in seconds (s).
     * @param frame        body ECEF frame containing current position, velocity and
     *                     body-to-ECEF frame coordinate transformation.
     * @param oldC         previous body-to-ECEF-frame coordinate transformation matrix.
     * @param oldVx        previous velocity of body frame x coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters
     *                     per second (m/s).
     * @param oldVy        previous velocity of body frame y coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters
     *                     per second (m/s).
     * @param oldVz        previous velocity of body frame z coordinate with respect ECEF
     *                     frame, resolved along EVEF-frame axes and expressed in meters
     *                     per second (m/s).
     * @return a new body kinematics instance.
     * @throws IllegalArgumentException if provided time interval is negative or coordinated transformation matrices
     *                                  are not ECEF frame valid.
     */
    public static BodyKinematics estimateKinematicsAndReturnNew(final double timeInterval,
                                                                final ECEFFrame frame,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustMixedRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustMixedRadioSourceEstimator.html#L1122">1122</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator.html#L1105">1105</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>            SequentialRobustMixedRadioSourceEstimatorListener&lt;S, P&gt; listener) {
        this(readings, initialPosition, initialTransmittedPowerdBm,
                initialPathLossExponent, listener);
        internalSetQualityScores(qualityScores);
    }

    /**
     * Indicates whether estimator is locked during estimation.
     *
     * @return true if estimator is locked, false otherwise.
     */
    public boolean isLocked() {
        return mLocked;
    }

    /**
     * Returns amount of progress variation before notifying a progress change during
     * estimation.
     *
     * @return amount of progress variation before notifying a progress change during
     * estimation.
     */
    public float getProgressDelta() {
        return mProgressDelta;
    }

    /**
     * Sets amount of progress variation before notifying a progress change during
     * estimation.
     *
     * @param progressDelta amount of progress variation before notifying a progress
     *                      change during estimation.
     * @throws IllegalArgumentException if progress delta is less than zero or greater than 1.
     * @throws LockedException if this estimator is locked.
     */
    public void setProgressDelta(float progressDelta) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (progressDelta &lt; MIN_PROGRESS_DELTA ||
                progressDelta &gt; MAX_PROGRESS_DELTA) {
            throw new IllegalArgumentException();
        }
        mProgressDelta = progressDelta;
    }

    /**
     * Gets robust method used for robust position estimation using ranging data.
     *
     * @return robust method used for robust position estimation.
     */
    public RobustEstimatorMethod getRangingRobustMethod() {
        return mRangingRobustMethod;
    }

    /**
     * Sets robust method used for robust position estimation using ranging data.
     *
     * @param rangingRobustMethod robust method used for robust position estimation.
     * @throws LockedException if estimator is locked.
     */
    public void setRangingRobustMethod(RobustEstimatorMethod rangingRobustMethod)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mRangingRobustMethod = rangingRobustMethod;
    }

    /**
     * Gets robust method used for pathloss exponent and transmitted power estimation
     * using RSSI data.
     *
     * @return robust method used for pathloss exponent and transmitted power
     * estimation.
     */
    public RobustEstimatorMethod getRssiRobustMethod() {
        return mRssiRobustMethod;
    }

    /**
     * Sets robust method used for pathloss exponent and transmitted power estimation
     * using RSSI data.
     *
     * @param rssiRobustMethod robust method used for pathloss exponent and transmitted
     *                         power estimation.
     * @throws LockedException if estimator is locked.
     */
    public void setRssiRobustMethod(RobustEstimatorMethod rssiRobustMethod)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mRssiRobustMethod = rssiRobustMethod;
    }

    /**
     * Gets size of subsets to be checked during ranging robust estimation.
     *
     * @return size of subsets to be checked during ranging robust estimation.
     */
    public int getRangingPreliminarySubsetSize() {
        return mRangingPreliminarySubsetSize;
    }

    /**
     * Sets size of subsets to be checked during ranging robust estimation.
     *
     * @param rangingPreliminarySubsetSize size of subsets to be checked during
     *                                     ranging robust estimation.
     * @throws LockedException if estimator is locked.
     * @throws IllegalArgumentException if provided value is less than {@link #getMinReadings()}.
     */
    public void setRangingPreliminarySubsetSize(int rangingPreliminarySubsetSize)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (rangingPreliminarySubsetSize &lt; getMinReadings()) {
            throw new IllegalArgumentException();
        }

        mRangingPreliminarySubsetSize = rangingPreliminarySubsetSize;
    }

    /**
     * Gets size of subsets to be checked during RSSI robust estimation.
     *
     * @return size of subsets to be checked during RSSI robust estimation.
     */
    public int getRssiPreliminarySubsetSize() {
        return mRssiPreliminarySubsetSize;
    }

    /**
     * Sets size of subsets to be checked during RSSI robust estimation.
     *
     * @param rssiPreliminarySubsetSize size of subsets to be checked during
     *                                  RSSI robust estimation.
     * @throws LockedException if estimator is locked.
     * @throws IllegalArgumentException if provided value is less than {@link #getMinReadings()}.
     */
    public void setRssiPreliminarySubsetSize(int rssiPreliminarySubsetSize)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (rssiPreliminarySubsetSize &lt; getMinReadings()) {
            throw new IllegalArgumentException();
        }

        mRssiPreliminarySubsetSize = rssiPreliminarySubsetSize;
    }

    /**
     * Gets threshold to determine when samples are inliers or not, used during robust
     * position estimation.
     * If not defined, default threshold will be used.
     *
     * @return threshold for ranging estimation or null.
     */
    public Double getRangingThreshold() {
        return mRangingThreshold;
    }

    /**
     * Sets threshold to determine when samples are inliers or not, used during robust
     * position estimation.
     * If not defined, default threshold will be used.
     *
     * @param rangingThreshold threshold for ranging estimation or null.
     * @throws LockedException if estimator is locked.
     */
    public void setRangingThreshold(Double rangingThreshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mRangingThreshold = rangingThreshold;
    }

    /**
     * Gets threshold to determine when samples are inliers or not, used during robust
     * pathloss exponent and transmitted power estimation.
     * If not defined, default threshold will be used.
     *
     * @return threshold for RSSI estimation or null.
     */
    public Double getRssiThreshold() {
        return mRssiThreshold;
    }

    /**
     * Sets threshold to determine when samples are inliers or not, used during robust
     * pathloss exponent and transmitted power estimation.
     * If not defined, default threshold will be used.
     *
     * @param rssiThreshold threshold for RSSI estimation or null.
     * @throws LockedException if estimator is locked.
     */
    public void setRssiThreshold(Double rssiThreshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mRssiThreshold = rssiThreshold;
    }

    /**
     * Returns amount of confidence expressed as a value between 0.0 and 1.0
     * (which is equivalent to 100%) for robust position estimation. The amount of
     * confidence indicates the probability that the estimated result is correct.
     * Usually this value will be close to 1.0, but not exactly 1.0.
     *
     * @return amount of confidence for robust position estimation as a value
     * between 0.0 and 1.0.
     */
    public double getRangingConfidence() {
        return mRangingConfidence;
    }

    /**
     * Sets amount of confidence expressed as a value between 0.0 and 1.0 (which is
     * equivalent to 100%) for robust position estimation. The amount of confidence
     * indicates the probability that the estimated result is correct. Usually this
     * value will be close to 1.0, but not exactly 1.0.
     *
     * @param rangingConfidence confidence to be set for robust position estimation
     *                          as a value between 0.0 and 1.0.
     * @throws IllegalArgumentException if provided value is not between 0.0 and 1.0.
     * @throws LockedException if estimator is locked.
     */
    public void setRangingConfidence(double rangingConfidence) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (rangingConfidence &lt; MIN_CONFIDENCE || rangingConfidence &gt; MAX_CONFIDENCE) {
            throw new IllegalArgumentException();
        }
        mRangingConfidence = rangingConfidence;
    }

    /**
     * Returns amount of confidence expressed as a value between 0.0 and 1.0
     * (which is equivalent to 100%) for pathloss exponent and transmitted power
     * estimation. The amount of confidence indicates the probability that the
     * estimated result is correct.
     * Usually this value will be close to 1.0, but not exactly 1.0.
     *
     * @return amount of confidence for robust pathloss exponent and transmitted power
     * estimation as a value between 0.0 and 1.0.
     */
    public double getRssiConfidence() {
        return mRssiConfidence;
    }

    /**
     * Sets amount of confidence expressed as a value between 0.0 and 1.0
     * (which is equivalent to 100%) for pathloss exponent and transmitted power
     * estimation. The amount of confidence indicates the probability that the
     * estimated result is correct. Usually this value will be close to 10.0, but
     * not exactly 1.0.
     *
     * @param rssiConfidence confidence to be set for robust pathloss exponent and
     *                       transmitted power estimation as a value between 0.0 and
     *                       1.0.
     * @throws IllegalArgumentException if provided value is not between 0.0 and 1.0.
     * @throws LockedException if estimator is locked.
     */
    public void setRssiConfidence(double rssiConfidence) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (rssiConfidence &lt; MIN_CONFIDENCE || rssiConfidence &gt; MAX_CONFIDENCE) {
            throw new IllegalArgumentException();
        }
        mRssiConfidence = rssiConfidence;
    }

    /**
     * Returns maximum allowed number of iterations for robust position estimation. If
     * maximum allowed number of iterations is achieved without converging to a result
     * when calling estimate(), a RobustEstimatorException will be raised.
     *
     * @return maximum allowed number of iterations for position estimation.
     */
    public int getRangingMaxIterations() {
        return mRangingMaxIterations;
    }

    /**
     * Sets maximum allowed number of iterations for robust position estimation. When
     * the maximum number of iterations is exceeded, an approximate result might be
     * available for retrieval.
     *
     * @param rangingMaxIterations maximum allowed number of iterations to be set
     *                             for position estimation.
     * @throws IllegalArgumentException if provided value is less than 1.
     * @throws LockedException if this estimator is locked.
     */
    public void setRangingMaxIterations(int rangingMaxIterations) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (rangingMaxIterations &lt; MIN_ITERATIONS) {
            throw new IllegalArgumentException();
        }
        mRangingMaxIterations = rangingMaxIterations;
    }

    /**
     * Returns maximum allowed number of iterations for robust pathloss exponent and
     * transmitted power estimation. If maximum allowed number of iterations is achieved
     * without converging to a result when calling estimate(), a RobustEstimatorException
     * will be raised.
     *
     * @return maximum allowed number of iterations for pathloss exponent and transmitted
     * power estimation.
     */
    public int getRssiMaxIterations() {
        return mRssiMaxIterations;
    }

    /**
     * Sets maximum allowed number of iterations for robust pathloss exponent and
     * transmitted power estimation. When the maximum number of iterations is exceeded,
     * an approximate result might be available for retrieval.
     *
     * @param rssiMaxIterations maximum allowed number of iterations to be set for
     *                          pathloss exponent and transmitted power estimation.
     * @throws IllegalArgumentException if provided value is less than 1.
     * @throws LockedException if this estimator is locked.
     */
    public void setRssiMaxIterations(int rssiMaxIterations) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (rssiMaxIterations &lt; MIN_ITERATIONS) {
            throw new IllegalArgumentException();
        }
        mRssiMaxIterations = rssiMaxIterations;
    }

    /**
     * Indicates whether result must be refined using a non-linear solver over found inliers.
     *
     * @return true to refine result, false to simply use result found by robust estimator
     * without further refining.
     */
    public boolean isResultRefined() {
        return mRefineResult;
    }

    /**
     * Specifies whether result must be refined using a non-linear solver over found inliers.
     *
     * @param refineResult true to refine result, false to simply use result found by robust
     *                     estimator without further refining.
     * @throws LockedException if estimator is locked.
     */
    public void setResultRefined(boolean refineResult) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mRefineResult = refineResult;
    }

    /**
     * Indicates whether covariance must be kept after refining result.
     * This setting is only taken into account if result is refined.
     *
     * @return true if covariance must be kept after refining result, false otherwise.
     */
    public boolean isCovarianceKept() {
        return mKeepCovariance;
    }

    /**
     * Specifies whether covariance must be kept after refining result.
     * This setting is only taken into account if result is refined.
     *
     * @param keepCovariance true if covariance must be kept after refining result,
     *                       false otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setCovarianceKept(boolean keepCovariance) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mKeepCovariance = keepCovariance;
    }

    /**
     * Gets signal readings belonging to the same radio source.
     *
     * @return signal readings belonging to the same radio source.
     */
    public List&lt;? extends ReadingLocated&lt;P&gt;&gt; getReadings() {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/estimators/ECEFKinematicsEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/estimators/ECEFKinematicsEstimator.html#L368">368</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/estimators/ECIKinematicsEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/estimators/ECIKinematicsEstimator.html#L338">338</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                         final ECEFFrame frame,
                         final CoordinateTransformation oldC,
                         final Speed oldVx, final Speed oldVy, final Speed oldVz,
                         final BodyKinematics result) {
        estimateKinematics(timeInterval, frame, oldC, oldVx, oldVy, oldVz, result);
    }

    /**
     * Estimates body kinematics (specific force applied to a body and its angular rates).
     *
     * @param timeInterval time interval between epochs expressed in seconds (s).
     * @param c            body-to-ECEF frame coordinate transformation matrix.
     * @param oldC         previous body-to-ECEF-frame coordinate transformation matrix.
     * @param vx           velocity of body frame x coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per
     *                     second (m/s).
     * @param vy           velocity of body frame y coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per
     *                     second (m/s).
     * @param vz           velocity of body frame z coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per
     *                     second (m/s).
     * @param oldVx        previous velocity of body frame x coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters
     *                     per second (m/s).
     * @param oldVy        previous velocity of body frame y coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters
     *                     per second (m/s).
     * @param oldVz        previous velocity of body frame z coordinate with respect ECEF
     *                     frame, resolved along EVEF-frame axes and expressed in meters
     *                     per second (m/s).
     * @param position     body position expressed in meters (m) with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param result       instance where body kinematics estimation will be stored.
     * @throws IllegalArgumentException if provided time interval is negative or coordinated transformation matrices
     *                                  are not ECEF frame valid.
     */
    public void estimate(final double timeInterval,
                         final CoordinateTransformation c,
                         final CoordinateTransformation oldC,
                         final double vx, final double vy, final double vz,
                         final double oldVx, final double oldVy, final double oldVz,
                         final Point3D position, final BodyKinematics result) {
        estimateKinematics(timeInterval, c, oldC, vx, vy, vz, oldVx, oldVy, oldVz,
                position, result);
    }

    /**
     * Estimates body kinematics (specific force applied to a body and its angular rates).
     *
     * @param timeInterval time interval between epochs.
     * @param c            body-to-ECEF frame coordinate transformation matrix.
     * @param oldC         previous body-to-ECEF-frame coordinate transformation matrix.
     * @param vx           velocity of body frame x coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per
     *                     second (m/s).
     * @param vy           velocity of body frame y coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per
     *                     second (m/s).
     * @param vz           velocity of body frame z coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per
     *                     second (m/s).
     * @param oldVx        previous velocity of body frame x coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters
     *                     per second (m/s).
     * @param oldVy        previous velocity of body frame y coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters
     *                     per second (m/s).
     * @param oldVz        previous velocity of body frame z coordinate with respect ECEF
     *                     frame, resolved along EVEF-frame axes and expressed in meters
     *                     per second (m/s).
     * @param position     body position expressed in meters (m) with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param result       instance where body kinematics estimation will be stored.
     * @throws IllegalArgumentException if provided time interval is negative or coordinated transformation matrices
     *                                  are not ECEF frame valid.
     */
    public void estimate(final Time timeInterval,
                         final CoordinateTransformation c,
                         final CoordinateTransformation oldC,
                         final double vx, final double vy, final double vz,
                         final double oldVx, final double oldVy, final double oldVz,
                         final Point3D position, final BodyKinematics result) {
        estimateKinematics(timeInterval, c, oldC, vx, vy, vz, oldVx, oldVy, oldVz,
                position, result);
    }

    /**
     * Estimates body kinematics (specific force applied to a body and its angular rates).
     *
     * @param timeInterval time interval between epochs expressed in seconds (s).
     * @param c            boy-to-ECEF frame coordinate transformation matrix.
     * @param oldC         previous body-to-ECEF-frame coordinate transformation matrix.
     * @param vx           velocity of body frame x coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param vy           velocity of body frame y coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param vz           velocity of body frame z coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param oldVx        previous velocity of body frame x coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldVy        previous velocity of body frame y coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldVz        previous velocity of body frame z coordinate with respect ECEF
     *                     frame, resolved along EVEF-frame axes.
     * @param position     body position expressed in meters (m) with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param result       instance where body kinematics estimation will be stored.
     * @throws IllegalArgumentException if provided time interval is negative or coordinated transformation matrices
     *                                  are not ECEF frame valid.
     */
    public void estimate(final double timeInterval,
                         final CoordinateTransformation c,
                         final CoordinateTransformation oldC,
                         final Speed vx, final Speed vy, final Speed vz,
                         final Speed oldVx, final Speed oldVy, final Speed oldVz,
                         final Point3D position, final BodyKinematics result) {
        estimateKinematics(timeInterval, c, oldC, vx, vy, vz, oldVx, oldVy, oldVz,
                position, result);
    }

    /**
     * Estimates body kinematics (specific force applied to a body and its angular rates).
     *
     * @param timeInterval time interval between epochs.
     * @param c            boy-to-ECEF frame coordinate transformation matrix.
     * @param oldC         previous body-to-ECEF-frame coordinate transformation matrix.
     * @param vx           velocity of body frame x coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param vy           velocity of body frame y coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param vz           velocity of body frame z coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param oldVx        previous velocity of body frame x coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldVy        previous velocity of body frame y coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldVz        previous velocity of body frame z coordinate with respect ECEF
     *                     frame, resolved along EVEF-frame axes.
     * @param position     body position expressed in meters (m) with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param result       instance where body kinematics estimation will be stored.
     * @throws IllegalArgumentException if provided time interval is negative or coordinated transformation matrices
     *                                  are not ECEF frame valid.
     */
    public void estimate(final Time timeInterval,
                         final CoordinateTransformation c,
                         final CoordinateTransformation oldC,
                         final Speed vx, final Speed vy, final Speed vz,
                         final Speed oldVx, final Speed oldVy, final Speed oldVz,
                         final Point3D position, final BodyKinematics result) {
        estimateKinematics(timeInterval, c, oldC, vx, vy, vz, oldVx, oldVy, oldVz,
                position, result);
    }

    /**
     * Estimates body kinematics (specific force applied to a body and its angular rates).
     *
     * @param timeInterval time interval between epochs expressed in seconds (s).
     * @param c            body-to-ECEF frame coordinate transformation matrix.
     * @param oldC         previous body-to-ECEF-frame coordinate transformation matrix.
     * @param vx           velocity of body frame x coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per
     *                     second (m/s).
     * @param vy           velocity of body frame y coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per
     *                     second (m/s).
     * @param vz           velocity of body frame z coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per
     *                     second (m/s).
     * @param oldVx        previous velocity of body frame x coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters
     *                     per second (m/s).
     * @param oldVy        previous velocity of body frame y coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters
     *                     per second (m/s).
     * @param oldVz        previous velocity of body frame z coordinate with respect ECEF
     *                     frame, resolved along EVEF-frame axes and expressed in meters
     *                     per second (m/s).
     * @param x            cartesian x coordinate of body position expressed in meters (m)
     *                     with respect ECEF frame, resolved along ECEF-frame axes.
     * @param y            cartesian y coordinate of body position expressed in meters (m)
     *                     with respect ECEF frame, resolved along ECEF-frame axes.
     * @param z            cartesian z coordinate of body position expressed in meters (m)
     *                     with respect ECEF frame, resolved along ECEF-frame axes.
     * @return a new body kinematics instance.
     * @throws IllegalArgumentException if provided time interval is negative or coordinated transformation matrices
     *                                  are not ECEF frame valid.
     */
    public BodyKinematics estimateAndReturnNew(final double timeInterval,
                                               final CoordinateTransformation c,
                                               final CoordinateTransformation oldC,
                                               final double vx, final double vy, final double vz,
                                               final double oldVx, final double oldVy, final double oldVz,
                                               final double x, final double y, final double z) {
        return estimateKinematicsAndReturnNew(timeInterval, c, oldC, vx, vy, vz, oldVx, oldVy, oldVz,
                x, y, z);
    }

    /**
     * Estimates body kinematics (specific force applied to a body and its angular rates).
     *
     * @param timeInterval time interval between.
     * @param c            body-to-ECEF frame coordinate transformation matrix.
     * @param oldC         previous body-to-ECEF-frame coordinate transformation matrix.
     * @param vx           velocity of body frame x coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per
     *                     second (m/s).
     * @param vy           velocity of body frame y coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per
     *                     second (m/s).
     * @param vz           velocity of body frame z coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per
     *                     second (m/s).
     * @param oldVx        previous velocity of body frame x coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters
     *                     per second (m/s).
     * @param oldVy        previous velocity of body frame y coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters
     *                     per second (m/s).
     * @param oldVz        previous velocity of body frame z coordinate with respect ECEF
     *                     frame, resolved along EVEF-frame axes and expressed in meters
     *                     per second (m/s).
     * @param x            cartesian x coordinate of body position expressed in meters (m)
     *                     with respect ECEF frame, resolved along ECEF-frame axes.
     * @param y            cartesian y coordinate of body position expressed in meters (m)
     *                     with respect ECEF frame, resolved along ECEF-frame axes.
     * @param z            cartesian z coordinate of body position expressed in meters (m)
     *                     with respect ECEF frame, resolved along ECEF-frame axes.
     * @return a new body kinematics instance.
     * @throws IllegalArgumentException if provided time interval is negative or coordinated transformation matrices
     *                                  are not ECEF frame valid.
     */
    public BodyKinematics estimateAndReturnNew(final Time timeInterval,
                                               final CoordinateTransformation c,
                                               final CoordinateTransformation oldC,
                                               final double vx, final double vy, final double vz,
                                               final double oldVx, final double oldVy, final double oldVz,
                                               final double x, final double y, final double z) {
        return estimateKinematicsAndReturnNew(timeInterval, c, oldC, vx, vy, vz,
                oldVx, oldVy, oldVz, x, y, z);
    }

    /**
     * Estimates body kinematics (specific force applied to a body and its angular rates).
     *
     * @param timeInterval time interval between epochs expressed in seconds (s).
     * @param frame        body ECEF frame containing current position, velocity and
     *                     body-to-ECEF frame coordinate transformation.
     * @param oldC         previous body-to-ECEF-frame coordinate transformation matrix.
     * @param oldVx        previous velocity of body frame x coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters
     *                     per second (m/s).
     * @param oldVy        previous velocity of body frame y coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters
     *                     per second (m/s).
     * @param oldVz        previous velocity of body frame z coordinate with respect ECEF
     *                     frame, resolved along EVEF-frame axes and expressed in meters
     *                     per second (m/s).
     * @return a new body kinematics instance.
     * @throws IllegalArgumentException if provided time interval is negative or coordinated transformation matrices
     *                                  are not ECEF frame valid.
     */
    public BodyKinematics estimateAndReturnNew(final double timeInterval,
                                               final ECEFFrame frame,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/estimators/ECEFKinematicsEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/estimators/ECEFKinematicsEstimator.html#L1277">1277</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/estimators/ECIKinematicsEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/estimators/ECIKinematicsEstimator.html#L1162">1162</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                                          final ECEFFrame frame, final ECEFFrame oldFrame,
                                          final BodyKinematics result) {
        estimateKinematics(timeInterval, frame,
                oldFrame.getCoordinateTransformation(),
                oldFrame.getVx(), oldFrame.getVy(), oldFrame.getVz(), result);
    }

    /**
     * Estimates body kinematics (specific force applied to a body and its angular rates).
     *
     * @param timeInterval time interval between epochs expressed in seconds (s).
     * @param c            body-to-ECEF frame coordinate transformation matrix.
     * @param oldC         previous body-to-ECEF-frame coordinate transformation matrix.
     * @param vx           velocity of body frame x coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param vy           velocity of body frame y coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param vz           velocity of body frame z coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param oldVx        previous velocity of body frame x coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldVy        previous velocity of body frame y coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldVz        previous velocity of body frame z coordinate with respect ECEF
     *                     frame, resolved along EVEF-frame axes.
     * @param x            cartesian x coordinate of body position expressed in meters (m)
     *                     with respect ECEF frame, resolved along ECEF-frame axes.
     * @param y            cartesian y coordinate of body position expressed in meters (m)
     *                     with respect ECEF frame, resolved along ECEF-frame axes.
     * @param z            cartesian z coordinate of body position expressed in meters (m)
     *                     with respect ECEF frame, resolved along ECEF-frame axes.
     * @param result       instance where body kinematics estimation will be stored.
     * @throws IllegalArgumentException if provided time interval is negative or coordinated transformation matrices
     *                                  are not ECEF frame valid.
     */
    public static void estimateKinematics(final double timeInterval,
                                          final CoordinateTransformation c,
                                          final CoordinateTransformation oldC,
                                          final Speed vx, final Speed vy, final Speed vz,
                                          final Speed oldVx, final Speed oldVy, final Speed oldVz,
                                          final double x, final double y, final double z,
                                          final BodyKinematics result) {
        estimateKinematics(timeInterval, c, oldC,
                SpeedConverter.convert(vx.getValue().doubleValue(), vx.getUnit(), SpeedUnit.METERS_PER_SECOND),
                SpeedConverter.convert(vy.getValue().doubleValue(), vy.getUnit(), SpeedUnit.METERS_PER_SECOND),
                SpeedConverter.convert(vz.getValue().doubleValue(), vz.getUnit(), SpeedUnit.METERS_PER_SECOND),
                SpeedConverter.convert(oldVx.getValue().doubleValue(), oldVx.getUnit(), SpeedUnit.METERS_PER_SECOND),
                SpeedConverter.convert(oldVy.getValue().doubleValue(), oldVy.getUnit(), SpeedUnit.METERS_PER_SECOND),
                SpeedConverter.convert(oldVz.getValue().doubleValue(), oldVz.getUnit(), SpeedUnit.METERS_PER_SECOND),
                x, y, z, result);
    }

    /**
     * Estimates body kinematics (specific force applied to a body and its angular rates).
     *
     * @param timeInterval time interval between epochs.
     * @param c            body-to-ECEF frame coordinate transformation matrix.
     * @param oldC         previous body-to-ECEF-frame coordinate transformation matrix.
     * @param vx           velocity of body frame x coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param vy           velocity of body frame y coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param vz           velocity of body frame z coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param oldVx        previous velocity of body frame x coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldVy        previous velocity of body frame y coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldVz        previous velocity of body frame z coordinate with respect ECEF
     *                     frame, resolved along EVEF-frame axes.
     * @param x            cartesian x coordinate of body position expressed in meters (m)
     *                     with respect ECEF frame, resolved along ECEF-frame axes.
     * @param y            cartesian y coordinate of body position expressed in meters (m)
     *                     with respect ECEF frame, resolved along ECEF-frame axes.
     * @param z            cartesian z coordinate of body position expressed in meters (m)
     *                     with respect ECEF frame, resolved along ECEF-frame axes.
     * @param result       instance where body kinematics estimation will be stored.
     * @throws IllegalArgumentException if provided time interval is negative or coordinated transformation matrices
     *                                  are not ECEF frame valid.
     */
    public static void estimateKinematics(final Time timeInterval,
                                          final CoordinateTransformation c,
                                          final CoordinateTransformation oldC,
                                          final Speed vx, final Speed vy, final Speed vz,
                                          final Speed oldVx, final Speed oldVy, final Speed oldVz,
                                          final double x, final double y, final double z,
                                          final BodyKinematics result) {
        estimateKinematics(timeInterval, c, oldC,
                SpeedConverter.convert(vx.getValue().doubleValue(), vx.getUnit(), SpeedUnit.METERS_PER_SECOND),
                SpeedConverter.convert(vy.getValue().doubleValue(), vy.getUnit(), SpeedUnit.METERS_PER_SECOND),
                SpeedConverter.convert(vz.getValue().doubleValue(), vz.getUnit(), SpeedUnit.METERS_PER_SECOND),
                SpeedConverter.convert(oldVx.getValue().doubleValue(), oldVx.getUnit(), SpeedUnit.METERS_PER_SECOND),
                SpeedConverter.convert(oldVy.getValue().doubleValue(), oldVy.getUnit(), SpeedUnit.METERS_PER_SECOND),
                SpeedConverter.convert(oldVz.getValue().doubleValue(), oldVz.getUnit(), SpeedUnit.METERS_PER_SECOND),
                x, y, z, result);
    }

    /**
     * Estimates body kinematics (specific force applied to a body and its angular rates).
     *
     * @param timeInterval time interval between epochs expressed in seconds (s).
     * @param frame        body ECEF frame containing current position, velocity and
     *                     body-to-ECEF frame coordinate transformation.
     * @param oldC         previous body-to-ECEF-frame coordinate transformation matrix.
     * @param oldVx        previous velocity of body frame x coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldVy        previous velocity of body frame y coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldVz        previous velocity of body frame z coordinate with respect ECEF
     *                     frame, resolved along EVEF-frame axes.
     * @param result       instance where body kinematics estimation will be stored.
     * @throws IllegalArgumentException if provided time interval is negative or coordinated transformation matrices
     *                                  are not ECEF frame valid.
     */
    public static void estimateKinematics(final double timeInterval,
                                          final ECEFFrame frame,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustMixedRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustMixedRadioSourceEstimator.html#L1556">1556</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator.html#L1539">1539</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>            SequentialRobustMixedRadioSourceEstimatorListener&lt;S, P&gt; listener)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }

        mListener = listener;
    }

    /**
     * Returns quality scores corresponding to each pair of
     * positions and distances (i.e. sample).
     * The larger the score value the better the quality of the sample.
     * This implementation always returns null.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @return quality scores corresponding to each sample.
     */
    public double[] getQualityScores() {
        return mQualityScores;
    }

    /**
     * Sets quality scores corresponding to each pair of positions and
     * distances (i.e. sample).
     * The larger the score value the better the quality of the sample.
     * This implementation makes no action.
     * Subclasses using quality scores must implement proper behaviour.
     *
     * @param qualityScores quality scores corresponding to each pair of
     *                      matched points.
     * @throws IllegalArgumentException if provided quality scores length
     * is smaller than minimum required samples.
     * @throws LockedException if robust solver is locked because an
     * estimation is already in progress.
     */
    public void setQualityScores(double[] qualityScores) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetQualityScores(qualityScores);
    }

    /**
     * Gets initial transmitted power to start the estimation of radio source
     * transmitted power (expressed in dBm's).
     * If not defined, average value of received power readings will be used.
     *
     * @return initial transmitted power to start the estimation of radio source
     * transmitted power.
     */
    public Double getInitialTransmittedPowerdBm() {
        return mInitialTransmittedPowerdBm;
    }

    /**
     * Sets initial transmitted power to start the estimation of radio source
     * transmitted power (expressed in dBm's).
     * If not defined, average value of received power readings will be used.
     *
     * @param initialTransmittedPowerdBm initial transmitted power to start the
     *                                   estimation of radio source transmitted
     *                                   power.
     * @throws LockedException if estimator is locked.
     */
    public void setInitialTransmittedPowerdBm(Double initialTransmittedPowerdBm)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mInitialTransmittedPowerdBm = initialTransmittedPowerdBm;
    }

    /**
     * Gets initial transmitted power to start the estimation of radio source
     * transmitted power (expressed in mW).
     * If not defined, average value of received power readings will be used.
     *
     * @return initial transmitted power to start the estimation of radio source
     * transmitted power.
     */
    public Double getInitialTransmittedPower() {
        return mInitialTransmittedPowerdBm != null ?
                Utils.dBmToPower(mInitialTransmittedPowerdBm) : null;
    }

    /**
     * Sets initial transmitted power to start the estimation of radio source
     * transmitted power (expressed in mW).
     * If not defined, average value of received power readings will be used.
     *
     * @param initialTransmittedPower initial transmitted power to start the
     *                                estimation of radio source transmitted power.
     * @throws LockedException if estimator is locked.
     * @throws IllegalArgumentException if provided value is negative.
     */
    public void setInitialTransmittedPower(Double initialTransmittedPower)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (initialTransmittedPower != null) {
            if (initialTransmittedPower &lt; 0.0) {
                throw new IllegalArgumentException();
            }
            mInitialTransmittedPowerdBm = Utils.powerTodBm(
                    initialTransmittedPower);
        } else {
            mInitialTransmittedPowerdBm = null;
        }
    }

    /**
     * Gets initial position to start the estimation of radio source position.
     * If not defined, centroid of provided fingerprints will be used.
     *
     * @return initial position to start the estimation of radio source position.
     */
    public P getInitialPosition() {
        return mInitialPosition;
    }

    /**
     * Sets initial position to start the estimation of radio source position.
     * If not defined, centroid of provided fingerprints will be used.
     *
     * @param initialPosition initial position to start the estimation of radio
     *                        source position.
     * @throws LockedException if estimator is locked.
     */
    public void setInitialPosition(P initialPosition) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mInitialPosition = initialPosition;
    }

    /**
     * Gets initial exponent typically used on free space for path loss propagation
     * in terms of distance.
     * On different environments path loss exponent might have different value:
     * - Free space: 2.0
     * - Urban Area: 2.7 to 3.5
     * - Suburban Area: 3 to 5
     * - Indoor (line-of-sight): 1.6 to 1.8
     *
     * If path loss exponent estimation is enabled, estimation will start at this
     * value and will converge to the most appropriate value.
     * If path loss exponent estimation is disabled, this value will be assumed
     * to be exact and the estimated path loss exponent will be equal to this
     * value.
     *
     * @return initial path loss exponent.
     */
    public double getInitialPathLossExponent() {
        return mInitialPathLossExponent;
    }

    /**
     * Sets initial exponent typically used on free space for path loss propagation
     * in terms of distance.
     * On different environments path loss exponent might have different value:
     * - Free space: 2.0
     * - Urban Area: 2.7 to 3.5
     * - Suburban Area: 3 to 5
     * - Indoor (line-of-sight): 1.6 to 1.8
     *
     * If path loss exponent estimation is enabled, estimation will start at this
     * value and will converge to the most appropriate value.
     * If path loss exponent estimation is disabled, this value will be assumed
     * to be exact and the estimated path loss exponent will be equal to this
     * value.
     *
     * @param initialPathLossExponent initial path loss exponent.
     * @throws LockedException if estimator is locked.
     */
    public void setInitialPathLossExponent(double initialPathLossExponent)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mInitialPathLossExponent = initialPathLossExponent;
    }

    /**
     * Indicates whether transmitted power estimation is enabled or not.
     *
     * @return true if transmitted power estimation is enabled, false otherwise.
     */
    public boolean isTransmittedPowerEstimationEnabled() {
        return mTransmittedPowerEstimationEnabled;
    }

    /**
     * Specifies whether transmitted power estimation is enabled or not.
     *
     * @param transmittedPowerEstimationEnabled true if transmitted power estimation is enabled,
     *                                          false otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setTransmittedPowerEstimationEnabled(boolean transmittedPowerEstimationEnabled)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mTransmittedPowerEstimationEnabled = transmittedPowerEstimationEnabled;
    }

    /**
     * Indicates whether path loss estimation is enabled or not.
     *
     * @return true if path loss estimation is enabled, false otherwise.
     */
    public boolean isPathLossEstimationEnabled() {
        return mPathLossEstimationEnabled;
    }

    /**
     * Specifies whether path loss estimation is enabled or not.
     *
     * @param pathLossEstimationEnabled true if path loss estimation is enabled,
     *                                  false otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setPathLossEstimationEnabled(boolean pathLossEstimationEnabled)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mPathLossEstimationEnabled = pathLossEstimationEnabled;
    }

    /**
     * Indicates whether position covariances of readings must be taken into account to increase
     * the amount of standard deviation of each ranging measure by the amount of position standard
     * deviation assuming that both measures are statistically independent.
     *
     * @return true to take into account reading position covariances, false otherwise.
     */
    public boolean getUseReadingPositionCovariance() {
        return mUseReadingPositionCovariances;
    }

    /**
     * Specifies whether position covariances of readings must be taken into account to increase
     * the amount of standard deviation of each ranging measure by the amount of position standard
     * deviation assuming that both measures are statistically independent.
     *
     * @param useReadingPositionCovariances true to take into account reading position covariances, false
     *                                      otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setUseReadingPositionCovariances(boolean useReadingPositionCovariances)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mUseReadingPositionCovariances = useReadingPositionCovariances;
    }

    /**
     * Indicates whether an homogeneous ranging linear solver is used to estimate preliminary
     * positions.
     *
     * @return true if homogeneous ranging linear solver is used, false if an inhomogeneous ranging linear
     * one is used instead.
     */
    public boolean isHomogeneousRangingLinearSolverUsed() {
        return mUseHomogeneousRangingLinearSolver;
    }

    /**
     * Specifies whether an homogeneous ranging linear solver is used to estimate preliminary
     * positions.
     *
     * @param useHomogeneousRangingLinearSolver true if homogeneous ranging linear solver is used, false
     *                                          if an inhomogeneous ranging linear one is used instead.
     * @throws LockedException if estimator is locked.
     */
    public void setHomogeneousRangingLinearSolverUsed(
            boolean useHomogeneousRangingLinearSolver) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }

        mUseHomogeneousRangingLinearSolver = useHomogeneousRangingLinearSolver;
    }


    /**
     * Gets covariance for estimated position and power.
     * Matrix contains information in the following order:
     * Top-left submatrix contains covariance of position,
     * then follows transmitted power variance, and finally
     * the last element contains pathloss exponent variance.
     * This is only available when result has been refined and covariance is kept.
     *
     * @return covariance for estimated position and power.
     */
    public Matrix getCovariance() {
        return mCovariance;
    }

    /**
     * Gets estimated position covariance.
     * Size of this matrix will depend on the number of dimensions
     * of estimated position (either 2 or 3).
     * This is only available when result has been refined and covariance is kept.
     *
     * @return estimated position covariance.
     */
    public Matrix getEstimatedPositionCovariance() {
        return mEstimatedPositionCovariance;
    }

    /**
     * Gets estimated position.
     *
     * @return estimated position.
     */
    public P getEstimatedPosition() {
        return mEstimatedPosition;
    }

    /**
     * Indicates whether readings are valid or not.
     * Readings are considered valid when there are enough readings.
     *
     * @param readings readings to be validated.
     * @return true if readings are valid, false otherwise.
     */
    public boolean areValidReadings(
            List&lt;? extends ReadingLocated&lt;P&gt;&gt; readings) {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/Utils.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/Utils.html#L492">492</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/Utils.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/Utils.html#L1188">1188</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public static MultivariateNormalDist propagateVariancesToRssiVarianceFirstOrderNonLinear3D(
            final double fingerprintRssi, final double pathLossExponent,
            Point3D fingerprintPosition, Point3D radioSourcePosition,
            Point3D estimatedPosition,
            Double fingerprintRssiVariance,
            Double pathLossExponentVariance,
            Matrix fingerprintPositionCovariance,
            Matrix radioSourcePositionCovariance,
            Matrix estimatedPositionCovariance) throws IndoorException {

        if (fingerprintPosition == null || radioSourcePosition == null ||
                estimatedPosition == null) {
            return null;
        }

        //1st order Taylor expression of received power in 3D:
        //Pr(pi) = Pr(p1)
        //  - 10*n*(x1 - xa)/(ln(10)*d1a^2)*(xi - x1)
        //  - 10*n*(y1 - ya)/(ln(10)*d1a^2)*(yi - y1)
        //  - 10*n*(z1 - za)/(ln(10)*d1a^2)*(zi - z1)
        //where d1a^2 = (x1 - xa)^2 + (y1 - ya)^2 + (z1 - za)^2

        final double x1 = fingerprintPosition.getInhomX();
        final double y1 = fingerprintPosition.getInhomY();
        final double z1 = fingerprintPosition.getInhomZ();

        final double xa = radioSourcePosition.getInhomX();
        final double ya = radioSourcePosition.getInhomY();
        final double za = radioSourcePosition.getInhomZ();

        final double xi = estimatedPosition.getInhomX();
        final double yi = estimatedPosition.getInhomY();
        final double zi = estimatedPosition.getInhomZ();

        double[] mean = new double[] {
                fingerprintRssi, pathLossExponent, x1, y1, z1, xa, ya, za, xi, yi, zi
        };
        Matrix covariance = Matrix.diagonal(new double[]{
                fingerprintRssiVariance != null ? fingerprintRssiVariance : 0.0,
                pathLossExponentVariance != null ? pathLossExponentVariance : 0.0,
                0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0
        });

        if (fingerprintPositionCovariance != null &amp;&amp;
                fingerprintPositionCovariance.getRows() == Point3D.POINT3D_INHOMOGENEOUS_COORDINATES_LENGTH &amp;&amp;
                fingerprintPositionCovariance.getColumns() == Point3D.POINT3D_INHOMOGENEOUS_COORDINATES_LENGTH) {

            covariance.setSubmatrix(2, 2,
                    4, 4,
                    fingerprintPositionCovariance);
        }

        if (radioSourcePositionCovariance != null &amp;&amp;
                radioSourcePositionCovariance.getRows() == Point3D.POINT3D_INHOMOGENEOUS_COORDINATES_LENGTH &amp;&amp;
                radioSourcePositionCovariance.getColumns() == Point3D.POINT3D_INHOMOGENEOUS_COORDINATES_LENGTH) {
            covariance.setSubmatrix(5, 5,
                    7, 7,
                    radioSourcePositionCovariance);
        }

        if (estimatedPositionCovariance != null &amp;&amp;
                estimatedPositionCovariance.getRows() == Point3D.POINT3D_INHOMOGENEOUS_COORDINATES_LENGTH &amp;&amp;
                estimatedPositionCovariance.getColumns() == Point3D.POINT3D_INHOMOGENEOUS_COORDINATES_LENGTH) {
            covariance.setSubmatrix(8, 8,
                    10, 10,
                    estimatedPositionCovariance);
        }

        try {
            return MultivariateNormalDist.propagate(new MultivariateNormalDist.JacobianEvaluator() {
                @Override
                public void evaluate(double[] x, double[] y, Matrix jacobian) {

                    //Pr(pi) = Pr(p1)
                    //  - 10*n*(x1 - xa)/(ln(10)*d1a^2)*(xi - x1)
                    //  - 10*n*(y1 - ya)/(ln(10)*d1a^2)*(yi - y1)
                    //  - 10*n*(z1 - za)/(ln(10)*d1a^2)*(zi - z1)
                    //where d1a^2 = (x1 - xa)^2 + (y1 - ya)^2 + (z1 - za)^2

                    //Hence:
                    //Pr(pi) = Pr(p1) -10*n*((x1 - xa)*(xi - x1) + (y1 - ya)*(yi - y1) + (z1 - za)*(zi - z1))/
                    //      (ln(10)*((x1 - xa)^2 + (y1 - ya)^2 + (z1 - za)^2))

                    double diffX1a = x1 - xa;
                    double diffY1a = y1 - ya;
                    double diffZ1a = z1 - za;

                    double diffXi1 = xi - x1;
                    double diffYi1 = yi - y1;
                    double diffZi1 = zi - z1;

                    double diffX1a2 = diffX1a * diffX1a;
                    double diffY1a2 = diffY1a * diffY1a;
                    double diffZ1a2 = diffZ1a * diffZ1a;

                    double d1a2 = diffX1a2 + diffY1a2 + diffZ1a2;</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator2D.html#L833">833</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator2D.html#L838">838</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>            RobustRangingAndRssiRadioSourceEstimatorListener&lt;S, Point2D&gt; listener) {
        super(readings, initialPosition, initialTransmittedPowerdBm,
                initialPathLossExponent, listener);
        internalSetQualityScores(qualityScores);
    }

    /**
     * Gets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on distance between estimated position and distances
     * provided for each sample.
     *
     * @return threshold to determine whether samples are inliers or not.
     */
    public double getThreshold() {
        return mThreshold;
    }

    /**
     * Sets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on distance between estimated position and distances
     * provided for each sample.
     *
     * @param threshold threshold to determine whether samples are inliers or not.
     * @throws IllegalArgumentException if provided value is equal or less than zero.
     * @throws LockedException if this solver is locked.
     */
    public void setThreshold(double threshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (threshold &lt;= MIN_THRESHOLD) {
            throw new IllegalArgumentException();
        }
        mThreshold = threshold;
    }

    /**
     * Returns quality scores corresponding to each pair of
     * positions and distances (i.e. sample).
     * The larger the score value the better the quality of the sample.
     * This implementation always returns null.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @return quality scores corresponding to each sample.
     */
    @Override
    public double[] getQualityScores() {
        return mQualityScores;
    }

    /**
     * Sets quality scores corresponding to each pair of positions and
     * distances (i.e. sample).
     * The larger the score value the better the quality of the sample.
     * This implementation makes no action.
     * Subclasses using quality scores must implement proper behaviour.
     *
     * @param qualityScores quality scores corresponding to each pair of
     *                      matched points.
     * @throws IllegalArgumentException if provided quality scores length
     * is smaller than minimum required samples.
     * @throws LockedException if robust solver is locked because an
     * estimation is already in progress.
     */
    public void setQualityScores(double[] qualityScores) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetQualityScores(qualityScores);
    }

    /**
     * Indicates whether solver is ready to find a solution.
     *
     * @return true if solver is ready, false otherwise.
     */
    @Override
    public boolean isReady() {
        return super.isReady() &amp;&amp; mQualityScores != null &amp;&amp;
                mQualityScores.length == mReadings.size();
    }

    /**
     * Indicates whether inliers must be computed and kept.
     *
     * @return true if inliers must be computed and kept, false if inliers
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepInliersEnabled() {
        return mComputeAndKeepInliers;
    }

    /**
     * Specifies whether inliers must be computed and kept.
     *
     * @param computeAndKeepInliers true if inliers must be computed and kept,
     *                              false if inliers only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepInliersEnabled(boolean computeAndKeepInliers)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mComputeAndKeepInliers = computeAndKeepInliers;
    }

    /**
     * Indicates whether residuals must be computed and kept.
     *
     * @return true if residuals must be computed and kept, false if residuals
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepResidualsEnabled() {
        return mComputeAndKeepResiduals;
    }

    /**
     * Specifies whether residuals must be computed and kept.
     *
     * @param computeAndKeepResiduals true if residuals must be computed and kept,
     *                                false if residuals only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepResidualsEnabled(boolean computeAndKeepResiduals)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mComputeAndKeepResiduals = computeAndKeepResiduals;
    }

    /**
     * Robustly estimates position, transmitted power and pathloss exponent for a
     * radio source.
     *
     * @throws LockedException if instance is busy during estimation.
     * @throws NotReadyException if estimator is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     * (i.e. numerical instability, no solution available, etc).
     */
    @Override
    public void estimate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        PROSACRobustEstimator&lt;Solution&lt;Point2D&gt;&gt; innerEstimator =
                new PROSACRobustEstimator&lt;&gt;(
                        new PROSACRobustEstimatorListener&lt;Solution&lt;Point2D&gt;&gt;() {

                    @Override
                    public double[] getQualityScores() {
                        return mQualityScores;
                    }

                    @Override
                    public double getThreshold() {
                        return mThreshold;
                    }

                    @Override
                    public int getTotalSamples() {
                        return mReadings.size();
                    }

                    @Override
                    public int getSubsetSize() {
                        return Math.max(mPreliminarySubsetSize, getMinReadings());
                    }

                    @Override
                    public void estimatePreliminarSolutions(int[] samplesIndices,
                            List&lt;Solution&lt;Point2D&gt;&gt; solutions) {
                        solvePreliminarSolutions(samplesIndices, solutions);
                    }

                    @Override
                    public double computeResidual(Solution&lt;Point2D&gt; currentEstimation, int i) {
                        return residual(currentEstimation, i);
                    }

                    @Override
                    public boolean isReady() {
                        return PROSACRobustRangingAndRssiRadioSourceEstimator2D.this.isReady();</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator3D.html#L832">832</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator3D.html#L837">837</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>            RobustRangingAndRssiRadioSourceEstimatorListener&lt;S, Point3D&gt; listener) {
        super(readings, initialPosition, initialTransmittedPowerdBm,
                initialPathLossExponent, listener);
        internalSetQualityScores(qualityScores);
    }

    /**
     * Gets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on distance between estimated position and distances
     * provided for each sample.
     *
     * @return threshold to determine whether samples are inliers or not.
     */
    public double getThreshold() {
        return mThreshold;
    }

    /**
     * Sets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on distance between estimated position and distances
     * provided for each sample.
     *
     * @param threshold threshold to determine whether samples are inliers or not.
     * @throws IllegalArgumentException if provided value is equal or less than zero.
     * @throws LockedException if this solver is locked.
     */
    public void setThreshold(double threshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (threshold &lt;= MIN_THRESHOLD) {
            throw new IllegalArgumentException();
        }
        mThreshold = threshold;
    }

    /**
     * Returns quality scores corresponding to each pair of
     * positions and distances (i.e. sample).
     * The larger the score value the better the quality of the sample.
     * This implementation always returns null.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @return quality scores corresponding to each sample.
     */
    @Override
    public double[] getQualityScores() {
        return mQualityScores;
    }

    /**
     * Sets quality scores corresponding to each pair of positions and
     * distances (i.e. sample).
     * The larger the score value the better the quality of the sample.
     * This implementation makes no action.
     * Subclasses using quality scores must implement proper behaviour.
     *
     * @param qualityScores quality scores corresponding to each pair of
     *                      matched points.
     * @throws IllegalArgumentException if provided quality scores length
     * is smaller than minimum required samples.
     * @throws LockedException if robust solver is locked because an
     * estimation is already in progress.
     */
    public void setQualityScores(double[] qualityScores)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetQualityScores(qualityScores);
    }

    /**
     * Indicates whether solver is ready to find a solution.
     *
     * @return true if solver is ready, false otherwise.
     */
    @Override
    public boolean isReady() {
        return super.isReady() &amp;&amp; mQualityScores != null &amp;&amp;
                mQualityScores.length == mReadings.size();
    }

    /**
     * Indicates whether inliers must be computed and kept.
     *
     * @return true if inliers must be computed and kept, false if inliers
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepInliersEnabled() {
        return mComputeAndKeepInliers;
    }

    /**
     * Specifies whether inliers must be computed and kept.
     *
     * @param computeAndKeepInliers true if inliers must be computed and kept,
     *                              false if inliers only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepInliersEnabled(boolean computeAndKeepInliers)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mComputeAndKeepInliers = computeAndKeepInliers;
    }

    /**
     * Indicates whether residuals must be computed and kept.
     *
     * @return true if residuals must be computed and kept, false if residuals
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepResidualsEnabled() {
        return mComputeAndKeepResiduals;
    }

    /**
     * Specifies whether residuals must be computed and kept.
     *
     * @param computeAndKeepResiduals true if residuals must be computed and kept,
     *                                false if residuals only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepResidualsEnabled(boolean computeAndKeepResiduals)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mComputeAndKeepResiduals = computeAndKeepResiduals;
    }

    /**
     * Robustly estimates position, transmitted power and pathloss exponent for a
     * radio source.
     *
     * @throws LockedException if instance is busy during estimation.
     * @throws NotReadyException if estimator is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     * (i.e. numerical instability, no solution available, etc).
     */
    @Override
    public void estimate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        PROSACRobustEstimator&lt;Solution&lt;Point3D&gt;&gt; innerEstimator =
                new PROSACRobustEstimator&lt;&gt;(
                        new PROSACRobustEstimatorListener&lt;Solution&lt;Point3D&gt;&gt;() {

                            @Override
                            public double[] getQualityScores() {
                                return mQualityScores;
                            }

                            @Override
                            public double getThreshold() {
                                return mThreshold;
                            }

                            @Override
                            public int getTotalSamples() {
                                return mReadings.size();
                            }

                            @Override
                            public int getSubsetSize() {
                                return Math.max(mPreliminarySubsetSize, getMinReadings());
                            }

                            @Override
                            public void estimatePreliminarSolutions(int[] samplesIndices,
                                                                    List&lt;Solution&lt;Point3D&gt;&gt; solutions) {
                                solvePreliminarSolutions(samplesIndices, solutions);
                            }

                            @Override
                            public double computeResidual(Solution&lt;Point3D&gt; currentEstimation, int i) {
                                return residual(currentEstimation, i);
                            }

                            @Override
                            public boolean isReady() {
                                return PROSACRobustRangingAndRssiRadioSourceEstimator3D.this.isReady();</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator2D.html#L835">835</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator2D.html#L325">325</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator2D.html#L840">840</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>                initialPathLossExponent, listener);
        internalSetQualityScores(qualityScores);
    }

    /**
     * Gets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on distance between estimated position and distances
     * provided for each sample.
     *
     * @return threshold to determine whether samples are inliers or not.
     */
    public double getThreshold() {
        return mThreshold;
    }

    /**
     * Sets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on distance between estimated position and distances
     * provided for each sample.
     *
     * @param threshold threshold to determine whether samples are inliers or not.
     * @throws IllegalArgumentException if provided value is equal or less than zero.
     * @throws LockedException if this solver is locked.
     */
    public void setThreshold(double threshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (threshold &lt;= MIN_THRESHOLD) {
            throw new IllegalArgumentException();
        }
        mThreshold = threshold;
    }

    /**
     * Returns quality scores corresponding to each pair of
     * positions and distances (i.e. sample).
     * The larger the score value the better the quality of the sample.
     * This implementation always returns null.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @return quality scores corresponding to each sample.
     */
    @Override
    public double[] getQualityScores() {
        return mQualityScores;
    }

    /**
     * Sets quality scores corresponding to each pair of positions and
     * distances (i.e. sample).
     * The larger the score value the better the quality of the sample.
     * This implementation makes no action.
     * Subclasses using quality scores must implement proper behaviour.
     *
     * @param qualityScores quality scores corresponding to each pair of
     *                      matched points.
     * @throws IllegalArgumentException if provided quality scores length
     * is smaller than minimum required samples.
     * @throws LockedException if robust solver is locked because an
     * estimation is already in progress.
     */
    public void setQualityScores(double[] qualityScores) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetQualityScores(qualityScores);
    }

    /**
     * Indicates whether solver is ready to find a solution.
     *
     * @return true if solver is ready, false otherwise.
     */
    @Override
    public boolean isReady() {
        return super.isReady() &amp;&amp; mQualityScores != null &amp;&amp;
                mQualityScores.length == mReadings.size();
    }

    /**
     * Indicates whether inliers must be computed and kept.
     *
     * @return true if inliers must be computed and kept, false if inliers
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepInliersEnabled() {
        return mComputeAndKeepInliers;
    }

    /**
     * Specifies whether inliers must be computed and kept.
     *
     * @param computeAndKeepInliers true if inliers must be computed and kept,
     *                              false if inliers only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepInliersEnabled(boolean computeAndKeepInliers)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mComputeAndKeepInliers = computeAndKeepInliers;
    }

    /**
     * Indicates whether residuals must be computed and kept.
     *
     * @return true if residuals must be computed and kept, false if residuals
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepResidualsEnabled() {
        return mComputeAndKeepResiduals;
    }

    /**
     * Specifies whether residuals must be computed and kept.
     *
     * @param computeAndKeepResiduals true if residuals must be computed and kept,
     *                                false if residuals only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepResidualsEnabled(boolean computeAndKeepResiduals)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mComputeAndKeepResiduals = computeAndKeepResiduals;
    }

    /**
     * Robustly estimates position, transmitted power and pathloss exponent for a
     * radio source.
     *
     * @throws LockedException if instance is busy during estimation.
     * @throws NotReadyException if estimator is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     * (i.e. numerical instability, no solution available, etc).
     */
    @Override
    public void estimate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        PROSACRobustEstimator&lt;Solution&lt;Point2D&gt;&gt; innerEstimator =
                new PROSACRobustEstimator&lt;&gt;(
                        new PROSACRobustEstimatorListener&lt;Solution&lt;Point2D&gt;&gt;() {

                    @Override
                    public double[] getQualityScores() {
                        return mQualityScores;
                    }

                    @Override
                    public double getThreshold() {
                        return mThreshold;
                    }

                    @Override
                    public int getTotalSamples() {
                        return mReadings.size();
                    }

                    @Override
                    public int getSubsetSize() {
                        return Math.max(mPreliminarySubsetSize, getMinReadings());
                    }

                    @Override
                    public void estimatePreliminarSolutions(int[] samplesIndices,
                            List&lt;Solution&lt;Point2D&gt;&gt; solutions) {
                        solvePreliminarSolutions(samplesIndices, solutions);
                    }

                    @Override
                    public double computeResidual(Solution&lt;Point2D&gt; currentEstimation, int i) {
                        return residual(currentEstimation, i);
                    }

                    @Override
                    public boolean isReady() {
                        return PROSACRobustRangingAndRssiRadioSourceEstimator2D.this.isReady();</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator3D.html#L834">834</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator3D.html#L325">325</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator3D.html#L839">839</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                initialPathLossExponent, listener);
        internalSetQualityScores(qualityScores);
    }

    /**
     * Gets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on distance between estimated position and distances
     * provided for each sample.
     *
     * @return threshold to determine whether samples are inliers or not.
     */
    public double getThreshold() {
        return mThreshold;
    }

    /**
     * Sets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on distance between estimated position and distances
     * provided for each sample.
     *
     * @param threshold threshold to determine whether samples are inliers or not.
     * @throws IllegalArgumentException if provided value is equal or less than zero.
     * @throws LockedException if this solver is locked.
     */
    public void setThreshold(double threshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (threshold &lt;= MIN_THRESHOLD) {
            throw new IllegalArgumentException();
        }
        mThreshold = threshold;
    }

    /**
     * Returns quality scores corresponding to each pair of
     * positions and distances (i.e. sample).
     * The larger the score value the better the quality of the sample.
     * This implementation always returns null.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @return quality scores corresponding to each sample.
     */
    @Override
    public double[] getQualityScores() {
        return mQualityScores;
    }

    /**
     * Sets quality scores corresponding to each pair of positions and
     * distances (i.e. sample).
     * The larger the score value the better the quality of the sample.
     * This implementation makes no action.
     * Subclasses using quality scores must implement proper behaviour.
     *
     * @param qualityScores quality scores corresponding to each pair of
     *                      matched points.
     * @throws IllegalArgumentException if provided quality scores length
     * is smaller than minimum required samples.
     * @throws LockedException if robust solver is locked because an
     * estimation is already in progress.
     */
    public void setQualityScores(double[] qualityScores)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetQualityScores(qualityScores);
    }

    /**
     * Indicates whether solver is ready to find a solution.
     *
     * @return true if solver is ready, false otherwise.
     */
    @Override
    public boolean isReady() {
        return super.isReady() &amp;&amp; mQualityScores != null &amp;&amp;
                mQualityScores.length == mReadings.size();
    }

    /**
     * Indicates whether inliers must be computed and kept.
     *
     * @return true if inliers must be computed and kept, false if inliers
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepInliersEnabled() {
        return mComputeAndKeepInliers;
    }

    /**
     * Specifies whether inliers must be computed and kept.
     *
     * @param computeAndKeepInliers true if inliers must be computed and kept,
     *                              false if inliers only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepInliersEnabled(boolean computeAndKeepInliers)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mComputeAndKeepInliers = computeAndKeepInliers;
    }

    /**
     * Indicates whether residuals must be computed and kept.
     *
     * @return true if residuals must be computed and kept, false if residuals
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepResidualsEnabled() {
        return mComputeAndKeepResiduals;
    }

    /**
     * Specifies whether residuals must be computed and kept.
     *
     * @param computeAndKeepResiduals true if residuals must be computed and kept,
     *                                false if residuals only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepResidualsEnabled(boolean computeAndKeepResiduals)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mComputeAndKeepResiduals = computeAndKeepResiduals;
    }

    /**
     * Robustly estimates position, transmitted power and pathloss exponent for a
     * radio source.
     *
     * @throws LockedException if instance is busy during estimation.
     * @throws NotReadyException if estimator is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     * (i.e. numerical instability, no solution available, etc).
     */
    @Override
    public void estimate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        PROSACRobustEstimator&lt;Solution&lt;Point3D&gt;&gt; innerEstimator =
                new PROSACRobustEstimator&lt;&gt;(
                        new PROSACRobustEstimatorListener&lt;Solution&lt;Point3D&gt;&gt;() {

                            @Override
                            public double[] getQualityScores() {
                                return mQualityScores;
                            }

                            @Override
                            public double getThreshold() {
                                return mThreshold;
                            }

                            @Override
                            public int getTotalSamples() {
                                return mReadings.size();
                            }

                            @Override
                            public int getSubsetSize() {
                                return Math.max(mPreliminarySubsetSize, getMinReadings());
                            }

                            @Override
                            public void estimatePreliminarSolutions(int[] samplesIndices,
                                                                    List&lt;Solution&lt;Point3D&gt;&gt; solutions) {
                                solvePreliminarSolutions(samplesIndices, solutions);
                            }

                            @Override
                            public double computeResidual(Solution&lt;Point3D&gt; currentEstimation, int i) {
                                return residual(currentEstimation, i);
                            }

                            @Override
                            public boolean isReady() {
                                return PROSACRobustRangingAndRssiRadioSourceEstimator3D.this.isReady();</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/fingerprint/BaseFingerprintPositionAndRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/fingerprint/BaseFingerprintPositionAndRadioSourceEstimator.html#L158">158</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/fingerprint/BaseFingerprintPositionEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/fingerprint/BaseFingerprintPositionEstimator.html#L165">165</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public BaseFingerprintPositionAndRadioSourceEstimator(
            List&lt;? extends RssiFingerprintLocated&lt;? extends RadioSource,
            ? extends RssiReading&lt;? extends RadioSource&gt;, P&gt;&gt; locatedFingerprints,
            RssiFingerprint&lt;? extends RadioSource,
            ? extends RssiReading&lt;? extends RadioSource&gt;&gt; fingerprint,
            L listener) {
        this(listener);
        internalSetLocatedFingerprints(locatedFingerprints);
        internalSetFingerprint(fingerprint);
    }

    /**
     * Gets located fingerprints containing RSSI readings.
     * @return located fingerprints containing RSSI readings.
     */
    public List&lt;? extends RssiFingerprintLocated&lt;? extends RadioSource,
            ? extends RssiReading&lt;? extends RadioSource&gt;, P&gt;&gt; getLocatedFingerprints() {
        return mLocatedFingerprints;
    }

    /**
     * Sets located fingerprints containing RSSI readings.
     * @param locatedFingerprints located fingerprints containing RSSI readings.
     * @throws LockedException if estimator is locked.
     * @throws IllegalArgumentException if provided value is null or there are not enough
     * fingerprints or readings within provided fingerprints (for 2D position estimation at
     * least 2 readings are required in a single fingerprint, or at least 2 fingerprints
     * at different locations containing a single reading are required. For 3D position
     * estimation 3 reading in a single fingerprint, or 3 fingerprints containing a single
     * reading or any combination resulting in at least 3 readings at different locations
     * are required).
     */
    public void setLocatedFingerprints(List&lt;? extends RssiFingerprintLocated&lt;? extends RadioSource,
            ? extends RssiReading&lt;? extends RadioSource&gt;, P&gt;&gt; locatedFingerprints)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }

        internalSetLocatedFingerprints(locatedFingerprints);
    }

    /**
     * Gets fingerprint containing readings at an unknown location for provided located
     * fingerprints.
     * @return fingerprint containing readings at an unknown location for provided located
     * fingerprints.
     */
    public RssiFingerprint&lt;? extends RadioSource, ? extends RssiReading&lt;? extends RadioSource&gt;&gt;
            getFingerprint() {
        return mFingerprint;
    }

    /**
     * Sets fingerprint containing readings at an unknown location for provided located fingerprints.
     * @param fingerprint fingerprint containing readings at an unknown location for provided located fingerprints.
     * @throws LockedException if estimator is locked.
     * @throws IllegalArgumentException if provided value is null.
     */
    public void setFingerprint(RssiFingerprint&lt;? extends RadioSource,
            ? extends RssiReading&lt;? extends RadioSource&gt;&gt; fingerprint)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }

        internalSetFingerprint(fingerprint);
    }

    /**
     * Get minimum number of nearest fingerprints to search.
     * @return minimum number of nearest fingerprints, -1 indicates to initially use
     * all fingerprints needed to estimate available radio sources.
     */
    public int getMinNearestFingerprints() {
        return mMinNearestFingerprints;
    }

    /**
     * Gets maximum number of nearest fingerprints to search.
     * @return maximum number of nearest fingerprints, -1 indicates to use all available
     * fingerprints.
     */
    public int getMaxNearestFingerprints() {
        return mMaxNearestFingerprints;
    }

    /**
     * Sets minimum and maximum number of nearest fingerprints to search.
     * If minimum value is -1, then the minimum required number of fingerprints needed
     * to estimate available radio sources is used.
     * If maximum value is -1, then the problem is attempted to be solved until all
     * available fingerprints are used.
     * @param minNearestFingerprints minimum number of nearest fingerprints or -1.
     * @param maxNearestFingerprints maximum number of nearest fingerprints or -1.
     * @throws LockedException if estimator is locked.
     * @throws IllegalArgumentException if minimum value is larger than maximum value (as
     * long as it has a limit defined), or if maximum value is not negative when
     * minimum one is less than 1, or if minimum value is zero.
     */
    public void setMinMaxNearestFingerprints(int minNearestFingerprints,
            int maxNearestFingerprints) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }

        internalSetMinMaxNearestFingerprints(minNearestFingerprints,
                maxNearestFingerprints);
    }

    /**
     * Gets path loss exponent to be used by default.
     * This is typically used on free space for path loss propagation in
     * terms of distance.
     * On different environments path loss exponent might have different values:
     * - Free space: 2.0
     * - Urban Area: 2.7 to 3.5
     * - Suburban Area: 3 to 5
     * - Indoor (line-of-sight): 1.6 to 1.8
     * @return path loss exponent to be used by default.
     */
    public double getPathLossExponent() {
        return mPathLossExponent;
    }

    /**
     * Sets path loss exponent to be used by default.
     * This is typically used on free space for path loss propagation in
     * terms of distance.
     * On different environments path loss exponent might have different values:
     * - Free space: 2.0
     * - Urban Area: 2.7 to 3.5
     * - Suburban Area: 3 to 5
     * - Indoor (line-of-sight): 1.6 to 1.8
     * @param pathLossExponent path loss exponent to be used by default.
     * @throws LockedException if estimator is locked.
     */
    public void setPathLossExponent(double pathLossExponent) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mPathLossExponent = pathLossExponent;
    }

    /**
     * Gets listener to be notified of events raised by this instance.
     * @return listener to be notified of events raised by this instance.
     */
    public L getListener() {
        return mListener;
    }

    /**
     * Sets listener to be notified of events raised by this instance.
     * @param listener listener to be notified of events raised by this instance.
     * @throws LockedException if estimator is locked.
     */
    public void setListener(L listener) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mListener = listener;
    }

    /**
     * Gets estimated inhomogeneous position coordinates.
     * @return estimated inhomogeneous position coordinates.
     */
    public double[] getEstimatedPositionCoordinates() {
        return mEstimatedPositionCoordinates;
    }

    /**
     * Gets estimated estimated position and stores result into provided instance.
     * @param estimatedPosition instance where estimated estimated position will be stored.
     */
    public void getEstimatedPosition(P estimatedPosition) {
        if (mEstimatedPositionCoordinates != null) {
            for (int i = 0; i &lt; mEstimatedPositionCoordinates.length; i++) {
                estimatedPosition.setInhomogeneousCoordinate(i,
                        mEstimatedPositionCoordinates[i]);
            }
        }
    }

    /**
     * Gets estimated position or null if not available yet.
     * @return estimated position or null.
     */
    public P getEstimatedPosition() {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/estimators/ECEFKinematicsEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/estimators/ECEFKinematicsEstimator.html#L823">823</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/estimators/ECIKinematicsEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/estimators/ECIKinematicsEstimator.html#L749">749</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                                               final ECEFFrame frame,
                                               final CoordinateTransformation oldC,
                                               final Speed oldVx, final Speed oldVy, final Speed oldVz) {
        return estimateKinematicsAndReturnNew(timeInterval, frame, oldC, oldVx, oldVy, oldVz);
    }

    /**
     * Estimates body kinematics (specific force applied to a body and its angular rates).
     *
     * @param timeInterval time interval between epochs expressed in seconds (s).
     * @param c            body-to-ECEF frame coordinate transformation matrix.
     * @param oldC         previous body-to-ECEF-frame coordinate transformation matrix.
     * @param vx           velocity of body frame x coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per
     *                     second (m/s).
     * @param vy           velocity of body frame y coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per
     *                     second (m/s).
     * @param vz           velocity of body frame z coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per
     *                     second (m/s).
     * @param oldVx        previous velocity of body frame x coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters
     *                     per second (m/s).
     * @param oldVy        previous velocity of body frame y coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters
     *                     per second (m/s).
     * @param oldVz        previous velocity of body frame z coordinate with respect ECEF
     *                     frame, resolved along EVEF-frame axes and expressed in meters
     *                     per second (m/s).
     * @param position     body position expressed in meters (m) with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @return a new body kinematics instance.
     * @throws IllegalArgumentException if provided time interval is negative or coordinated transformation matrices
     *                                  are not ECEF frame valid.
     */
    public BodyKinematics estimateAndReturnNew(final double timeInterval,
                                               final CoordinateTransformation c,
                                               final CoordinateTransformation oldC,
                                               final double vx, final double vy, final double vz,
                                               final double oldVx, final double oldVy, final double oldVz,
                                               final Point3D position) {
        return estimateKinematicsAndReturnNew(timeInterval, c, oldC, vx, vy, vz,
                oldVx, oldVy, oldVz, position);
    }

    /**
     * Estimates body kinematics (specific force applied to a body and its angular rates).
     *
     * @param timeInterval time interval between epochs.
     * @param c            body-to-ECEF frame coordinate transformation matrix.
     * @param oldC         previous body-to-ECEF-frame coordinate transformation matrix.
     * @param vx           velocity of body frame x coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per
     *                     second (m/s).
     * @param vy           velocity of body frame y coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per
     *                     second (m/s).
     * @param vz           velocity of body frame z coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per
     *                     second (m/s).
     * @param oldVx        previous velocity of body frame x coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters
     *                     per second (m/s).
     * @param oldVy        previous velocity of body frame y coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters
     *                     per second (m/s).
     * @param oldVz        previous velocity of body frame z coordinate with respect ECEF
     *                     frame, resolved along EVEF-frame axes and expressed in meters
     *                     per second (m/s).
     * @param position     body position expressed in meters (m) with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @return a new body kinematics instance.
     * @throws IllegalArgumentException if provided time interval is negative or coordinated transformation matrices
     *                                  are not ECEF frame valid.
     */
    public BodyKinematics estimateAndReturnNew(final Time timeInterval,
                                               final CoordinateTransformation c,
                                               final CoordinateTransformation oldC,
                                               final double vx, final double vy, final double vz,
                                               final double oldVx, final double oldVy, final double oldVz,
                                               final Point3D position) {
        return estimateKinematicsAndReturnNew(timeInterval, c, oldC, vx, vy, vz, oldVx, oldVy, oldVz,
                position);
    }

    /**
     * Estimates body kinematics (specific force applied to a body and its angular rates).
     *
     * @param timeInterval time interval between epochs expressed in seconds (s).
     * @param c            boy-to-ECEF frame coordinate transformation matrix.
     * @param oldC         previous body-to-ECEF-frame coordinate transformation matrix.
     * @param vx           velocity of body frame x coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param vy           velocity of body frame y coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param vz           velocity of body frame z coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param oldVx        previous velocity of body frame x coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldVy        previous velocity of body frame y coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldVz        previous velocity of body frame z coordinate with respect ECEF
     *                     frame, resolved along EVEF-frame axes.
     * @param position     body position expressed in meters (m) with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @return a new body kinematics instance.
     * @throws IllegalArgumentException if provided time interval is negative or coordinated transformation matrices
     *                                  are not ECEF frame valid.
     */
    public BodyKinematics estimateAndReturnNew(final double timeInterval,
                                               final CoordinateTransformation c,
                                               final CoordinateTransformation oldC,
                                               final Speed vx, final Speed vy, final Speed vz,
                                               final Speed oldVx, final Speed oldVy, final Speed oldVz,
                                               final Point3D position) {
        return estimateKinematicsAndReturnNew(timeInterval, c, oldC, vx, vy, vz,
                oldVx, oldVy, oldVz, position);
    }

    /**
     * Estimates body kinematics (specific force applied to a body and its angular rates).
     *
     * @param timeInterval time interval between epochs.
     * @param c            boy-to-ECEF frame coordinate transformation matrix.
     * @param oldC         previous body-to-ECEF-frame coordinate transformation matrix.
     * @param vx           velocity of body frame x coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param vy           velocity of body frame y coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param vz           velocity of body frame z coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param oldVx        previous velocity of body frame x coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldVy        previous velocity of body frame y coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldVz        previous velocity of body frame z coordinate with respect ECEF
     *                     frame, resolved along EVEF-frame axes.
     * @param position     body position expressed in meters (m) with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @return a new body kinematics instance.
     * @throws IllegalArgumentException if provided time interval is negative or coordinated transformation matrices
     *                                  are not ECEF frame valid.
     */
    public BodyKinematics estimateAndReturnNew(final Time timeInterval,
                                               final CoordinateTransformation c,
                                               final CoordinateTransformation oldC,
                                               final Speed vx, final Speed vy, final Speed vz,
                                               final Speed oldVx, final Speed oldVy, final Speed oldVz,
                                               final Point3D position) {
        return estimateKinematicsAndReturnNew(timeInterval, c, oldC, vx, vy, vz,
                oldVx, oldVy, oldVz, position);
    }

    /**
     * Estimates body kinematics (specific force applied to a body and its angular rates)..
     *
     * @param timeInterval time interval between epochs expressed in seconds (s).
     * @param c            body-to-ECEF-frame coordinate transformation.
     * @param oldC         previous body-to-ECEF-frame coordinate transformation matrix.
     * @param vx           x coordinate of velocity of body frame expressed in meters per second (m/s) and resolved
     *                     along ECEF-frame axes.
     * @param vy           y coordinate of velocity of body frame expressed in meters per second (m/s) and resolved
     *                     along ECEF-frame axes.
     * @param vz           z coordinate of velocity of body frame expressed in meters per second (m/s) and resolved
     *                     along ECEF-frame axes.
     * @param oldVx        x coordinate of previous velocity of body frame expressed in meters per second (m/s) and
     *                     resolved along ECEF-frame axes.
     * @param oldVy        y coordinate of previous velocity of body frame expressed in meters per second (m/s) and
     *                     resolved along ECEF-frame axes.
     * @param oldVz        z coordinate of previous velocity of body frame expressed in meters per second (m/s) and
     *                     resolved along ECEF-frame axes.
     * @param x            cartesian x coordinate of body position expressed in meters (m) and resolved along
     *                     ECEF-frame axes.
     * @param y            cartesian y coordinate of body position expressed in meters (m) and resolved along
     *                     ECEF-frame axes.
     * @param z            cartesian z coordinate of body position expressed in meters (m) and resolved along
     *                     ECEF-frame axes.
     * @param result       instance where estimated body kinematics will be stored.
     * @throws IllegalArgumentException if provided time interval is negative or coordinated transformation matrices
     *                                  are not ECEF frame valid.
     */
    public static void estimateKinematics(final double timeInterval,
                                          final CoordinateTransformation c,
                                          final CoordinateTransformation oldC,
                                          final double vx, final double vy, final double vz,
                                          final double oldVx, final double oldVy, final double oldVz,
                                          final double x, final double y, final double z,
                                          final BodyKinematics result) {
        if (timeInterval &lt; 0.0
                || !ECEFFrame.isValidCoordinateTransformation(c)</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/Utils.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/Utils.html#L251">251</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/Utils.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/Utils.html#L786">786</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public static MultivariateNormalDist propagateVariancesToRssiVarianceFirstOrderNonLinear2D(
            final double fingerprintRssi, final double pathLossExponent,
            Point2D fingerprintPosition, Point2D radioSourcePosition,
            Point2D estimatedPosition,
            Double fingerprintRssiVariance,
            Double pathLossExponentVariance,
            Matrix fingerprintPositionCovariance,
            Matrix radioSourcePositionCovariance,
            Matrix estimatedPositionCovariance) throws IndoorException {

        if (fingerprintPosition == null || radioSourcePosition == null ||
                estimatedPosition == null) {
            return null;
        }

        //1st order Taylor expression of received power in 2D:
        //Pr(pi) = Pr(p1)
        //  - 10*n*(x1 - xa)/(ln(10)*d1a^2)*(xi - x1)
        //  - 10*n*(y1 - ya)/(ln(10)*d1a^2)*(yi - y1)
        //where d1a^2 = (x1 - xa)^2 + (y1 - ya)^2

        final double x1 = fingerprintPosition.getInhomX();
        final double y1 = fingerprintPosition.getInhomY();

        final double xa = radioSourcePosition.getInhomX();
        final double ya = radioSourcePosition.getInhomY();

        final double xi = estimatedPosition.getInhomX();
        final double yi = estimatedPosition.getInhomY();

        double[] mean = new double[] {
                fingerprintRssi, pathLossExponent, x1, y1, xa, ya, xi, yi
        };
        Matrix covariance = Matrix.diagonal(new double[]{
                fingerprintRssiVariance != null ? fingerprintRssiVariance : 0.0,
                pathLossExponentVariance != null ? pathLossExponentVariance : 0.0,
                0.0, 0.0, 0.0, 0.0, 0.0, 0.0
        });

        if (fingerprintPositionCovariance != null &amp;&amp;
                fingerprintPositionCovariance.getRows() == Point2D.POINT2D_INHOMOGENEOUS_COORDINATES_LENGTH &amp;&amp;
                fingerprintPositionCovariance.getColumns() == Point2D.POINT2D_INHOMOGENEOUS_COORDINATES_LENGTH) {

            covariance.setSubmatrix(2, 2,
                    3, 3,
                    fingerprintPositionCovariance);
        }

        if (radioSourcePositionCovariance != null &amp;&amp;
                radioSourcePositionCovariance.getRows() == Point2D.POINT2D_INHOMOGENEOUS_COORDINATES_LENGTH &amp;&amp;
                radioSourcePositionCovariance.getColumns() == Point2D.POINT2D_INHOMOGENEOUS_COORDINATES_LENGTH) {
            covariance.setSubmatrix(4, 4,
                    5, 5,
                    radioSourcePositionCovariance);
        }

        if (estimatedPositionCovariance != null &amp;&amp;
                estimatedPositionCovariance.getRows() == Point2D.POINT2D_INHOMOGENEOUS_COORDINATES_LENGTH &amp;&amp;
                estimatedPositionCovariance.getColumns() == Point2D.POINT2D_INHOMOGENEOUS_COORDINATES_LENGTH) {
            covariance.setSubmatrix(6, 6,
                    7, 7,
                    estimatedPositionCovariance);
        }

        try {
            return MultivariateNormalDist.propagate(new MultivariateNormalDist.JacobianEvaluator() {
                @Override
                public void evaluate(double[] x, double[] y, Matrix jacobian) {

                    //Pr(pi) = Pr(p1)
                    //  - 10*n*(x1 - xa)/(ln(10)*d1a^2)*(xi - x1)
                    //  - 10*n*(y1 - ya)/(ln(10)*d1a^2)*(yi - y1)
                    //where d1a^2 = (x1 - xa)^2 + (y1 - ya)^2

                    //Hence:
                    //Pr(pi) = Pr(p1) -10*n*((x1 - xa)*(xi - x1) + (y1 - ya)*(yi - y1))/
                    //      (ln(10)*((x1 - xa)^2 + (y1 - ya)^2))

                    double diffX1a = x1 - xa;
                    double diffY1a = y1 - ya;

                    double diffXi1 = xi - x1;
                    double diffYi1 = yi - y1;

                    double diffX1a2 = diffX1a * diffX1a;
                    double diffY1a2 = diffY1a * diffY1a;

                    double d1a2 = diffX1a2 + diffY1a2;</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator2D.html#L2891">2891</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator3D.html#L2891">2891</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>        Point2D initialPosition = result.getEstimatedPosition();
        double initialTransmittedPowerdBm =
                result.getEstimatedTransmittedPowerdBm();
        double initialPathLossExponent = result.getEstimatedPathLossExponent();

        if (mRefineResult &amp;&amp; mInliersData != null) {
            BitSet inliers = mInliersData.getInliers();
            int nSamples = mReadings.size();

            mInnerReadings.clear();

            for (int i = 0; i &lt; nSamples; i++) {
                if (inliers.get(i)) {
                    //sample is inlier
                    mInnerReadings.add(mReadings.get(i));
                }
            }

            try {
                mInnerEstimator.setInitialPosition(initialPosition);
                mInnerEstimator.setInitialTransmittedPowerdBm(initialTransmittedPowerdBm);
                mInnerEstimator.setInitialPathLossExponent(initialPathLossExponent);
                mInnerEstimator.setTransmittedPowerEstimationEnabled(mTransmittedPowerEstimationEnabled);
                mInnerEstimator.setPositionEstimationEnabled(mPositionEstimationEnabled);
                mInnerEstimator.setPathLossEstimationEnabled(mPathLossEstimationEnabled);
                mInnerEstimator.setReadings(mInnerReadings);

                mInnerEstimator.estimate();

                Matrix cov = mInnerEstimator.getEstimatedCovariance();
                if (mKeepCovariance &amp;&amp; cov != null) {
                    //keep covariance
                    mCovariance = cov;

                    int dims = getNumberOfDimensions();
                    int pos = 0;
                    if (mPositionEstimationEnabled) {
                        //position estimation enabled
                        int d = dims -1;
                        if (mEstimatedPositionCovariance == null) {
                            mEstimatedPositionCovariance = mCovariance.
                                    getSubmatrix(0, 0, d, d);
                        } else {
                            mCovariance.getSubmatrix(0, 0, d, d,
                                    mEstimatedPositionCovariance);
                        }
                        pos += dims;
                    } else {
                        //position estimation disabled
                        mEstimatedPositionCovariance = null;
                    }

                    if (mTransmittedPowerEstimationEnabled) {
                        //transmitted power estimation enabled
                        mEstimatedTransmittedPowerVariance = mCovariance.
                                getElementAt(pos, pos);
                        pos++;
                    } else {
                        //transmitted power estimation disabled
                        mEstimatedTransmittedPowerVariance = null;
                    }

                    if (mPathLossEstimationEnabled) {
                        //pathloss exponent estimation enabled
                        mEstimatedPathLossExponentVariance = mCovariance.
                                getElementAt(pos, pos);
                    } else {
                        //pathloss exponent estimation disabled
                        mEstimatedPathLossExponentVariance = null;
                    }
                } else {
                    mCovariance = null;
                    mEstimatedPositionCovariance = null;
                    mEstimatedTransmittedPowerVariance = null;
                    mEstimatedPathLossExponentVariance = null;
                }

                mEstimatedPosition = mInnerEstimator.getEstimatedPosition();
                mEstimatedTransmittedPowerdBm =
                        mInnerEstimator.getEstimatedTransmittedPowerdBm();
                mEstimatedPathLossExponent =
                        mInnerEstimator.getEstimatedPathLossExponent();
            } catch (Exception e) {
                //refinement failed, so we return input value, and covariance
                //becomes unavailable
                mCovariance = null;
                mEstimatedPositionCovariance = null;
                mEstimatedTransmittedPowerVariance = null;
                mEstimatedPathLossExponentVariance = null;

                mEstimatedPosition = initialPosition;
                mEstimatedTransmittedPowerdBm = initialTransmittedPowerdBm;
                mEstimatedPathLossExponent = initialPathLossExponent;
            }
        } else {
            mCovariance = null;
            mEstimatedPositionCovariance = null;
            mEstimatedTransmittedPowerVariance = null;
            mEstimatedPathLossExponentVariance = null;

            mEstimatedPosition = initialPosition;
            mEstimatedTransmittedPowerdBm = initialTransmittedPowerdBm;
            mEstimatedPathLossExponent = initialPathLossExponent;
        }
    }
}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator2D.html#L2917">2917</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator3D.html#L2919">2919</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>        Point2D initialPosition = result.getEstimatedPosition();
        double initialTransmittedPowerdBm =
                result.getEstimatedTransmittedPowerdBm();
        double initialPathLossExponent = result.getEstimatedPathLossExponent();

        if (mRefineResult &amp;&amp; mInliersData != null) {
            BitSet inliers = mInliersData.getInliers();
            int nSamples = mReadings.size();

            mInnerReadings.clear();

            for (int i = 0; i &lt; nSamples; i++) {
                if (inliers.get(i)) {
                    //sample is inlier
                    mInnerReadings.add(mReadings.get(i));
                }
            }

            try {
                mInnerEstimator.setInitialPosition(initialPosition);
                mInnerEstimator.setInitialTransmittedPowerdBm(initialTransmittedPowerdBm);
                mInnerEstimator.setInitialPathLossExponent(initialPathLossExponent);
                mInnerEstimator.setTransmittedPowerEstimationEnabled(
                        mTransmittedPowerEstimationEnabled);
                mInnerEstimator.setPathLossEstimationEnabled(
                        mPathLossEstimationEnabled);
                mInnerEstimator.setReadings(mInnerReadings);
                mInnerEstimator.setUseReadingPositionCovariances(
                        mUseReadingPositionCovariances);

                mInnerEstimator.estimate();

                Matrix cov = mInnerEstimator.getEstimatedCovariance();
                if (mKeepCovariance &amp;&amp; cov != null) {
                    //keep covariance
                    mCovariance = cov;

                    int dims = getNumberOfDimensions();
                    int pos = 0;

                    int d = dims -1;
                    if (mEstimatedPositionCovariance == null) {
                        mEstimatedPositionCovariance = mCovariance.
                                getSubmatrix(0, 0, d, d);
                    } else {
                        mCovariance.getSubmatrix(0, 0, d, d,
                                mEstimatedPositionCovariance);
                    }
                    pos += dims;

                    if (mTransmittedPowerEstimationEnabled) {
                        //transmitted power estimation enabled
                        mEstimatedTransmittedPowerVariance = mCovariance.
                                getElementAt(pos, pos);
                        pos++;
                    } else {
                        //transmitted power estimation disabled
                        mEstimatedTransmittedPowerVariance = null;
                    }

                    if (mPathLossEstimationEnabled) {
                        //pathloss exponent estimation enabled
                        mEstimatedPathLossExponentVariance = mCovariance.
                                getElementAt(pos, pos);
                    } else {
                        //pathloss exponent estimation disabled
                        mEstimatedPathLossExponentVariance = null;
                    }
                } else {
                    mCovariance = null;
                    mEstimatedPositionCovariance = null;
                    mEstimatedTransmittedPowerVariance = null;
                    mEstimatedPathLossExponentVariance = null;
                }

                mEstimatedPosition = mInnerEstimator.getEstimatedPosition();
                mEstimatedTransmittedPowerdBm =
                        mInnerEstimator.getEstimatedTransmittedPowerdBm();
                mEstimatedPathLossExponent =
                        mInnerEstimator.getEstimatedPathLossExponent();
            } catch (Exception e) {
                //refinement failed, so we return input value, and covariance
                //becomes unavailable
                mCovariance = null;
                mEstimatedPositionCovariance = null;
                mEstimatedTransmittedPowerVariance = null;
                mEstimatedPathLossExponentVariance = null;

                mEstimatedPosition = initialPosition;
                mEstimatedTransmittedPowerdBm = initialTransmittedPowerdBm;
                mEstimatedPathLossExponent = initialPathLossExponent;
            }
        } else {
            mCovariance = null;
            mEstimatedPositionCovariance = null;
            mEstimatedTransmittedPowerVariance = null;
            mEstimatedPathLossExponentVariance = null;

            mEstimatedPosition = initialPosition;
            mEstimatedTransmittedPowerdBm = initialTransmittedPowerdBm;
            mEstimatedPathLossExponent = initialPathLossExponent;
        }
    }
}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/MixedRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MixedRadioSourceEstimator.html#L494">494</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RangingAndRssiRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RangingAndRssiRadioSourceEstimator.html#L484">484</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>            MixedRadioSourceEstimatorListener&lt;S, P&gt; listener) {
        this(readings, initialPosition, initialTransmittedPowerdBm, listener);
        mInitialPathLossExponent = initialPathLossExponent;
    }

    /**
     * Gets initial transmitted power to start the estimation of radio source
     * transmitted power (expressed in dBm's).
     * If not defined, average value of received power readings will be used.
     *
     * If transmitted power estimation is enabled, estimation will start at this
     * value and will converte the most appropriate value.
     * If transmitted power estimation is disabled, this value will be assumed to be
     * exact and the estimated transmitted power will be equal to this value
     * (converted to dBm's).
     * @return initial transmitted power to start the estimation of radio source
     * transmitted power.
     */
    public Double getInitialTransmittedPowerdBm() {
        return mInitialTransmittedPowerdBm;
    }

    /**
     * Sets initial transmitted power to start the estimation of radio source
     * transmitted power (expressed in dBm's).
     * If not defined, average value of received power readings will be used.
     *
     * If transmitted power estimation is enabled, estimation will start at this
     * value and will converte the most appropriate value.
     * If transmitted power estimation is disabled, this value will be assumed to be
     * exact and the estimated transmitted power will be equal to this value
     * (converted to dBm's).
     * @param initialTransmittedPowerdBm initial transmitted power to start the
     *                                   estimation of radio source transmitted
     *                                   power.
     * @throws LockedException if estimator is locked.
     */
    public void setInitialTransmittedPowerdBm(Double initialTransmittedPowerdBm)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mInitialTransmittedPowerdBm = initialTransmittedPowerdBm;
    }

    /**
     * Gets initial transmitted power to start the estimation of radio source
     * transmitted power (expressed in mW).
     * If not defined, average value of received power readings will be used.
     *
     * If transmitted power estimation is enabled, estimation will start at this
     * value and will converte the most appropriate value.
     * If transmitted power estimation is disabled, this value will be assumed to be
     * exact and the estimated transmitted power will be equal to this value
     * (converted to dBm's).
     * @return initial transmitted power to start the estimation of radio source
     * transmitted power.
     */
    public Double getInitialTransmittedPower() {
        return mInitialTransmittedPowerdBm != null ?
                Utils.dBmToPower(mInitialTransmittedPowerdBm) : null;
    }

    /**
     * Sets initial transmitted power to start the estimation of radio source
     * transmitted power (expressed in mW).
     * If not defined, average value of received power readings will be used.
     *
     * If transmitted power estimation is enabled, estimation will start at this
     * value and will converte the most appropriate value.
     * If transmitted power estimation is disabled, this value will be assumed to be
     * exact and the estimated transmitted power will be equal to this value
     * (converted to dBm's).
     * @param initialTransmittedPower initial transmitted power to start the
     *                                estimation of radio source transmitted power.
     * @throws LockedException if estimator is locked.
     * @throws IllegalArgumentException if provided value is negative.
     */
    public void setInitialTransmittedPower(Double initialTransmittedPower)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (initialTransmittedPower != null) {
            if (initialTransmittedPower &lt; 0.0) {
                throw new IllegalArgumentException();
            }
            mInitialTransmittedPowerdBm = Utils.powerTodBm(
                    initialTransmittedPower);
        } else {
            mInitialTransmittedPowerdBm = null;
        }
    }

    /**
     * Indicates whether transmitted power estimation is enabled or not.
     * @return true if transmitted power estimation is enabled, false otherwise.
     */
    public boolean isTransmittedPowerEstimationEnabled() {
        return mTransmittedPowerEstimationEnabled;
    }

    /**
     * Specifies whether transmitted power estimation is enabled or not.
     * @param transmittedPowerEstimationEnabled true if transmitted power estimation is enabled,
     *                                          false otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setTransmittedPowerEstimationEnabled(boolean transmittedPowerEstimationEnabled)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mTransmittedPowerEstimationEnabled = transmittedPowerEstimationEnabled;
    }

    /**
     * Gets initial position to start the estimation of radio source position.
     * If not defined, centroid of provided readings will be used.
     *
     * If position estimation is enabled, estimation will start at this value
     * and will converge to the most appropriate value.
     * If position estimation is disabled, this value will be assumed to
     * be exact and the estimated position will be equal to this value.
     * @return initial position to start the estimation of radio source position.
     */
    public P getInitialPosition() {
        return mInitialPosition;
    }

    /**
     * Sets initial position to start the estimation of radio source position.
     * If not defined, centroid of provided fingerprints will be used.
     *
     * If position estimation is enabled, estimation will start at this value
     * and will converge to the most appropriate value.
     * If position estimation is disabled, this value will be assumed to
     * be exact and the estimated position will be equal to this value.
     * @param initialPosition initial position to start the estimation of radio
     *                        source position.
     * @throws LockedException if estimator is locked.
     */
    public void setInitialPosition(P initialPosition) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mInitialPosition = initialPosition;
    }

    /**
     * Gets initial exponent typically used on free space for path loss propagation
     * in terms of distance.
     * On different environments path loss exponent might have different value:
     * - Free space: 2.0
     * - Urban Area: 2.7 to 3.5
     * - Suburban Area: 3 to 5
     * - Indoor (line-of-sight): 1.6 to 1.8
     *
     * If path loss exponent estimation is enabled, estimation will start at this
     * value and will converge to the most appropriate value.
     * If path loss exponent estimation is disabled, this value will be assumed
     * to be exact and the estimated path loss exponent will be equal to this
     * value.
     * @return initial path loss exponent.
     */
    public double getInitialPathLossExponent() {
        return mInitialPathLossExponent;
    }

    /**
     * Sets initial exponent typically used on free space for path loss propagation
     * in terms of distance.
     * On different environments path loss exponent might have different value:
     * - Free space: 2.0
     * - Urban Area: 2.7 to 3.5
     * - Suburban Area: 3 to 5
     * - Indoor (line-of-sight): 1.6 to 1.8
     *
     * If path loss exponent estimation is enabled, estimation will start at this
     * value and will converge to the most appropriate value.
     * If path loss exponent estimation is disabled, this value will be assumed
     * to be exact and the estimated path loss exponent will be equal to this
     * value.
     * @param initialPathLossExponent initial path loss exponent.
     * @throws LockedException if estimator is locked.
     */
    public void setInitialPathLossExponent(double initialPathLossExponent)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mInitialPathLossExponent = initialPathLossExponent;
    }

    /**
     * Indicates whether path loss estimation is enabled or not.
     * @return true if path loss estimation is enabled, false otherwise.
     */
    public boolean isPathLossEstimationEnabled() {
        return mPathLossEstimationEnabled;
    }

    /**
     * Specifies whether path loss estimation is enabled or not.
     * @param pathLossEstimationEnabled true if path loss estimation is enabled,
     *                                  false otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setPathLossEstimationEnabled(boolean pathLossEstimationEnabled)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mPathLossEstimationEnabled = pathLossEstimationEnabled;
    }

    /**
     * Indicates whether position covariances of readings must be taken into account to increase
     * the amount of standard deviation of each ranging measure by the amount of position standard
     * deviation assuming that both measures are statistically independent.
     * @return true to take into account reading position covariances, false otherwise.
     */
    public boolean getUseReadingPositionCovariance() {
        return mUseReadingPositionCovariances;
    }

    /**
     * Specifies whether position covariances of readings must be taken into account to increase
     * the amount of standard deviation of each ranging measure by the amount of position standard
     * deviation assuming that both measures are statistically independent.
     * @param useReadingPositionCovariances true to take into account reading position covariances, false
     *                                      otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setUseReadingPositionCovariances(boolean useReadingPositionCovariances)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mUseReadingPositionCovariances = useReadingPositionCovariances;
    }

    /**
     * Indicates whether an homogeneous linear solver is used to estimate an initial
     * position for the internal ranging radio source estimator.
     * @return true if homogeneous linear solver is used, false if an inhomogeneous linear
     * one is used instead.
     */
    public boolean isHomogeneousRangingLinearSolverUsed() {
        return mUseHomogeneousRangingLinearSolver;
    }

    /**
     * Specifies whether an homogeneous linear solver is used to estimate an initial
     * position for the internal ranging radio source estimator.
     * @param useHomogeneousLinearSolver true if homogeneous linear solver is used, false
     *                                   if an inhomogeneous linear one is used instead.
     * @throws LockedException if estimator is locked.
     */
    public void setHomogeneousRangingLinearSolverUsed(boolean useHomogeneousLinearSolver)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }

        mUseHomogeneousRangingLinearSolver = useHomogeneousLinearSolver;
    }</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/Utils.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/Utils.html#L492">492</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/Utils.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/Utils.html#L1188">1188</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/Utils.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/Utils.html#L2142">2142</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    public static MultivariateNormalDist propagateVariancesToRssiVarianceFirstOrderNonLinear3D(
            final double fingerprintRssi, final double pathLossExponent,
            Point3D fingerprintPosition, Point3D radioSourcePosition,
            Point3D estimatedPosition,
            Double fingerprintRssiVariance,
            Double pathLossExponentVariance,
            Matrix fingerprintPositionCovariance,
            Matrix radioSourcePositionCovariance,
            Matrix estimatedPositionCovariance) throws IndoorException {

        if (fingerprintPosition == null || radioSourcePosition == null ||
                estimatedPosition == null) {
            return null;
        }

        //1st order Taylor expression of received power in 3D:
        //Pr(pi) = Pr(p1)
        //  - 10*n*(x1 - xa)/(ln(10)*d1a^2)*(xi - x1)
        //  - 10*n*(y1 - ya)/(ln(10)*d1a^2)*(yi - y1)
        //  - 10*n*(z1 - za)/(ln(10)*d1a^2)*(zi - z1)
        //where d1a^2 = (x1 - xa)^2 + (y1 - ya)^2 + (z1 - za)^2

        final double x1 = fingerprintPosition.getInhomX();
        final double y1 = fingerprintPosition.getInhomY();
        final double z1 = fingerprintPosition.getInhomZ();

        final double xa = radioSourcePosition.getInhomX();
        final double ya = radioSourcePosition.getInhomY();
        final double za = radioSourcePosition.getInhomZ();

        final double xi = estimatedPosition.getInhomX();
        final double yi = estimatedPosition.getInhomY();
        final double zi = estimatedPosition.getInhomZ();

        double[] mean = new double[] {
                fingerprintRssi, pathLossExponent, x1, y1, z1, xa, ya, za, xi, yi, zi
        };
        Matrix covariance = Matrix.diagonal(new double[]{
                fingerprintRssiVariance != null ? fingerprintRssiVariance : 0.0,
                pathLossExponentVariance != null ? pathLossExponentVariance : 0.0,
                0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0
        });

        if (fingerprintPositionCovariance != null &amp;&amp;
                fingerprintPositionCovariance.getRows() == Point3D.POINT3D_INHOMOGENEOUS_COORDINATES_LENGTH &amp;&amp;
                fingerprintPositionCovariance.getColumns() == Point3D.POINT3D_INHOMOGENEOUS_COORDINATES_LENGTH) {

            covariance.setSubmatrix(2, 2,
                    4, 4,
                    fingerprintPositionCovariance);
        }

        if (radioSourcePositionCovariance != null &amp;&amp;
                radioSourcePositionCovariance.getRows() == Point3D.POINT3D_INHOMOGENEOUS_COORDINATES_LENGTH &amp;&amp;
                radioSourcePositionCovariance.getColumns() == Point3D.POINT3D_INHOMOGENEOUS_COORDINATES_LENGTH) {
            covariance.setSubmatrix(5, 5,
                    7, 7,
                    radioSourcePositionCovariance);
        }

        if (estimatedPositionCovariance != null &amp;&amp;
                estimatedPositionCovariance.getRows() == Point3D.POINT3D_INHOMOGENEOUS_COORDINATES_LENGTH &amp;&amp;
                estimatedPositionCovariance.getColumns() == Point3D.POINT3D_INHOMOGENEOUS_COORDINATES_LENGTH) {
            covariance.setSubmatrix(8, 8,
                    10, 10,
                    estimatedPositionCovariance);
        }

        try {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator2D.html#L831">831</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator2D.html#L842">842</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>            RobustRangingAndRssiRadioSourceEstimatorListener&lt;S, Point2D&gt; listener) {
        super(readings, initialPosition, initialTransmittedPowerdBm,
                initialPathLossExponent, listener);
        internalSetQualityScores(qualityScores);
    }

    /**
     * Returns threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value, the
     * algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algorithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @return stop threshold to stop the algorithm prematurely when a certain
     * accuracy has been reached.
     */
    public double getStopThreshold() {
        return mStopThreshold;
    }

    /**
     * Sets threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value,
     * the algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algorithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @param stopThreshold stop threshold to stop the algorithm prematurely
     *                      when a certain accuracy has been reached.
     * @throws IllegalArgumentException if provided value is zero or negative.
     * @throws LockedException if this solver is locked.
     */
    public void setStopThreshold(double stopThreshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (stopThreshold &lt;= MIN_STOP_THRESHOLD) {
            throw new IllegalArgumentException();
        }

        mStopThreshold = stopThreshold;
    }

    /**
     * Returns quality scores corresponding to each pair of
     * positions and distances (i.e. sample).
     * The larger the score value the better the quality of the sample.
     * This implementation always returns null.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @return quality scores corresponding to each sample.
     */
    @Override
    public double[] getQualityScores() {
        return mQualityScores;
    }

    /**
     * Sets quality scores corresponding to each pair of positions and
     * distances (i.e. sample).
     * The larger the score value the better the quality of the sample.
     * This implementation makes no action.
     * Subclasses using quality scores must implement proper behaviour.
     *
     * @param qualityScores quality scores corresponding to each pair of
     *                      matched points.
     * @throws IllegalArgumentException if provided quality scores length
     * is smaller than minimum required samples.
     * @throws LockedException if robust solver is locked because an
     * estimation is already in progress.
     */
    public void setQualityScores(double[] qualityScores) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetQualityScores(qualityScores);
    }

    /**
     * Indicates whether solver is ready to find a solution.
     *
     * @return true if solver is ready, false otherwise.
     */
    @Override
    public boolean isReady() {
        return super.isReady() &amp;&amp; mQualityScores != null &amp;&amp;
                mQualityScores.length == mReadings.size();
    }

    /**
     * Robustly estimates position, transmitted power and pathloss exponent for a
     * radio source.
     *
     * @throws LockedException if instance is busy during estimation.
     * @throws NotReadyException if estimator is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     * (i.e. numerical instability, no solution available, etc).
     */
    @Override
    public void estimate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        PROMedSRobustEstimator&lt;Solution&lt;Point2D&gt;&gt; innerEstimator =
                new PROMedSRobustEstimator&lt;&gt;(
                        new PROMedSRobustEstimatorListener&lt;Solution&lt;Point2D&gt;&gt;() {

                    @Override
                    public double[] getQualityScores() {
                        return mQualityScores;
                    }

                    @Override
                    public double getThreshold() {
                        return mStopThreshold;
                    }

                    @Override
                    public int getTotalSamples() {
                        return mReadings.size();
                    }

                    @Override
                    public int getSubsetSize() {
                        return Math.max(mPreliminarySubsetSize, getMinReadings());
                    }

                    @Override
                    public void estimatePreliminarSolutions(int[] samplesIndices,
                            List&lt;Solution&lt;Point2D&gt;&gt; solutions) {
                        solvePreliminarSolutions(samplesIndices, solutions);
                    }

                    @Override
                    public double computeResidual(Solution&lt;Point2D&gt; currentEstimation, int i) {
                        return residual(currentEstimation, i);
                    }

                    @Override
                    public boolean isReady() {
                        return PROMedSRobustRangingAndRssiRadioSourceEstimator2D.this.isReady();</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator3D.html#L831">831</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator3D.html#L841">841</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>            RobustRangingAndRssiRadioSourceEstimatorListener&lt;S, Point3D&gt; listener) {
        super(readings, initialPosition, initialTransmittedPowerdBm,
                initialPathLossExponent, listener);
        internalSetQualityScores(qualityScores);
    }

    /**
     * Returns threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value, the
     * algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algorithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @return stop threshold to stop the algorithm prematurely when a certain
     * accuracy has been reached.
     */
    public double getStopThreshold() {
        return mStopThreshold;
    }

    /**
     * Sets threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value,
     * the algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algorithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @param stopThreshold stop threshold to stop the algorithm prematurely
     *                      when a certain accuracy has been reached.
     * @throws IllegalArgumentException if provided value is zero or negative.
     * @throws LockedException if this solver is locked.
     */
    public void setStopThreshold(double stopThreshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (stopThreshold &lt;= MIN_STOP_THRESHOLD) {
            throw new IllegalArgumentException();
        }

        mStopThreshold = stopThreshold;
    }

    /**
     * Returns quality scores corresponding to each pair of
     * positions and distances (i.e. sample).
     * The larger the score value the better the quality of the sample.
     * This implementation always returns null.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @return quality scores corresponding to each sample.
     */
    @Override
    public double[] getQualityScores() {
        return mQualityScores;
    }

    /**
     * Sets quality scores corresponding to each pair of positions and
     * distances (i.e. sample).
     * The larger the score value the better the quality of the sample.
     * This implementation makes no action.
     * Subclasses using quality scores must implement proper behaviour.
     *
     * @param qualityScores quality scores corresponding to each pair of
     *                      matched points.
     * @throws IllegalArgumentException if provided quality scores length
     * is smaller than minimum required samples.
     * @throws LockedException if robust solver is locked because an
     * estimation is already in progress.
     */
    public void setQualityScores(double[] qualityScores) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetQualityScores(qualityScores);
    }

    /**
     * Indicates whether solver is ready to find a solution.
     *
     * @return true if solver is ready, false otherwise.
     */
    @Override
    public boolean isReady() {
        return super.isReady() &amp;&amp; mQualityScores != null &amp;&amp;
                mQualityScores.length == mReadings.size();
    }

    /**
     * Robustly estimates position, transmitted power and pathloss exponent for a
     * radio source.
     *
     * @throws LockedException if instance is busy during estimation.
     * @throws NotReadyException if estimator is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     * (i.e. numerical instability, no solution available, etc).
     */
    @Override
    public void estimate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        PROMedSRobustEstimator&lt;Solution&lt;Point3D&gt;&gt; innerEstimator =
                new PROMedSRobustEstimator&lt;&gt;(
                        new PROMedSRobustEstimatorListener&lt;Solution&lt;Point3D&gt;&gt;() {

                            @Override
                            public double[] getQualityScores() {
                                return mQualityScores;
                            }

                            @Override
                            public double getThreshold() {
                                return mStopThreshold;
                            }

                            @Override
                            public int getTotalSamples() {
                                return mReadings.size();
                            }

                            @Override
                            public int getSubsetSize() {
                                return Math.max(mPreliminarySubsetSize, getMinReadings());
                            }

                            @Override
                            public void estimatePreliminarSolutions(int[] samplesIndices,
                                                                    List&lt;Solution&lt;Point3D&gt;&gt; solutions) {
                                solvePreliminarSolutions(samplesIndices, solutions);
                            }

                            @Override
                            public double computeResidual(Solution&lt;Point3D&gt; currentEstimation, int i) {
                                return residual(currentEstimation, i);
                            }

                            @Override
                            public boolean isReady() {
                                return PROMedSRobustRangingAndRssiRadioSourceEstimator3D.this.isReady();</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/PROSACRobustMixedPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROSACRobustMixedPositionEstimator2D.html#L357">357</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/PROSACRobustRangingAndRssiPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROSACRobustRangingAndRssiPositionEstimator2D.html#L361">361</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/PROSACRobustRangingPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROSACRobustRangingPositionEstimator2D.html#L357">357</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/PROSACRobustRssiPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROSACRobustRssiPositionEstimator2D.html#L359">359</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>            RobustMixedPositionEstimatorListener&lt;Point2D&gt; listener) {
        this(sources, fingerprint, listener);
        internalSetSourceQualityScores(sourceQualityScores);
        internalSetFingerprintReadingsQualityScores(fingerprintReadingQualityScores);
    }

    /**
     * Returns quality scores corresponding to each radio source.
     * The larger the score value the better the quality of the sample.
     *
     * @return quality scores corresponding to each radio source.
     */
    public double[] getSourceQualityScores() {
        return mSourceQualityScores;
    }

    /**
     * Sets quality scores corresponding to each radio source.
     * The larger the score value the better the quality of the radio source.
     *
     * @param sourceQualityScores quality scores corresponding to each radio source.
     * @throws LockedException          if this instance is locked.
     * @throws IllegalArgumentException if provided quality scores length is smaller
     *                                  than minimum required samples.
     */
    public void setSourceQualityScores(double[] sourceQualityScores)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetSourceQualityScores(sourceQualityScores);
    }

    /**
     * Gets quality scores corresponding to each reading within provided fingerprint.
     * The larger the score value the better the quality of the reading.
     * This implementation always returns null.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @return quality scores corresponding to each reading within provided
     * fingerprint.
     */
    public double[] getFingerprintReadingsQualityScores() {
        return mFingerprintReadingsQualityScores;
    }

    /**
     * Sets quality scores corresponding to each reading within provided fingerprint.
     * The larger the score value the better the quality of the reading.
     * This implementation makes no action.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @param fingerprintReadingsQualityScores quality scores corresponding to each
     *                                         reading within provided fingerprint.
     * @throws LockedException          if this instance is locked.
     * @throws IllegalArgumentException if provided quality scores length is smaller
     *                                  than minimum required samples.
     */
    public void setFingerprintReadingsQualityScores(
            double[] fingerprintReadingsQualityScores) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetFingerprintReadingsQualityScores(fingerprintReadingsQualityScores);
    }

    /**
     * Gets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on distance between estimated position and distances
     * provided for each sample.
     * @return threshold to determine whether samples are inliers or not.
     */
    public double getThreshold() {
        return ((PROSACRobustLateration2DSolver) mLaterationSolver).
                getThreshold();
    }

    /**
     * Sets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on distance between estimated position and distances
     * provided for each sample.
     * @param threshold threshold to determine whether samples are inliers or not.
     * @throws IllegalArgumentException if provided value is equal or less than zero.
     * @throws LockedException if this solver is locked.
     */
    public void setThreshold(double threshold) throws LockedException {
        ((PROSACRobustLateration2DSolver) mLaterationSolver).
                setThreshold(threshold);
    }

    /**
     * Indicates whether inliers must be computed and kept.
     * @return true if inliers must be computed and kept, false if inliers
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepInliersEnabled() {
        return ((PROSACRobustLateration2DSolver) mLaterationSolver).
                isComputeAndKeepInliersEnabled();
    }

    /**
     * Specifies whether inliers must be computed and kept.
     * @param computeAndKeepInliers true if inliers must be computed and kept,
     *                              false if inliers only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepInliersEnabled(boolean computeAndKeepInliers)
            throws LockedException {
        ((PROSACRobustLateration2DSolver) mLaterationSolver).
                setComputeAndKeepInliersEnabled(computeAndKeepInliers);
    }

    /**
     * Indicates whether residuals must be computed and kept.
     * @return true if residuals must be computed and kept, false if residuals
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepResiduals() {
        return ((PROSACRobustLateration2DSolver) mLaterationSolver).
                isComputeAndKeepResiduals();
    }

    /**
     * Specifies whether residuals must be computed and kept.
     * @param computeAndKeepResiduals true if residuals must be computed and kept,
     *                                false if residuals only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepResidualsEnabled(boolean computeAndKeepResiduals)
            throws LockedException {
        ((PROSACRobustLateration2DSolver) mLaterationSolver).
                setComputeAndKeepResidualsEnabled(computeAndKeepResiduals);
    }

    /**
     * Returns method being used for robust estimation.
     * @return method being used for robust estimation.
     */
    @Override
    public RobustEstimatorMethod getMethod() {
        return RobustEstimatorMethod.PROSAC;
    }

    /**
     * Initializes robust lateration solver.
     */
    private void init() {
        mLaterationSolver = new PROSACRobustLateration2DSolver(
                mTrilaterationSolverListener);
    }

    /**
     * Sets quality scores corresponding to each provided located radio source.
     * This method is used internally and does not check whether instance is
     * locked or not.
     * @param sourceQualityScores quality scores to be set.
     * @throws IllegalArgumentException if provided quality scores length
     * is smaller than 3 samples.
     */
    private void internalSetSourceQualityScores(double[] sourceQualityScores) {
        if (sourceQualityScores == null ||
                sourceQualityScores.length &lt; getMinRequiredSources()) {
            throw new IllegalArgumentException();
        }

        mSourceQualityScores = sourceQualityScores;

        buildPositionsDistancesDistanceStandardDeviationsAndQualityScores();
    }

    /**
     * Sets quality scores corresponding to each provided reading within provided
     * fingerprint.
     * This method is used internally and does not check whether instance is locked
     * or not.
     * @param fingerprintReadingsQualityScores quality scores to be set.
     * @throws IllegalArgumentException if provided quality scores lengt is
     * smaller than 3 samples.
     */
    private void internalSetFingerprintReadingsQualityScores(
            double[] fingerprintReadingsQualityScores) {
        if (fingerprintReadingsQualityScores == null ||
                fingerprintReadingsQualityScores.length &lt; getMinRequiredSources()) {
            throw new IllegalArgumentException();
        }

        mFingerprintReadingsQualityScores = fingerprintReadingsQualityScores;

        buildPositionsDistancesDistanceStandardDeviationsAndQualityScores();
    }
}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/PROSACRobustMixedPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROSACRobustMixedPositionEstimator3D.html#L357">357</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/PROSACRobustRangingAndRssiPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROSACRobustRangingAndRssiPositionEstimator3D.html#L361">361</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/PROSACRobustRangingPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROSACRobustRangingPositionEstimator3D.html#L357">357</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/PROSACRobustRssiPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROSACRobustRssiPositionEstimator3D.html#L359">359</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>                                                RobustMixedPositionEstimatorListener&lt;Point3D&gt; listener) {
        this(sources, fingerprint, listener);
        internalSetSourceQualityScores(sourceQualityScores);
        internalSetFingerprintReadingsQualityScores(fingerprintReadingQualityScores);
    }

    /**
     * Returns quality scores corresponding to each radio source.
     * The larger the score value the better the quality of the sample.
     *
     * @return quality scores corresponding to each radio source.
     */
    public double[] getSourceQualityScores() {
        return mSourceQualityScores;
    }

    /**
     * Sets quality scores corresponding to each radio source.
     * The larger the score value the better the quality of the radio source.
     *
     * @param sourceQualityScores quality scores corresponding to each radio source.
     * @throws LockedException          if this instance is locked.
     * @throws IllegalArgumentException if provided quality scores length is smaller
     *                                  than minimum required samples.
     */
    public void setSourceQualityScores(double[] sourceQualityScores)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetSourceQualityScores(sourceQualityScores);
    }

    /**
     * Gets quality scores corresponding to each reading within provided fingerprint.
     * The larger the score value the better the quality of the reading.
     * This implementation always returns null.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @return quality scores corresponding to each reading within provided
     * fingerprint.
     */
    public double[] getFingerprintReadingsQualityScores() {
        return mFingerprintReadingsQualityScores;
    }

    /**
     * Sets quality scores corresponding to each reading within provided fingerprint.
     * The larger the score value the better the quality of the reading.
     * This implementation makes no action.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @param fingerprintReadingsQualityScores quality scores corresponding to each
     *                                         reading within provided fingerprint.
     * @throws LockedException          if this instance is locked.
     * @throws IllegalArgumentException if provided quality scores length is smaller
     *                                  than minimum required samples.
     */
    public void setFingerprintReadingsQualityScores(
            double[] fingerprintReadingsQualityScores) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetFingerprintReadingsQualityScores(fingerprintReadingsQualityScores);
    }

    /**
     * Gets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on distance between estimated position and distances
     * provided for each sample.
     * @return threshold to determine whether samples are inliers or not.
     */
    public double getThreshold() {
        return ((PROSACRobustLateration3DSolver) mLaterationSolver).
                getThreshold();
    }

    /**
     * Sets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on distance between estimated position and distances
     * provided for each sample.
     * @param threshold threshold to determine whether samples are inliers or not.
     * @throws IllegalArgumentException if provided value is equal or less than zero.
     * @throws LockedException if this solver is locked.
     */
    public void setThreshold(double threshold) throws LockedException {
        ((PROSACRobustLateration3DSolver) mLaterationSolver).
                setThreshold(threshold);
    }

    /**
     * Indicates whether inliers must be computed and kept.
     * @return true if inliers must be computed and kept, false if inliers
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepInliersEnabled() {
        return ((PROSACRobustLateration3DSolver) mLaterationSolver).
                isComputeAndKeepInliersEnabled();
    }

    /**
     * Specifies whether inliers must be computed and kept.
     * @param computeAndKeepInliers true if inliers must be computed and kept,
     *                              false if inliers only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepInliersEnabled(boolean computeAndKeepInliers)
            throws LockedException {
        ((PROSACRobustLateration3DSolver) mLaterationSolver).
                setComputeAndKeepInliersEnabled(computeAndKeepInliers);
    }

    /**
     * Indicates whether residuals must be computed and kept.
     * @return true if residuals must be computed and kept, false if residuals
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepResiduals() {
        return ((PROSACRobustLateration3DSolver) mLaterationSolver).
                isComputeAndKeepResiduals();
    }

    /**
     * Specifies whether residuals must be computed and kept.
     * @param computeAndKeepResiduals true if residuals must be computed and kept,
     *                                false if residuals only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepResidualsEnabled(boolean computeAndKeepResiduals)
            throws LockedException {
        ((PROSACRobustLateration3DSolver) mLaterationSolver).
                setComputeAndKeepResidualsEnabled(computeAndKeepResiduals);
    }

    /**
     * Returns method being used for robust estimation.
     * @return method being used for robust estimation.
     */
    @Override
    public RobustEstimatorMethod getMethod() {
        return RobustEstimatorMethod.PROSAC;
    }

    /**
     * Initializes robust lateration solver.
     */
    private void init() {
        mLaterationSolver = new PROSACRobustLateration3DSolver(
                mTrilaterationSolverListener);
    }

    /**
     * Sets quality scores corresponding to each provided located radio source.
     * This method is used internally and does not check whether instance is
     * locked or not.
     * @param sourceQualityScores quality scores to be set.
     * @throws IllegalArgumentException if provided quality scores length
     * is smaller than 3 samples.
     */
    private void internalSetSourceQualityScores(double[] sourceQualityScores) {
        if (sourceQualityScores == null ||
                sourceQualityScores.length &lt; getMinRequiredSources()) {
            throw new IllegalArgumentException();
        }

        mSourceQualityScores = sourceQualityScores;

        buildPositionsDistancesDistanceStandardDeviationsAndQualityScores();
    }

    /**
     * Sets quality scores corresponding to each provided reading within provided
     * fingerprint.
     * This method is used internally and does not check whether instance is locked
     * or not.
     * @param fingerprintReadingsQualityScores quality scores to be set.
     * @throws IllegalArgumentException if provided quality scores lengt is
     * smaller than 3 samples.
     */
    private void internalSetFingerprintReadingsQualityScores(
            double[] fingerprintReadingsQualityScores) {
        if (fingerprintReadingsQualityScores == null ||
                fingerprintReadingsQualityScores.length &lt; getMinRequiredSources()) {
            throw new IllegalArgumentException();
        }

        mFingerprintReadingsQualityScores = fingerprintReadingsQualityScores;

        buildPositionsDistancesDistanceStandardDeviationsAndQualityScores();
    }
}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator2D.html#L2807">2807</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator2D.html#L2785">2785</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>        List&lt;? extends RangingAndRssiReadingLocated&lt;S, Point2D&gt;&gt; readings = getReadings();
        if (readings == null || readings.isEmpty()) {
            return null;
        }
        S source = readings.get(0).getSource();

        Point2D estimatedPosition = getEstimatedPosition();
        if (estimatedPosition == null) {
            return null;
        }

        Matrix estimatedPositionCovariance = getEstimatedPositionCovariance();

        Double transmittedPowerVariance =
                getEstimatedTransmittedPowerVariance();
        Double transmittedPowerStandardDeviation = transmittedPowerVariance != null ?
                Math.sqrt(transmittedPowerVariance) : null;

        Double pathlossExponentVariance =
                getEstimatedPathLossExponentVariance();
        Double pathlossExponentStandardDeviation = pathlossExponentVariance != null ?
                Math.sqrt(pathlossExponentVariance) : null;

        if (source instanceof WifiAccessPoint) {
            WifiAccessPoint accessPoint = (WifiAccessPoint) source;
            return new WifiAccessPointWithPowerAndLocated2D(accessPoint.getBssid(),
                    source.getFrequency(), accessPoint.getSsid(),
                    getEstimatedTransmittedPowerdBm(),
                    transmittedPowerStandardDeviation,
                    getEstimatedPathLossExponent(),
                    pathlossExponentStandardDeviation,
                    estimatedPosition,
                    estimatedPositionCovariance);
        } else if(source instanceof Beacon) {
            Beacon beacon = (Beacon) source;
            return new BeaconWithPowerAndLocated2D(beacon.getIdentifiers(),
                    getEstimatedTransmittedPowerdBm(), beacon.getFrequency(),
                    beacon.getBluetoothAddress(), beacon.getBeaconTypeCode(),
                    beacon.getManufacturer(), beacon.getServiceUuid(),
                    beacon.getBluetoothName(),
                    getEstimatedPathLossExponent(),
                    transmittedPowerStandardDeviation,
                    pathlossExponentStandardDeviation,
                    estimatedPosition, estimatedPositionCovariance);
        }else {
            return null;
        }
    }

    /**
     * Solves preliminar solution for a subset of samples.
     *
     * @param samplesIndices    indices of subset samples.
     * @param solutions         instance where solution will be stored.
     */
    @Override
    protected void solvePreliminarSolutions(int[] samplesIndices,
            List&lt;Solution&lt;Point2D&gt;&gt; solutions) {

        try {
            int index;

            mInnerReadings.clear();
            for (int samplesIndice : samplesIndices) {
                index = samplesIndice;
                mInnerReadings.add(mReadings.get(index));
            }

            //initial transmitted power and position might or might not be available
            mInnerEstimator.setInitialTransmittedPowerdBm(
                    mInitialTransmittedPowerdBm);
            mInnerEstimator.setInitialPosition(mInitialPosition);
            mInnerEstimator.setInitialPathLossExponent(mInitialPathLossExponent);

            mInnerEstimator.setTransmittedPowerEstimationEnabled(
                    mTransmittedPowerEstimationEnabled);
            mInnerEstimator.setPathLossEstimationEnabled(mPathLossEstimationEnabled);</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/NonLinearMixedPositionEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/NonLinearMixedPositionEstimator.html#L116">116</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/NonLinearRangingAndRssiPositionEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/NonLinearRangingAndRssiPositionEstimator.html#L116">116</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/NonLinearRangingPositionEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/NonLinearRangingPositionEstimator.html#L116">116</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/NonLinearRssiPositionEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/NonLinearRssiPositionEstimator.html#L115">115</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>            MixedPositionEstimatorListener&lt;P&gt; listener) {
        this(listener);
        mInitialPosition = initialPosition;
    }

    /**
     * Gets initial position to start position estimation.
     * If not defined, centroid of located sources position will be used to start
     * the estimation.
     *
     * @return initial position to start position estimation.
     */
    public P getInitialPosition() {
        return mInitialPosition;
    }

    /**
     * Sets initial position to start position estimation.
     * If not defined, centroid of located sources position will be used to start
     * the estimation.
     *
     * @param initialPosition initial position to start position estimation.
     * @throws LockedException if estimator is locked.
     */
    public void setInitialPosition(P initialPosition) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mInitialPosition = initialPosition;
    }

    /**
     * Indicates whether located radio source position covariance must be taken into
     * account (if available) to determine distance standard deviation.
     *
     * @return true to take radio source position covariance into account, false
     * otherwise.
     */
    public boolean isRadioSourcePositionCovarianceUsed() {
        return mUseRadioSourcePositionCovariance;
    }

    /**
     * Specifies whether located radio source position covariance must be taken into
     * account (if available) to determine distance standard deviation.
     *
     * @param useRadioSourcePositionCovariance true to take radio source position
     *                                         covariance into account, false otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setRadioSourcePositionCovarianceUsed(
            boolean useRadioSourcePositionCovariance) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mUseRadioSourcePositionCovariance = useRadioSourcePositionCovariance;
    }

    /**
     * Gets distance standard deviation fallback value to use when none can be
     * determined from provided radio sources and fingerprint readings.
     *
     * @return distance standard deviation to use as fallback.
     */
    public double getFallbackDistanceStandardDeviation() {
        return mFallbackDistanceStandardDeviation;
    }

    /**
     * Sets distance standard deviation fallback value to use when none can be
     * determined from provided radio sources and fingerprint readings.
     *
     * @param fallbackDistanceStandardDeviation distance standard deviation to use
     *                                          as fallback.
     * @throws LockedException if estimator is locked.
     */
    public void setFallbackDistanceStandardDeviation(
            double fallbackDistanceStandardDeviation) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mFallbackDistanceStandardDeviation = fallbackDistanceStandardDeviation;
    }

    /**
     * Gets minimum required number of located radio sources to perform lateration.
     *
     * @return minimum required number of located radio sources to perform lateration.
     */
    @Override
    public int getMinRequiredSources() {
        return mTrilaterationSolver.getMinRequiredPositionsAndDistances();
    }

    /**
     * Indicates whether estimator is ready to find a solution.
     *
     * @return true if estimator is ready, false otherwise.
     */
    @Override
    public boolean isReady() {
        return mTrilaterationSolver.isReady();
    }

    /**
     * Returns boolean indicating whether this estimator is locked because an estimation
     * is already in progress.
     *
     * @return true if estimator is locked, false otherwise.
     */
    @Override
    public boolean isLocked() {
        return mTrilaterationSolver.isLocked();
    }

    /**
     * Gets standard deviations of distances from known located radio sources to the
     * location of provided readings in a fingerprint.
     * Distance standard deviations are used internally to solve lateration.
     *
     * @return standard deviations used internally.
     */
    public double[] getDistanceStandardDeviations() {
        return mTrilaterationSolver.getDistanceStandardDeviations();
    }

    /**
     * Estimates position based on provided located radio sources and readings of such
     * radio sources at an unknown location.
     *
     * @throws LockedException              if estimator is locked.
     * @throws NotReadyException            if estimator is not ready.
     * @throws PositionEstimationException  if estimation fails for some other reason.
     */
    @Override
    public void estimate() throws LockedException, NotReadyException,
            PositionEstimationException {
        try {
            mTrilaterationSolver.setInitialPosition(mInitialPosition);

            mTrilaterationSolver.solve();
            mEstimatedPositionCoordinates =
                    mTrilaterationSolver.getEstimatedPositionCoordinates();
        } catch (LaterationException e) {
            throw new PositionEstimationException(e);
        }
    }

    /**
     * Gets known positions of radio sources used internally to solve lateration.
     *
     * @return known positions used internally.
     */
    @Override
    public P[] getPositions() {
        return mTrilaterationSolver.getPositions();
    }

    /**
     * Gets euclidean distances from known located radio sources to the location of
     * provided readings in a fingerprint.
     * Distance values are used internally to solve lateration.
     *
     * @return euclidean distances used internally.
     */
    @Override
    public double[] getDistances() {
        return mTrilaterationSolver.getDistances();
    }

    /**
     * Gets estimated covariance matrix for estimated position.
     *
     * @return estimated covariance matrix for estimated position.
     */
    public Matrix getCovariance() {
        return mTrilaterationSolver.getCovariance();
    }

    /**
     * Internally sets located radio sources used for lateration.
     * @param sources located radio sources used for lateration.
     * @throws IllegalArgumentException if provided value is null or the number of
     * provided sources is less than the required minimum.
     */
    protected void internalSetSources(List&lt;? extends RadioSourceLocated&lt;P&gt;&gt; sources) {
        super.internalSetSources(sources);
        buildPositionsDistancesAndDistanceStandardDeviations();
    }

    /**
     * Internally sets fingerprint containing readings at an unknown location for provided
     * located radio sources.
     *
     * @param fingerprint fingerprint containing readings at an unknown location for
     *                    provided located radio sources.
     * @throws IllegalArgumentException if provided value is null.
     */
    protected void internalSetFingerprint(
            Fingerprint&lt;? extends RadioSource, ? extends Reading&lt;? extends RadioSource&gt;&gt; fingerprint) {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator2D.html#L833">833</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator2D.html#L329">329</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator2D.html#L844">844</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                initialPathLossExponent, listener);
        internalSetQualityScores(qualityScores);
    }

    /**
     * Returns threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value, the
     * algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algorithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @return stop threshold to stop the algorithm prematurely when a certain
     * accuracy has been reached.
     */
    public double getStopThreshold() {
        return mStopThreshold;
    }

    /**
     * Sets threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value,
     * the algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algorithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @param stopThreshold stop threshold to stop the algorithm prematurely
     *                      when a certain accuracy has been reached.
     * @throws IllegalArgumentException if provided value is zero or negative.
     * @throws LockedException if this solver is locked.
     */
    public void setStopThreshold(double stopThreshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (stopThreshold &lt;= MIN_STOP_THRESHOLD) {
            throw new IllegalArgumentException();
        }

        mStopThreshold = stopThreshold;
    }

    /**
     * Returns quality scores corresponding to each pair of
     * positions and distances (i.e. sample).
     * The larger the score value the better the quality of the sample.
     * This implementation always returns null.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @return quality scores corresponding to each sample.
     */
    @Override
    public double[] getQualityScores() {
        return mQualityScores;
    }

    /**
     * Sets quality scores corresponding to each pair of positions and
     * distances (i.e. sample).
     * The larger the score value the better the quality of the sample.
     * This implementation makes no action.
     * Subclasses using quality scores must implement proper behaviour.
     *
     * @param qualityScores quality scores corresponding to each pair of
     *                      matched points.
     * @throws IllegalArgumentException if provided quality scores length
     * is smaller than minimum required samples.
     * @throws LockedException if robust solver is locked because an
     * estimation is already in progress.
     */
    public void setQualityScores(double[] qualityScores) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetQualityScores(qualityScores);
    }

    /**
     * Indicates whether solver is ready to find a solution.
     *
     * @return true if solver is ready, false otherwise.
     */
    @Override
    public boolean isReady() {
        return super.isReady() &amp;&amp; mQualityScores != null &amp;&amp;
                mQualityScores.length == mReadings.size();
    }

    /**
     * Robustly estimates position, transmitted power and pathloss exponent for a
     * radio source.
     *
     * @throws LockedException if instance is busy during estimation.
     * @throws NotReadyException if estimator is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     * (i.e. numerical instability, no solution available, etc).
     */
    @Override
    public void estimate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        PROMedSRobustEstimator&lt;Solution&lt;Point2D&gt;&gt; innerEstimator =
                new PROMedSRobustEstimator&lt;&gt;(
                        new PROMedSRobustEstimatorListener&lt;Solution&lt;Point2D&gt;&gt;() {

                    @Override
                    public double[] getQualityScores() {
                        return mQualityScores;
                    }

                    @Override
                    public double getThreshold() {
                        return mStopThreshold;
                    }

                    @Override
                    public int getTotalSamples() {
                        return mReadings.size();
                    }

                    @Override
                    public int getSubsetSize() {
                        return Math.max(mPreliminarySubsetSize, getMinReadings());
                    }

                    @Override
                    public void estimatePreliminarSolutions(int[] samplesIndices,
                            List&lt;Solution&lt;Point2D&gt;&gt; solutions) {
                        solvePreliminarSolutions(samplesIndices, solutions);
                    }

                    @Override
                    public double computeResidual(Solution&lt;Point2D&gt; currentEstimation, int i) {
                        return residual(currentEstimation, i);
                    }

                    @Override
                    public boolean isReady() {
                        return PROMedSRobustRangingAndRssiRadioSourceEstimator2D.this.isReady();</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator3D.html#L833">833</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator3D.html#L329">329</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator3D.html#L843">843</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>                initialPathLossExponent, listener);
        internalSetQualityScores(qualityScores);
    }

    /**
     * Returns threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value, the
     * algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algorithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @return stop threshold to stop the algorithm prematurely when a certain
     * accuracy has been reached.
     */
    public double getStopThreshold() {
        return mStopThreshold;
    }

    /**
     * Sets threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value,
     * the algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algorithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @param stopThreshold stop threshold to stop the algorithm prematurely
     *                      when a certain accuracy has been reached.
     * @throws IllegalArgumentException if provided value is zero or negative.
     * @throws LockedException if this solver is locked.
     */
    public void setStopThreshold(double stopThreshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (stopThreshold &lt;= MIN_STOP_THRESHOLD) {
            throw new IllegalArgumentException();
        }

        mStopThreshold = stopThreshold;
    }

    /**
     * Returns quality scores corresponding to each pair of
     * positions and distances (i.e. sample).
     * The larger the score value the better the quality of the sample.
     * This implementation always returns null.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @return quality scores corresponding to each sample.
     */
    @Override
    public double[] getQualityScores() {
        return mQualityScores;
    }

    /**
     * Sets quality scores corresponding to each pair of positions and
     * distances (i.e. sample).
     * The larger the score value the better the quality of the sample.
     * This implementation makes no action.
     * Subclasses using quality scores must implement proper behaviour.
     *
     * @param qualityScores quality scores corresponding to each pair of
     *                      matched points.
     * @throws IllegalArgumentException if provided quality scores length
     * is smaller than minimum required samples.
     * @throws LockedException if robust solver is locked because an
     * estimation is already in progress.
     */
    public void setQualityScores(double[] qualityScores) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetQualityScores(qualityScores);
    }

    /**
     * Indicates whether solver is ready to find a solution.
     *
     * @return true if solver is ready, false otherwise.
     */
    @Override
    public boolean isReady() {
        return super.isReady() &amp;&amp; mQualityScores != null &amp;&amp;
                mQualityScores.length == mReadings.size();
    }

    /**
     * Robustly estimates position, transmitted power and pathloss exponent for a
     * radio source.
     *
     * @throws LockedException if instance is busy during estimation.
     * @throws NotReadyException if estimator is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     * (i.e. numerical instability, no solution available, etc).
     */
    @Override
    public void estimate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        PROMedSRobustEstimator&lt;Solution&lt;Point3D&gt;&gt; innerEstimator =
                new PROMedSRobustEstimator&lt;&gt;(
                        new PROMedSRobustEstimatorListener&lt;Solution&lt;Point3D&gt;&gt;() {

                            @Override
                            public double[] getQualityScores() {
                                return mQualityScores;
                            }

                            @Override
                            public double getThreshold() {
                                return mStopThreshold;
                            }

                            @Override
                            public int getTotalSamples() {
                                return mReadings.size();
                            }

                            @Override
                            public int getSubsetSize() {
                                return Math.max(mPreliminarySubsetSize, getMinReadings());
                            }

                            @Override
                            public void estimatePreliminarSolutions(int[] samplesIndices,
                                                                    List&lt;Solution&lt;Point3D&gt;&gt; solutions) {
                                solvePreliminarSolutions(samplesIndices, solutions);
                            }

                            @Override
                            public double computeResidual(Solution&lt;Point3D&gt; currentEstimation, int i) {
                                return residual(currentEstimation, i);
                            }

                            @Override
                            public boolean isReady() {
                                return PROMedSRobustRangingAndRssiRadioSourceEstimator3D.this.isReady();</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator2D.html#L394">394</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator2D.html#L405">405</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>            RobustRangingAndRssiRadioSourceEstimatorListener&lt;S, Point2D&gt; listener) {
        super(readings, initialPosition, initialTransmittedPowerdBm,
                initialPathLossExponent, listener);
    }

    /**
     * Gets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on received power (RSSI) expressed
     * in dBm's between received value that should have been received on estimated
     * isotropical model and actual measured value.
     *
     * @return threshold to determine whether samples are inliers or not.
     */
    public double getThreshold() {
        return mThreshold;
    }

    /**
     * Sets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on received power (RSSI) expressed
     * in dBm's between received value that should have been received on estimated
     * isotropical model and actual measured value.
     *
     * @param threshold threshold to determine whether samples are inliers or not.
     * @throws IllegalArgumentException if provided value is equal or less than zero.
     * @throws LockedException if this estimator is locked.
     */
    public void setThreshold(double threshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (threshold &lt;= MIN_THRESHOLD) {
            throw new IllegalArgumentException();
        }
        mThreshold = threshold;
    }


    /**
     * Indicates whether inliers must be computed and kept.
     *
     * @return true if inliers must be computed and kept, false if inliers
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepInliersEnabled() {
        return mComputeAndKeepInliers;
    }

    /**
     * Specifies whether inliers must be computed and kept.
     *
     * @param computeAndKeepInliers true if inliers must be computed and kept,
     *                              false if inliers only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepInliersEnabled(boolean computeAndKeepInliers)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mComputeAndKeepInliers = computeAndKeepInliers;
    }

    /**
     * Indicates whether residuals must be computed and kept.
     *
     * @return true if residuals must be computed and kept, false if residuals
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepResidualsEnabled() {
        return mComputeAndKeepResiduals;
    }

    /**
     * Specifies whether residuals must be computed and kept.
     *
     * @param computeAndKeepResiduals true if residuals must be computed and kept,
     *                                false if residuals only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepResidualsEnabled(boolean computeAndKeepResiduals)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mComputeAndKeepResiduals = computeAndKeepResiduals;
    }

    /**
     * Robustly estimates position, transmitted power and pathloss exponent for a
     * radio source.
     *
     * @throws LockedException if instance is busy during estimation.
     * @throws NotReadyException if estimator is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     * (i.e. numerical instability, no solution available, etc).
     */
    @Override
    public void estimate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        RANSACRobustEstimator&lt;Solution&lt;Point2D&gt;&gt; innerEstimator =
                new RANSACRobustEstimator&lt;&gt;(
                        new RANSACRobustEstimatorListener&lt;Solution&lt;Point2D&gt;&gt;() {
                    @Override
                    public double getThreshold() {
                        return mThreshold;
                    }

                    @Override
                    public int getTotalSamples() {
                        return mReadings.size();
                    }

                    @Override
                    public int getSubsetSize() {
                        return Math.max(mPreliminarySubsetSize, getMinReadings());
                    }

                    @Override
                    public void estimatePreliminarSolutions(int[] samplesIndices,
                            List&lt;Solution&lt;Point2D&gt;&gt; solutions) {
                        solvePreliminarSolutions(samplesIndices, solutions);
                    }

                    @Override
                    public double computeResidual(Solution&lt;Point2D&gt; currentEstimation, int i) {
                        return residual(currentEstimation, i);
                    }

                    @Override
                    public boolean isReady() {
                        return RANSACRobustRangingAndRssiRadioSourceEstimator2D.this.isReady();</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator3D.html#L394">394</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator3D.html#L405">405</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>            RobustRangingAndRssiRadioSourceEstimatorListener&lt;S, Point3D&gt; listener) {
        super(readings, initialPosition, initialTransmittedPowerdBm,
                initialPathLossExponent, listener);
    }

    /**
     * Gets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on received power (RSSI) expressed
     * in dBm's between received value that should have been received on estimated
     * isotropical model and actual measured value.
     *
     * @return threshold to determine whether samples are inliers or not.
     */
    public double getThreshold() {
        return mThreshold;
    }

    /**
     * Sets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on received power (RSSI) expressed
     * in dBm's between received value that should have been received on estimated
     * isotropical model and actual measured value.
     *
     * @param threshold threshold to determine whether samples are inliers or not.
     * @throws IllegalArgumentException if provided value is equal or less than zero.
     * @throws LockedException if this estimator is locked.
     */
    public void setThreshold(double threshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (threshold &lt;= MIN_THRESHOLD) {
            throw new IllegalArgumentException();
        }
        mThreshold = threshold;
    }


    /**
     * Indicates whether inliers must be computed and kept.
     *
     * @return true if inliers must be computed and kept, false if inliers
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepInliersEnabled() {
        return mComputeAndKeepInliers;
    }

    /**
     * Specifies whether inliers must be computed and kept.
     *
     * @param computeAndKeepInliers true if inliers must be computed and kept,
     *                              false if inliers only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepInliersEnabled(boolean computeAndKeepInliers)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mComputeAndKeepInliers = computeAndKeepInliers;
    }

    /**
     * Indicates whether residuals must be computed and kept.
     *
     * @return true if residuals must be computed and kept, false if residuals
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepResidualsEnabled() {
        return mComputeAndKeepResiduals;
    }

    /**
     * Specifies whether residuals must be computed and kept.
     *
     * @param computeAndKeepResiduals true if residuals must be computed and kept,
     *                                false if residuals only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepResidualsEnabled(boolean computeAndKeepResiduals)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mComputeAndKeepResiduals = computeAndKeepResiduals;
    }

    /**
     * Robustly estimates position, transmitted power and pathloss exponent for a
     * radio source.
     *
     * @throws LockedException if instance is busy during estimation.
     * @throws NotReadyException if estimator is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     * (i.e. numerical instability, no solution available, etc).
     */
    @Override
    public void estimate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        RANSACRobustEstimator&lt;Solution&lt;Point3D&gt;&gt; innerEstimator =
                new RANSACRobustEstimator&lt;&gt;(
                        new RANSACRobustEstimatorListener&lt;Solution&lt;Point3D&gt;&gt;() {
                            @Override
                            public double getThreshold() {
                                return mThreshold;
                            }

                            @Override
                            public int getTotalSamples() {
                                return mReadings.size();
                            }

                            @Override
                            public int getSubsetSize() {
                                return Math.max(mPreliminarySubsetSize, getMinReadings());
                            }

                            @Override
                            public void estimatePreliminarSolutions(int[] samplesIndices,
                                                                    List&lt;Solution&lt;Point3D&gt;&gt; solutions) {
                                solvePreliminarSolutions(samplesIndices, solutions);
                            }

                            @Override
                            public double computeResidual(Solution&lt;Point3D&gt; currentEstimation, int i) {
                                return residual(currentEstimation, i);
                            }

                            @Override
                            public boolean isReady() {
                                return RANSACRobustRangingAndRssiRadioSourceEstimator3D.this.isReady();</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/RadioSourceKNearestFinder.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/RadioSourceKNearestFinder.html#L41">41</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/RadioSourceNoMeanKNearestFinder.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/RadioSourceNoMeanKNearestFinder.html#L45">45</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    public RadioSourceKNearestFinder(Collection&lt;? extends RssiFingerprintLocated&lt;S, RssiReading&lt;S&gt;, P&gt;&gt; fingerprints) {
        if (fingerprints == null) {
            throw new IllegalArgumentException();
        }
        mFingerprints = fingerprints;
    }

    /**
     * Finds nearest fingerprint to provided one, in terms of signal euclidean distances, within the collection of
     * provided fingerprints.
     * @param fingerprint fingerprint to find the nearest to.
     * @return nearest fingerprint or null if none could be found.
     */
    public RssiFingerprintLocated&lt;S, RssiReading&lt;S&gt;, P&gt; findNearestTo(RssiFingerprint&lt;S, RssiReading&lt;S&gt;&gt; fingerprint) {
        return findNearestTo(fingerprint, mFingerprints);
    }

    /**
     * Finds k-nearest fingerprints to provided one, in terms of signal euclidean distances, within the collection
     * of provided fingerprints.
     * @param fingerprint fingerprint to find the k-nearest ones to.
     * @param k number of nearest fingerprints to find.
     * @return nearest fingerprints ordered from closest to farthest or an empty list if none could be found.
     * @throws IllegalArgumentException if either fingerprint is null or k is les than 1.
     */
    public List&lt;RssiFingerprintLocated&lt;S, RssiReading&lt;S&gt;, P&gt;&gt; findKNearestTo(
            RssiFingerprint&lt;S, RssiReading&lt;S&gt;&gt; fingerprint, int k) {
        return findKNearestTo(fingerprint, mFingerprints, k);
    }

    /**
     * Finds k-nearest fingerprints to provided one, in terms of signal euclidean distances, within the collection
     * of provided fingerprints.
     * @param fingerprint fingerprint to find the k-nearest ones to.
     * @param k number of nearest fingerprints to find.
     * @param nearestFingerprints list where found nearest fingerprints will be stored ordered from closest to farthest
     *                            or an empty list if none could be found.
     * @param nearestSqrDistances list where squared signal euclidean distances corresponding to found fingerprints will
     *                            be stored or an empty list if no fingerprint is found.
     * @throws IllegalArgumentException if any parameter is null or k is less than 1.
     */
    public void findKNearestTo(RssiFingerprint&lt;S, RssiReading&lt;S&gt;&gt; fingerprint, int k,
            List&lt;RssiFingerprintLocated&lt;S, RssiReading&lt;S&gt;, P&gt;&gt; nearestFingerprints,
            List&lt;Double&gt; nearestSqrDistances) {
        findKNearestTo(fingerprint, mFingerprints, k, nearestFingerprints, nearestSqrDistances);
    }

    /**
     * Gets collection of fingerprints to match against.
     * @return collection of fingerprints to match against.
     */
    public Collection&lt;? extends RssiFingerprintLocated&lt;S, RssiReading&lt;S&gt;, P&gt;&gt; getFingerprints() {
        return mFingerprints;
    }

    /**
     * Finds nearest fingerprint to provided one, in terms of signal euclidean distances, within the collection of
     * provided fingerprints.
     * @param fingerprint fingerprint to find the nearest to.
     * @param fingerprints collection of fingerprints to make the search for the nearest one.
     * @return nearest fingerprint or null if none could be found.
     * @throws IllegalArgumentException if either fingerprint or collection of fingerprints is null.
     * @param &lt;P&gt; a {@link Point} type.
     * @param &lt;S&gt; a {@link RadioSource} type.
     */
    @SuppressWarnings(&quot;Duplicates&quot;)
    public static &lt;P extends Point, S extends RadioSource&gt; RssiFingerprintLocated&lt;S, RssiReading&lt;S&gt;, P&gt;
            findNearestTo(RssiFingerprint&lt;S, RssiReading&lt;S&gt;&gt; fingerprint,
            Collection&lt;? extends RssiFingerprintLocated&lt;S, RssiReading&lt;S&gt;, P&gt;&gt; fingerprints) {
        if (fingerprint == null || fingerprints == null) {
            throw new IllegalArgumentException();
        }

        double bestSqrDist = Double.MAX_VALUE;
        RssiFingerprintLocated&lt;S, RssiReading&lt;S&gt;, P&gt; result = null;
        for(RssiFingerprintLocated&lt;S, RssiReading&lt;S&gt;, P&gt; f : fingerprints) {
            double sqrDist = f.sqrDistanceTo(fingerprint);</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/Utils.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/Utils.html#L251">251</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/Utils.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/Utils.html#L786">786</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/Utils.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/Utils.html#L1949">1949</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public static MultivariateNormalDist propagateVariancesToRssiVarianceFirstOrderNonLinear2D(
            final double fingerprintRssi, final double pathLossExponent,
            Point2D fingerprintPosition, Point2D radioSourcePosition,
            Point2D estimatedPosition,
            Double fingerprintRssiVariance,
            Double pathLossExponentVariance,
            Matrix fingerprintPositionCovariance,
            Matrix radioSourcePositionCovariance,
            Matrix estimatedPositionCovariance) throws IndoorException {

        if (fingerprintPosition == null || radioSourcePosition == null ||
                estimatedPosition == null) {
            return null;
        }

        //1st order Taylor expression of received power in 2D:
        //Pr(pi) = Pr(p1)
        //  - 10*n*(x1 - xa)/(ln(10)*d1a^2)*(xi - x1)
        //  - 10*n*(y1 - ya)/(ln(10)*d1a^2)*(yi - y1)
        //where d1a^2 = (x1 - xa)^2 + (y1 - ya)^2

        final double x1 = fingerprintPosition.getInhomX();
        final double y1 = fingerprintPosition.getInhomY();

        final double xa = radioSourcePosition.getInhomX();
        final double ya = radioSourcePosition.getInhomY();

        final double xi = estimatedPosition.getInhomX();
        final double yi = estimatedPosition.getInhomY();

        double[] mean = new double[] {
                fingerprintRssi, pathLossExponent, x1, y1, xa, ya, xi, yi
        };
        Matrix covariance = Matrix.diagonal(new double[]{
                fingerprintRssiVariance != null ? fingerprintRssiVariance : 0.0,
                pathLossExponentVariance != null ? pathLossExponentVariance : 0.0,
                0.0, 0.0, 0.0, 0.0, 0.0, 0.0
        });

        if (fingerprintPositionCovariance != null &amp;&amp;
                fingerprintPositionCovariance.getRows() == Point2D.POINT2D_INHOMOGENEOUS_COORDINATES_LENGTH &amp;&amp;
                fingerprintPositionCovariance.getColumns() == Point2D.POINT2D_INHOMOGENEOUS_COORDINATES_LENGTH) {

            covariance.setSubmatrix(2, 2,
                    3, 3,
                    fingerprintPositionCovariance);
        }

        if (radioSourcePositionCovariance != null &amp;&amp;
                radioSourcePositionCovariance.getRows() == Point2D.POINT2D_INHOMOGENEOUS_COORDINATES_LENGTH &amp;&amp;
                radioSourcePositionCovariance.getColumns() == Point2D.POINT2D_INHOMOGENEOUS_COORDINATES_LENGTH) {
            covariance.setSubmatrix(4, 4,
                    5, 5,
                    radioSourcePositionCovariance);
        }

        if (estimatedPositionCovariance != null &amp;&amp;
                estimatedPositionCovariance.getRows() == Point2D.POINT2D_INHOMOGENEOUS_COORDINATES_LENGTH &amp;&amp;
                estimatedPositionCovariance.getColumns() == Point2D.POINT2D_INHOMOGENEOUS_COORDINATES_LENGTH) {
            covariance.setSubmatrix(6, 6,
                    7, 7,
                    estimatedPositionCovariance);
        }

        try {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator2D.html#L396">396</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator2D.html#L173">173</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator2D.html#L407">407</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>                initialPathLossExponent, listener);
    }

    /**
     * Gets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on received power (RSSI) expressed
     * in dBm's between received value that should have been received on estimated
     * isotropical model and actual measured value.
     *
     * @return threshold to determine whether samples are inliers or not.
     */
    public double getThreshold() {
        return mThreshold;
    }

    /**
     * Sets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on received power (RSSI) expressed
     * in dBm's between received value that should have been received on estimated
     * isotropical model and actual measured value.
     *
     * @param threshold threshold to determine whether samples are inliers or not.
     * @throws IllegalArgumentException if provided value is equal or less than zero.
     * @throws LockedException if this estimator is locked.
     */
    public void setThreshold(double threshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (threshold &lt;= MIN_THRESHOLD) {
            throw new IllegalArgumentException();
        }
        mThreshold = threshold;
    }


    /**
     * Indicates whether inliers must be computed and kept.
     *
     * @return true if inliers must be computed and kept, false if inliers
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepInliersEnabled() {
        return mComputeAndKeepInliers;
    }

    /**
     * Specifies whether inliers must be computed and kept.
     *
     * @param computeAndKeepInliers true if inliers must be computed and kept,
     *                              false if inliers only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepInliersEnabled(boolean computeAndKeepInliers)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mComputeAndKeepInliers = computeAndKeepInliers;
    }

    /**
     * Indicates whether residuals must be computed and kept.
     *
     * @return true if residuals must be computed and kept, false if residuals
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepResidualsEnabled() {
        return mComputeAndKeepResiduals;
    }

    /**
     * Specifies whether residuals must be computed and kept.
     *
     * @param computeAndKeepResiduals true if residuals must be computed and kept,
     *                                false if residuals only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepResidualsEnabled(boolean computeAndKeepResiduals)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mComputeAndKeepResiduals = computeAndKeepResiduals;
    }

    /**
     * Robustly estimates position, transmitted power and pathloss exponent for a
     * radio source.
     *
     * @throws LockedException if instance is busy during estimation.
     * @throws NotReadyException if estimator is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     * (i.e. numerical instability, no solution available, etc).
     */
    @Override
    public void estimate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        RANSACRobustEstimator&lt;Solution&lt;Point2D&gt;&gt; innerEstimator =
                new RANSACRobustEstimator&lt;&gt;(
                        new RANSACRobustEstimatorListener&lt;Solution&lt;Point2D&gt;&gt;() {
                    @Override
                    public double getThreshold() {
                        return mThreshold;
                    }

                    @Override
                    public int getTotalSamples() {
                        return mReadings.size();
                    }

                    @Override
                    public int getSubsetSize() {
                        return Math.max(mPreliminarySubsetSize, getMinReadings());
                    }

                    @Override
                    public void estimatePreliminarSolutions(int[] samplesIndices,
                            List&lt;Solution&lt;Point2D&gt;&gt; solutions) {
                        solvePreliminarSolutions(samplesIndices, solutions);
                    }

                    @Override
                    public double computeResidual(Solution&lt;Point2D&gt; currentEstimation, int i) {
                        return residual(currentEstimation, i);
                    }

                    @Override
                    public boolean isReady() {
                        return RANSACRobustRangingAndRssiRadioSourceEstimator2D.this.isReady();</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator3D.html#L396">396</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator3D.html#L173">173</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator3D.html#L407">407</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                initialPathLossExponent, listener);
    }

    /**
     * Gets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on received power (RSSI) expressed
     * in dBm's between received value that should have been received on estimated
     * isotropical model and actual measured value.
     *
     * @return threshold to determine whether samples are inliers or not.
     */
    public double getThreshold() {
        return mThreshold;
    }

    /**
     * Sets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on received power (RSSI) expressed
     * in dBm's between received value that should have been received on estimated
     * isotropical model and actual measured value.
     *
     * @param threshold threshold to determine whether samples are inliers or not.
     * @throws IllegalArgumentException if provided value is equal or less than zero.
     * @throws LockedException if this estimator is locked.
     */
    public void setThreshold(double threshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (threshold &lt;= MIN_THRESHOLD) {
            throw new IllegalArgumentException();
        }
        mThreshold = threshold;
    }


    /**
     * Indicates whether inliers must be computed and kept.
     *
     * @return true if inliers must be computed and kept, false if inliers
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepInliersEnabled() {
        return mComputeAndKeepInliers;
    }

    /**
     * Specifies whether inliers must be computed and kept.
     *
     * @param computeAndKeepInliers true if inliers must be computed and kept,
     *                              false if inliers only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepInliersEnabled(boolean computeAndKeepInliers)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mComputeAndKeepInliers = computeAndKeepInliers;
    }

    /**
     * Indicates whether residuals must be computed and kept.
     *
     * @return true if residuals must be computed and kept, false if residuals
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepResidualsEnabled() {
        return mComputeAndKeepResiduals;
    }

    /**
     * Specifies whether residuals must be computed and kept.
     *
     * @param computeAndKeepResiduals true if residuals must be computed and kept,
     *                                false if residuals only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepResidualsEnabled(boolean computeAndKeepResiduals)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mComputeAndKeepResiduals = computeAndKeepResiduals;
    }

    /**
     * Robustly estimates position, transmitted power and pathloss exponent for a
     * radio source.
     *
     * @throws LockedException if instance is busy during estimation.
     * @throws NotReadyException if estimator is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     * (i.e. numerical instability, no solution available, etc).
     */
    @Override
    public void estimate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        RANSACRobustEstimator&lt;Solution&lt;Point3D&gt;&gt; innerEstimator =
                new RANSACRobustEstimator&lt;&gt;(
                        new RANSACRobustEstimatorListener&lt;Solution&lt;Point3D&gt;&gt;() {
                            @Override
                            public double getThreshold() {
                                return mThreshold;
                            }

                            @Override
                            public int getTotalSamples() {
                                return mReadings.size();
                            }

                            @Override
                            public int getSubsetSize() {
                                return Math.max(mPreliminarySubsetSize, getMinReadings());
                            }

                            @Override
                            public void estimatePreliminarSolutions(int[] samplesIndices,
                                                                    List&lt;Solution&lt;Point3D&gt;&gt; solutions) {
                                solvePreliminarSolutions(samplesIndices, solutions);
                            }

                            @Override
                            public double computeResidual(Solution&lt;Point3D&gt; currentEstimation, int i) {
                                return residual(currentEstimation, i);
                            }

                            @Override
                            public boolean isReady() {
                                return RANSACRobustRangingAndRssiRadioSourceEstimator3D.this.isReady();</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator.html#L446">446</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustMixedRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustMixedRadioSourceEstimator.html#L1597">1597</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator.html#L1580">1580</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    }

    /**
     * Gets initial transmitted power to start the estimation of radio source
     * transmitted power (expressed in dBm's).
     * If not defined, average value of received power readings will be used.
     * @return initial transmitted power to start the estimation of radio source
     * transmitted power.
     */
    public Double getInitialTransmittedPowerdBm() {
        return mInitialTransmittedPowerdBm;
    }

    /**
     * Sets initial transmitted power to start the estimation of radio source
     * transmitted power (expressed in dBm's).
     * If not defined, average value of received power readings will be used.
     * @param initialTransmittedPowerdBm initial transmitted power to start the
     *                                   estimation of radio source transmitted
     *                                   power.
     * @throws LockedException if estimator is locked.
     */
    public void setInitialTransmittedPowerdBm(Double initialTransmittedPowerdBm)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mInitialTransmittedPowerdBm = initialTransmittedPowerdBm;
    }

    /**
     * Gets initial transmitted power to start the estimation of radio source
     * transmitted power (expressed in mW).
     * If not defined, average value of received power readings will be used.
     * @return initial transmitted power to start the estimation of radio source
     * transmitted power.
     */
    public Double getInitialTransmittedPower() {
        return mInitialTransmittedPowerdBm != null ?
                Utils.dBmToPower(mInitialTransmittedPowerdBm) : null;
    }

    /**
     * Sets initial transmitted power to start the estimation of radio source
     * transmitted power (expressed in mW).
     * If not defined, average value of received power readings will be used.
     * @param initialTransmittedPower initial transmitted power to start the
     *                                estimation of radio source transmitted power.
     * @throws LockedException if estimator is locked.
     * @throws IllegalArgumentException if provided value is negative.
     */
    public void setInitialTransmittedPower(Double initialTransmittedPower)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (initialTransmittedPower != null) {
            if (initialTransmittedPower &lt; 0.0) {
                throw new IllegalArgumentException();
            }
            mInitialTransmittedPowerdBm = Utils.powerTodBm(
                    initialTransmittedPower);
        } else {
            mInitialTransmittedPowerdBm = null;
        }
    }

    /**
     * Gets initial position to start the estimation of radio source position.
     * If not defined, centroid of provided fingerprints will be used.
     * @return initial position to start the estimation of radio source position.
     */
    public P getInitialPosition() {
        return mInitialPosition;
    }

    /**
     * Sets initial position to start the estimation of radio source position.
     * If not defined, centroid of provided fingerprints will be used.
     * @param initialPosition initial position to start the estimation of radio
     *                        source position.
     * @throws LockedException if estimator is locked.
     */
    public void setInitialPosition(P initialPosition) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mInitialPosition = initialPosition;
    }

    /**
     * Gets initial exponent typically used on free space for path loss propagation
     * in terms of distance.
     * On different environments path loss exponent might have different value:
     * - Free space: 2.0
     * - Urban Area: 2.7 to 3.5
     * - Suburban Area: 3 to 5
     * - Indoor (line-of-sight): 1.6 to 1.8
     *
     * If path loss exponent estimation is enabled, estimation will start at this
     * value and will converge to the most appropriate value.
     * If path loss exponent estimation is disabled, this value will be assumed
     * to be exact and the estimated path loss exponent will be equal to this
     * value.
     * @return initial path loss exponent.
     */
    public double getInitialPathLossExponent() {
        return mInitialPathLossExponent;
    }

    /**
     * Sets initial exponent typically used on free space for path loss propagation
     * in terms of distance.
     * On different environments path loss exponent might have different value:
     * - Free space: 2.0
     * - Urban Area: 2.7 to 3.5
     * - Suburban Area: 3 to 5
     * - Indoor (line-of-sight): 1.6 to 1.8
     *
     * If path loss exponent estimation is enabled, estimation will start at this
     * value and will converge to the most appropriate value.
     * If path loss exponent estimation is disabled, this value will be assumed
     * to be exact and the estimated path loss exponent will be equal to this
     * value.
     * @param initialPathLossExponent initial path loss exponent.
     * @throws LockedException if estimator is locked.
     */
    public void setInitialPathLossExponent(double initialPathLossExponent)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mInitialPathLossExponent = initialPathLossExponent;
    }

    /**
     * Indicates whether transmitted power estimation is enabled or not.
     * @return true if transmitted power estimation is enabled, false otherwise.
     */
    public boolean isTransmittedPowerEstimationEnabled() {
        return mTransmittedPowerEstimationEnabled;
    }

    /**
     * Specifies whether transmitted power estimation is enabled or not.
     * @param transmittedPowerEstimationEnabled true if transmitted power estimation is enabled,
     *                                          false otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setTransmittedPowerEstimationEnabled(boolean transmittedPowerEstimationEnabled)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mTransmittedPowerEstimationEnabled = transmittedPowerEstimationEnabled;
    }

    /**
     * Indicates whether path loss estimation is enabled or not.
     * @return true if path loss estimation is enabled, false otherwise.
     */
    public boolean isPathLossEstimationEnabled() {
        return mPathLossEstimationEnabled;
    }

    /**
     * Specifies whether path loss estimation is enabled or not.
     * @param pathLossEstimationEnabled true if path loss estimation is enabled,
     *                                  false otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setPathLossEstimationEnabled(boolean pathLossEstimationEnabled)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mPathLossEstimationEnabled = pathLossEstimationEnabled;
    }

    /**
     * Indicates whether position covariances of readings must be taken into account to increase
     * the amount of standard deviation of each ranging measure by the amount of position standard
     * deviation assuming that both measures are statistically independent.
     * @return true to take into account reading position covariances, false otherwise.
     */
    public boolean getUseReadingPositionCovariance() {
        return mUseReadingPositionCovariances;
    }

    /**
     * Specifies whether position covariances of readings must be taken into account to increase
     * the amount of standard deviation of each ranging measure by the amount of position standard
     * deviation assuming that both measures are statistically independent.
     * @param useReadingPositionCovariances true to take into account reading position covariances, false
     *                                      otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setUseReadingPositionCovariances(boolean useReadingPositionCovariances)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mUseReadingPositionCovariances = useReadingPositionCovariances;
    }

    /**
     * Indicates whether an homogeneous linear solver is used to estimate an initial
     * position for the internal ranging radio source estimator.
     * @return true if homogeneous linear solver is used, false if an inhomogeneous linear
     * one is used instead.
     */
    public abstract boolean isHomogeneousRangingLinearSolverUsed();</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/lateration/HomogeneousLinearLeastSquaresLateration2DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/HomogeneousLinearLeastSquaresLateration2DSolver.html#L85">85</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/lateration/InhomogeneousLinearLeastSquaresLateration2DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/InhomogeneousLinearLeastSquaresLateration2DSolver.html#L85">85</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    public HomogeneousLinearLeastSquaresLateration2DSolver(Circle[] circles,
                                                           LaterationSolverListener&lt;Point2D&gt; listener) {
        super(listener);
        internalSetCircles(circles);
    }

    /**
     * Gets circles defined by provided positions and distances.
     * @return circles defined by provided positions and distances.
     */
    public Circle[] getCircles() {
        if (mPositions == null) {
            return null;
        }

        Circle[] result = new Circle[mPositions.length];

        for (int i = 0; i &lt; mPositions.length; i++) {
            result[i] = new Circle(mPositions[i], mDistances[i]);
        }
        return result;
    }

    /**
     * Sets circles defining positions and euclidean distances.
     * @param circles circles defining positions and distances.
     * @throws IllegalArgumentException if circles is null or length of array of circles
     * is less than 2.
     * @throws LockedException if instance is busy solving the lateration problem.
     */
    public void setCircles(Circle[] circles) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetCircles(circles);
    }

    /**
     * Gets number of dimensions of provided points.
     * @return always returns 2 dimensions.
     */
    @Override
    public int getNumberOfDimensions() {
        return Point2D.POINT2D_INHOMOGENEOUS_COORDINATES_LENGTH;
    }

    /**
     * Minimum required number of positions and distances.
     * At least 3 positions and distances will be required to linearly solve a 2D problem.
     * @return minimum required number of positions and distances.
     */
    @Override
    public int getMinRequiredPositionsAndDistances() {
        return Point2D.POINT2D_INHOMOGENEOUS_COORDINATES_LENGTH + 1;
    }

    /**
     * Gets estimated position.
     * @return estimated position.
     */
    @Override
    public Point2D getEstimatedPosition() {
        if (mEstimatedPositionCoordinates == null) {
            return null;
        }

        InhomogeneousPoint2D position = new InhomogeneousPoint2D();
        getEstimatedPosition(position);
        return position;
    }

    /**
     * Internally sets circles defining positions and euclidean distances.
     * @param circles circles defining positions and distances.
     * @throws IllegalArgumentException if circles is null or length of array of circles
     * is less than 3.
     */
    private void internalSetCircles(Circle[] circles) {
        if (circles == null || circles.length &lt; getMinRequiredPositionsAndDistances()) {
            throw new IllegalArgumentException();
        }

        Point2D[] positions = new Point2D[circles.length];
        double[] distances = new double[circles.length];
        for (int i = 0; i &lt; circles.length; i++) {
            Circle circle = circles[i];
            positions[i] = circle.getCenter();
            distances[i] = circle.getRadius();
        }

        internalSetPositionsAndDistances(positions, distances);
    }
}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/lateration/HomogeneousLinearLeastSquaresLateration3DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/HomogeneousLinearLeastSquaresLateration3DSolver.html#L85">85</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/lateration/InhomogeneousLinearLeastSquaresLateration3DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/InhomogeneousLinearLeastSquaresLateration3DSolver.html#L85">85</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    public HomogeneousLinearLeastSquaresLateration3DSolver(Sphere[] spheres,
                                                           LaterationSolverListener&lt;Point3D&gt; listener) {
        super(listener);
        internalSetSpheres(spheres);
    }

    /**
     * Gets spheres defined by provided positions and distances.
     * @return spheres defined by provided positions and distances.
     */
    public Sphere[] getSpheres() {
        if (mPositions == null) {
            return null;
        }

        Sphere[] result = new Sphere[mPositions.length];

        for (int i = 0; i &lt; mPositions.length; i++) {
            result[i] = new Sphere(mPositions[i], mDistances[i]);
        }
        return result;
    }

    /**
     * Sets spheres defining positions and euclidean distances.
     * @param spheres spheres defining positions and distances.
     * @throws IllegalArgumentException if spheres is null or length of array of spheres
     * is less than 2.
     * @throws LockedException if instance is busy solving the lateration problem.
     */
    public void setSpheres(Sphere[] spheres) throws LockedException {
        if(isLocked()) {
            throw new LockedException();
        }
        internalSetSpheres(spheres);
    }

    /**
     * Gets number of dimensions of provided points.
     * @return always returns 2 dimensions.
     */
    @Override
    public int getNumberOfDimensions() {
        return Point3D.POINT3D_INHOMOGENEOUS_COORDINATES_LENGTH;
    }

    /**
     * Minimum required number of positions and distances.
     * At least 4 positions and distances will be required to linearly solve a 3D problem.
     * @return minimum required number of positions and distances.
     */
    @Override
    public int getMinRequiredPositionsAndDistances() {
        return Point3D.POINT3D_INHOMOGENEOUS_COORDINATES_LENGTH + 1;
    }

    /**
     * Gets estimated position.
     * @return estimated position.
     */
    @Override
    public Point3D getEstimatedPosition() {
        if (mEstimatedPositionCoordinates == null) {
            return null;
        }

        InhomogeneousPoint3D position = new InhomogeneousPoint3D();
        getEstimatedPosition(position);
        return position;
    }

    /**
     * Internally sets spheres defining positions and euclidean distances.
     * @param spheres spheres defining positions and distances.
     * @throws IllegalArgumentException if spheres is null or length of array of spheres
     * is less than 4.
     */
    private void internalSetSpheres(Sphere[] spheres) {
        if (spheres == null || spheres.length &lt; getMinRequiredPositionsAndDistances()) {
            throw new IllegalArgumentException();
        }

        Point3D[] positions = new Point3D[spheres.length];
        double[] distances = new double[spheres.length];
        for (int i = 0; i &lt; spheres.length; i++) {
            Sphere sphere = spheres[i];
            positions[i] = sphere.getCenter();
            distances[i] = sphere.getRadius();
        }

        internalSetPositionsAndDistances(positions, distances);
    }
}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/LinearMixedPositionEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/LinearMixedPositionEstimator.html#L79">79</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/LinearRangingAndRssiPositionEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/LinearRangingAndRssiPositionEstimator.html#L80">80</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/LinearRangingPositionEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/LinearRangingPositionEstimator.html#L79">79</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/LinearRssiPositionEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/LinearRssiPositionEstimator.html#L82">82</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    public LinearMixedPositionEstimator(MixedPositionEstimatorListener&lt;P&gt; listener) {
        super(listener);
        init();
    }

    /**
     * Indicates whether an homogeneous linear solver is used to estimate position.
     *
     * @return  true if homogeneous linear solver is used, false if an inhomogeneous
     *          linear one is used instead.
     */
    public boolean isHomogeneousLinearSolverUsed() {
        return mUseHomogeneousLinearSolver;
    }

    /**
     * Specifies whether an homogeneous linear solver is used to estimate position.
     *
     * @param useHomogeneousLinearSolver true if homogeneous linear solver is used, false
     *                                   if an inhomogeneous linear one is used instead.
     * @throws LockedException if estimator is locked.
     */
    public void setHomogeneousLinearSolverUsed(boolean useHomogeneousLinearSolver)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }

        mUseHomogeneousLinearSolver = useHomogeneousLinearSolver;
    }

    /**
     * Gets minimum required number of located radio sources to perform lateration.
     *
     * @return minimum required number of located radio sources to perform lateration.
     */
    @Override
    public int getMinRequiredSources() {
        return mUseHomogeneousLinearSolver?
                mHomogeneousTrilaterationSolver.getMinRequiredPositionsAndDistances() :
                mInhomogeneousTrilaterationSolver.getMinRequiredPositionsAndDistances();
    }

    /**
     * Indicates whether estimator is ready to find a solution.
     * @return true if estimator is ready, false otherwise.
     */
    @Override
    public boolean isReady() {
        return (!mUseHomogeneousLinearSolver &amp;&amp; mInhomogeneousTrilaterationSolver.isReady()) ||
                (mUseHomogeneousLinearSolver &amp;&amp; mHomogeneousTrilaterationSolver.isReady());
    }

    /**
     * Returns boolean indicating whether this estimator is locked because an estimation is already in progress.
     * @return true if estimator is locked, false otherwise.
     */
    @Override
    public boolean isLocked() {
        return mInhomogeneousTrilaterationSolver.isLocked() ||
                mHomogeneousTrilaterationSolver.isLocked();
    }

    /**
     * Estimates position based on provided located radio sources and RSSI readings of
     * such radio sources at an unknown location.
     * @throws LockedException if estimator is locked.
     * @throws NotReadyException if estimator is not ready.
     * @throws PositionEstimationException if estimation fails for some other reason.
     */
    @SuppressWarnings(&quot;Duplicates&quot;)
    @Override
    public void estimate() throws LockedException, NotReadyException,
            PositionEstimationException {
        try {
            if (mUseHomogeneousLinearSolver) {
                mHomogeneousTrilaterationSolver.solve();
                mEstimatedPositionCoordinates =
                        mHomogeneousTrilaterationSolver.getEstimatedPositionCoordinates();
            } else {
                mInhomogeneousTrilaterationSolver.solve();
                mEstimatedPositionCoordinates =
                        mInhomogeneousTrilaterationSolver.getEstimatedPositionCoordinates();
            }
        } catch (LaterationException e) {
            throw new PositionEstimationException(e);
        }
    }

    /**
     * Gets known positions of radio sources used internally to solve lateration.
     *
     * @return known positions used internally.
     */
    @Override
    public P[] getPositions() {
        return mUseHomogeneousLinearSolver ?
                mHomogeneousTrilaterationSolver.getPositions() :
                mInhomogeneousTrilaterationSolver.getPositions();
    }

    /**
     * Gets euclidean distances from known located radio sources to
     * the location of provided readings in a fingerprint.
     * Distance values are used internally to solve lateration.
     *
     * @return euclidean distances used internally.
     */
    @Override
    public double[] getDistances() {
        return mUseHomogeneousLinearSolver ?
                mHomogeneousTrilaterationSolver.getDistances() :
                mInhomogeneousTrilaterationSolver.getDistances();
    }

    /**
     * Internally sets located radio sources used for lateration.
     *
     * @param sources located radio sources used for lateration.
     * @throws IllegalArgumentException if provided value is null or the number of
     *                                  provided sources is less than the required
     *                                  minimum.
     */
    protected void internalSetSources(List&lt;? extends RadioSourceLocated&lt;P&gt;&gt; sources) {
        super.internalSetSources(sources);
        buildPositionsAndDistances();
    }

    /**
     * Internally sets fingerprint containing readings at an unknown location for provided
     * located radio sources.
     *
     * @param fingerprint fingerprint containing readings at an unknown location for
     *                    provided located radio sources.
     * @throws IllegalArgumentException if provided value is null.
     */
    protected void internalSetFingerprint(
            Fingerprint&lt;? extends RadioSource, ? extends Reading&lt;? extends RadioSource&gt;&gt; fingerprint) {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/SequentialRobustMixedPositionEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/SequentialRobustMixedPositionEstimator.html#L974">974</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/SequentialRobustRangingAndRssiPositionEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/SequentialRobustRangingAndRssiPositionEstimator.html#L947">947</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustMixedRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustMixedRadioSourceEstimator.html#L1326">1326</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator.html#L1309">1309</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    }

    /**
     * Returns amount of confidence expressed as a value between 0.0 and 1.0 (which
     * is equivalent to 100%) for robust position estimation on ranging data. The
     * amount of confidence indicates the probability that the estimated result is
     * correct. Usually this value will be close to 1.0, but not exactly 1.0.
     *
     * @return amount of confidence for robust position estimation as a value between
     * 0.0 and 1.0.
     */
    public double getRangingConfidence() {
        return mRangingConfidence;
    }

    /**
     * Sets amount of confidence expressed as a value between 0.0 and 1.0 (which is
     * equivalent to 100%) for robust position estimation on ranging data. The amount
     * of confidence indicates the probability that the estimated result is correct.
     * Usually this value will be close to 1.0, but not exactly 1.0.
     *
     * @param rangingConfidence confidence to be set for robust position estimation as
     *                          a value between 0.0 and 1.0.
     * @throws IllegalArgumentException if provided value is not between 0.0 and 1.0.
     * @throws LockedException          if estimator is locked.
     */
    public void setRangingConfidence(double rangingConfidence) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (rangingConfidence &lt; MIN_CONFIDENCE || rangingConfidence &gt; MAX_CONFIDENCE) {
            throw new IllegalArgumentException();
        }
        mRangingConfidence = rangingConfidence;
    }

    /**
     * Returns amount of confidence expressed as a value between 0.0 and 1.0 (which is
     * equivalent to 100%) for robust position estimation on RSSI data. The amount of
     * confidence indicates the probability that the estimated result is correct.
     * Usually this value will be close to 1.0, but not exactly 1.0.
     *
     * @return amount of confidence for robust position estimation as a value between
     * 0.0 and 1.0.
     */
    public double getRssiConfidence() {
        return mRssiConfidence;
    }

    /**
     * Sets amount of confidence expressed as a value between 0.0 and 1.0 (which is
     * equivalent to 100%) for robust position estimation on RSSI data. The amount
     * of confidence indicates the probability that the estimated result is correct.
     * Usually this value will be close to 1.0, but not exactly 1.0.
     *
     * @param rssiConfidence    amount of confidence for robust position estimation as
     *                          a value between 0.0 and 1.0.
     * @throws IllegalArgumentException if provided value is not between 0.0 and 1.0.
     * @throws LockedException          if estimator is locked.
     */
    public void setRssiConfidence(double rssiConfidence) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (rssiConfidence &lt; MIN_CONFIDENCE || rssiConfidence &gt; MAX_CONFIDENCE) {
            throw new IllegalArgumentException();
        }
        mRssiConfidence = rssiConfidence;
    }

    /**
     * Gets maximum allowed number of iterations for robust ranging position estimation.
     * When the maximum number of iterations is exceeded, an approximate result might
     * be available for retrieval.
     *
     * @return maximum allowed number of iterations for position estimation.
     */
    public int getRangingMaxIterations() {
        return mRangingMaxIterations;
    }

    /**
     * Sets maximum allowed number of iterations for robust ranging position
     * estimation.
     * When the maximum number of iterations is exceeded, an approximate result might
     * be available for retrieval.
     *
     * @param rangingMaxIterations  maximum allowed number of iterations to be set for
     *                              position estimation.
     * @throws IllegalArgumentException if provided value is less than 1.
     * @throws LockedException          if estimator is locked.
     */
    public void setRangingMaxIterations(int rangingMaxIterations)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (rangingMaxIterations &lt; MIN_ITERATIONS) {
            throw new IllegalArgumentException();
        }
        mRangingMaxIterations = rangingMaxIterations;
    }

    /**
     * Gets maximum allowed number of iterations for robust RSSI position estimation.
     * When the maximum number of iterations is exceeded, an approximate result might
     * be available for retrieval.
     *
     * @return maximum allowed number of iterations for position estimation.
     */
    public int getRssiMaxIterations() {
        return mRssiMaxIterations;
    }

    /**
     * Sets maximum allowed number of iterations for robust RSSI position estimation.
     * When the maximum number of iterations is exceeded, an approximate result might
     * be available for retrieval.
     *
     * @param rssiMaxIterations maximum allowed number of iterations to be set for
     *                          position estimation.
     * @throws IllegalArgumentException if provided value is less than 1.
     * @throws LockedException          if estimator is locked.
     */
    public void setRssiMaxIterations(int rssiMaxIterations) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (rssiMaxIterations &lt; MIN_ITERATIONS) {
            throw new IllegalArgumentException();
        }
        mRssiMaxIterations = rssiMaxIterations;
    }

    /**
     * Indicates whether result is refined using all found inliers.
     *
     * @return true if result is refined, false otherwise.
     */
    public boolean isResultRefined() {
        return mRefineResult;
    }

    /**
     * Specifies whether result is refined using all found inliers.
     *
     * @param refineResult true if result is refined, false otherwise.
     * @throws LockedException if this instance is locked.
     */
    public void setResultRefined(boolean refineResult) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }

        mRefineResult = refineResult;
    }

    /**
     * Indicates whether covariance must be kept after refining result.
     * This setting is only taken into account if result is refined.
     *
     * @return true if covariance must be kept after refining result, false otherwise.
     */
    public boolean isCovarianceKept() {
        return mKeepCovariance;
    }

    /**
     * Specifies whether covariance must be kept after refining result.
     * This setting is only taken into account if result is refined.
     *
     * @param keepCovariance true if covariance must be kept after refining result,
     *                       false otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setCovarianceKept(boolean keepCovariance) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mKeepCovariance = keepCovariance;
    }

    /**
     * Indicates whether a linear solver is used for preliminary solution estimation
     * using ranging measurements.
     * The result obtained on each preliminary solution might be later refined.
     *
     * @return true if a linear solver is used for preliminary solution estimation on
     * ranging readings.
     */
    public boolean isRangingLinearSolverUsed() {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/RadioSourceKNearestFinder.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/RadioSourceKNearestFinder.html#L117">117</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/RadioSourceNoMeanKNearestFinder.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/RadioSourceNoMeanKNearestFinder.html#L122">122</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>            double sqrDist = f.sqrDistanceTo(fingerprint);
            if (sqrDist &lt; bestSqrDist) {
                bestSqrDist = sqrDist;
                result = f;
            }
        }

        return result;
    }

    /**
     * Finds k-nearest fingerprints to provided one, in terms of signal euclidean distances, within the collection
     * of provided fingerprints.
     * @param fingerprint fingerprint to find the k-nearest ones to.
     * @param fingerprints collection of fingerprints to make the search for the nearest ones.
     * @param k number of nearest fingerprints to find.
     * @return nearest fingerprints ordered from closest to farthest or an empty list if none could be found.
     * @throws IllegalArgumentException if either fingerprint or collection of fingerprints is null, or k is less than
     * 1.
     * @param &lt;P&gt; a {@link Point} type.
     * @param &lt;S&gt; a {@link RadioSource} type.
     */
    public static &lt;P extends Point, S extends RadioSource&gt; List&lt;RssiFingerprintLocated&lt;S, RssiReading&lt;S&gt;, P&gt;&gt;
            findKNearestTo(RssiFingerprint&lt;S, RssiReading&lt;S&gt;&gt; fingerprint,
            Collection&lt;? extends RssiFingerprintLocated&lt;S, RssiReading&lt;S&gt;, P&gt;&gt; fingerprints,
            int k) {

        List&lt;RssiFingerprintLocated&lt;S, RssiReading&lt;S&gt;, P&gt;&gt; result =
                new ArrayList&lt;&gt;();
        List&lt;Double&gt; nearestSqrDistances = new ArrayList&lt;&gt;();
        findKNearestTo(fingerprint, fingerprints, k, result, nearestSqrDistances);

        return result;
    }

    /**
     * Finds k-nearest fingerprints to provided one, in terms of signal euclidean distances, within the collection
     * of provided fingerprints.
     * @param fingerprint fingerprint to find the k-nearest ones to.
     * @param fingerprints collection of fingerprints ot make the search for the nearest ones.
     * @param k number of nearest fingerprints to find.
     * @param nearestFingerprints list where found nearest fingerprints will be stored ordered from closest to farthest
     *                            or an empty list if none could be found.
     * @param nearestSqrDistances list where squared signal euclidean distances corresponding to found fingerprints will
     *                            be stored or an empty list if no fingerprint is found.
     * @throws IllegalArgumentException if any parameter is null or k is less than 1.
     * @param &lt;P&gt; a {@link Point} type.
     * @param &lt;S&gt; a {@link RadioSource} type.
     */
    @SuppressWarnings(&quot;Duplicates&quot;)
    public static &lt;P extends Point, S extends RadioSource&gt; void findKNearestTo(
            RssiFingerprint&lt;S, RssiReading&lt;S&gt;&gt; fingerprint,
            Collection&lt;? extends RssiFingerprintLocated&lt;S, RssiReading&lt;S&gt;, P&gt;&gt; fingerprints,
            int k, List&lt;RssiFingerprintLocated&lt;S, RssiReading&lt;S&gt;, P&gt;&gt; nearestFingerprints,
            List&lt;Double&gt; nearestSqrDistances) {

        if (fingerprint == null || fingerprints == null || k &lt; 1 || nearestFingerprints == null ||
                nearestSqrDistances == null) {
            throw new IllegalArgumentException();
        }

        nearestSqrDistances.clear();
        nearestFingerprints.clear();

        double maxSqrDist = Double.MAX_VALUE;
        for (RssiFingerprintLocated&lt;S, RssiReading&lt;S&gt;, P&gt; f : fingerprints) {
            double sqrDist = f.sqrDistanceTo(fingerprint);</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator2D.html#L2797">2797</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator2D.html#L840">840</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    }

    /**
     * Gets estimated located radio source with estimated transmitted power.
     *
     * @return estimated located radio source with estimated transmitted power or null.
     */
    @Override
    @SuppressWarnings(&quot;unchecked&quot;)
    public RadioSourceWithPowerAndLocated&lt;Point2D&gt; getEstimatedRadioSource() {
        List&lt;? extends RangingAndRssiReadingLocated&lt;S, Point2D&gt;&gt; readings = getReadings();
        if (readings == null || readings.isEmpty()) {
            return null;
        }
        S source = readings.get(0).getSource();

        Point2D estimatedPosition = getEstimatedPosition();
        if (estimatedPosition == null) {
            return null;
        }

        Matrix estimatedPositionCovariance = getEstimatedPositionCovariance();

        Double transmittedPowerVariance =
                getEstimatedTransmittedPowerVariance();
        Double transmittedPowerStandardDeviation = transmittedPowerVariance != null ?
                Math.sqrt(transmittedPowerVariance) : null;

        Double pathlossExponentVariance =
                getEstimatedPathLossExponentVariance();
        Double pathlossExponentStandardDeviation = pathlossExponentVariance != null ?
                Math.sqrt(pathlossExponentVariance) : null;

        if (source instanceof WifiAccessPoint) {
            WifiAccessPoint accessPoint = (WifiAccessPoint) source;
            return new WifiAccessPointWithPowerAndLocated2D(accessPoint.getBssid(),
                    source.getFrequency(), accessPoint.getSsid(),
                    getEstimatedTransmittedPowerdBm(),
                    transmittedPowerStandardDeviation,
                    getEstimatedPathLossExponent(),
                    pathlossExponentStandardDeviation,
                    estimatedPosition,
                    estimatedPositionCovariance);
        } else if(source instanceof Beacon) {
            Beacon beacon = (Beacon) source;
            return new BeaconWithPowerAndLocated2D(beacon.getIdentifiers(),
                    getEstimatedTransmittedPowerdBm(), beacon.getFrequency(),
                    beacon.getBluetoothAddress(), beacon.getBeaconTypeCode(),
                    beacon.getManufacturer(), beacon.getServiceUuid(),
                    beacon.getBluetoothName(),
                    getEstimatedPathLossExponent(),
                    transmittedPowerStandardDeviation,
                    pathlossExponentStandardDeviation,
                    estimatedPosition, estimatedPositionCovariance);
        }else {
            return null;
        }
    }

    /**
     * Solves preliminar solution for a subset of samples.
     *
     * @param samplesIndices    indices of subset samples.
     * @param solutions         instance where solution will be stored.
     */
    @Override
    protected void solvePreliminarSolutions(int[] samplesIndices,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator3D.html#L2799">2799</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator3D.html#L839">839</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    }

    /**
     * Gets estimated located radio source with estimated transmitted power.
     *
     * @return estimated located radio source with estimated transmitted power or null.
     */
    @Override
    @SuppressWarnings(&quot;unchecked&quot;)
    public RadioSourceWithPowerAndLocated&lt;Point3D&gt; getEstimatedRadioSource() {
        List&lt;? extends RangingAndRssiReadingLocated&lt;S, Point3D&gt;&gt; readings = getReadings();
        if (readings == null || readings.isEmpty()) {
            return null;
        }
        S source = readings.get(0).getSource();

        Point3D estimatedPosition = getEstimatedPosition();
        if (estimatedPosition == null) {
            return null;
        }

        Matrix estimatedPositionCovariance = getEstimatedPositionCovariance();

        Double transmittedPowerVariance =
                getEstimatedTransmittedPowerVariance();
        Double transmittedPowerStandardDeviation = transmittedPowerVariance != null ?
                Math.sqrt(transmittedPowerVariance) : null;

        Double pathlossExponentVariance =
                getEstimatedPathLossExponentVariance();
        Double pathlossExponentStandardDeviation = pathlossExponentVariance != null ?
                Math.sqrt(pathlossExponentVariance) : null;

        if (source instanceof WifiAccessPoint) {
            WifiAccessPoint accessPoint = (WifiAccessPoint) source;
            return new WifiAccessPointWithPowerAndLocated3D(accessPoint.getBssid(),
                    source.getFrequency(), accessPoint.getSsid(),
                    getEstimatedTransmittedPowerdBm(),
                    transmittedPowerStandardDeviation,
                    getEstimatedPathLossExponent(),
                    pathlossExponentStandardDeviation,
                    estimatedPosition,
                    estimatedPositionCovariance);
        } else if(source instanceof Beacon) {
            Beacon beacon = (Beacon) source;
            return new BeaconWithPowerAndLocated3D(beacon.getIdentifiers(),
                    getEstimatedTransmittedPowerdBm(), beacon.getFrequency(),
                    beacon.getBluetoothAddress(), beacon.getBeaconTypeCode(),
                    beacon.getManufacturer(), beacon.getServiceUuid(),
                    beacon.getBluetoothName(),
                    getEstimatedPathLossExponent(),
                    transmittedPowerStandardDeviation,
                    pathlossExponentStandardDeviation,
                    estimatedPosition, estimatedPositionCovariance);
        }else {
            return null;
        }
    }

    /**
     * Solves preliminar solution for a subset of samples.
     *
     * @param samplesIndices    indices of subset samples.
     * @param solutions         instance where solution will be stored.
     */
    @Override
    protected void solvePreliminarSolutions(int[] samplesIndices,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator2D.html#L2775">2775</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RssiRadioSourceEstimator2D.html#L402">402</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    }

    /**
     * Gets estimated located radio source with estimated transmitted power.
     *
     * @return estimated located radio source with estimated transmitted power or null.
     */
    @Override
    @SuppressWarnings(&quot;unchecked&quot;)
    public RadioSourceWithPowerAndLocated&lt;Point2D&gt; getEstimatedRadioSource() {
        List&lt;? extends RssiReadingLocated&lt;S, Point2D&gt;&gt; readings = getReadings();
        if (readings == null || readings.isEmpty()) {
            return null;
        }
        S source = readings.get(0).getSource();

        Point2D estimatedPosition = getEstimatedPosition();
        if (estimatedPosition == null) {
            return null;
        }

        Matrix estimatedPositionCovariance = getEstimatedPositionCovariance();

        Double transmittedPowerVariance =
                getEstimatedTransmittedPowerVariance();
        Double transmittedPowerStandardDeviation = transmittedPowerVariance != null ?
                Math.sqrt(transmittedPowerVariance) : null;

        Double pathlossExponentVariance =
                getEstimatedPathLossExponentVariance();
        Double pathlossExponentStandardDeviation = pathlossExponentVariance != null ?
                Math.sqrt(pathlossExponentVariance) : null;

        if (source instanceof WifiAccessPoint) {
            WifiAccessPoint accessPoint = (WifiAccessPoint) source;
            return new WifiAccessPointWithPowerAndLocated2D(accessPoint.getBssid(),
                    source.getFrequency(), accessPoint.getSsid(),
                    getEstimatedTransmittedPowerdBm(),
                    transmittedPowerStandardDeviation,
                    getEstimatedPathLossExponent(),
                    pathlossExponentStandardDeviation,
                    estimatedPosition,
                    estimatedPositionCovariance);
        } else if(source instanceof Beacon) {
            Beacon beacon = (Beacon) source;
            return new BeaconWithPowerAndLocated2D(beacon.getIdentifiers(),
                    getEstimatedTransmittedPowerdBm(), beacon.getFrequency(),
                    beacon.getBluetoothAddress(), beacon.getBeaconTypeCode(),
                    beacon.getManufacturer(), beacon.getServiceUuid(),
                    beacon.getBluetoothName(),
                    getEstimatedPathLossExponent(),
                    transmittedPowerStandardDeviation,
                    pathlossExponentStandardDeviation,
                    estimatedPosition, estimatedPositionCovariance);
        }else {
            return null;
        }
    }</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator2D.html#L833">833</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator3D.html#L832">832</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator2D.html#L838">838</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator3D.html#L837">837</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>            RobustRangingAndRssiRadioSourceEstimatorListener&lt;S, Point2D&gt; listener) {
        super(readings, initialPosition, initialTransmittedPowerdBm,
                initialPathLossExponent, listener);
        internalSetQualityScores(qualityScores);
    }

    /**
     * Gets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on distance between estimated position and distances
     * provided for each sample.
     *
     * @return threshold to determine whether samples are inliers or not.
     */
    public double getThreshold() {
        return mThreshold;
    }

    /**
     * Sets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on distance between estimated position and distances
     * provided for each sample.
     *
     * @param threshold threshold to determine whether samples are inliers or not.
     * @throws IllegalArgumentException if provided value is equal or less than zero.
     * @throws LockedException if this solver is locked.
     */
    public void setThreshold(double threshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (threshold &lt;= MIN_THRESHOLD) {
            throw new IllegalArgumentException();
        }
        mThreshold = threshold;
    }

    /**
     * Returns quality scores corresponding to each pair of
     * positions and distances (i.e. sample).
     * The larger the score value the better the quality of the sample.
     * This implementation always returns null.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @return quality scores corresponding to each sample.
     */
    @Override
    public double[] getQualityScores() {
        return mQualityScores;
    }

    /**
     * Sets quality scores corresponding to each pair of positions and
     * distances (i.e. sample).
     * The larger the score value the better the quality of the sample.
     * This implementation makes no action.
     * Subclasses using quality scores must implement proper behaviour.
     *
     * @param qualityScores quality scores corresponding to each pair of
     *                      matched points.
     * @throws IllegalArgumentException if provided quality scores length
     * is smaller than minimum required samples.
     * @throws LockedException if robust solver is locked because an
     * estimation is already in progress.
     */
    public void setQualityScores(double[] qualityScores) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetQualityScores(qualityScores);
    }

    /**
     * Indicates whether solver is ready to find a solution.
     *
     * @return true if solver is ready, false otherwise.
     */
    @Override
    public boolean isReady() {
        return super.isReady() &amp;&amp; mQualityScores != null &amp;&amp;
                mQualityScores.length == mReadings.size();
    }

    /**
     * Indicates whether inliers must be computed and kept.
     *
     * @return true if inliers must be computed and kept, false if inliers
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepInliersEnabled() {
        return mComputeAndKeepInliers;
    }

    /**
     * Specifies whether inliers must be computed and kept.
     *
     * @param computeAndKeepInliers true if inliers must be computed and kept,
     *                              false if inliers only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepInliersEnabled(boolean computeAndKeepInliers)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mComputeAndKeepInliers = computeAndKeepInliers;
    }

    /**
     * Indicates whether residuals must be computed and kept.
     *
     * @return true if residuals must be computed and kept, false if residuals
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepResidualsEnabled() {
        return mComputeAndKeepResiduals;
    }

    /**
     * Specifies whether residuals must be computed and kept.
     *
     * @param computeAndKeepResiduals true if residuals must be computed and kept,
     *                                false if residuals only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepResidualsEnabled(boolean computeAndKeepResiduals)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mComputeAndKeepResiduals = computeAndKeepResiduals;
    }

    /**
     * Robustly estimates position, transmitted power and pathloss exponent for a
     * radio source.
     *
     * @throws LockedException if instance is busy during estimation.
     * @throws NotReadyException if estimator is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     * (i.e. numerical instability, no solution available, etc).
     */
    @Override
    public void estimate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        PROSACRobustEstimator&lt;Solution&lt;Point2D&gt;&gt; innerEstimator =</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator2D.html#L324">324</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator3D.html#L324">324</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>            RobustRangingRadioSourceEstimatorListener&lt;S, Point2D&gt; listener) {
        super(readings, initialPosition, listener);
        internalSetQualityScores(qualityScores);
    }

    /**
     * Gets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on distance between estimated position and distances
     * provided for each sample.
     *
     * @return threshold to determine whether samples are inliers or not.
     */
    public double getThreshold() {
        return mThreshold;
    }

    /**
     * Sets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on distance between estimated position and distances
     * provided for each sample.
     *
     * @param threshold threshold to determine whether samples are inliers or not.
     * @throws IllegalArgumentException if provided value is equal or less than zero.
     * @throws LockedException if this solver is locked.
     */
    public void setThreshold(double threshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (threshold &lt;= MIN_THRESHOLD) {
            throw new IllegalArgumentException();
        }
        mThreshold = threshold;
    }

    /**
     * Returns quality scores corresponding to each pair of
     * positions and distances (i.e. sample).
     * The larger the score value the better the quality of the sample.
     * This implementation always returns null.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @return quality scores corresponding to each sample.
     */
    @Override
    public double[] getQualityScores() {
        return mQualityScores;
    }

    /**
     * Sets quality scores corresponding to each pair of positions and
     * distances (i.e. sample).
     * The larger the score value the better the quality of the sample.
     * This implementation makes no action.
     * Subclasses using quality scores must implement proper behaviour.
     *
     * @param qualityScores quality scores corresponding to each pair of
     *                      matched points.
     * @throws IllegalArgumentException if provided quality scores length
     * is smaller than minimum required samples.
     * @throws LockedException if robust solver is locked because an
     * estimation is already in progress.
     */
    public void setQualityScores(double[] qualityScores)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetQualityScores(qualityScores);
    }

    /**
     * Indicates whether solver is ready to find a solution.
     *
     * @return true if solver is ready, false otherwise.
     */
    @Override
    public boolean isReady() {
        return super.isReady() &amp;&amp; mQualityScores != null &amp;&amp;
                mQualityScores.length == mReadings.size();
    }

    /**
     * Indicates whether inliers must be computed and kept.
     *
     * @return true if inliers must be computed and kept, false if inliers
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepInliersEnabled() {
        return mComputeAndKeepInliers;
    }

    /**
     * Specifies whether inliers must be computed and kept.
     *
     * @param computeAndKeepInliers true if inliers must be computed and kept,
     *                              false if inliers only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepInliersEnabled(boolean computeAndKeepInliers)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mComputeAndKeepInliers = computeAndKeepInliers;
    }

    /**
     * Indicates whether residuals must be computed and kept.
     *
     * @return true if residuals must be computed and kept, false if residuals
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepResidualsEnabled() {
        return mComputeAndKeepResiduals;
    }

    /**
     * Specifies whether residuals must be computed and kept.
     *
     * @param computeAndKeepResiduals true if residuals must be computed and kept,
     *                                false if residuals only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepResidualsEnabled(boolean computeAndKeepResiduals)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mComputeAndKeepResiduals = computeAndKeepResiduals;
    }

    /**
     * Robustly estimates position for a radio source.
     *
     * @throws LockedException if instance is busy during estimation.
     * @throws NotReadyException if estimator is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     * (i.e. numerical instability, no solution available, etc).
     */
    @Override
    public void estimate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        PROSACRobustEstimator&lt;Solution&lt;Point2D&gt;&gt; innerEstimator =</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/PROMedSRobustMixedPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROMedSRobustMixedPositionEstimator2D.html#L358">358</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/PROMedSRobustRangingAndRssiPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROMedSRobustRangingAndRssiPositionEstimator2D.html#L358">358</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/PROMedSRobustRangingPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROMedSRobustRangingPositionEstimator2D.html#L357">357</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/PROMedSRobustRssiPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROMedSRobustRssiPositionEstimator2D.html#L356">356</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>            RobustMixedPositionEstimatorListener&lt;Point2D&gt; listener) {
        this(sources, fingerprint, listener);
        internalSetSourceQualityScores(sourceQualityScores);
        internalSetFingerprintReadingsQualityScores(fingerprintReadingsQualityScores);
    }

    /**
     * Returns quality scores corresponding to each radio source.
     * The larger the score value the better the quality of the sample.
     *
     * @return quality scores corresponding to each radio source.
     */
    public double[] getSourceQualityScores() {
        return mSourceQualityScores;
    }

    /**
     * Sets quality scores corresponding to each radio source.
     * The larger the score value the better the quality of the radio source.
     *
     * @param sourceQualityScores quality scores corresponding to each radio source.
     * @throws LockedException          if this instance is locked.
     * @throws IllegalArgumentException if provided quality scores length is smaller
     *                                  than minimum required samples.
     */
    public void setSourceQualityScores(double[] sourceQualityScores)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetSourceQualityScores(sourceQualityScores);
    }

    /**
     * Gets quality scores corresponding to each reading within provided fingerprint.
     * The larger the score value the better the quality of the reading.
     * This implementation always returns null.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @return quality scores corresponding to each reading within provided
     * fingerprint.
     */
    public double[] getFingerprintReadingsQualityScores() {
        return mFingerprintReadingsQualityScores;
    }

    /**
     * Sets quality scores corresponding to each reading within provided fingerprint.
     * The larger the score value the better the quality of the reading.
     * This implementation makes no action.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @param fingerprintReadingsQualityScores quality scores corresponding to each
     *                                         reading within provided fingerprint.
     * @throws LockedException          if this instance is locked.
     * @throws IllegalArgumentException if provided quality scores length is smaller
     *                                  than minimum required samples.
     */
    public void setFingerprintReadingsQualityScores(
            double[] fingerprintReadingsQualityScores) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetFingerprintReadingsQualityScores(fingerprintReadingsQualityScores);
    }

    /**
     * Returns threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value, the
     * algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algrithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @return stop threshold to stop the algorithm prematurely when a certain
     * accuracy has been reached.
     */
    public double getStopThreshold() {
        return ((PROMedSRobustLateration2DSolver) mLaterationSolver).
                getStopThreshold();
    }

    /**
     * Sets threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value,
     * the algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algorithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @param stopThreshold stop threshold to stop the algorithm prematurely
     *                      when a certain accuracy has been reached.
     * @throws IllegalArgumentException if provided value is zero or negative.
     * @throws LockedException if this solver is locked.
     */
    public void setStopThreshold(double stopThreshold) throws LockedException {
        ((PROMedSRobustLateration2DSolver) mLaterationSolver).
                setStopThreshold(stopThreshold);
    }

    /**
     * Returns method being used for robust estimation.
     * @return method being used for robust estimation.
     */
    @Override
    public RobustEstimatorMethod getMethod() {
        return RobustEstimatorMethod.PROMedS;
    }

    /**
     * Initializes robust lateration solver.
     */
    private void init() {
        mLaterationSolver = new PROMedSRobustLateration2DSolver(
                mTrilaterationSolverListener);
    }

    /**
     * Sets quality scores corresponding to each provided located radio source.
     * This method is used internally and does not check whether instance is
     * locked or not.
     * @param sourceQualityScores quality scores to be set.
     * @throws IllegalArgumentException if provided quality scores length
     * is smaller than 3 samples.
     */
    private void internalSetSourceQualityScores(double[] sourceQualityScores) {
        if (sourceQualityScores == null ||
                sourceQualityScores.length &lt; getMinRequiredSources()) {
            throw new IllegalArgumentException();
        }

        mSourceQualityScores = sourceQualityScores;

        buildPositionsDistancesDistanceStandardDeviationsAndQualityScores();
    }

    /**
     * Sets quality scores corresponding to each provided reading within provided
     * fingerprint.
     * This method is used internally and does not check whether instance is locked
     * or not.
     * @param fingerprintReadingsQualityScores quality scores to be set.
     * @throws IllegalArgumentException if provided quality scores lengt is
     * smaller than 3 samples.
     */
    private void internalSetFingerprintReadingsQualityScores(
            double[] fingerprintReadingsQualityScores) {
        if (fingerprintReadingsQualityScores == null ||
                fingerprintReadingsQualityScores.length &lt; getMinRequiredSources()) {
            throw new IllegalArgumentException();
        }

        mFingerprintReadingsQualityScores = fingerprintReadingsQualityScores;

        buildPositionsDistancesDistanceStandardDeviationsAndQualityScores();
    }
}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/PROMedSRobustMixedPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROMedSRobustMixedPositionEstimator3D.html#L358">358</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/PROMedSRobustRangingAndRssiPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROMedSRobustRangingAndRssiPositionEstimator3D.html#L358">358</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/PROMedSRobustRangingPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROMedSRobustRangingPositionEstimator3D.html#L357">357</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                                                 RobustMixedPositionEstimatorListener&lt;Point3D&gt; listener) {
        this(sources, fingerprint, listener);
        internalSetSourceQualityScores(sourceQualityScores);
        internalSetFingerprintReadingsQualityScores(fingerprintReadingsQualityScores);
    }

    /**
     * Returns quality scores corresponding to each radio source.
     * The larger the score value the better the quality of the sample.
     *
     * @return quality scores corresponding to each radio source.
     */
    public double[] getSourceQualityScores() {
        return mSourceQualityScores;
    }

    /**
     * Sets quality scores corresponding to each radio source.
     * The larger the score value the better the quality of the radio source.
     *
     * @param sourceQualityScores quality scores corresponding to each radio source.
     * @throws LockedException          if this instance is locked.
     * @throws IllegalArgumentException if provided quality scores length is smaller
     *                                  than minimum required samples.
     */
    public void setSourceQualityScores(double[] sourceQualityScores)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetSourceQualityScores(sourceQualityScores);
    }

    /**
     * Gets quality scores corresponding to each reading within provided fingerprint.
     * The larger the score value the better the quality of the reading.
     * This implementation always returns null.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @return quality scores corresponding to each reading within provided
     * fingerprint.
     */
    public double[] getFingerprintReadingsQualityScores() {
        return mFingerprintReadingsQualityScores;
    }

    /**
     * Sets quality scores corresponding to each reading within provided fingerprint.
     * The larger the score value the better the quality of the reading.
     * This implementation makes no action.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @param fingerprintReadingsQualityScores quality scores corresponding to each
     *                                         reading within provided fingerprint.
     * @throws LockedException          if this instance is locked.
     * @throws IllegalArgumentException if provided quality scores length is smaller
     *                                  than minimum required samples.
     */
    public void setFingerprintReadingsQualityScores(
            double[] fingerprintReadingsQualityScores) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetFingerprintReadingsQualityScores(fingerprintReadingsQualityScores);
    }

    /**
     * Returns threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value, the
     * algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algrithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @return stop threshold to stop the algorithm prematurely when a certain
     * accuracy has been reached.
     */
    public double getStopThreshold() {
        return ((PROMedSRobustLateration3DSolver) mLaterationSolver).
                getStopThreshold();
    }

    /**
     * Sets threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value,
     * the algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algorithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @param stopThreshold stop threshold to stop the algorithm prematurely
     *                      when a certain accuracy has been reached.
     * @throws IllegalArgumentException if provided value is zero or negative.
     * @throws LockedException if this solver is locked.
     */
    public void setStopThreshold(double stopThreshold) throws LockedException {
        ((PROMedSRobustLateration3DSolver) mLaterationSolver).
                setStopThreshold(stopThreshold);
    }

    /**
     * Returns method being used for robust estimation.
     * @return method being used for robust estimation.
     */
    @Override
    public RobustEstimatorMethod getMethod() {
        return RobustEstimatorMethod.PROMedS;
    }

    /**
     * Initializes robust lateration solver.
     */
    private void init() {
        mLaterationSolver = new PROMedSRobustLateration3DSolver(
                mTrilaterationSolverListener);
    }

    /**
     * Sets quality scores corresponding to each provided located radio source.
     * This method is used internally and does not check whether instance is
     * locked or not.
     * @param sourceQualityScores quality scores to be set.
     * @throws IllegalArgumentException if provided quality scores length
     * is smaller than 3 samples.
     */
    private void internalSetSourceQualityScores(double[] sourceQualityScores) {
        if (sourceQualityScores == null ||
                sourceQualityScores.length &lt; getMinRequiredSources()) {
            throw new IllegalArgumentException();
        }

        mSourceQualityScores = sourceQualityScores;

        buildPositionsDistancesDistanceStandardDeviationsAndQualityScores();
    }

    /**
     * Sets quality scores corresponding to each provided reading within provided
     * fingerprint.
     * This method is used internally and does not check whether instance is locked
     * or not.
     * @param fingerprintReadingsQualityScores quality scores to be set.
     * @throws IllegalArgumentException if provided quality scores lengt is
     * smaller than 3 samples.
     */
    private void internalSetFingerprintReadingsQualityScores(
            double[] fingerprintReadingsQualityScores) {
        if (fingerprintReadingsQualityScores == null ||
                fingerprintReadingsQualityScores.length &lt; getMinRequiredSources()) {
            throw new IllegalArgumentException();
        }

        mFingerprintReadingsQualityScores = fingerprintReadingsQualityScores;

        buildPositionsDistancesDistanceStandardDeviationsAndQualityScores();
    }
}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/lateration/NonLinearLeastSquaresLateration2DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/NonLinearLeastSquaresLateration2DSolver.html#L351">351</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/lateration/RobustLateration2DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/RobustLateration2DSolver.html#L1346">1346</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    }

    /**
     * Internally sets circles defining positions and euclidean distances.
     * @param circles circles defining positions and distances.
     * @throws IllegalArgumentException if circles is null or length of array of circles
     * is less than 2.
     */
    private void internalSetCircles(Circle[] circles) {
        if (circles == null || circles.length &lt; getMinRequiredPositionsAndDistances()) {
            throw new IllegalArgumentException();
        }

        Point2D[] positions = new Point2D[circles.length];
        double[] distances = new double[circles.length];
        for (int i = 0; i &lt; circles.length; i++) {
            Circle circle = circles[i];
            positions[i] = circle.getCenter();
            distances[i] = circle.getRadius();
        }

        internalSetPositionsAndDistances(positions, distances);
    }

    /**
     * Internally sets circles defining positions and euclidean distances along with the standard
     * deviations of provided circles radii.
     * @param circles circles defining positions and distances.
     * @param radiusStandardDeviations standard deviations of circles radii.
     * @throws IllegalArgumentException if circles is null, length of arrays is less than
     * 2 or don't have the same length.
     */
    private void internalSetCirclesAndStandardDeviations(Circle[] circles,
            double[] radiusStandardDeviations) {
        if (circles == null || circles.length &lt; getMinRequiredPositionsAndDistances()) {
            throw new IllegalArgumentException();
        }

        if (radiusStandardDeviations == null) {
            throw new IllegalArgumentException();
        }

        if (radiusStandardDeviations.length != circles.length) {
            throw new IllegalArgumentException();
        }

        Point2D[] positions = new Point2D[circles.length];
        double[] distances = new double[circles.length];
        for (int i = 0; i &lt; circles.length; i++) {
            Circle circle = circles[i];
            positions[i] = circle.getCenter();
            distances[i] = circle.getRadius();
        }

        internalSetPositionsDistancesAndStandardDeviations(positions, distances,
                radiusStandardDeviations);
    }</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RobustRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRadioSourceEstimator.html#L217">217</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/lateration/RobustLaterationSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/RobustLaterationSolver.html#L412">412</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    }

    /**
     * Indicates whether estimator is locked during estimation.
     *
     * @return true if estimator is locked, false otherwise.
     */
    public boolean isLocked() {
        return mLocked;
    }

    /**
     * Returns amount of progress variation before notifying a progress change during
     * estimation.
     *
     * @return amount of progress variation before notifying a progress change during
     * estimation.
     */
    public float getProgressDelta() {
        return mProgressDelta;
    }

    /**
     * Sets amount of progress variation before notifying a progress change during
     * estimation.
     *
     * @param progressDelta amount of progress variation before notifying a progress
     *                      change during estimation.
     * @throws IllegalArgumentException if progress delta is less than zero or greater than 1.
     * @throws LockedException if this estimator is locked.
     */
    public void setProgressDelta(float progressDelta) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (progressDelta &lt; MIN_PROGRESS_DELTA ||
                progressDelta &gt; MAX_PROGRESS_DELTA) {
            throw new IllegalArgumentException();
        }
        mProgressDelta = progressDelta;
    }

    /**
     * Returns amount of confidence expressed as a value between 0.0 and 1.0
     * (which is equivalent to 100%). The amount of confidence indicates the probability
     * that the estimated result is correct. Usually this value will be close to 1.0, but
     * not exactly 1.0.
     *
     * @return amount of confidence as a value between 0.0 and 1.0.
     */
    public double getConfidence() {
        return mConfidence;
    }

    /**
     * Sets amount of confidence expressed as a value between 0.0 and 1.0 (which is
     * equivalent to 100%). The amount of confidence indicates the probability that
     * the estimated result is correct. Usually this value will be close to 1.0, but
     * not exactly 1.0.
     *
     * @param confidence confidence to be set as a value between 0.0 and 1.0.
     * @throws IllegalArgumentException if provided value is not between 0.0 and 1.0.
     * @throws LockedException if estimator is locked.
     */
    public void setConfidence(double confidence) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (confidence &lt; MIN_CONFIDENCE || confidence &gt; MAX_CONFIDENCE) {
            throw new IllegalArgumentException();
        }
        mConfidence = confidence;
    }

    /**
     * Returns maximum allowed number of iterations. If maximum allowed number of
     * iterations is achieved without converging to a result when calling estimate(),
     * a RobustEstimatorException will be raised.
     *
     * @return maximum allowed number of iterations.
     */
    public int getMaxIterations() {
        return mMaxIterations;
    }

    /**
     * Sets maximum allowed number of iterations. When the maximum number of iterations
     * is exceeded, result will not be available, however an approximate result will be
     * available for retrieval.
     *
     * @param maxIterations maximum allowed number of iterations to be set.
     * @throws IllegalArgumentException if provided value is less than 1.
     * @throws LockedException if this estimator is locked.
     */
    public void setMaxIterations(int maxIterations) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (maxIterations &lt; MIN_ITERATIONS) {
            throw new IllegalArgumentException();
        }
        mMaxIterations = maxIterations;
    }

    /**
     * Gets data related to inliers found after estimation.
     *
     * @return data related to inliers found after estimation.
     */
    public InliersData getInliersData() {
        return mInliersData;
    }

    /**
     * Indicates whether result must be refined using a non-linear solver over found inliers.
     *
     * @return true to refine result, false to simply use result found by robust estimator
     * without further refining.
     */
    public boolean isResultRefined() {
        return mRefineResult;
    }

    /**
     * Specifies whether result must be refined using a non-linear solver over found inliers.
     *
     * @param refineResult true to refine result, false to simply use result found by robust
     *                     estimator without further refining.
     * @throws LockedException if estimator is locked.
     */
    public void setResultRefined(boolean refineResult) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mRefineResult = refineResult;
    }

    /**
     * Indicates whether covariance must be kept after refining result.
     * This setting is only taken into account if result is refined.
     *
     * @return true if covariance must be kept after refining result, false otherwise.
     */
    public boolean isCovarianceKept() {
        return mKeepCovariance;
    }

    /**
     * Specifies whether covariance must be kept after refining result.
     * This setting is only taken into account if result is refined.
     *
     * @param keepCovariance true if covariance must be kept after refining result,
     *                       false otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setCovarianceKept(boolean keepCovariance) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mKeepCovariance = keepCovariance;
    }

    /**
     * Gets signal readings belonging to the same radio source.
     *
     * @return signal readings belonging to the same radio source.
     */
    public List&lt;? extends R&gt; getReadings() {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator.html#L442">442</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator.html#L439">439</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>            RobustRangingAndRssiRadioSourceEstimatorListener&lt;S, P&gt; listener) {
        this(readings, initialPosition, initialTransmittedPowerdBm,
                listener);
        mInitialPathLossExponent = initialPathLossExponent;
    }

    /**
     * Gets initial transmitted power to start the estimation of radio source
     * transmitted power (expressed in dBm's).
     * If not defined, average value of received power readings will be used.
     * @return initial transmitted power to start the estimation of radio source
     * transmitted power.
     */
    public Double getInitialTransmittedPowerdBm() {
        return mInitialTransmittedPowerdBm;
    }

    /**
     * Sets initial transmitted power to start the estimation of radio source
     * transmitted power (expressed in dBm's).
     * If not defined, average value of received power readings will be used.
     * @param initialTransmittedPowerdBm initial transmitted power to start the
     *                                   estimation of radio source transmitted
     *                                   power.
     * @throws LockedException if estimator is locked.
     */
    public void setInitialTransmittedPowerdBm(Double initialTransmittedPowerdBm)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mInitialTransmittedPowerdBm = initialTransmittedPowerdBm;
    }

    /**
     * Gets initial transmitted power to start the estimation of radio source
     * transmitted power (expressed in mW).
     * If not defined, average value of received power readings will be used.
     * @return initial transmitted power to start the estimation of radio source
     * transmitted power.
     */
    public Double getInitialTransmittedPower() {
        return mInitialTransmittedPowerdBm != null ?
                Utils.dBmToPower(mInitialTransmittedPowerdBm) : null;
    }

    /**
     * Sets initial transmitted power to start the estimation of radio source
     * transmitted power (expressed in mW).
     * If not defined, average value of received power readings will be used.
     * @param initialTransmittedPower initial transmitted power to start the
     *                                estimation of radio source transmitted power.
     * @throws LockedException if estimator is locked.
     * @throws IllegalArgumentException if provided value is negative.
     */
    public void setInitialTransmittedPower(Double initialTransmittedPower)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (initialTransmittedPower != null) {
            if (initialTransmittedPower &lt; 0.0) {
                throw new IllegalArgumentException();
            }
            mInitialTransmittedPowerdBm = Utils.powerTodBm(
                    initialTransmittedPower);
        } else {
            mInitialTransmittedPowerdBm = null;
        }
    }

    /**
     * Gets initial position to start the estimation of radio source position.
     * If not defined, centroid of provided fingerprints will be used.
     * @return initial position to start the estimation of radio source position.
     */
    public P getInitialPosition() {
        return mInitialPosition;
    }

    /**
     * Sets initial position to start the estimation of radio source position.
     * If not defined, centroid of provided fingerprints will be used.
     * @param initialPosition initial position to start the estimation of radio
     *                        source position.
     * @throws LockedException if estimator is locked.
     */
    public void setInitialPosition(P initialPosition) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mInitialPosition = initialPosition;
    }

    /**
     * Gets initial exponent typically used on free space for path loss propagation
     * in terms of distance.
     * On different environments path loss exponent might have different value:
     * - Free space: 2.0
     * - Urban Area: 2.7 to 3.5
     * - Suburban Area: 3 to 5
     * - Indoor (line-of-sight): 1.6 to 1.8
     *
     * If path loss exponent estimation is enabled, estimation will start at this
     * value and will converge to the most appropriate value.
     * If path loss exponent estimation is disabled, this value will be assumed
     * to be exact and the estimated path loss exponent will be equal to this
     * value.
     * @return initial path loss exponent.
     */
    public double getInitialPathLossExponent() {
        return mInitialPathLossExponent;
    }

    /**
     * Sets initial exponent typically used on free space for path loss propagation
     * in terms of distance.
     * On different environments path loss exponent might have different value:
     * - Free space: 2.0
     * - Urban Area: 2.7 to 3.5
     * - Suburban Area: 3 to 5
     * - Indoor (line-of-sight): 1.6 to 1.8
     *
     * If path loss exponent estimation is enabled, estimation will start at this
     * value and will converge to the most appropriate value.
     * If path loss exponent estimation is disabled, this value will be assumed
     * to be exact and the estimated path loss exponent will be equal to this
     * value.
     * @param initialPathLossExponent initial path loss exponent.
     * @throws LockedException if estimator is locked.
     */
    public void setInitialPathLossExponent(double initialPathLossExponent)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mInitialPathLossExponent = initialPathLossExponent;
    }

    /**
     * Indicates whether transmitted power estimation is enabled or not.
     * @return true if transmitted power estimation is enabled, false otherwise.
     */
    public boolean isTransmittedPowerEstimationEnabled() {
        return mTransmittedPowerEstimationEnabled;
    }

    /**
     * Specifies whether transmitted power estimation is enabled or not.
     * @param transmittedPowerEstimationEnabled true if transmitted power estimation is enabled,
     *                                          false otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setTransmittedPowerEstimationEnabled(boolean transmittedPowerEstimationEnabled)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mTransmittedPowerEstimationEnabled = transmittedPowerEstimationEnabled;
    }

    /**
     * Indicates whether path loss estimation is enabled or not.
     * @return true if path loss estimation is enabled, false otherwise.
     */
    public boolean isPathLossEstimationEnabled() {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator2D.html#L835">835</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator3D.html#L325">325</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator2D.html#L840">840</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>                initialPathLossExponent, listener);
        internalSetQualityScores(qualityScores);
    }

    /**
     * Gets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on distance between estimated position and distances
     * provided for each sample.
     *
     * @return threshold to determine whether samples are inliers or not.
     */
    public double getThreshold() {
        return mThreshold;
    }

    /**
     * Sets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on distance between estimated position and distances
     * provided for each sample.
     *
     * @param threshold threshold to determine whether samples are inliers or not.
     * @throws IllegalArgumentException if provided value is equal or less than zero.
     * @throws LockedException if this solver is locked.
     */
    public void setThreshold(double threshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (threshold &lt;= MIN_THRESHOLD) {
            throw new IllegalArgumentException();
        }
        mThreshold = threshold;
    }

    /**
     * Returns quality scores corresponding to each pair of
     * positions and distances (i.e. sample).
     * The larger the score value the better the quality of the sample.
     * This implementation always returns null.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @return quality scores corresponding to each sample.
     */
    @Override
    public double[] getQualityScores() {
        return mQualityScores;
    }

    /**
     * Sets quality scores corresponding to each pair of positions and
     * distances (i.e. sample).
     * The larger the score value the better the quality of the sample.
     * This implementation makes no action.
     * Subclasses using quality scores must implement proper behaviour.
     *
     * @param qualityScores quality scores corresponding to each pair of
     *                      matched points.
     * @throws IllegalArgumentException if provided quality scores length
     * is smaller than minimum required samples.
     * @throws LockedException if robust solver is locked because an
     * estimation is already in progress.
     */
    public void setQualityScores(double[] qualityScores) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetQualityScores(qualityScores);
    }

    /**
     * Indicates whether solver is ready to find a solution.
     *
     * @return true if solver is ready, false otherwise.
     */
    @Override
    public boolean isReady() {
        return super.isReady() &amp;&amp; mQualityScores != null &amp;&amp;
                mQualityScores.length == mReadings.size();
    }

    /**
     * Indicates whether inliers must be computed and kept.
     *
     * @return true if inliers must be computed and kept, false if inliers
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepInliersEnabled() {
        return mComputeAndKeepInliers;
    }

    /**
     * Specifies whether inliers must be computed and kept.
     *
     * @param computeAndKeepInliers true if inliers must be computed and kept,
     *                              false if inliers only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepInliersEnabled(boolean computeAndKeepInliers)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mComputeAndKeepInliers = computeAndKeepInliers;
    }

    /**
     * Indicates whether residuals must be computed and kept.
     *
     * @return true if residuals must be computed and kept, false if residuals
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepResidualsEnabled() {
        return mComputeAndKeepResiduals;
    }

    /**
     * Specifies whether residuals must be computed and kept.
     *
     * @param computeAndKeepResiduals true if residuals must be computed and kept,
     *                                false if residuals only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepResidualsEnabled(boolean computeAndKeepResiduals)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mComputeAndKeepResiduals = computeAndKeepResiduals;
    }

    /**
     * Robustly estimates position, transmitted power and pathloss exponent for a
     * radio source.
     *
     * @throws LockedException if instance is busy during estimation.
     * @throws NotReadyException if estimator is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     * (i.e. numerical instability, no solution available, etc).
     */
    @Override
    public void estimate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        PROSACRobustEstimator&lt;Solution&lt;Point2D&gt;&gt; innerEstimator =</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator3D.html#L834">834</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator2D.html#L325">325</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator3D.html#L839">839</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                initialPathLossExponent, listener);
        internalSetQualityScores(qualityScores);
    }

    /**
     * Gets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on distance between estimated position and distances
     * provided for each sample.
     *
     * @return threshold to determine whether samples are inliers or not.
     */
    public double getThreshold() {
        return mThreshold;
    }

    /**
     * Sets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on distance between estimated position and distances
     * provided for each sample.
     *
     * @param threshold threshold to determine whether samples are inliers or not.
     * @throws IllegalArgumentException if provided value is equal or less than zero.
     * @throws LockedException if this solver is locked.
     */
    public void setThreshold(double threshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (threshold &lt;= MIN_THRESHOLD) {
            throw new IllegalArgumentException();
        }
        mThreshold = threshold;
    }

    /**
     * Returns quality scores corresponding to each pair of
     * positions and distances (i.e. sample).
     * The larger the score value the better the quality of the sample.
     * This implementation always returns null.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @return quality scores corresponding to each sample.
     */
    @Override
    public double[] getQualityScores() {
        return mQualityScores;
    }

    /**
     * Sets quality scores corresponding to each pair of positions and
     * distances (i.e. sample).
     * The larger the score value the better the quality of the sample.
     * This implementation makes no action.
     * Subclasses using quality scores must implement proper behaviour.
     *
     * @param qualityScores quality scores corresponding to each pair of
     *                      matched points.
     * @throws IllegalArgumentException if provided quality scores length
     * is smaller than minimum required samples.
     * @throws LockedException if robust solver is locked because an
     * estimation is already in progress.
     */
    public void setQualityScores(double[] qualityScores)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetQualityScores(qualityScores);
    }

    /**
     * Indicates whether solver is ready to find a solution.
     *
     * @return true if solver is ready, false otherwise.
     */
    @Override
    public boolean isReady() {
        return super.isReady() &amp;&amp; mQualityScores != null &amp;&amp;
                mQualityScores.length == mReadings.size();
    }

    /**
     * Indicates whether inliers must be computed and kept.
     *
     * @return true if inliers must be computed and kept, false if inliers
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepInliersEnabled() {
        return mComputeAndKeepInliers;
    }

    /**
     * Specifies whether inliers must be computed and kept.
     *
     * @param computeAndKeepInliers true if inliers must be computed and kept,
     *                              false if inliers only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepInliersEnabled(boolean computeAndKeepInliers)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mComputeAndKeepInliers = computeAndKeepInliers;
    }

    /**
     * Indicates whether residuals must be computed and kept.
     *
     * @return true if residuals must be computed and kept, false if residuals
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepResidualsEnabled() {
        return mComputeAndKeepResiduals;
    }

    /**
     * Specifies whether residuals must be computed and kept.
     *
     * @param computeAndKeepResiduals true if residuals must be computed and kept,
     *                                false if residuals only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepResidualsEnabled(boolean computeAndKeepResiduals)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mComputeAndKeepResiduals = computeAndKeepResiduals;
    }

    /**
     * Robustly estimates position, transmitted power and pathloss exponent for a
     * radio source.
     *
     * @throws LockedException if instance is busy during estimation.
     * @throws NotReadyException if estimator is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     * (i.e. numerical instability, no solution available, etc).
     */
    @Override
    public void estimate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        PROSACRobustEstimator&lt;Solution&lt;Point3D&gt;&gt; innerEstimator =</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/lateration/NonLinearLeastSquaresLateration3DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/NonLinearLeastSquaresLateration3DSolver.html#L359">359</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/lateration/RobustLateration3DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/RobustLateration3DSolver.html#L1353">1353</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public void internalSetSpheres(Sphere[] spheres) {
        if (spheres == null || spheres.length &lt; getMinRequiredPositionsAndDistances()) {
            throw new IllegalArgumentException();
        }

        Point3D[] positions = new Point3D[spheres.length];
        double[] distances = new double[spheres.length];
        for (int i = 0; i &lt; spheres.length; i++) {
            Sphere sphere = spheres[i];
            positions[i] = sphere.getCenter();
            distances[i] = sphere.getRadius();
        }

        internalSetPositionsAndDistances(positions, distances);
    }

    /**
     * Internally sets spheres defining positions and euclidean distances along with the standard
     * deviations of provided spheres radii.
     * @param spheres spheres defining positions and distances.
     * @param radiusStandardDeviations standard deviations of circles radii.
     * @throws IllegalArgumentException if spheres is null, length of arrays is less than
     * 2 or don't have the same length.
     */
    private void internalSetSpheresAndStandardDeviations(Sphere[] spheres,
            double[] radiusStandardDeviations) {
        if (spheres == null || spheres.length &lt; getMinRequiredPositionsAndDistances()) {
            throw new IllegalArgumentException();
        }

        if (radiusStandardDeviations == null) {
            throw new IllegalArgumentException();
        }

        if (radiusStandardDeviations.length != spheres.length) {
            throw new IllegalArgumentException();
        }

        Point3D[] positions = new Point3D[spheres.length];
        double[] distances = new double[spheres.length];
        for (int i = 0; i &lt; spheres.length; i++) {
            Sphere sphere = spheres[i];
            positions[i] = sphere.getCenter();
            distances[i] = sphere.getRadius();
        }

        internalSetPositionsDistancesAndStandardDeviations(positions, distances,
                radiusStandardDeviations);

    }</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator2D.html#L2785">2785</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator2D.html#L850">850</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>        List&lt;? extends RssiReadingLocated&lt;S, Point2D&gt;&gt; readings = getReadings();
        if (readings == null || readings.isEmpty()) {
            return null;
        }
        S source = readings.get(0).getSource();

        Point2D estimatedPosition = getEstimatedPosition();
        if (estimatedPosition == null) {
            return null;
        }

        Matrix estimatedPositionCovariance = getEstimatedPositionCovariance();

        Double transmittedPowerVariance =
                getEstimatedTransmittedPowerVariance();
        Double transmittedPowerStandardDeviation = transmittedPowerVariance != null ?
                Math.sqrt(transmittedPowerVariance) : null;

        Double pathlossExponentVariance =
                getEstimatedPathLossExponentVariance();
        Double pathlossExponentStandardDeviation = pathlossExponentVariance != null ?
                Math.sqrt(pathlossExponentVariance) : null;

        if (source instanceof WifiAccessPoint) {
            WifiAccessPoint accessPoint = (WifiAccessPoint) source;
            return new WifiAccessPointWithPowerAndLocated2D(accessPoint.getBssid(),
                    source.getFrequency(), accessPoint.getSsid(),
                    getEstimatedTransmittedPowerdBm(),
                    transmittedPowerStandardDeviation,
                    getEstimatedPathLossExponent(),
                    pathlossExponentStandardDeviation,
                    estimatedPosition,
                    estimatedPositionCovariance);
        } else if(source instanceof Beacon) {
            Beacon beacon = (Beacon) source;
            return new BeaconWithPowerAndLocated2D(beacon.getIdentifiers(),
                    getEstimatedTransmittedPowerdBm(), beacon.getFrequency(),
                    beacon.getBluetoothAddress(), beacon.getBeaconTypeCode(),
                    beacon.getManufacturer(), beacon.getServiceUuid(),
                    beacon.getBluetoothName(),
                    getEstimatedPathLossExponent(),
                    transmittedPowerStandardDeviation,
                    pathlossExponentStandardDeviation,
                    estimatedPosition, estimatedPositionCovariance);
        }else {
            return null;
        }
    }

    /**
     * Solves preliminar solution for a subset of samples.
     *
     * @param samplesIndices indices of subset samples.
     * @param solutions instance where solution will be stored.
     */
    @Override
    protected void solvePreliminarSolutions(int[] samplesIndices,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRangingAndRssiRadioSourceEstimator2D.html#L372">372</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRssiRadioSourceEstimator2D.html#L383">383</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>            RobustRangingAndRssiRadioSourceEstimatorListener&lt;S, Point2D&gt; listener) {
        super(readings, initialPosition, initialTransmittedPowerdBm,
                initialPathLossExponent, listener);
    }

    /**
     * Returns threshold to determine whether samples are inliers or not.
     *
     * @return threshold to determine whether samples are inliers or not.
     */
    public double getThreshold() {
        return mThreshold;
    }

    /**
     * Sets threshold to determine whether samples are inliers or not.
     *
     * @param threshold threshold to be set.
     * @throws IllegalArgumentException if provided value is equal or less than
     * zero.
     * @throws LockedException if robust estimator is locked because an
     * estimation is already in progress.
     */
    public void setThreshold(double threshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (threshold &lt;= MIN_THRESHOLD) {
            throw new IllegalArgumentException();
        }
        mThreshold = threshold;
    }

    /**
     * Robustly estimates position, transmitted power and pathloss exponent for a
     * radio source.
     *
     * @throws LockedException if instance is busy during estimation.
     * @throws NotReadyException if estimator is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     * (i.e. numerical instability, no solution available, etc).
     */
    @Override
    public void estimate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        MSACRobustEstimator&lt;Solution&lt;Point2D&gt;&gt; innerEstimator =
                new MSACRobustEstimator&lt;&gt;(
                        new MSACRobustEstimatorListener&lt;Solution&lt;Point2D&gt;&gt;() {
                    @Override
                    public double getThreshold() {
                        return mThreshold;
                    }

                    @Override
                    public int getTotalSamples() {
                        return mReadings.size();
                    }

                    @Override
                    public int getSubsetSize() {
                        return Math.max(mPreliminarySubsetSize, getMinReadings());
                    }

                    @Override
                    public void estimatePreliminarSolutions(int[] samplesIndices,
                            List&lt;Solution&lt;Point2D&gt;&gt; solutions) {
                        solvePreliminarSolutions(samplesIndices, solutions);
                    }

                    @Override
                    public double computeResidual(Solution&lt;Point2D&gt; currentEstimation, int i) {
                        return residual(currentEstimation, i);
                    }

                    @Override
                    public boolean isReady() {
                        return MSACRobustRangingAndRssiRadioSourceEstimator2D.this.isReady();</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRangingAndRssiRadioSourceEstimator3D.html#L372">372</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRssiRadioSourceEstimator3D.html#L383">383</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>            RobustRangingAndRssiRadioSourceEstimatorListener&lt;S, Point3D&gt; listener) {
        super(readings, initialPosition, initialTransmittedPowerdBm,
                initialPathLossExponent, listener);
    }

    /**
     * Returns threshold to determine whether samples are inliers or not.
     *
     * @return threshold to determine whether samples are inliers or not.
     */
    public double getThreshold() {
        return mThreshold;
    }

    /**
     * Sets threshold to determine whether samples are inliers or not.
     *
     * @param threshold threshold to be set.
     * @throws IllegalArgumentException if provided value is equal or less than
     * zero.
     * @throws LockedException if robust estimator is locked because an
     * estimation is already in progress.
     */
    public void setThreshold(double threshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (threshold &lt;= MIN_THRESHOLD) {
            throw new IllegalArgumentException();
        }
        mThreshold = threshold;
    }

    /**
     * Robustly estimates position, transmitted power and pathloss exponent for a
     * radio source.
     *
     * @throws LockedException if instance is busy during estimation.
     * @throws NotReadyException if estimator is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     * (i.e. numerical instability, no solution available, etc).
     */
    @Override
    public void estimate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        MSACRobustEstimator&lt;Solution&lt;Point3D&gt;&gt; innerEstimator =
                new MSACRobustEstimator&lt;&gt;(
                        new MSACRobustEstimatorListener&lt;Solution&lt;Point3D&gt;&gt;() {
                            @Override
                            public double getThreshold() {
                                return mThreshold;
                            }

                            @Override
                            public int getTotalSamples() {
                                return mReadings.size();
                            }

                            @Override
                            public int getSubsetSize() {
                                return Math.max(mPreliminarySubsetSize, getMinReadings());
                            }

                            @Override
                            public void estimatePreliminarSolutions(int[] samplesIndices,
                                                                    List&lt;Solution&lt;Point3D&gt;&gt; solutions) {
                                solvePreliminarSolutions(samplesIndices, solutions);
                            }

                            @Override
                            public double computeResidual(Solution&lt;Point3D&gt; currentEstimation, int i) {
                                return residual(currentEstimation, i);
                            }

                            @Override
                            public boolean isReady() {
                                return MSACRobustRangingAndRssiRadioSourceEstimator3D.this.isReady();</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/frames/NEDFrame.java</td>
<td><a href="./xref/com/irurueta/navigation/frames/NEDFrame.html#L883">883</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/NEDVelocity.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/NEDVelocity.html#L186">186</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>        return new Speed(getVelocityNorm(), SpeedUnit.METERS_PER_SECOND);
    }

    /**
     * Gets coordinate of velocity of body frame with respect ECEF frame and
     * resolved along North axis.
     *
     * @param result instance where North velocity coordinate will be stored.
     */
    public void getSpeedN(final Speed result) {
        result.setValue(mVn);
        result.setUnit(SpeedUnit.METERS_PER_SECOND);
    }

    /**
     * Gets coordinate of velocity of body frame with respect ECEF frame and
     * resolved along North axis.
     *
     * @return North velocity coordinate.
     */
    public Speed getSpeedN() {
        return new Speed(mVn, SpeedUnit.METERS_PER_SECOND);
    }

    /**
     * Sets coordinate of velocity of body frame with respect ECEF frame and
     * resolved along North axis.
     *
     * @param speedN North velocity coordinate to be set.
     */
    public void setSpeedN(final Speed speedN) {
        mVn = SpeedConverter.convert(speedN.getValue().doubleValue(),
                speedN.getUnit(), SpeedUnit.METERS_PER_SECOND);
    }

    /**
     * Gets coordinate of velocity of body frame with respect ECEF frame and
     * resolved along East axis.
     *
     * @param result instance where East velocity coordinate will be stored.
     */
    public void getSpeedE(final Speed result) {
        result.setValue(mVe);
        result.setUnit(SpeedUnit.METERS_PER_SECOND);
    }

    /**
     * Gets coordinate of velocity of body frame with respect ECEF frame and
     * resolved along East axis.
     *
     * @return East velocity coordinate.
     */
    public Speed getSpeedE() {
        return new Speed(mVe, SpeedUnit.METERS_PER_SECOND);
    }

    /**
     * Sets coordinate of velocity of body frame with respect ECEF frame and
     * resolved along East axis.
     *
     * @param speedE East velocity coordinate to be set.
     */
    public void setSpeedE(final Speed speedE) {
        mVe = SpeedConverter.convert(speedE.getValue().doubleValue(),
                speedE.getUnit(), SpeedUnit.METERS_PER_SECOND);
    }

    /**
     * Gets coordinate of velocity of body frame with respect ECEF frame and
     * resolved along Down axis.
     *
     * @param result instance where Down velocity coordinate will be stored.
     */
    public void getSpeedD(final Speed result) {
        result.setValue(mVd);
        result.setUnit(SpeedUnit.METERS_PER_SECOND);
    }

    /**
     * Gets coordinate of velocity of body frame with respect ECEF frame and
     * resolved along Down axis.
     *
     * @return Down velocity coordinate.
     */
    public Speed getSpeedD() {
        return new Speed(mVd, SpeedUnit.METERS_PER_SECOND);
    }

    /**
     * Sets coordinate of velocity of body frame with respect ECEF frame and
     * resolved along Down axis.
     *
     * @param speedD Down velocity coordinate to be set.
     */
    public void setSpeedD(final Speed speedD) {
        mVd = SpeedConverter.convert(speedD.getValue().doubleValue(),
                speedD.getUnit(), SpeedUnit.METERS_PER_SECOND);
    }

    /**
     * Sets velocity coordinates of body frame resolved along North, East, Down
     * axes.
     *
     * @param speedN North velocity coordinate.
     * @param speedE East velocity coordinate.
     * @param speedD Down velocity coordinate.
     */
    public void setSpeedCoordinates(final Speed speedN, final Speed speedE,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator2D.html#L2807">2807</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RssiRadioSourceEstimator2D.html#L411">411</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator2D.html#L850">850</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>        List&lt;? extends RangingAndRssiReadingLocated&lt;S, Point2D&gt;&gt; readings = getReadings();
        if (readings == null || readings.isEmpty()) {
            return null;
        }
        S source = readings.get(0).getSource();

        Point2D estimatedPosition = getEstimatedPosition();
        if (estimatedPosition == null) {
            return null;
        }

        Matrix estimatedPositionCovariance = getEstimatedPositionCovariance();

        Double transmittedPowerVariance =
                getEstimatedTransmittedPowerVariance();
        Double transmittedPowerStandardDeviation = transmittedPowerVariance != null ?
                Math.sqrt(transmittedPowerVariance) : null;

        Double pathlossExponentVariance =
                getEstimatedPathLossExponentVariance();
        Double pathlossExponentStandardDeviation = pathlossExponentVariance != null ?
                Math.sqrt(pathlossExponentVariance) : null;

        if (source instanceof WifiAccessPoint) {
            WifiAccessPoint accessPoint = (WifiAccessPoint) source;
            return new WifiAccessPointWithPowerAndLocated2D(accessPoint.getBssid(),
                    source.getFrequency(), accessPoint.getSsid(),
                    getEstimatedTransmittedPowerdBm(),
                    transmittedPowerStandardDeviation,
                    getEstimatedPathLossExponent(),
                    pathlossExponentStandardDeviation,
                    estimatedPosition,
                    estimatedPositionCovariance);
        } else if(source instanceof Beacon) {
            Beacon beacon = (Beacon) source;
            return new BeaconWithPowerAndLocated2D(beacon.getIdentifiers(),
                    getEstimatedTransmittedPowerdBm(), beacon.getFrequency(),
                    beacon.getBluetoothAddress(), beacon.getBeaconTypeCode(),
                    beacon.getManufacturer(), beacon.getServiceUuid(),
                    beacon.getBluetoothName(),
                    getEstimatedPathLossExponent(),
                    transmittedPowerStandardDeviation,
                    pathlossExponentStandardDeviation,
                    estimatedPosition, estimatedPositionCovariance);
        }else {
            return null;
        }
    }</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator3D.html#L2809">2809</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator3D.html#L2786">2786</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator3D.html#L849">849</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>        List&lt;? extends RangingAndRssiReadingLocated&lt;S, Point3D&gt;&gt; readings = getReadings();
        if (readings == null || readings.isEmpty()) {
            return null;
        }
        S source = readings.get(0).getSource();

        Point3D estimatedPosition = getEstimatedPosition();
        if (estimatedPosition == null) {
            return null;
        }

        Matrix estimatedPositionCovariance = getEstimatedPositionCovariance();

        Double transmittedPowerVariance =
                getEstimatedTransmittedPowerVariance();
        Double transmittedPowerStandardDeviation = transmittedPowerVariance != null ?
                Math.sqrt(transmittedPowerVariance) : null;

        Double pathlossExponentVariance =
                getEstimatedPathLossExponentVariance();
        Double pathlossExponentStandardDeviation = pathlossExponentVariance != null ?
                Math.sqrt(pathlossExponentVariance) : null;

        if (source instanceof WifiAccessPoint) {
            WifiAccessPoint accessPoint = (WifiAccessPoint) source;
            return new WifiAccessPointWithPowerAndLocated3D(accessPoint.getBssid(),
                    source.getFrequency(), accessPoint.getSsid(),
                    getEstimatedTransmittedPowerdBm(),
                    transmittedPowerStandardDeviation,
                    getEstimatedPathLossExponent(),
                    pathlossExponentStandardDeviation,
                    estimatedPosition,
                    estimatedPositionCovariance);
        } else if(source instanceof Beacon) {
            Beacon beacon = (Beacon) source;
            return new BeaconWithPowerAndLocated3D(beacon.getIdentifiers(),
                    getEstimatedTransmittedPowerdBm(), beacon.getFrequency(),
                    beacon.getBluetoothAddress(), beacon.getBeaconTypeCode(),
                    beacon.getManufacturer(), beacon.getServiceUuid(),
                    beacon.getBluetoothName(),
                    getEstimatedPathLossExponent(),
                    transmittedPowerStandardDeviation,
                    pathlossExponentStandardDeviation,
                    estimatedPosition, estimatedPositionCovariance);
        }else {
            return null;
        }
    }</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/PROMedSRobustMixedPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROMedSRobustMixedPositionEstimator3D.html#L361">361</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/PROMedSRobustRangingAndRssiPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROMedSRobustRangingAndRssiPositionEstimator3D.html#L361">361</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/PROMedSRobustRangingPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROMedSRobustRangingPositionEstimator3D.html#L360">360</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/PROMedSRobustRssiPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROMedSRobustRssiPositionEstimator3D.html#L364">364</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>        internalSetFingerprintReadingsQualityScores(fingerprintReadingsQualityScores);
    }

    /**
     * Returns quality scores corresponding to each radio source.
     * The larger the score value the better the quality of the sample.
     *
     * @return quality scores corresponding to each radio source.
     */
    public double[] getSourceQualityScores() {
        return mSourceQualityScores;
    }

    /**
     * Sets quality scores corresponding to each radio source.
     * The larger the score value the better the quality of the radio source.
     *
     * @param sourceQualityScores quality scores corresponding to each radio source.
     * @throws LockedException          if this instance is locked.
     * @throws IllegalArgumentException if provided quality scores length is smaller
     *                                  than minimum required samples.
     */
    public void setSourceQualityScores(double[] sourceQualityScores)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetSourceQualityScores(sourceQualityScores);
    }

    /**
     * Gets quality scores corresponding to each reading within provided fingerprint.
     * The larger the score value the better the quality of the reading.
     * This implementation always returns null.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @return quality scores corresponding to each reading within provided
     * fingerprint.
     */
    public double[] getFingerprintReadingsQualityScores() {
        return mFingerprintReadingsQualityScores;
    }

    /**
     * Sets quality scores corresponding to each reading within provided fingerprint.
     * The larger the score value the better the quality of the reading.
     * This implementation makes no action.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @param fingerprintReadingsQualityScores quality scores corresponding to each
     *                                         reading within provided fingerprint.
     * @throws LockedException          if this instance is locked.
     * @throws IllegalArgumentException if provided quality scores length is smaller
     *                                  than minimum required samples.
     */
    public void setFingerprintReadingsQualityScores(
            double[] fingerprintReadingsQualityScores) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetFingerprintReadingsQualityScores(fingerprintReadingsQualityScores);
    }

    /**
     * Returns threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value, the
     * algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algrithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @return stop threshold to stop the algorithm prematurely when a certain
     * accuracy has been reached.
     */
    public double getStopThreshold() {
        return ((PROMedSRobustLateration3DSolver) mLaterationSolver).
                getStopThreshold();
    }

    /**
     * Sets threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value,
     * the algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algorithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @param stopThreshold stop threshold to stop the algorithm prematurely
     *                      when a certain accuracy has been reached.
     * @throws IllegalArgumentException if provided value is zero or negative.
     * @throws LockedException if this solver is locked.
     */
    public void setStopThreshold(double stopThreshold) throws LockedException {
        ((PROMedSRobustLateration3DSolver) mLaterationSolver).
                setStopThreshold(stopThreshold);
    }

    /**
     * Returns method being used for robust estimation.
     * @return method being used for robust estimation.
     */
    @Override
    public RobustEstimatorMethod getMethod() {
        return RobustEstimatorMethod.PROMedS;
    }

    /**
     * Initializes robust lateration solver.
     */
    private void init() {
        mLaterationSolver = new PROMedSRobustLateration3DSolver(
                mTrilaterationSolverListener);
    }

    /**
     * Sets quality scores corresponding to each provided located radio source.
     * This method is used internally and does not check whether instance is
     * locked or not.
     * @param sourceQualityScores quality scores to be set.
     * @throws IllegalArgumentException if provided quality scores length
     * is smaller than 3 samples.
     */
    private void internalSetSourceQualityScores(double[] sourceQualityScores) {
        if (sourceQualityScores == null ||
                sourceQualityScores.length &lt; getMinRequiredSources()) {
            throw new IllegalArgumentException();
        }

        mSourceQualityScores = sourceQualityScores;

        buildPositionsDistancesDistanceStandardDeviationsAndQualityScores();
    }

    /**
     * Sets quality scores corresponding to each provided reading within provided
     * fingerprint.
     * This method is used internally and does not check whether instance is locked
     * or not.
     * @param fingerprintReadingsQualityScores quality scores to be set.
     * @throws IllegalArgumentException if provided quality scores lengt is
     * smaller than 3 samples.
     */
    private void internalSetFingerprintReadingsQualityScores(
            double[] fingerprintReadingsQualityScores) {
        if (fingerprintReadingsQualityScores == null ||
                fingerprintReadingsQualityScores.length &lt; getMinRequiredSources()) {
            throw new IllegalArgumentException();
        }

        mFingerprintReadingsQualityScores = fingerprintReadingsQualityScores;

        buildPositionsDistancesDistanceStandardDeviationsAndQualityScores();
    }
}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator.html#L443">443</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustMixedRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustMixedRadioSourceEstimator.html#L1597">1597</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator.html#L1580">1580</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    }

    /**
     * Gets initial transmitted power to start the estimation of radio source
     * transmitted power (expressed in dBm's).
     * If not defined, average value of received power readings will be used.
     * @return initial transmitted power to start the estimation of radio source
     * transmitted power.
     */
    public Double getInitialTransmittedPowerdBm() {
        return mInitialTransmittedPowerdBm;
    }

    /**
     * Sets initial transmitted power to start the estimation of radio source
     * transmitted power (expressed in dBm's).
     * If not defined, average value of received power readings will be used.
     * @param initialTransmittedPowerdBm initial transmitted power to start the
     *                                   estimation of radio source transmitted
     *                                   power.
     * @throws LockedException if estimator is locked.
     */
    public void setInitialTransmittedPowerdBm(Double initialTransmittedPowerdBm)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mInitialTransmittedPowerdBm = initialTransmittedPowerdBm;
    }

    /**
     * Gets initial transmitted power to start the estimation of radio source
     * transmitted power (expressed in mW).
     * If not defined, average value of received power readings will be used.
     * @return initial transmitted power to start the estimation of radio source
     * transmitted power.
     */
    public Double getInitialTransmittedPower() {
        return mInitialTransmittedPowerdBm != null ?
                Utils.dBmToPower(mInitialTransmittedPowerdBm) : null;
    }

    /**
     * Sets initial transmitted power to start the estimation of radio source
     * transmitted power (expressed in mW).
     * If not defined, average value of received power readings will be used.
     * @param initialTransmittedPower initial transmitted power to start the
     *                                estimation of radio source transmitted power.
     * @throws LockedException if estimator is locked.
     * @throws IllegalArgumentException if provided value is negative.
     */
    public void setInitialTransmittedPower(Double initialTransmittedPower)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (initialTransmittedPower != null) {
            if (initialTransmittedPower &lt; 0.0) {
                throw new IllegalArgumentException();
            }
            mInitialTransmittedPowerdBm = Utils.powerTodBm(
                    initialTransmittedPower);
        } else {
            mInitialTransmittedPowerdBm = null;
        }
    }

    /**
     * Gets initial position to start the estimation of radio source position.
     * If not defined, centroid of provided fingerprints will be used.
     * @return initial position to start the estimation of radio source position.
     */
    public P getInitialPosition() {
        return mInitialPosition;
    }

    /**
     * Sets initial position to start the estimation of radio source position.
     * If not defined, centroid of provided fingerprints will be used.
     * @param initialPosition initial position to start the estimation of radio
     *                        source position.
     * @throws LockedException if estimator is locked.
     */
    public void setInitialPosition(P initialPosition) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mInitialPosition = initialPosition;
    }

    /**
     * Gets initial exponent typically used on free space for path loss propagation
     * in terms of distance.
     * On different environments path loss exponent might have different value:
     * - Free space: 2.0
     * - Urban Area: 2.7 to 3.5
     * - Suburban Area: 3 to 5
     * - Indoor (line-of-sight): 1.6 to 1.8
     *
     * If path loss exponent estimation is enabled, estimation will start at this
     * value and will converge to the most appropriate value.
     * If path loss exponent estimation is disabled, this value will be assumed
     * to be exact and the estimated path loss exponent will be equal to this
     * value.
     * @return initial path loss exponent.
     */
    public double getInitialPathLossExponent() {
        return mInitialPathLossExponent;
    }

    /**
     * Sets initial exponent typically used on free space for path loss propagation
     * in terms of distance.
     * On different environments path loss exponent might have different value:
     * - Free space: 2.0
     * - Urban Area: 2.7 to 3.5
     * - Suburban Area: 3 to 5
     * - Indoor (line-of-sight): 1.6 to 1.8
     *
     * If path loss exponent estimation is enabled, estimation will start at this
     * value and will converge to the most appropriate value.
     * If path loss exponent estimation is disabled, this value will be assumed
     * to be exact and the estimated path loss exponent will be equal to this
     * value.
     * @param initialPathLossExponent initial path loss exponent.
     * @throws LockedException if estimator is locked.
     */
    public void setInitialPathLossExponent(double initialPathLossExponent)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mInitialPathLossExponent = initialPathLossExponent;
    }

    /**
     * Indicates whether transmitted power estimation is enabled or not.
     * @return true if transmitted power estimation is enabled, false otherwise.
     */
    public boolean isTransmittedPowerEstimationEnabled() {
        return mTransmittedPowerEstimationEnabled;
    }

    /**
     * Specifies whether transmitted power estimation is enabled or not.
     * @param transmittedPowerEstimationEnabled true if transmitted power estimation is enabled,
     *                                          false otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setTransmittedPowerEstimationEnabled(boolean transmittedPowerEstimationEnabled)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mTransmittedPowerEstimationEnabled = transmittedPowerEstimationEnabled;
    }

    /**
     * Indicates whether radio source position estimation is enabled or not.
     * @return true if position estimation is enabled, false otherwise.
     */
    public boolean isPositionEstimationEnabled() {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/estimators/ECEFKinematicsEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/estimators/ECEFKinematicsEstimator.html#L1312">1312</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/estimators/ECEFKinematicsEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/estimators/ECEFKinematicsEstimator.html#L1357">1357</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/estimators/ECIKinematicsEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/estimators/ECIKinematicsEstimator.html#L1197">1197</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/estimators/ECIKinematicsEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/estimators/ECIKinematicsEstimator.html#L1242">1242</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    public static void estimateKinematics(final double timeInterval,
                                          final CoordinateTransformation c,
                                          final CoordinateTransformation oldC,
                                          final Speed vx, final Speed vy, final Speed vz,
                                          final Speed oldVx, final Speed oldVy, final Speed oldVz,
                                          final double x, final double y, final double z,
                                          final BodyKinematics result) {
        estimateKinematics(timeInterval, c, oldC,
                SpeedConverter.convert(vx.getValue().doubleValue(), vx.getUnit(), SpeedUnit.METERS_PER_SECOND),
                SpeedConverter.convert(vy.getValue().doubleValue(), vy.getUnit(), SpeedUnit.METERS_PER_SECOND),
                SpeedConverter.convert(vz.getValue().doubleValue(), vz.getUnit(), SpeedUnit.METERS_PER_SECOND),
                SpeedConverter.convert(oldVx.getValue().doubleValue(), oldVx.getUnit(), SpeedUnit.METERS_PER_SECOND),
                SpeedConverter.convert(oldVy.getValue().doubleValue(), oldVy.getUnit(), SpeedUnit.METERS_PER_SECOND),
                SpeedConverter.convert(oldVz.getValue().doubleValue(), oldVz.getUnit(), SpeedUnit.METERS_PER_SECOND),
                x, y, z, result);
    }

    /**
     * Estimates body kinematics (specific force applied to a body and its angular rates).
     *
     * @param timeInterval time interval between epochs.
     * @param c            body-to-ECEF frame coordinate transformation matrix.
     * @param oldC         previous body-to-ECEF-frame coordinate transformation matrix.
     * @param vx           velocity of body frame x coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param vy           velocity of body frame y coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param vz           velocity of body frame z coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param oldVx        previous velocity of body frame x coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldVy        previous velocity of body frame y coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldVz        previous velocity of body frame z coordinate with respect ECEF
     *                     frame, resolved along EVEF-frame axes.
     * @param x            cartesian x coordinate of body position expressed in meters (m)
     *                     with respect ECEF frame, resolved along ECEF-frame axes.
     * @param y            cartesian y coordinate of body position expressed in meters (m)
     *                     with respect ECEF frame, resolved along ECEF-frame axes.
     * @param z            cartesian z coordinate of body position expressed in meters (m)
     *                     with respect ECEF frame, resolved along ECEF-frame axes.
     * @param result       instance where body kinematics estimation will be stored.
     * @throws IllegalArgumentException if provided time interval is negative or coordinated transformation matrices
     *                                  are not ECEF frame valid.
     */
    public static void estimateKinematics(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/estimators/ECEFKinematicsEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/estimators/ECEFKinematicsEstimator.html#L1764">1764</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/estimators/ECIKinematicsEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/estimators/ECIKinematicsEstimator.html#L1617">1617</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>                                                                final ECEFFrame frame, final ECEFFrame oldFrame) {
        final BodyKinematics result = new BodyKinematics();
        estimateKinematics(timeInterval, frame, oldFrame, result);
        return result;
    }

    /**
     * Estimates body kinematics (specific force applied to a body and its angular rates).
     *
     * @param timeInterval time interval between epochs expressed in seconds (s).
     * @param c            body-to-ECEF frame coordinate transformation matrix.
     * @param oldC         previous body-to-ECEF-frame coordinate transformation matrix.
     * @param vx           velocity of body frame x coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param vy           velocity of body frame y coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param vz           velocity of body frame z coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param oldVx        previous velocity of body frame x coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldVy        previous velocity of body frame y coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldVz        previous velocity of body frame z coordinate with respect ECEF
     *                     frame, resolved along EVEF-frame axes.
     * @param x            cartesian x coordinate of body position expressed in meters (m)
     *                     with respect ECEF frame, resolved along ECEF-frame axes.
     * @param y            cartesian y coordinate of body position expressed in meters (m)
     *                     with respect ECEF frame, resolved along ECEF-frame axes.
     * @param z            cartesian z coordinate of body position expressed in meters (m)
     *                     with respect ECEF frame, resolved along ECEF-frame axes.
     * @return a new body kinematics instance.
     * @throws IllegalArgumentException if provided time interval is negative or coordinated transformation matrices
     *                                  are not ECEF frame valid.
     */
    public static BodyKinematics estimateKinematicsAndReturnNew(final double timeInterval,
                                                                final CoordinateTransformation c,
                                                                final CoordinateTransformation oldC,
                                                                final Speed vx, final Speed vy, final Speed vz,
                                                                final Speed oldVx, final Speed oldVy, final Speed oldVz,
                                                                final double x, final double y, final double z) {
        final BodyKinematics result = new BodyKinematics();
        estimateKinematics(timeInterval, c, oldC, vx, vy, vz, oldVx, oldVy, oldVz,
                x, y, z, result);
        return result;
    }

    /**
     * Estimates body kinematics (specific force applied to a body and its angular rates).
     *
     * @param timeInterval time interval between epochs.
     * @param c            body-to-ECEF frame coordinate transformation matrix.
     * @param oldC         previous body-to-ECEF-frame coordinate transformation matrix.
     * @param vx           velocity of body frame x coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param vy           velocity of body frame y coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param vz           velocity of body frame z coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param oldVx        previous velocity of body frame x coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldVy        previous velocity of body frame y coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldVz        previous velocity of body frame z coordinate with respect ECEF
     *                     frame, resolved along EVEF-frame axes.
     * @param x            cartesian x coordinate of body position expressed in meters (m)
     *                     with respect ECEF frame, resolved along ECEF-frame axes.
     * @param y            cartesian y coordinate of body position expressed in meters (m)
     *                     with respect ECEF frame, resolved along ECEF-frame axes.
     * @param z            cartesian z coordinate of body position expressed in meters (m)
     *                     with respect ECEF frame, resolved along ECEF-frame axes.
     * @return a new body kinematics instance.
     * @throws IllegalArgumentException if provided time interval is negative or coordinated transformation matrices
     *                                  are not ECEF frame valid.
     */
    public static BodyKinematics estimateKinematicsAndReturnNew(final Time timeInterval,
                                                                final CoordinateTransformation c,
                                                                final CoordinateTransformation oldC,
                                                                final Speed vx, final Speed vy, final Speed vz,
                                                                final Speed oldVx, final Speed oldVy, final Speed oldVz,
                                                                final double x, final double y, final double z) {
        final BodyKinematics result = new BodyKinematics();
        estimateKinematics(timeInterval, c, oldC, vx, vy, vz, oldVx, oldVy, oldVz,
                x, y, z, result);
        return result;
    }

    /**
     * Estimates body kinematics (specific force applied to a body and its angular rates).
     *
     * @param timeInterval time interval between epochs expressed in seconds (s).
     * @param frame        body ECEF frame containing current position, velocity and
     *                     body-to-ECEF frame coordinate transformation.
     * @param oldC         previous body-to-ECEF-frame coordinate transformation matrix.
     * @param oldVx        previous velocity of body frame x coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldVy        previous velocity of body frame y coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldVz        previous velocity of body frame z coordinate with respect ECEF
     *                     frame, resolved along EVEF-frame axes.
     * @return a new body kinematics instance.
     * @throws IllegalArgumentException if provided time interval is negative or coordinated transformation matrices
     *                                  are not ECEF frame valid.
     */
    public static BodyKinematics estimateKinematicsAndReturnNew(final double timeInterval,
                                                                final ECEFFrame frame,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/RobustMixedPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/RobustMixedPositionEstimator2D.html#L973">973</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/RobustRangingAndRssiPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/RobustRangingAndRssiPositionEstimator2D.html#L969">969</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/RobustRangingPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/RobustRangingPositionEstimator2D.html#L977">977</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/RobustRssiPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/RobustRssiPositionEstimator2D.html#L969">969</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>            RobustMixedPositionEstimatorListener&lt;Point2D&gt; listener) {
        return create(sourceQualityScores, fingerprintReadingQualityScores,
                sources, fingerprint, listener, DEFAULT_ROBUST_METHOD);
    }

    /**
     * Sets positions, distances and standard deviations of distances on internal
     * lateration solver.
     *
     * @param positions                     positions to be set.
     * @param distances                     distances to be set.
     * @param distanceStandardDeviations    standard deviations of distances to be set.
     * @param distanceQualityScores         distance quality scores or null if not
     *                                      required.
     */
    @Override
    protected void setPositionsDistancesDistanceStandardDeviationsAndQualityScores(
            List&lt;Point2D&gt; positions, List&lt;Double&gt; distances,
            List&lt;Double&gt; distanceStandardDeviations,
            List&lt;Double&gt; distanceQualityScores) {
        int size = positions.size();
        Point2D[] positionsArray = new InhomogeneousPoint2D[size];
        positionsArray = positions.toArray(positionsArray);

        double[] distancesArray = new double[size];
        double[] distanceStandardDeviationsArray = new double[size];

        double[] qualityScoresArray = null;
        if (distanceQualityScores != null) {
            qualityScoresArray = new double[size];
        }

        for (int i = 0; i &lt; size; i++) {
            distancesArray[i] = distances.get(i);
            distanceStandardDeviationsArray[i] = distanceStandardDeviations.get(i);

            if (qualityScoresArray != null) {
                qualityScoresArray[i] = distanceQualityScores.get(i);
            }
        }

        try {
            mLaterationSolver.setPositionsDistancesAndStandardDeviations(
                    positionsArray, distancesArray, distanceStandardDeviationsArray);

            if (qualityScoresArray != null) {
                mLaterationSolver.setQualityScores(qualityScoresArray);
            }
        } catch (LockedException e) {
            throw new IllegalArgumentException(e);
        }
    }
}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/RobustRangingAndRssiPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/RobustRangingAndRssiPositionEstimator3D.html#L969">969</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/RobustRssiPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/RobustRssiPositionEstimator3D.html#L969">969</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>            RobustRangingAndRssiPositionEstimatorListener&lt;Point3D&gt; listener) {
        return create(sourceQualityScores, fingerprintReadingQualityScores,
                sources, fingerprint, listener, DEFAULT_ROBUST_METHOD);
    }

    /**
     * Sets positions, distances and standard deviations of distances on internal
     * lateration solver.
     *
     * @param positions                     positions to be set.
     * @param distances                     distances to be set.
     * @param distanceStandardDeviations    standard deviations of distances to be set.
     * @param distanceQualityScores         distance quality scores or null if not
     *                                      required.
     */
    @Override
    protected void setPositionsDistancesDistanceStandardDeviationsAndQualityScores(
            List&lt;Point3D&gt; positions, List&lt;Double&gt; distances,
            List&lt;Double&gt; distanceStandardDeviations,
            List&lt;Double&gt; distanceQualityScores) {
        int size = positions.size();
        Point3D[] positionsArray = new InhomogeneousPoint3D[size];
        positionsArray = positions.toArray(positionsArray);

        double[] distancesArray = new double[size];
        double[] distanceStandardDeviationsArray = new double[size];

        double[] qualityScoresArray = null;
        if (distanceQualityScores != null) {
            qualityScoresArray = new double[size];
        }

        for (int i = 0; i &lt; size; i++) {
            distancesArray[i] = distances.get(i);
            distanceStandardDeviationsArray[i] = distanceStandardDeviations.get(i);

            if (qualityScoresArray != null) {
                qualityScoresArray[i] = distanceQualityScores.get(i);
            }
        }

        try {
            mLaterationSolver.setPositionsDistancesAndStandardDeviations(
                    positionsArray, distancesArray, distanceStandardDeviationsArray);

            if (qualityScoresArray != null) {
                mLaterationSolver.setQualityScores(qualityScoresArray);
            }
        } catch (LockedException e) {
            throw new IllegalArgumentException(e);
        }
    }
}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/MixedRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MixedRadioSourceEstimator.html#L494">494</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RangingAndRssiRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RangingAndRssiRadioSourceEstimator.html#L484">484</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RssiRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RssiRadioSourceEstimator.html#L486">486</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>            MixedRadioSourceEstimatorListener&lt;S, P&gt; listener) {
        this(readings, initialPosition, initialTransmittedPowerdBm, listener);
        mInitialPathLossExponent = initialPathLossExponent;
    }

    /**
     * Gets initial transmitted power to start the estimation of radio source
     * transmitted power (expressed in dBm's).
     * If not defined, average value of received power readings will be used.
     *
     * If transmitted power estimation is enabled, estimation will start at this
     * value and will converte the most appropriate value.
     * If transmitted power estimation is disabled, this value will be assumed to be
     * exact and the estimated transmitted power will be equal to this value
     * (converted to dBm's).
     * @return initial transmitted power to start the estimation of radio source
     * transmitted power.
     */
    public Double getInitialTransmittedPowerdBm() {
        return mInitialTransmittedPowerdBm;
    }

    /**
     * Sets initial transmitted power to start the estimation of radio source
     * transmitted power (expressed in dBm's).
     * If not defined, average value of received power readings will be used.
     *
     * If transmitted power estimation is enabled, estimation will start at this
     * value and will converte the most appropriate value.
     * If transmitted power estimation is disabled, this value will be assumed to be
     * exact and the estimated transmitted power will be equal to this value
     * (converted to dBm's).
     * @param initialTransmittedPowerdBm initial transmitted power to start the
     *                                   estimation of radio source transmitted
     *                                   power.
     * @throws LockedException if estimator is locked.
     */
    public void setInitialTransmittedPowerdBm(Double initialTransmittedPowerdBm)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mInitialTransmittedPowerdBm = initialTransmittedPowerdBm;
    }

    /**
     * Gets initial transmitted power to start the estimation of radio source
     * transmitted power (expressed in mW).
     * If not defined, average value of received power readings will be used.
     *
     * If transmitted power estimation is enabled, estimation will start at this
     * value and will converte the most appropriate value.
     * If transmitted power estimation is disabled, this value will be assumed to be
     * exact and the estimated transmitted power will be equal to this value
     * (converted to dBm's).
     * @return initial transmitted power to start the estimation of radio source
     * transmitted power.
     */
    public Double getInitialTransmittedPower() {
        return mInitialTransmittedPowerdBm != null ?
                Utils.dBmToPower(mInitialTransmittedPowerdBm) : null;
    }

    /**
     * Sets initial transmitted power to start the estimation of radio source
     * transmitted power (expressed in mW).
     * If not defined, average value of received power readings will be used.
     *
     * If transmitted power estimation is enabled, estimation will start at this
     * value and will converte the most appropriate value.
     * If transmitted power estimation is disabled, this value will be assumed to be
     * exact and the estimated transmitted power will be equal to this value
     * (converted to dBm's).
     * @param initialTransmittedPower initial transmitted power to start the
     *                                estimation of radio source transmitted power.
     * @throws LockedException if estimator is locked.
     * @throws IllegalArgumentException if provided value is negative.
     */
    public void setInitialTransmittedPower(Double initialTransmittedPower)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (initialTransmittedPower != null) {
            if (initialTransmittedPower &lt; 0.0) {
                throw new IllegalArgumentException();
            }
            mInitialTransmittedPowerdBm = Utils.powerTodBm(
                    initialTransmittedPower);
        } else {
            mInitialTransmittedPowerdBm = null;
        }
    }

    /**
     * Indicates whether transmitted power estimation is enabled or not.
     * @return true if transmitted power estimation is enabled, false otherwise.
     */
    public boolean isTransmittedPowerEstimationEnabled() {
        return mTransmittedPowerEstimationEnabled;
    }

    /**
     * Specifies whether transmitted power estimation is enabled or not.
     * @param transmittedPowerEstimationEnabled true if transmitted power estimation is enabled,
     *                                          false otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setTransmittedPowerEstimationEnabled(boolean transmittedPowerEstimationEnabled)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mTransmittedPowerEstimationEnabled = transmittedPowerEstimationEnabled;
    }

    /**
     * Gets initial position to start the estimation of radio source position.
     * If not defined, centroid of provided readings will be used.
     *
     * If position estimation is enabled, estimation will start at this value
     * and will converge to the most appropriate value.
     * If position estimation is disabled, this value will be assumed to
     * be exact and the estimated position will be equal to this value.
     * @return initial position to start the estimation of radio source position.
     */
    public P getInitialPosition() {
        return mInitialPosition;
    }

    /**
     * Sets initial position to start the estimation of radio source position.
     * If not defined, centroid of provided fingerprints will be used.
     *
     * If position estimation is enabled, estimation will start at this value
     * and will converge to the most appropriate value.
     * If position estimation is disabled, this value will be assumed to
     * be exact and the estimated position will be equal to this value.
     * @param initialPosition initial position to start the estimation of radio
     *                        source position.
     * @throws LockedException if estimator is locked.
     */
    public void setInitialPosition(P initialPosition) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mInitialPosition = initialPosition;
    }

    /**
     * Gets initial exponent typically used on free space for path loss propagation
     * in terms of distance.
     * On different environments path loss exponent might have different value:
     * - Free space: 2.0
     * - Urban Area: 2.7 to 3.5
     * - Suburban Area: 3 to 5
     * - Indoor (line-of-sight): 1.6 to 1.8
     *
     * If path loss exponent estimation is enabled, estimation will start at this
     * value and will converge to the most appropriate value.
     * If path loss exponent estimation is disabled, this value will be assumed
     * to be exact and the estimated path loss exponent will be equal to this
     * value.
     * @return initial path loss exponent.
     */
    public double getInitialPathLossExponent() {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/NonLinearMixedPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/NonLinearMixedPositionEstimator2D.html#L287">287</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/NonLinearRangingAndRssiPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/NonLinearRangingAndRssiPositionEstimator2D.html#L286">286</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/NonLinearRangingPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/NonLinearRangingPositionEstimator2D.html#L287">287</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>            MixedPositionEstimatorListener&lt;Point2D&gt; listener) {
        super(initialPosition, listener);
        init();
        internalSetSources(sources);
        internalSetFingerprint(fingerprint);
    }

    /**
     * Gets estimated position.
     *
     * @return estimated position.
     */
    public Point2D getEstimatedPosition() {
        if (mEstimatedPositionCoordinates == null) {
            return null;
        }

        InhomogeneousPoint2D result = new InhomogeneousPoint2D();
        getEstimatedPosition(result);
        return result;
    }

    /**
     * Sets positions, distances and standard deviations of distances on internal
     * lateration solver.
     *
     * @param positions positions to be set.
     * @param distances distances to be set.
     * @param distanceStandardDeviations standard deviations of distances to be set.
     */
    @Override
    @SuppressWarnings(&quot;Duplicates&quot;)
    protected void setPositionsDistancesAndDistanceStandardDeviations(
            List&lt;Point2D&gt; positions, List&lt;Double&gt; distances,
            List&lt;Double&gt; distanceStandardDeviations) {

        int size = positions.size();
        Point2D[] positionsArray = new InhomogeneousPoint2D[size];
        positionsArray = positions.toArray(positionsArray);

        double[] distancesArray = new double[size];
        double[] distanceStandardDeviationsArray = new double[size];
        for (int i = 0; i &lt; size; i++) {
            distancesArray[i] = distances.get(i);
            distanceStandardDeviationsArray[i] = distanceStandardDeviations.get(i);
        }

        try {
            mTrilaterationSolver.setPositionsDistancesAndStandardDeviations(
                    positionsArray, distancesArray, distanceStandardDeviationsArray);
        } catch (LockedException e) {
            throw new IllegalArgumentException(e);
        }
    }

    /**
     * Initializes lateration solver.
     */
    private void init() {
        mTrilaterationSolver = new NonLinearLeastSquaresLateration2DSolver(
                mLaterationSolverListener);
    }
}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/NonLinearMixedPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/NonLinearMixedPositionEstimator3D.html#L290">290</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/NonLinearRangingAndRssiPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/NonLinearRangingAndRssiPositionEstimator3D.html#L290">290</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/NonLinearRangingPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/NonLinearRangingPositionEstimator3D.html#L287">287</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>            MixedPositionEstimatorListener&lt;Point3D&gt; listener) {
        super(initialPosition, listener);
        init();
        internalSetSources(sources);
        internalSetFingerprint(fingerprint);
    }

    /**
     * Gets estimated position.
     *
     * @return estimated position.
     */
    public Point3D getEstimatedPosition() {
        if (mEstimatedPositionCoordinates == null) {
            return null;
        }

        InhomogeneousPoint3D result = new InhomogeneousPoint3D();
        getEstimatedPosition(result);
        return result;
    }

    /**
     * Sets positions, distances and standard deviations of distances on internal
     * lateration solver.
     *
     * @param positions positions to be set.
     * @param distances distances to be set.
     * @param distanceStandardDeviations standard deviations of distances to be set.
     */
    @Override
    @SuppressWarnings(&quot;Duplicates&quot;)
    protected void setPositionsDistancesAndDistanceStandardDeviations(
            List&lt;Point3D&gt; positions, List&lt;Double&gt; distances,
            List&lt;Double&gt; distanceStandardDeviations) {

        int size = positions.size();
        Point3D[] positionsArray = new InhomogeneousPoint3D[size];
        positionsArray = positions.toArray(positionsArray);

        double[] distancesArray = new double[size];
        double[] distanceStandardDeviationsArray = new double[size];
        for (int i = 0; i &lt; size; i++) {
            distancesArray[i] = distances.get(i);
            distanceStandardDeviationsArray[i] = distanceStandardDeviations.get(i);
        }

        try {
            mTrilaterationSolver.setPositionsDistancesAndStandardDeviations(
                    positionsArray, distancesArray, distanceStandardDeviationsArray);
        } catch (LockedException e) {
            throw new IllegalArgumentException(e);
        }
    }

    /**
     * Initializes lateration solver.
     */
    private void init() {
        mTrilaterationSolver = new NonLinearLeastSquaresLateration3DSolver(
                mLaterationSolverListener);
    }
}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/lateration/PROSACRobustLateration2DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/PROSACRobustLateration2DSolver.html#L379">379</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/lateration/PROSACRobustLateration3DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/PROSACRobustLateration3DSolver.html#L379">379</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>        super(circles, distanceStandardDeviations, listener);
        internalSetQualityScores(qualityScores);
    }

    /**
     * Gets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on distance between estimated position and distances
     * provided for each sample.
     * @return threshold to determine whether samples are inliers or not.
     */
    public double getThreshold() {
        return mThreshold;
    }

    /**
     * Sets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on distance between estimated position and distances
     * provided for each sample.
     * @param threshold threshold to determine whether samples are inliers or not.
     * @throws IllegalArgumentException if provided value is equal or less than zero.
     * @throws LockedException if this solver is locked.
     */
    public void setThreshold(double threshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (threshold &lt;= MIN_THRESHOLD) {
            throw new IllegalArgumentException();
        }
        mThreshold = threshold;
    }

    /**
     * Returns quality scores corresponding to each pair of
     * positions and distances (i.e. sample).
     * The larger the score value the better the quality of the sample.
     * @return quality scores corresponding to each sample.
     */
    @Override
    public double[] getQualityScores() {
        return mQualityScores;
    }

    /**
     * Sets quality scores corresponding to each pair of positions and
     * distances (i.e. sample).
     * The larger the score value the better the quality of the sample.
     * @param qualityScores quality scores corresponding to each pair of
     *                      matched points.
     * @throws IllegalArgumentException if provided quality scores length
     * is smaller than minimum required samples.
     * @throws LockedException if robust solver is locked because an
     * estimation is already in progress.
     */
    @Override
    public void setQualityScores(double[] qualityScores)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetQualityScores(qualityScores);
    }

    /**
     * Indicates whether solver is ready to find a solution.
     * @return true if solver is ready, false otherwise.
     */
    @Override
    public boolean isReady() {
        return super.isReady() &amp;&amp; mQualityScores != null &amp;&amp;
                mQualityScores.length == mDistances.length;
    }

    /**
     * Indicates whether inliers must be computed and kept.
     * @return true if inliers must be computed and kept, false if inliers
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepInliersEnabled() {
        return mComputeAndKeepInliers;
    }

    /**
     * Specifies whether inliers must be computed and kept.
     * @param computeAndKeepInliers true if inliers must be computed and kept,
     *                              false if inliers only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepInliersEnabled(boolean computeAndKeepInliers)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mComputeAndKeepInliers = computeAndKeepInliers;
    }

    /**
     * Indicates whether residuals must be computed and kept.
     * @return true if residuals must be computed and kept, false if residuals
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepResiduals() {
        return mComputeAndKeepResiduals;
    }

    /**
     * Specifies whether residuals must be computed and kept.
     * @param computeAndKeepResiduals true if residuals must be computed and kept,
     *                                false if residuals only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepResidualsEnabled(boolean computeAndKeepResiduals)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mComputeAndKeepResiduals = computeAndKeepResiduals;
    }

    /**
     * Solves the lateration problem.
     * @return estimated position.
     * @throws LockedException if instance is busy solving the lateration problem.
     * @throws NotReadyException is solver is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     * (i.e. numerical instability, no solution available, etc).
     */
    @Override
    public Point2D solve() throws LockedException, NotReadyException,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/lateration/RobustLateration2DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/RobustLateration2DSolver.html#L1248">1248</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/lateration/RobustLateration3DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/RobustLateration3DSolver.html#L1247">1247</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>            Point2D[] inlierPositions = new Point2D[nInliers];
            double[] inlierDistances = new double[nInliers];
            double[] inlierStandardDeviations = null;
            if (mDistanceStandardDeviations != null) {
                inlierStandardDeviations = new double[nInliers];
            }
            int pos = 0;
            for (int i = 0; i &lt; nSamples; i++) {
                if (inliers.get(i)) {
                    //sample is inlier
                    inlierPositions[pos] = mPositions[i];
                    inlierDistances[pos] = mDistances[i];
                    if (inlierStandardDeviations != null) {
                        inlierStandardDeviations[pos] = mDistanceStandardDeviations[i];
                    }
                    pos++;
                }
            }

            try {
                mNonLinearSolver.setInitialPosition(position);
                if (inlierStandardDeviations != null) {
                    mNonLinearSolver.setPositionsDistancesAndStandardDeviations(
                            inlierPositions, inlierDistances, inlierStandardDeviations);
                } else {
                    mNonLinearSolver.setPositionsAndDistances(
                            inlierPositions, inlierDistances);
                }
                mNonLinearSolver.solve();

                if (mKeepCovariance) {
                    //keep covariance
                    mCovariance = mNonLinearSolver.getCovariance();
                } else {
                    mCovariance = null;
                }

                mEstimatedPosition = mNonLinearSolver.getEstimatedPosition();
            } catch (Exception e) {
                //refinement failed, so we return input value
                mCovariance = null;
                mEstimatedPosition = position;
            }
        } else {
            mCovariance = null;
            mEstimatedPosition = position;
        }

        return mEstimatedPosition;
    }

    /**
     * Solves a preliminar solution for a subset of samples picked by a robust estimator.
     * @param samplesIndices indices of samples picked by the robust estimator.
     * @param solutions list where estimated preliminar solution will be stored.
     */
    protected void solvePreliminarSolutions(int[] samplesIndices, List&lt;Point2D&gt; solutions) {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/estimators/ECEFKinematicsEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/estimators/ECEFKinematicsEstimator.html#L51">51</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/estimators/ECIKinematicsEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/estimators/ECIKinematicsEstimator.html#L45">45</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    private static final double SCALING_THRESHOLD = 2e-5;

    /**
     * Alpha threshold.
     */
    private static final double ALPHA_THRESHOLD = 1e-8;

    /**
     * Number of rows.
     */
    private static final int ROWS = 3;

    /**
     * Estimates body kinematics (specific force applied to a body and its angular rates).
     *
     * @param timeInterval time interval between epochs expressed in seconds (s).
     * @param c            body-to-ECEF frame coordinate transformation matrix.
     * @param oldC         previous body-to-ECEF-frame coordinate transformation matrix.
     * @param vx           velocity of body frame x coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per
     *                     second (m/s).
     * @param vy           velocity of body frame y coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per
     *                     second (m/s).
     * @param vz           velocity of body frame z coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per
     *                     second (m/s).
     * @param oldVx        previous velocity of body frame x coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters
     *                     per second (m/s).
     * @param oldVy        previous velocity of body frame y coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters
     *                     per second (m/s).
     * @param oldVz        previous velocity of body frame z coordinate with respect ECEF
     *                     frame, resolved along EVEF-frame axes and expressed in meters
     *                     per second (m/s).
     * @param x            cartesian x coordinate of body position expressed in meters (m)
     *                     with respect ECEF frame, resolved along ECEF-frame axes.
     * @param y            cartesian y coordinate of body position expressed in meters (m)
     *                     with respect ECEF frame, resolved along ECEF-frame axes.
     * @param z            cartesian z coordinate of body position expressed in meters (m)
     *                     with respect ECEF frame, resolved along ECEF-frame axes.
     * @param result       instance where body kinematics estimation will be stored.
     * @throws IllegalArgumentException if provided time interval is negative or coordinated transformation matrices
     *                                  are not ECEF frame valid.
     */
    public void estimate(final double timeInterval,
                         final CoordinateTransformation c,
                         final CoordinateTransformation oldC,
                         final double vx, final double vy, final double vz,
                         final double oldVx, final double oldVy, final double oldVz,
                         final double x, final double y, final double z,
                         final BodyKinematics result) {
        estimateKinematics(timeInterval, c, oldC, vx, vy, vz, oldVx, oldVy, oldVz,
                x, y, z, result);
    }

    /**
     * Estimates body kinematics (specific force applied to a body and its angular rates).
     *
     * @param timeInterval time interval between epochs.
     * @param c            boy-to-ECEF frame coordinate transformation matrix.
     * @param oldC         previous body-to-ECEF-frame coordinate transformation matrix.
     * @param vx           velocity of body frame x coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per
     *                     second (m/s).
     * @param vy           velocity of body frame y coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per
     *                     second (m/s).
     * @param vz           velocity of body frame z coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per
     *                     second (m/s).
     * @param oldVx        previous velocity of body frame x coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters
     *                     per second (m/s).
     * @param oldVy        previous velocity of body frame y coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters
     *                     per second (m/s).
     * @param oldVz        previous velocity of body frame z coordinate with respect ECEF
     *                     frame, resolved along EVEF-frame axes and expressed in meters
     *                     per second (m/s).
     * @param x            cartesian x coordinate of body position expressed in meters (m)
     *                     with respect ECEF frame, resolved along ECEF-frame axes.
     * @param y            cartesian y coordinate of body position expressed in meters (m)
     *                     with respect ECEF frame, resolved along ECEF-frame axes.
     * @param z            cartesian z coordinate of body position expressed in meters (m)
     *                     with respect ECEF frame, resolved along ECEF-frame axes.
     * @param result       instance where body kinematics estimation will be stored.
     * @throws IllegalArgumentException if provided time interval is negative or coordinated transformation matrices
     *                                  are not ECEF frame valid.
     */
    public void estimate(final Time timeInterval,
                         final CoordinateTransformation c,
                         final CoordinateTransformation oldC,
                         final double vx, final double vy, final double vz,
                         final double oldVx, final double oldVy, final double oldVz,
                         final double x, final double y, final double z,
                         final BodyKinematics result) {
        estimateKinematics(timeInterval, c, oldC, vx, vy, vz, oldVx, oldVy, oldVz,
                x, y, z, result);
    }

    /**
     * Estimates body kinematics (specific force applied to a body and its angular rates).
     *
     * @param timeInterval time interval between epochs expressed in seconds (s).
     * @param frame        body ECEF frame containing current position, velocity and
     *                     body-to-ECEF frame coordinate transformation.
     * @param oldC         previous body-to-ECEF-frame coordinate transformation matrix.
     * @param oldVx        previous velocity of body frame x coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters
     *                     per second (m/s).
     * @param oldVy        previous velocity of body frame y coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters
     *                     per second (m/s).
     * @param oldVz        previous velocity of body frame z coordinate with respect ECEF
     *                     frame, resolved along EVEF-frame axes and expressed in meters
     *                     per second (m/s).
     * @param result       instance where body kinematics estimation will be stored.
     * @throws IllegalArgumentException if provided time interval is negative or coordinated transformation matrices
     *                                  are not ECEF frame valid.
     */
    public void estimate(final double timeInterval,
                         final ECEFFrame frame,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/SequentialRobustMixedPositionEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/SequentialRobustMixedPositionEstimator.html#L41">41</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/SequentialRobustRangingAndRssiPositionEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/SequentialRobustRangingAndRssiPositionEstimator.html#L38">38</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>public abstract class SequentialRobustMixedPositionEstimator&lt;P extends Point&gt; {

    /**
     * Default robust estimator method for robust position estimation using ranging
     * data when no robust method is provided.
     */
    public static final RobustEstimatorMethod DEFAULT_RANGING_ROBUST_METHOD =
            RobustEstimatorMethod.PROMedS;

    /**
     * Default robust method for coarse robust position estimation using RSSI
     * data when no robust method is provided.
     */
    public static final RobustEstimatorMethod DEFAULT_RSSI_ROBUST_METHOD =
            RobustEstimatorMethod.PROMedS;

    /**
     * Indicates that by default located radio source position covariance is taken
     * into account (if available) to determine distance standard deviation for ranging
     * measurements.
     */
    public static final boolean DEFAULT_USE_RANGING_RADIO_SOURCE_POSITION_COVARIANCE =
            true;

    /**
     * Indicates that by default located radio source position covariance is taken
     * into account (if available) to determine distance standard deviation for RSSI
     * measurements.
     */
    public static final boolean DEFAULT_USE_RSSI_RADIO_SOURCE_POSITION_COVARIANCE =
            true;

    /**
     * Indicates that by default readings are distributed evenly among radio sources
     * taking into account quality scores of both radio sources and ranging readings.
     */
    public static final boolean DEFAULT_EVENLY_DISTRIBUTE_RANGING_READINGS = true;

    /**
     * Indicates that by default readings are distributed evenly among radio sources
     * taking into account quality scores of both radio sources and RSSI readings.
     */
    public static final boolean DEFAULT_EVENLY_DISTRIBUTE_RSSI_READINGS = true;

    /**
     * Distance standard deviation assumed for provided distances as a fallback when
     * none can be determined.
     */
    public static final double FALLBACK_DISTANCE_STANDARD_DEVIATION =
            RobustPositionEstimator.FALLBACK_DISTANCE_STANDARD_DEVIATION;

    /**
     * Default amount of progress variation before notifying a change in estimation progress.
     * By default this is set to 5%.
     */
    public static final float DEFAULT_PROGRESS_DELTA = 0.05f;

    /**
     * Minimum allowed value for progress delta.
     */
    public static final float MIN_PROGRESS_DELTA = 0.0f;

    /**
     * Maximum allowed value for progress delta.
     */
    public static final float MAX_PROGRESS_DELTA = 1.0f;

    /**
     * Constant defining default confidence of the estimated result, which is
     * 99%. This means that with a probability of 99% estimation will be
     * accurate because chosen subsamples will be inliers.
     */
    public static final double DEFAULT_CONFIDENCE = 0.99;

    /**
     * Default maximum allowed number of iterations.
     */
    public static final int DEFAULT_MAX_ITERATIONS = 5000;

    /**
     * Minimum allowed confidence value.
     */
    public static final double MIN_CONFIDENCE = 0.0;

    /**
     * Maximum allowed confidence value.
     */
    public static final double MAX_CONFIDENCE = 1.0;

    /**
     * Minimum allowed number of iterations.
     */
    public static final int MIN_ITERATIONS = 1;

    /**
     * Indicates that result is refined by default using all found inliers.
     */
    public static final boolean DEFAULT_REFINE_RESULT = true;

    /**
     * Indicates that covariance is kept by default after refining result.
     */
    public static final boolean DEFAULT_KEEP_COVARIANCE = true;

    /**
     * Indicates that by default a linear solver is used for preliminary solution
     * estimation using ranging measurements.
     * The result obtained on each preliminary solution might be later refined.
     */
    public static final boolean DEFAULT_USE_RANGING_LINEAR_SOLVER = true;

    /**
     * Indicates that by default a linear solver is used for preliminary solution
     * estimation using RSSI measurements.
     * The result obtained on each preliminary solution might be later refined.
     */
    public static final boolean DEFAULT_USE_RSSI_LINEAR_SOLVER = true;

    /**
     * Indicates that by default an homogeneous linear solver is used either to
     * estimate preliminary solutions or an initial solution for preliminary solutions
     * that will be later refined on the ranging fine estimation.
     */
    public static final boolean DEFAULT_USE_RANGING_HOMOGENEOUS_LINEAR_SOLVER = false;

    /**
     * Indicates that by default an homogeneous linear solver is used either to
     * estimate preliminary solutions or an initial solution for preliminary solutions
     * that will be later refined on the RSSI coarse estimation.
     */
    public static final boolean DEFAULT_USE_RSSI_HOMOGENEOUS_LINEAR_SOLVER = false;

    /**
     * Indicates that by default preliminary ranging solutions are refined.
     */
    public static final boolean DEFAULT_REFINE_RANGING_PRELIMINARY_SOLUTIONS = true;

    /**
     * Indicates that by default preliminary RSSI solutions are refined.
     */
    public static final boolean DEFAULT_REFINE_RSSI_PRELIMINARY_SOLUTIONS = true;

    /**
     * Internal robust estimator for position estimation using ranging readings.
     */
    protected RobustRangingPositionEstimator&lt;P&gt; mRangingEstimator;

    /**
     * Internal robust estimator for coarse position estimation using RSSI readings.
     */
    protected RobustRssiPositionEstimator&lt;P&gt; mRssiEstimator;

    /**
     * Robust method used for robust position estimation using ranging data.
     */
    protected RobustEstimatorMethod mRangingRobustMethod =
            DEFAULT_RANGING_ROBUST_METHOD;

    /**
     * Robust method used for coarse robust position estimation using RSSI data.
     */
    protected RobustEstimatorMethod mRssiRobustMethod =
            DEFAULT_RSSI_ROBUST_METHOD;

    /**
     * Size of subsets to be checked during robust estimation.
     */
    protected int mRangingPreliminarySubsetSize;

    /**
     * Size of subsets to be checked during RSSI robust estimation.
     */
    protected int mRssiPreliminarySubsetSize;</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator.html#L759">759</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator.html#L738">738</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>        RangingAndRssiReadingLocated&lt;S, P&gt; reading = mReadings.get(i);
        double frequency = reading.getSource().getFrequency();

        double pathLossExponent = currentEstimation.getEstimatedPathLossExponent();

        //compute k as the constant part of the isotropic received power formula
        //so that: Pr = Pte*k^n/d^n
        double k = RssiRadioSourceEstimator.SPEED_OF_LIGHT /
                (4.0 * Math.PI * frequency);
        final double kdB = 10.0 * pathLossExponent * Math.log10(k);

        //get distance from estimated radio source position and reading position
        P readingPosition = reading.getPosition();
        P radioSourcePosition = currentEstimation.getEstimatedPosition();

        //noinspection unchecked
        double sqrDistance = radioSourcePosition.sqrDistanceTo(readingPosition);

        double transmittedPowerdBm = currentEstimation.
                getEstimatedTransmittedPowerdBm();

        //compute expected received power assuming isotropic transmission
        //and compare agains measured RSSI at fingerprint location
        double expectedRSSI = kdB + transmittedPowerdBm -
                5.0 * pathLossExponent * Math.log10(sqrDistance);
        double rssi = reading.getRssi();

        return Math.abs(expectedRSSI - rssi);
    }

    /**
     * Contains a solution obtained during robust estimation for a subset of
     * samples.
     * @param &lt;P&gt; a {@link Point} type.
     */
    static class Solution&lt;P extends Point&gt; {
        /**
         * Estimated position for a subset of samples.
         */
        private P mEstimatedPosition;

        /**
         * Estimated transmitted power expressed in dBm's for a subset of samples.
         */
        private double mEstimatedTransmittedPowerdBm;

        /**
         * Estimated path loss exponent for a subset of samples.
         */
        private double mEstimatedPathLossExponent;

        /**
         * Constructor.
         * @param estimatedPosition estimated position for a subset of samples.
         * @param estimatedTransmittedPowerdBm estimated transmitted power expressed
         *                                     in dBm's for a subset of samples.
         * @param estimatedPathLossExponent estimated path loss exponent.
         */
        public Solution(P estimatedPosition, double estimatedTransmittedPowerdBm,
                        double estimatedPathLossExponent) {
            mEstimatedPosition = estimatedPosition;
            mEstimatedTransmittedPowerdBm = estimatedTransmittedPowerdBm;
            mEstimatedPathLossExponent = estimatedPathLossExponent;
        }

        /**
         * Gets estimated position for a subset of samples.
         * @return estimated position for a subset of samples.
         */
        public P getEstimatedPosition() {
            return mEstimatedPosition;
        }

        /**
         * Gets estimated transmitted power expressed in dBm's for a subset of
         * samples.
         * @return estimated transmitted power expressed in dBm's for a subset
         * of samples.
         */
        public double getEstimatedTransmittedPowerdBm() {
            return mEstimatedTransmittedPowerdBm;
        }

        /**
         * Gets estimated path loss exponent.
         * @return estimated path loss exponent.
         */
        public double getEstimatedPathLossExponent() {
            return mEstimatedPathLossExponent;
        }
    }
}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/estimators/ECEFKinematicsEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/estimators/ECEFKinematicsEstimator.html#L242">242</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/estimators/ECIKinematicsEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/estimators/ECIKinematicsEstimator.html#L214">214</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                         final ECEFFrame frame, final ECEFFrame oldFrame,
                         final BodyKinematics result) {
        estimateKinematics(timeInterval, frame, oldFrame, result);
    }

    /**
     * Estimates body kinematics (specific force applied to a body and its angular rates).
     *
     * @param timeInterval time interval between epochs expressed in seconds (s).
     * @param c            body-to-ECEF frame coordinate transformation matrix.
     * @param oldC         previous body-to-ECEF-frame coordinate transformation matrix.
     * @param vx           velocity of body frame x coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param vy           velocity of body frame y coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param vz           velocity of body frame z coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param oldVx        previous velocity of body frame x coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldVy        previous velocity of body frame y coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldVz        previous velocity of body frame z coordinate with respect ECEF
     *                     frame, resolved along EVEF-frame axes.
     * @param x            cartesian x coordinate of body position expressed in meters (m)
     *                     with respect ECEF frame, resolved along ECEF-frame axes.
     * @param y            cartesian y coordinate of body position expressed in meters (m)
     *                     with respect ECEF frame, resolved along ECEF-frame axes.
     * @param z            cartesian z coordinate of body position expressed in meters (m)
     *                     with respect ECEF frame, resolved along ECEF-frame axes.
     * @param result       instance where body kinematics estimation will be stored.
     * @throws IllegalArgumentException if provided time interval is negative or coordinated transformation matrices
     *                                  are not ECEF frame valid.
     */
    public void estimate(final double timeInterval,
                         final CoordinateTransformation c,
                         final CoordinateTransformation oldC,
                         final Speed vx, final Speed vy, final Speed vz,
                         final Speed oldVx, final Speed oldVy, final Speed oldVz,
                         final double x, final double y, final double z,
                         final BodyKinematics result) {
        estimateKinematics(timeInterval, c, oldC, vx, vy, vz, oldVx, oldVy, oldVz,
                x, y, z, result);
    }

    /**
     * Estimates body kinematics (specific force applied to a body and its angular rates).
     *
     * @param timeInterval time interval between epochs.
     * @param c            body-to-ECEF frame coordinate transformation matrix.
     * @param oldC         previous body-to-ECEF-frame coordinate transformation matrix.
     * @param vx           velocity of body frame x coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param vy           velocity of body frame y coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param vz           velocity of body frame z coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param oldVx        previous velocity of body frame x coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldVy        previous velocity of body frame y coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldVz        previous velocity of body frame z coordinate with respect ECEF
     *                     frame, resolved along EVEF-frame axes.
     * @param x            cartesian x coordinate of body position expressed in meters (m)
     *                     with respect ECEF frame, resolved along ECEF-frame axes.
     * @param y            cartesian y coordinate of body position expressed in meters (m)
     *                     with respect ECEF frame, resolved along ECEF-frame axes.
     * @param z            cartesian z coordinate of body position expressed in meters (m)
     *                     with respect ECEF frame, resolved along ECEF-frame axes.
     * @param result       instance where body kinematics estimation will be stored.
     * @throws IllegalArgumentException if provided time interval is negative or coordinated transformation matrices
     *                                  are not ECEF frame valid.
     */
    public void estimate(final Time timeInterval,
                         final CoordinateTransformation c,
                         final CoordinateTransformation oldC,
                         final Speed vx, final Speed vy, final Speed vz,
                         final Speed oldVx, final Speed oldVy, final Speed oldVz,
                         final double x, final double y, final double z,
                         final BodyKinematics result) {
        estimateKinematics(timeInterval, c, oldC, vx, vy, vz,
                oldVx, oldVy, oldVz, x, y, z, result);
    }

    /**
     * Estimates body kinematics (specific force applied to a body and its angular rates).
     *
     * @param timeInterval time interval between epochs expressed in seconds (s).
     * @param frame        body ECEF frame containing current position, velocity and
     *                     body-to-ECEF frame coordinate transformation.
     * @param oldC         previous body-to-ECEF-frame coordinate transformation matrix.
     * @param oldVx        previous velocity of body frame x coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldVy        previous velocity of body frame y coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldVz        previous velocity of body frame z coordinate with respect ECEF
     *                     frame, resolved along EVEF-frame axes.
     * @param result       instance where body kinematics estimation will be stored.
     * @throws IllegalArgumentException if provided time interval is negative or coordinated transformation matrices
     *                                  are not ECEF frame valid.
     */
    public void estimate(final double timeInterval,
                         final ECEFFrame frame,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RangingRadioSourceEstimator2D.html#L174">174</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRangingRadioSourceEstimator2D.html#L696">696</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public RadioSourceLocated&lt;Point2D&gt; getEstimatedRadioSource() {
        List&lt;? extends RangingReadingLocated&lt;S, Point2D&gt;&gt; readings = getReadings();
        if (readings == null || readings.isEmpty()) {
            return null;
        }
        S source = readings.get(0).getSource();

        Point2D estimatedPosition = getEstimatedPosition();
        if (estimatedPosition == null) {
            return null;
        }

        Matrix estimatedPositionCovariance = getEstimatedPositionCovariance();

        if (source instanceof WifiAccessPoint) {
            WifiAccessPoint accessPoint = (WifiAccessPoint)source;
            return new WifiAccessPointLocated2D(accessPoint.getBssid(),
                    accessPoint.getFrequency(), accessPoint.getSsid(),
                    estimatedPosition, estimatedPositionCovariance);
        } else if (source instanceof Beacon) {
            Beacon beacon = (Beacon)source;
            return new BeaconLocated2D(beacon.getIdentifiers(),
                    beacon.getTransmittedPower(), beacon.getFrequency(),
                    beacon.getBluetoothAddress(), beacon.getBeaconTypeCode(),
                    beacon.getManufacturer(), beacon.getServiceUuid(),
                    beacon.getBluetoothName(), estimatedPosition,
                    estimatedPositionCovariance);
        } else {
            return null;
        }
    }

    /**
     * Builds an instance of a linear lateration solver if needed.
     */
    @Override</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RangingRadioSourceEstimator3D.html#L174">174</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRangingRadioSourceEstimator3D.html#L698">698</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public RadioSourceLocated&lt;Point3D&gt; getEstimatedRadioSource() {
        List&lt;? extends RangingReadingLocated&lt;S, Point3D&gt;&gt; readings = getReadings();
        if (readings == null || readings.isEmpty()) {
            return null;
        }
        S source = readings.get(0).getSource();

        Point3D estimatedPosition = getEstimatedPosition();
        if (estimatedPosition == null) {
            return null;
        }

        Matrix estimatedPositionCovariance = getEstimatedPositionCovariance();

        if (source instanceof WifiAccessPoint) {
            WifiAccessPoint accessPoint = (WifiAccessPoint)source;
            return new WifiAccessPointLocated3D(accessPoint.getBssid(),
                    accessPoint.getFrequency(), accessPoint.getSsid(),
                    estimatedPosition, estimatedPositionCovariance);
        } else if (source instanceof Beacon) {
            Beacon beacon = (Beacon)source;
            return new BeaconLocated3D(beacon.getIdentifiers(),
                    beacon.getTransmittedPower(), beacon.getFrequency(),
                    beacon.getBluetoothAddress(), beacon.getBeaconTypeCode(),
                    beacon.getManufacturer(), beacon.getServiceUuid(),
                    beacon.getBluetoothName(), estimatedPosition,
                    estimatedPositionCovariance);
        } else {
            return null;
        }
    }

    /**
     * Builds an instance of a linear lateration solver if needed.
     */
    @Override</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/RobustMixedPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/RobustMixedPositionEstimator3D.html#L980">980</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/RobustRangingAndRssiPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/RobustRangingAndRssiPositionEstimator3D.html#L972">972</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/RobustRssiPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/RobustRssiPositionEstimator3D.html#L972">972</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    }

    /**
     * Sets positions, distances and standard deviations of distances on internal
     * lateration solver.
     *
     * @param positions                     positions to be set.
     * @param distances                     distances to be set.
     * @param distanceStandardDeviations    standard deviations of distances to be set.
     * @param distanceQualityScores         distance quality scores or null if not
     *                                      required.
     */
    @Override
    protected void setPositionsDistancesDistanceStandardDeviationsAndQualityScores(
            List&lt;Point3D&gt; positions, List&lt;Double&gt; distances,
            List&lt;Double&gt; distanceStandardDeviations,
            List&lt;Double&gt; distanceQualityScores) {
        int size = positions.size();
        Point3D[] positionsArray = new InhomogeneousPoint3D[size];
        positionsArray = positions.toArray(positionsArray);

        double[] distancesArray = new double[size];
        double[] distanceStandardDeviationsArray = new double[size];

        double[] qualityScoresArray = null;
        if (distanceQualityScores != null) {
            qualityScoresArray = new double[size];
        }

        for (int i = 0; i &lt; size; i++) {
            distancesArray[i] = distances.get(i);
            distanceStandardDeviationsArray[i] = distanceStandardDeviations.get(i);

            if (qualityScoresArray != null) {
                qualityScoresArray[i] = distanceQualityScores.get(i);
            }
        }

        try {
            mLaterationSolver.setPositionsDistancesAndStandardDeviations(
                    positionsArray, distancesArray, distanceStandardDeviationsArray);

            if (qualityScoresArray != null) {
                mLaterationSolver.setQualityScores(qualityScoresArray);
            }
        } catch (LockedException e) {
            throw new IllegalArgumentException(e);
        }
    }
}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/MixedRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MixedRadioSourceEstimator.html#L1088">1088</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustMixedRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustMixedRadioSourceEstimator.html#L2400">2400</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    private RangingReadingLocated&lt;S, P&gt; createRangingReading(RangingAndRssiReadingLocated&lt;S, P&gt; reading) {
        return new RangingReadingLocated&lt;&gt;(reading.getSource(),
                reading.getDistance(), reading.getPosition(),
                reading.getDistanceStandardDeviation(),
                reading.getPositionCovariance());
    }

    /**
     * Creates an RSSI reading from a ranging and RSSI reading.
     * @param reading input reading to convert from.
     * @return an RSSI reading containing only the RSSI data of input reading.
     */
    private RssiReadingLocated&lt;S, P&gt; createRssiReading(RangingAndRssiReadingLocated&lt;S, P&gt; reading) {
        return new RssiReadingLocated&lt;&gt;(reading.getSource(),
                reading.getRssi(), reading.getPosition(),
                reading.getRssiStandardDeviation(),
                reading.getPositionCovariance());
    }

    /**
     * Checks number of available ranging readings and number of available RSSI readings. Also determines
     * whether position must be estimated using ranging data or RSSI data.
     * @param readings readings to be checked.
     */
    private void checkReadings(List&lt;? extends ReadingLocated&lt;P&gt;&gt; readings) {
        mNumRangingReadings = mNumRssiReadings = 0;

        if (readings == null) {
            return;
        }

        for (ReadingLocated&lt;P&gt; reading : readings) {
            if (reading instanceof RangingReadingLocated) {
                mNumRangingReadings++;

            } else if (reading instanceof RssiReadingLocated) {
                mNumRssiReadings++;

            } else if (reading instanceof RangingAndRssiReadingLocated) {
                mNumRangingReadings++;
                mNumRssiReadings++;
            }
        }

        mRssiPositionEnabled = mNumRangingReadings &lt; getMinRangingReadings();
    }
}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/LinearMixedPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/LinearMixedPositionEstimator2D.html#L155">155</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/LinearRangingAndRssiPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/LinearRangingAndRssiPositionEstimator2D.html#L152">152</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/LinearRangingPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/LinearRangingPositionEstimator2D.html#L152">152</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/LinearRssiPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/LinearRssiPositionEstimator2D.html#L153">153</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>            MixedPositionEstimatorListener&lt;Point2D&gt; listener) {
        super(listener);
        init();
        internalSetSources(sources);
        internalSetFingerprint(fingerprint);
    }

    /**
     * Gets estimated position.
     * @return estimated position.
     */
    @Override
    public Point2D getEstimatedPosition() {
        if(mEstimatedPositionCoordinates == null) {
            return null;
        }

        InhomogeneousPoint2D result = new InhomogeneousPoint2D();
        getEstimatedPosition(result);
        return result;
    }

    /**
     * Sets positions and distances on internal lateration solver.
     * @param positions positions to be set.
     * @param distances distances to be set.
     * @throws IllegalArgumentException if something fails.
     */
    @Override
    @SuppressWarnings(&quot;Duplicates&quot;)
    protected void setPositionsAndDistances(List&lt;Point2D&gt; positions,
                                            List&lt;Double&gt; distances) {
        int size = positions.size();
        Point2D[] positionsArray = new InhomogeneousPoint2D[size];
        positionsArray = positions.toArray(positionsArray);

        double[] distancesArray = new double[size];
        for (int i = 0; i &lt; size; i++) {
            distancesArray[i] = distances.get(i);
        }

        try {
            mHomogeneousTrilaterationSolver.setPositionsAndDistances(positionsArray,
                    distancesArray);
            mInhomogeneousTrilaterationSolver.setPositionsAndDistances(positionsArray,
                    distancesArray);
        } catch (LockedException e) {
            throw new IllegalArgumentException(e);
        }
    }

    /**
     * Initializes lateration solver.
     */
    private void init() {
        mHomogeneousTrilaterationSolver = new HomogeneousLinearLeastSquaresLateration2DSolver(
                mLaterationSolverListener);
        mInhomogeneousTrilaterationSolver = new InhomogeneousLinearLeastSquaresLateration2DSolver(
                mLaterationSolverListener);
    }
}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/LinearMixedPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/LinearMixedPositionEstimator3D.html#L155">155</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/LinearRangingAndRssiPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/LinearRangingAndRssiPositionEstimator3D.html#L155">155</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/LinearRangingPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/LinearRangingPositionEstimator3D.html#L155">155</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/LinearRssiPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/LinearRssiPositionEstimator3D.html#L153">153</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>            MixedPositionEstimatorListener&lt;Point3D&gt; listener) {
        super(listener);
        init();
        internalSetSources(sources);
        internalSetFingerprint(fingerprint);
    }

    /**
     * Gets estimated position.
     * @return estimated position.
     */
    @Override
    public Point3D getEstimatedPosition() {
        if(mEstimatedPositionCoordinates == null) {
            return null;
        }

        InhomogeneousPoint3D result = new InhomogeneousPoint3D();
        getEstimatedPosition(result);
        return result;
    }

    /**
     * Sets positions and distances on internal lateration solver.
     * @param positions positions to be set.
     * @param distances distances to be set.
     * @throws IllegalArgumentException if something fails.
     */
    @Override
    @SuppressWarnings(&quot;Duplicates&quot;)
    protected void setPositionsAndDistances(List&lt;Point3D&gt; positions,
                                            List&lt;Double&gt; distances) {
        int size = positions.size();
        Point3D[] positionsArray = new InhomogeneousPoint3D[size];
        positionsArray = positions.toArray(positionsArray);

        double[] distancesArray = new double[size];
        for (int i = 0; i &lt; size; i++) {
            distancesArray[i] = distances.get(i);
        }

        try {
            mHomogeneousTrilaterationSolver.setPositionsAndDistances(positionsArray,
                    distancesArray);
            mInhomogeneousTrilaterationSolver.setPositionsAndDistances(positionsArray,
                    distancesArray);
        } catch (LockedException e) {
            throw new IllegalArgumentException(e);
        }
    }

    /**
     * Initializes lateration solver.
     */
    private void init() {
        mHomogeneousTrilaterationSolver = new HomogeneousLinearLeastSquaresLateration3DSolver(
                mLaterationSolverListener);
        mInhomogeneousTrilaterationSolver = new InhomogeneousLinearLeastSquaresLateration3DSolver(
                mLaterationSolverListener);
    }
}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/RobustMixedPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/RobustMixedPositionEstimator3D.html#L993">993</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/RobustRangingAndRssiPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/RobustRangingAndRssiPositionEstimator3D.html#L985">985</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/RobustRangingPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/RobustRangingPositionEstimator3D.html#L994">994</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/RobustRssiPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/RobustRssiPositionEstimator3D.html#L984">984</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    protected void setPositionsDistancesDistanceStandardDeviationsAndQualityScores(
            List&lt;Point3D&gt; positions, List&lt;Double&gt; distances,
            List&lt;Double&gt; distanceStandardDeviations,
            List&lt;Double&gt; distanceQualityScores) {
        int size = positions.size();
        Point3D[] positionsArray = new InhomogeneousPoint3D[size];
        positionsArray = positions.toArray(positionsArray);

        double[] distancesArray = new double[size];
        double[] distanceStandardDeviationsArray = new double[size];

        double[] qualityScoresArray = null;
        if (distanceQualityScores != null) {
            qualityScoresArray = new double[size];
        }

        for (int i = 0; i &lt; size; i++) {
            distancesArray[i] = distances.get(i);
            distanceStandardDeviationsArray[i] = distanceStandardDeviations.get(i);

            if (qualityScoresArray != null) {
                qualityScoresArray[i] = distanceQualityScores.get(i);
            }
        }

        try {
            mLaterationSolver.setPositionsDistancesAndStandardDeviations(
                    positionsArray, distancesArray, distanceStandardDeviationsArray);

            if (qualityScoresArray != null) {
                mLaterationSolver.setQualityScores(qualityScoresArray);
            }
        } catch (LockedException e) {
            throw new IllegalArgumentException(e);
        }
    }
}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/SequentialRobustMixedPositionEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/SequentialRobustMixedPositionEstimator.html#L2026">2026</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/SequentialRobustRangingAndRssiPositionEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/SequentialRobustRangingAndRssiPositionEstimator.html#L1909">1909</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    private void internalSetFingerprint(Fingerprint&lt;? extends RadioSource, ? extends Reading&lt;? extends RadioSource&gt;&gt; fingerprint) {
        if (fingerprint == null) {
            throw new IllegalArgumentException();
        }

        mFingerprint = fingerprint;
    }

    /**
     * Sets quality scores corresponding to each provided located radio source.
     * This method is used internally and does not check whether instance is
     * locked or not.
     * @param sourceQualityScores quality scores to be set.
     * @throws IllegalArgumentException if provided quality scores length is
     * smaller than 3 samples for 2D or 4 samples for 3D.
     */
    private void internalSetSourceQualityScores(double[] sourceQualityScores) {
        if (sourceQualityScores == null ||
                sourceQualityScores.length &lt; getMinRequiredSources()) {
            throw new IllegalArgumentException();
        }

        mSourceQualityScores = sourceQualityScores;
    }

    /**
     * Sets quality scores corresponding to each provided reading within provided
     * fingerprint.
     * This method is used internally and does not check whether instance is locked
     * or not.
     * @param fingerprintReadingsQualityScores quality scores to be set.
     * @throws IllegalArgumentException if provided quality scores length is smaller
     * than 3 samples for 2D or 4 samples for 3D.
     */
    private void internalSetFingerprintReadingsQualityScores(
            double[] fingerprintReadingsQualityScores) {
        if (fingerprintReadingsQualityScores == null ||
                fingerprintReadingsQualityScores.length &lt; getMinRequiredSources()) {
            throw new IllegalArgumentException();
        }

        mFingerprintReadingsQualityScores = fingerprintReadingsQualityScores;
    }

    /**
     * Creates a ranging reading from a ranging and RSSI reading.
     *
     * @param reading input reading to convert from.
     * @return a ranging reading containing only the ranging data of input reading.
     */
    private RangingReading&lt;RadioSource&gt; createRangingReading(
            RangingAndRssiReading&lt;? extends RadioSource&gt; reading) {
        return new RangingReading&lt;&gt;(reading.getSource(),
                reading.getDistance(),
                reading.getDistanceStandardDeviation(),
                reading.getNumAttemptedMeasurements(),
                reading.getNumSuccessfulMeasurements());
    }

    /**
     * Creates an RSSI reading from a ranging and RSSI reading.
     *
     * @param reading input reading to convert from.
     * @return an RSSI reading containing only the RSSI data of input reading.
     */
    private RssiReading&lt;RadioSource&gt; createRssiReading(
            RangingAndRssiReading&lt;? extends RadioSource&gt; reading) {
        return new RssiReading&lt;&gt;(reading.getSource(), reading.getRssi(),
                reading.getRssiStandardDeviation());
    }</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator2D.html#L831">831</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator3D.html#L831">831</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator2D.html#L842">842</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator3D.html#L841">841</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>            RobustRangingAndRssiRadioSourceEstimatorListener&lt;S, Point2D&gt; listener) {
        super(readings, initialPosition, initialTransmittedPowerdBm,
                initialPathLossExponent, listener);
        internalSetQualityScores(qualityScores);
    }

    /**
     * Returns threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value, the
     * algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algorithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @return stop threshold to stop the algorithm prematurely when a certain
     * accuracy has been reached.
     */
    public double getStopThreshold() {
        return mStopThreshold;
    }

    /**
     * Sets threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value,
     * the algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algorithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @param stopThreshold stop threshold to stop the algorithm prematurely
     *                      when a certain accuracy has been reached.
     * @throws IllegalArgumentException if provided value is zero or negative.
     * @throws LockedException if this solver is locked.
     */
    public void setStopThreshold(double stopThreshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (stopThreshold &lt;= MIN_STOP_THRESHOLD) {
            throw new IllegalArgumentException();
        }

        mStopThreshold = stopThreshold;
    }

    /**
     * Returns quality scores corresponding to each pair of
     * positions and distances (i.e. sample).
     * The larger the score value the better the quality of the sample.
     * This implementation always returns null.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @return quality scores corresponding to each sample.
     */
    @Override
    public double[] getQualityScores() {
        return mQualityScores;
    }

    /**
     * Sets quality scores corresponding to each pair of positions and
     * distances (i.e. sample).
     * The larger the score value the better the quality of the sample.
     * This implementation makes no action.
     * Subclasses using quality scores must implement proper behaviour.
     *
     * @param qualityScores quality scores corresponding to each pair of
     *                      matched points.
     * @throws IllegalArgumentException if provided quality scores length
     * is smaller than minimum required samples.
     * @throws LockedException if robust solver is locked because an
     * estimation is already in progress.
     */
    public void setQualityScores(double[] qualityScores) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetQualityScores(qualityScores);
    }

    /**
     * Indicates whether solver is ready to find a solution.
     *
     * @return true if solver is ready, false otherwise.
     */
    @Override
    public boolean isReady() {
        return super.isReady() &amp;&amp; mQualityScores != null &amp;&amp;
                mQualityScores.length == mReadings.size();
    }

    /**
     * Robustly estimates position, transmitted power and pathloss exponent for a
     * radio source.
     *
     * @throws LockedException if instance is busy during estimation.
     * @throws NotReadyException if estimator is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     * (i.e. numerical instability, no solution available, etc).
     */
    @Override
    public void estimate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        PROMedSRobustEstimator&lt;Solution&lt;Point2D&gt;&gt; innerEstimator =</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/NonLinearMixedPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/NonLinearMixedPositionEstimator2D.html#L299">299</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/NonLinearRangingAndRssiPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/NonLinearRangingAndRssiPositionEstimator2D.html#L298">298</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/NonLinearRangingPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/NonLinearRangingPositionEstimator2D.html#L299">299</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/NonLinearRssiPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/NonLinearRssiPositionEstimator2D.html#L300">300</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    public Point2D getEstimatedPosition() {
        if (mEstimatedPositionCoordinates == null) {
            return null;
        }

        InhomogeneousPoint2D result = new InhomogeneousPoint2D();
        getEstimatedPosition(result);
        return result;
    }

    /**
     * Sets positions, distances and standard deviations of distances on internal
     * lateration solver.
     *
     * @param positions positions to be set.
     * @param distances distances to be set.
     * @param distanceStandardDeviations standard deviations of distances to be set.
     */
    @Override
    @SuppressWarnings(&quot;Duplicates&quot;)
    protected void setPositionsDistancesAndDistanceStandardDeviations(
            List&lt;Point2D&gt; positions, List&lt;Double&gt; distances,
            List&lt;Double&gt; distanceStandardDeviations) {

        int size = positions.size();
        Point2D[] positionsArray = new InhomogeneousPoint2D[size];
        positionsArray = positions.toArray(positionsArray);

        double[] distancesArray = new double[size];
        double[] distanceStandardDeviationsArray = new double[size];
        for (int i = 0; i &lt; size; i++) {
            distancesArray[i] = distances.get(i);
            distanceStandardDeviationsArray[i] = distanceStandardDeviations.get(i);
        }

        try {
            mTrilaterationSolver.setPositionsDistancesAndStandardDeviations(
                    positionsArray, distancesArray, distanceStandardDeviationsArray);
        } catch (LockedException e) {
            throw new IllegalArgumentException(e);
        }
    }

    /**
     * Initializes lateration solver.
     */
    private void init() {
        mTrilaterationSolver = new NonLinearLeastSquaresLateration2DSolver(
                mLaterationSolverListener);
    }
}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/NonLinearMixedPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/NonLinearMixedPositionEstimator3D.html#L302">302</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/NonLinearRangingAndRssiPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/NonLinearRangingAndRssiPositionEstimator3D.html#L302">302</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/NonLinearRangingPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/NonLinearRangingPositionEstimator3D.html#L299">299</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/NonLinearRssiPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/NonLinearRssiPositionEstimator3D.html#L301">301</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    public Point3D getEstimatedPosition() {
        if (mEstimatedPositionCoordinates == null) {
            return null;
        }

        InhomogeneousPoint3D result = new InhomogeneousPoint3D();
        getEstimatedPosition(result);
        return result;
    }

    /**
     * Sets positions, distances and standard deviations of distances on internal
     * lateration solver.
     *
     * @param positions positions to be set.
     * @param distances distances to be set.
     * @param distanceStandardDeviations standard deviations of distances to be set.
     */
    @Override
    @SuppressWarnings(&quot;Duplicates&quot;)
    protected void setPositionsDistancesAndDistanceStandardDeviations(
            List&lt;Point3D&gt; positions, List&lt;Double&gt; distances,
            List&lt;Double&gt; distanceStandardDeviations) {

        int size = positions.size();
        Point3D[] positionsArray = new InhomogeneousPoint3D[size];
        positionsArray = positions.toArray(positionsArray);

        double[] distancesArray = new double[size];
        double[] distanceStandardDeviationsArray = new double[size];
        for (int i = 0; i &lt; size; i++) {
            distancesArray[i] = distances.get(i);
            distanceStandardDeviationsArray[i] = distanceStandardDeviations.get(i);
        }

        try {
            mTrilaterationSolver.setPositionsDistancesAndStandardDeviations(
                    positionsArray, distancesArray, distanceStandardDeviationsArray);
        } catch (LockedException e) {
            throw new IllegalArgumentException(e);
        }
    }

    /**
     * Initializes lateration solver.
     */
    private void init() {
        mTrilaterationSolver = new NonLinearLeastSquaresLateration3DSolver(
                mLaterationSolverListener);
    }
}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/MixedRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MixedRadioSourceEstimator2D.html#L351">351</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustMixedRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustMixedRadioSourceEstimator2D.html#L847">847</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    public RadioSourceLocated&lt;Point2D&gt; getEstimatedRadioSource() {
        List&lt;? extends ReadingLocated&lt;Point2D&gt;&gt; readings = getReadings();
        if (readings == null || readings.isEmpty()) {
            return null;
        }

        S source;
        ReadingLocated&lt;Point2D&gt; reading = readings.get(0);
        if (reading instanceof RangingReadingLocated) {
            source = ((RangingReadingLocated&lt;S, Point2D&gt;)reading).getSource();
        } else if (reading instanceof RssiReadingLocated) {
            source = ((RssiReadingLocated&lt;S, Point2D&gt;)reading).getSource();
        } else if (reading instanceof RangingAndRssiReadingLocated) {
            source = ((RangingAndRssiReadingLocated&lt;S, Point2D&gt;)reading).getSource();
        } else {
            return null;
        }

        Point2D estimatedPosition = getEstimatedPosition();
        if (estimatedPosition == null) {
            return null;
        }

        Matrix estimatedPositionCovariance = getEstimatedPositionCovariance();

        Double transmittedPowerdBm = getEstimatedTransmittedPowerdBm();

        Double transmittedPowerVariance = getEstimatedTransmittedPowerVariance();
        Double transmittedPowerStandardDeviation = transmittedPowerVariance != null ?
                Math.sqrt(transmittedPowerVariance) : null;</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/MixedRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MixedRadioSourceEstimator3D.html#L351">351</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustMixedRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustMixedRadioSourceEstimator3D.html#L849">849</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    public RadioSourceLocated&lt;Point3D&gt; getEstimatedRadioSource() {
        List&lt;? extends ReadingLocated&lt;Point3D&gt;&gt; readings = getReadings();
        if (readings == null || readings.isEmpty()) {
            return null;
        }

        S source;
        ReadingLocated&lt;Point3D&gt; reading = readings.get(0);
        if (reading instanceof RangingReadingLocated) {
            source = ((RangingReadingLocated&lt;S, Point3D&gt;)reading).getSource();
        } else if (reading instanceof RssiReadingLocated) {
            source = ((RssiReadingLocated&lt;S, Point3D&gt;)reading).getSource();
        } else if (reading instanceof RangingAndRssiReadingLocated) {
            source = ((RangingAndRssiReadingLocated&lt;S, Point3D&gt;)reading).getSource();
        } else {
            return null;
        }

        Point3D estimatedPosition = getEstimatedPosition();
        if (estimatedPosition == null) {
            return null;
        }

        Matrix estimatedPositionCovariance = getEstimatedPositionCovariance();

        Double transmittedPowerdBm = getEstimatedTransmittedPowerdBm();

        Double transmittedPowerVariance = getEstimatedTransmittedPowerVariance();
        Double transmittedPowerStandardDeviation = transmittedPowerVariance != null ?
                Math.sqrt(transmittedPowerVariance) : null;</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator2D.html#L2889">2889</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator2D.html#L2863">2863</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>                    mUseReadingPositionCovariances);

            mInnerEstimator.estimate();

            Point2D estimatedPosition = mInnerEstimator.getEstimatedPosition();
            double estimatedTransmittedPowerdBm =
                    mInnerEstimator.getEstimatedTransmittedPowerdBm();
            double estimatedPathLossExponent =
                    mInnerEstimator.getEstimatedPathLossExponent();
            solutions.add(new Solution&lt;&gt;(estimatedPosition,
                    estimatedTransmittedPowerdBm, estimatedPathLossExponent));
        } catch(NavigationException ignore) {
            //if anything fails, no solution is added
        }
    }

    /**
     * Attempts to refine estimated position and transmitted power contained in
     * provided solution if refinement is requested.
     * This method sets a refined result and transmitted power or provided input
     * result if refinement is not requested or has failed.
     * If refinement is enabled and it is requested to keep covariance, this method
     * will also keep covariance of refined result.
     * solution if not requested or refinement failed.
     *
     * @param result result to be refined.
     */
    protected void attemptRefine(Solution&lt;Point2D&gt; result) {
        Point2D initialPosition = result.getEstimatedPosition();
        double initialTransmittedPowerdBm =
                result.getEstimatedTransmittedPowerdBm();
        double initialPathLossExponent = result.getEstimatedPathLossExponent();

        if (mRefineResult &amp;&amp; mInliersData != null) {
            BitSet inliers = mInliersData.getInliers();
            int nSamples = mReadings.size();

            mInnerReadings.clear();

            for (int i = 0; i &lt; nSamples; i++) {
                if (inliers.get(i)) {
                    //sample is inlier
                    mInnerReadings.add(mReadings.get(i));
                }
            }

            try {
                mInnerEstimator.setInitialPosition(initialPosition);
                mInnerEstimator.setInitialTransmittedPowerdBm(initialTransmittedPowerdBm);
                mInnerEstimator.setInitialPathLossExponent(initialPathLossExponent);
                mInnerEstimator.setTransmittedPowerEstimationEnabled(
                        mTransmittedPowerEstimationEnabled);
                mInnerEstimator.setPathLossEstimationEnabled(</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator3D.html#L2891">2891</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator3D.html#L2863">2863</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>                    mUseReadingPositionCovariances);

            mInnerEstimator.estimate();

            Point3D estimatedPosition = mInnerEstimator.getEstimatedPosition();
            double estimatedTransmittedPowerdBm =
                    mInnerEstimator.getEstimatedTransmittedPowerdBm();
            double estimatedPathLossExponent =
                    mInnerEstimator.getEstimatedPathLossExponent();
            solutions.add(new Solution&lt;&gt;(estimatedPosition,
                    estimatedTransmittedPowerdBm, estimatedPathLossExponent));
        } catch(NavigationException ignore) {
            //if anything fails, no solution is added
        }
    }

    /**
     * Attempts to refine estimated position and transmitted power contained in
     * provided solution if refinement is requested.
     * This method sets a refined result and transmitted power or provided input
     * result if refinement is not requested or has failed.
     * If refinement is enabled and it is requested to keep covariance, this method
     * will also keep covariance of refined result.
     * solution if not requested or refinement failed.
     *
     * @param result result to be refined.
     */
    protected void attemptRefine(Solution&lt;Point3D&gt; result) {
        Point3D initialPosition = result.getEstimatedPosition();
        double initialTransmittedPowerdBm =
                result.getEstimatedTransmittedPowerdBm();
        double initialPathLossExponent = result.getEstimatedPathLossExponent();

        if (mRefineResult &amp;&amp; mInliersData != null) {
            BitSet inliers = mInliersData.getInliers();
            int nSamples = mReadings.size();

            mInnerReadings.clear();

            for (int i = 0; i &lt; nSamples; i++) {
                if (inliers.get(i)) {
                    //sample is inlier
                    mInnerReadings.add(mReadings.get(i));
                }
            }

            try {
                mInnerEstimator.setInitialPosition(initialPosition);
                mInnerEstimator.setInitialTransmittedPowerdBm(initialTransmittedPowerdBm);
                mInnerEstimator.setInitialPathLossExponent(initialPathLossExponent);
                mInnerEstimator.setTransmittedPowerEstimationEnabled(
                        mTransmittedPowerEstimationEnabled);
                mInnerEstimator.setPathLossEstimationEnabled(</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/estimators/ECEFKinematicsEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/estimators/ECEFKinematicsEstimator.html#L701">701</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/estimators/ECIKinematicsEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/estimators/ECIKinematicsEstimator.html#L629">629</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>                                               final ECEFFrame oldFrame) {
        return estimateKinematicsAndReturnNew(timeInterval, frame, oldFrame);
    }

    /**
     * Estimates body kinematics (specific force applied to a body and its angular rates).
     *
     * @param timeInterval time interval between epochs expressed in seconds (s).
     * @param c            body-to-ECEF frame coordinate transformation matrix.
     * @param oldC         previous body-to-ECEF-frame coordinate transformation matrix.
     * @param vx           velocity of body frame x coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param vy           velocity of body frame y coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param vz           velocity of body frame z coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param oldVx        previous velocity of body frame x coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldVy        previous velocity of body frame y coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldVz        previous velocity of body frame z coordinate with respect ECEF
     *                     frame, resolved along EVEF-frame axes.
     * @param x            cartesian x coordinate of body position expressed in meters (m)
     *                     with respect ECEF frame, resolved along ECEF-frame axes.
     * @param y            cartesian y coordinate of body position expressed in meters (m)
     *                     with respect ECEF frame, resolved along ECEF-frame axes.
     * @param z            cartesian z coordinate of body position expressed in meters (m)
     *                     with respect ECEF frame, resolved along ECEF-frame axes.
     * @return a new body kinematics instance.
     * @throws IllegalArgumentException if provided time interval is negative or coordinated transformation matrices
     *                                  are not ECEF frame valid.
     */
    public BodyKinematics estimateAndReturnNew(final double timeInterval,
                                               final CoordinateTransformation c,
                                               final CoordinateTransformation oldC,
                                               final Speed vx, final Speed vy, final Speed vz,
                                               final Speed oldVx, final Speed oldVy, final Speed oldVz,
                                               final double x, final double y, final double z) {
        return estimateKinematicsAndReturnNew(timeInterval, c, oldC, vx, vy, vz,
                oldVx, oldVy, oldVz, x, y, z);
    }

    /**
     * Estimates body kinematics (specific force applied to a body and its angular rates).
     *
     * @param timeInterval time interval between epochs.
     * @param c            body-to-ECEF frame coordinate transformation matrix.
     * @param oldC         previous body-to-ECEF-frame coordinate transformation matrix.
     * @param vx           velocity of body frame x coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param vy           velocity of body frame y coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param vz           velocity of body frame z coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param oldVx        previous velocity of body frame x coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldVy        previous velocity of body frame y coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldVz        previous velocity of body frame z coordinate with respect ECEF
     *                     frame, resolved along EVEF-frame axes.
     * @param x            cartesian x coordinate of body position expressed in meters (m)
     *                     with respect ECEF frame, resolved along ECEF-frame axes.
     * @param y            cartesian y coordinate of body position expressed in meters (m)
     *                     with respect ECEF frame, resolved along ECEF-frame axes.
     * @param z            cartesian z coordinate of body position expressed in meters (m)
     *                     with respect ECEF frame, resolved along ECEF-frame axes.
     * @return a new body kinematics instance.
     * @throws IllegalArgumentException if provided time interval is negative or coordinated transformation matrices
     *                                  are not ECEF frame valid.
     */
    public BodyKinematics estimateAndReturnNew(final Time timeInterval,
                                               final CoordinateTransformation c,
                                               final CoordinateTransformation oldC,
                                               final Speed vx, final Speed vy, final Speed vz,
                                               final Speed oldVx, final Speed oldVy, final Speed oldVz,
                                               final double x, final double y, final double z) {
        return estimateKinematicsAndReturnNew(timeInterval, c, oldC, vx, vy, vz,
                oldVx, oldVy, oldVz, x, y, z);
    }

    /**
     * Estimates body kinematics (specific force applied to a body and its angular rates).
     *
     * @param timeInterval time interval between epochs expressed in seconds (s).
     * @param frame        body ECEF frame containing current position, velocity and
     *                     body-to-ECEF frame coordinate transformation.
     * @param oldC         previous body-to-ECEF-frame coordinate transformation matrix.
     * @param oldVx        previous velocity of body frame x coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldVy        previous velocity of body frame y coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldVz        previous velocity of body frame z coordinate with respect ECEF
     *                     frame, resolved along EVEF-frame axes.
     * @return a new body kinematics instance.
     * @throws IllegalArgumentException if provided time interval is negative or coordinated transformation matrices
     *                                  are not ECEF frame valid.
     */
    public BodyKinematics estimateAndReturnNew(final double timeInterval,
                                               final ECEFFrame frame,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator2D.html#L328">328</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator3D.html#L328">328</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>            RobustRangingRadioSourceEstimatorListener&lt;S, Point2D&gt; listener) {
        super(readings, initialPosition, listener);
        internalSetQualityScores(qualityScores);
    }

    /**
     * Returns threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value, the
     * algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algorithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @return stop threshold to stop the algorithm prematurely when a certain
     * accuracy has been reached.
     */
    public double getStopThreshold() {
        return mStopThreshold;
    }

    /**
     * Sets threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value,
     * the algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algorithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @param stopThreshold stop threshold to stop the algorithm prematurely
     *                      when a certain accuracy has been reached.
     * @throws IllegalArgumentException if provided value is zero or negative.
     * @throws LockedException if this solver is locked.
     */
    public void setStopThreshold(double stopThreshold)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (stopThreshold &lt;= MIN_STOP_THRESHOLD) {
            throw new IllegalArgumentException();
        }

        mStopThreshold = stopThreshold;
    }

    /**
     * Returns quality scores corresponding to each pair of
     * positions and distances (i.e. sample).
     * The larger the score value the better the quality of the sample.
     * This implementation always returns null.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @return quality scores corresponding to each sample.
     */
    @Override
    public double[] getQualityScores() {
        return mQualityScores;
    }

    /**
     * Sets quality scores corresponding to each pair of positions and
     * distances (i.e. sample).
     * The larger the score value the better the quality of the sample.
     * This implementation makes no action.
     * Subclasses using quality scores must implement proper behaviour.
     *
     * @param qualityScores quality scores corresponding to each pair of
     *                      matched points.
     * @throws IllegalArgumentException if provided quality scores length
     * is smaller than minimum required samples.
     * @throws LockedException if robust solver is locked because an
     * estimation is already in progress.
     */
    public void setQualityScores(double[] qualityScores) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetQualityScores(qualityScores);
    }

    /**
     * Indicates whether solver is ready to find a solution.
     *
     * @return true if solver is ready, false otherwise.
     */
    @Override
    public boolean isReady() {
        return super.isReady() &amp;&amp; mQualityScores != null &amp;&amp;
                mQualityScores.length == mReadings.size();
    }

    /**
     * Robustly estimates position for a radio source.
     *
     * @throws LockedException if instance is busy during estimation.
     * @throws NotReadyException if estimator is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     * (i.e. numerical instability, no solution available, etc).
     */
    @Override
    public void estimate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        PROMedSRobustEstimator&lt;Solution&lt;Point2D&gt;&gt; innerEstimator =</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator2D.html#L394">394</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator3D.html#L394">394</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator2D.html#L405">405</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator3D.html#L405">405</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>            RobustRangingAndRssiRadioSourceEstimatorListener&lt;S, Point2D&gt; listener) {
        super(readings, initialPosition, initialTransmittedPowerdBm,
                initialPathLossExponent, listener);
    }

    /**
     * Gets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on received power (RSSI) expressed
     * in dBm's between received value that should have been received on estimated
     * isotropical model and actual measured value.
     *
     * @return threshold to determine whether samples are inliers or not.
     */
    public double getThreshold() {
        return mThreshold;
    }

    /**
     * Sets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on received power (RSSI) expressed
     * in dBm's between received value that should have been received on estimated
     * isotropical model and actual measured value.
     *
     * @param threshold threshold to determine whether samples are inliers or not.
     * @throws IllegalArgumentException if provided value is equal or less than zero.
     * @throws LockedException if this estimator is locked.
     */
    public void setThreshold(double threshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (threshold &lt;= MIN_THRESHOLD) {
            throw new IllegalArgumentException();
        }
        mThreshold = threshold;
    }


    /**
     * Indicates whether inliers must be computed and kept.
     *
     * @return true if inliers must be computed and kept, false if inliers
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepInliersEnabled() {
        return mComputeAndKeepInliers;
    }

    /**
     * Specifies whether inliers must be computed and kept.
     *
     * @param computeAndKeepInliers true if inliers must be computed and kept,
     *                              false if inliers only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepInliersEnabled(boolean computeAndKeepInliers)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mComputeAndKeepInliers = computeAndKeepInliers;
    }

    /**
     * Indicates whether residuals must be computed and kept.
     *
     * @return true if residuals must be computed and kept, false if residuals
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepResidualsEnabled() {
        return mComputeAndKeepResiduals;
    }

    /**
     * Specifies whether residuals must be computed and kept.
     *
     * @param computeAndKeepResiduals true if residuals must be computed and kept,
     *                                false if residuals only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepResidualsEnabled(boolean computeAndKeepResiduals)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mComputeAndKeepResiduals = computeAndKeepResiduals;
    }

    /**
     * Robustly estimates position, transmitted power and pathloss exponent for a
     * radio source.
     *
     * @throws LockedException if instance is busy during estimation.
     * @throws NotReadyException if estimator is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     * (i.e. numerical instability, no solution available, etc).
     */
    @Override
    public void estimate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        RANSACRobustEstimator&lt;Solution&lt;Point2D&gt;&gt; innerEstimator =</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator2D.html#L172">172</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator3D.html#L172">172</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>            RobustRangingRadioSourceEstimatorListener&lt;S, Point2D&gt; listener) {
        super(readings, initialPosition, listener);
    }

    /**
     * Gets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on ranging distances.
     *
     * @return threshold to determine whether samples are inliers or not.
     */
    public double getThreshold() {
        return mThreshold;
    }

    /**
     * Sets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on ranging distances.
     *
     * @param threshold threshold to determine whether samples are inliers or not.
     * @throws IllegalArgumentException if provided value is equal or less than zero.
     * @throws LockedException if this estimator is locked.
     */
    public void setThreshold(double threshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (threshold &lt;= MIN_THRESHOLD) {
            throw new IllegalArgumentException();
        }
        mThreshold = threshold;
    }


    /**
     * Indicates whether inliers must be computed and kept.
     *
     * @return true if inliers must be computed and kept, false if inliers
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepInliersEnabled() {
        return mComputeAndKeepInliers;
    }

    /**
     * Specifies whether inliers must be computed and kept.
     *
     * @param computeAndKeepInliers true if inliers must be computed and kept,
     *                              false if inliers only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepInliersEnabled(boolean computeAndKeepInliers)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mComputeAndKeepInliers = computeAndKeepInliers;
    }

    /**
     * Indicates whether residuals must be computed and kept.
     *
     * @return true if residuals must be computed and kept, false if residuals
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepResidualsEnabled() {
        return mComputeAndKeepResiduals;
    }

    /**
     * Specifies whether residuals must be computed and kept.
     *
     * @param computeAndKeepResiduals true if residuals must be computed and kept,
     *                                false if residuals only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepResidualsEnabled(boolean computeAndKeepResiduals)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mComputeAndKeepResiduals = computeAndKeepResiduals;
    }

    /**
     * Robustly estimates position for a radio source.
     *
     * @throws LockedException if instance is busy during estimation.
     * @throws NotReadyException if estimator is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     * (i.e. numerical instability, no solution available, etc).
     */
    @Override
    public void estimate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        RANSACRobustEstimator&lt;Solution&lt;Point2D&gt;&gt; innerEstimator =</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/estimators/ECEFKinematicsEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/estimators/ECEFKinematicsEstimator.html#L1118">1118</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/estimators/ECIKinematicsEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/estimators/ECIKinematicsEstimator.html#L1015">1015</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>                final double specificForceZ = invAveCbe.getElementAtIndex(2);

                // save result data
                result.setSpecificForceCoordinates(specificForceX, specificForceY,
                        specificForceZ);
                result.setAngularRateCoordinates(angularRateX, angularRateY,
                        angularRateZ);

            } catch (final AlgebraException ignore) {
                // never happens
            }
        } else {
            // If time interval is zero, set angular rate and specific force to zero
            result.setSpecificForceCoordinates(0.0, 0.0, 0.0);
            result.setAngularRateCoordinates(0.0, 0.0, 0.0);
        }
    }

    /**
     * Estimates body kinematics (specific force applied to a body and its angular rates).
     *
     * @param timeInterval time interval between epochs.
     * @param c            boy-to-ECEF frame coordinate transformation matrix.
     * @param oldC         previous body-to-ECEF-frame coordinate transformation matrix.
     * @param vx           velocity of body frame x coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per
     *                     second (m/s).
     * @param vy           velocity of body frame y coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per
     *                     second (m/s).
     * @param vz           velocity of body frame z coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per
     *                     second (m/s).
     * @param oldVx        previous velocity of body frame x coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters
     *                     per second (m/s).
     * @param oldVy        previous velocity of body frame y coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters
     *                     per second (m/s).
     * @param oldVz        previous velocity of body frame z coordinate with respect ECEF
     *                     frame, resolved along EVEF-frame axes and expressed in meters
     *                     per second (m/s).
     * @param x            cartesian x coordinate of body position expressed in meters (m)
     *                     with respect ECEF frame, resolved along ECEF-frame axes.
     * @param y            cartesian y coordinate of body position expressed in meters (m)
     *                     with respect ECEF frame, resolved along ECEF-frame axes.
     * @param z            cartesian z coordinate of body position expressed in meters (m)
     *                     with respect ECEF frame, resolved along ECEF-frame axes.
     * @param result       instance where body kinematics estimation will be stored.
     * @throws IllegalArgumentException if provided time interval is negative or coordinated transformation matrices
     *                                  are not ECEF frame valid.
     */
    public static void estimateKinematics(final Time timeInterval,
                                          final CoordinateTransformation c,
                                          final CoordinateTransformation oldC,
                                          final double vx, final double vy, final double vz,
                                          final double oldVx, final double oldVy, final double oldVz,
                                          final double x, final double y, final double z,
                                          final BodyKinematics result) {
        estimateKinematics(TimeConverter.convert(timeInterval.getValue().doubleValue(),
                timeInterval.getUnit(), TimeUnit.SECOND),
                c, oldC, vx, vy, vz, oldVx, oldVy, oldVz, x, y, z, result);
    }

    /**
     * Estimates body kinematics (specific force applied to a body and its angular rates).
     *
     * @param timeInterval time interval between epochs expressed in seconds (s).
     * @param frame        body ECEF frame containing current position, velocity and
     *                     body-to-ECEF frame coordinate transformation.
     * @param oldC         previous body-to-ECEF-frame coordinate transformation matrix.
     * @param oldVx        previous velocity of body frame x coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters
     *                     per second (m/s).
     * @param oldVy        previous velocity of body frame y coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters
     *                     per second (m/s).
     * @param oldVz        previous velocity of body frame z coordinate with respect ECEF
     *                     frame, resolved along EVEF-frame axes and expressed in meters
     *                     per second (m/s).
     * @param result       instance where body kinematics estimation will be stored.
     * @throws IllegalArgumentException if provided time interval is negative or coordinated transformation matrices
     *                                  are not ECEF frame valid.
     */
    public static void estimateKinematics(final double timeInterval,
                                          final ECEFFrame frame,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRangingRadioSourceEstimator2D.html#L810">810</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRangingRadioSourceEstimator3D.html#L812">812</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>        Point2D initialPosition = result.getEstimatedPosition();

        if (mRefineResult &amp;&amp; mInliersData != null) {
            BitSet inliers = mInliersData.getInliers();
            int nSamples = mReadings.size();

            mInnerReadings.clear();

            for (int i = 0; i &lt; nSamples; i++) {
                if (inliers.get(i)) {
                    //sample is inlier
                    mInnerReadings.add(mReadings.get(i));
                }
            }

            try {
                mInnerEstimator.setInitialPosition(initialPosition);
                mInnerEstimator.setReadings(mInnerReadings);

                mInnerEstimator.setNonLinearSolverEnabled(true);
                mInnerEstimator.setUseReadingPositionCovariances(
                        mUseReadingPositionCovariances);
                mInnerEstimator.estimate();

                Matrix cov = mInnerEstimator.getEstimatedCovariance();
                if (mKeepCovariance &amp;&amp; cov != null) {
                    //keep covariance
                    mEstimatedPositionCovariance = mCovariance = cov;

                } else {
                    mCovariance = null;
                    mEstimatedPositionCovariance = null;
                }

                mEstimatedPosition = mInnerEstimator.getEstimatedPosition();
            } catch (Exception e) {
                //refinement failed, so we return input value, and covariance
                //becomes unavailable
                mCovariance = null;
                mEstimatedPositionCovariance = null;

                mEstimatedPosition = initialPosition;
            }
        } else {
            mCovariance = null;
            mEstimatedPositionCovariance = null;

            mEstimatedPosition = initialPosition;
        }
    }
}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L7441">7441</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L7485">7485</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    private static double convertTimeToDouble(final Time time) {
        return TimeConverter.convert(time.getValue().doubleValue(), time.getUnit(),
                TimeUnit.SECOND);
    }

    /**
     * Converts provided distance instance into its corresponding value expressed in
     * meters.
     *
     * @param distance distance instance to be converted.
     * @return converted value expressed in meters.
     */
    private static double convertDistanceToDouble(final Distance distance) {
        return DistanceConverter.convert(distance.getValue().doubleValue(),
                distance.getUnit(), DistanceUnit.METER);
    }

    /**
     * Converts provided speed instance into its corresponding value expressed in
     * meters per second.
     *
     * @param speed speed instance to be converted.
     * @return converted value expressed in meters per second.
     */
    private static double convertSpeedToDouble(final Speed speed) {
        return SpeedConverter.convert(speed.getValue().doubleValue(),
                speed.getUnit(), SpeedUnit.METERS_PER_SECOND);
    }

    /**
     * Converts provided acceleration instance into its corresponding value expressed
     * in meters per squared second.
     *
     * @param acceleration acceleration instance to be converted.
     * @return converted value expressed in meters per squared second.
     */
    private static double convertAccelerationToDouble(final Acceleration acceleration) {
        return AccelerationConverter.convert(acceleration.getValue().doubleValue(),
                acceleration.getUnit(), AccelerationUnit.METERS_PER_SQUARED_SECOND);
    }

    /**
     * Converts provided angular speed into its corresponding value expressed in
     * radians per second.
     *
     * @param angularSpeed angular speed instance to be converted.
     * @return converted value expressed in radians per second.
     */
    private static double convertAngularSpeedToDouble(final AngularSpeed angularSpeed) {
        return AngularSpeedConverter.convert(angularSpeed.getValue().doubleValue(),
                angularSpeed.getUnit(), AngularSpeedUnit.RADIANS_PER_SECOND);
    }
}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRangingAndRssiRadioSourceEstimator2D.html#L374">374</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRangingRadioSourceEstimator2D.html#L151">151</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRssiRadioSourceEstimator2D.html#L385">385</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                initialPathLossExponent, listener);
    }

    /**
     * Returns threshold to determine whether samples are inliers or not.
     *
     * @return threshold to determine whether samples are inliers or not.
     */
    public double getThreshold() {
        return mThreshold;
    }

    /**
     * Sets threshold to determine whether samples are inliers or not.
     *
     * @param threshold threshold to be set.
     * @throws IllegalArgumentException if provided value is equal or less than
     * zero.
     * @throws LockedException if robust estimator is locked because an
     * estimation is already in progress.
     */
    public void setThreshold(double threshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (threshold &lt;= MIN_THRESHOLD) {
            throw new IllegalArgumentException();
        }
        mThreshold = threshold;
    }

    /**
     * Robustly estimates position, transmitted power and pathloss exponent for a
     * radio source.
     *
     * @throws LockedException if instance is busy during estimation.
     * @throws NotReadyException if estimator is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     * (i.e. numerical instability, no solution available, etc).
     */
    @Override
    public void estimate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        MSACRobustEstimator&lt;Solution&lt;Point2D&gt;&gt; innerEstimator =
                new MSACRobustEstimator&lt;&gt;(
                        new MSACRobustEstimatorListener&lt;Solution&lt;Point2D&gt;&gt;() {
                    @Override
                    public double getThreshold() {
                        return mThreshold;
                    }

                    @Override
                    public int getTotalSamples() {
                        return mReadings.size();
                    }

                    @Override
                    public int getSubsetSize() {
                        return Math.max(mPreliminarySubsetSize, getMinReadings());
                    }

                    @Override
                    public void estimatePreliminarSolutions(int[] samplesIndices,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRangingAndRssiRadioSourceEstimator3D.html#L374">374</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRangingRadioSourceEstimator3D.html#L151">151</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRssiRadioSourceEstimator3D.html#L385">385</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>                initialPathLossExponent, listener);
    }

    /**
     * Returns threshold to determine whether samples are inliers or not.
     *
     * @return threshold to determine whether samples are inliers or not.
     */
    public double getThreshold() {
        return mThreshold;
    }

    /**
     * Sets threshold to determine whether samples are inliers or not.
     *
     * @param threshold threshold to be set.
     * @throws IllegalArgumentException if provided value is equal or less than
     * zero.
     * @throws LockedException if robust estimator is locked because an
     * estimation is already in progress.
     */
    public void setThreshold(double threshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (threshold &lt;= MIN_THRESHOLD) {
            throw new IllegalArgumentException();
        }
        mThreshold = threshold;
    }

    /**
     * Robustly estimates position, transmitted power and pathloss exponent for a
     * radio source.
     *
     * @throws LockedException if instance is busy during estimation.
     * @throws NotReadyException if estimator is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     * (i.e. numerical instability, no solution available, etc).
     */
    @Override
    public void estimate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        MSACRobustEstimator&lt;Solution&lt;Point3D&gt;&gt; innerEstimator =
                new MSACRobustEstimator&lt;&gt;(
                        new MSACRobustEstimatorListener&lt;Solution&lt;Point3D&gt;&gt;() {
                            @Override
                            public double getThreshold() {
                                return mThreshold;
                            }

                            @Override
                            public int getTotalSamples() {
                                return mReadings.size();
                            }

                            @Override
                            public int getSubsetSize() {
                                return Math.max(mPreliminarySubsetSize, getMinReadings());
                            }

                            @Override
                            public void estimatePreliminarSolutions(int[] samplesIndices,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator2D.html#L833">833</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator3D.html#L329">329</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator2D.html#L844">844</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                initialPathLossExponent, listener);
        internalSetQualityScores(qualityScores);
    }

    /**
     * Returns threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value, the
     * algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algorithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @return stop threshold to stop the algorithm prematurely when a certain
     * accuracy has been reached.
     */
    public double getStopThreshold() {
        return mStopThreshold;
    }

    /**
     * Sets threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value,
     * the algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algorithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @param stopThreshold stop threshold to stop the algorithm prematurely
     *                      when a certain accuracy has been reached.
     * @throws IllegalArgumentException if provided value is zero or negative.
     * @throws LockedException if this solver is locked.
     */
    public void setStopThreshold(double stopThreshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (stopThreshold &lt;= MIN_STOP_THRESHOLD) {
            throw new IllegalArgumentException();
        }

        mStopThreshold = stopThreshold;
    }

    /**
     * Returns quality scores corresponding to each pair of
     * positions and distances (i.e. sample).
     * The larger the score value the better the quality of the sample.
     * This implementation always returns null.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @return quality scores corresponding to each sample.
     */
    @Override
    public double[] getQualityScores() {
        return mQualityScores;
    }

    /**
     * Sets quality scores corresponding to each pair of positions and
     * distances (i.e. sample).
     * The larger the score value the better the quality of the sample.
     * This implementation makes no action.
     * Subclasses using quality scores must implement proper behaviour.
     *
     * @param qualityScores quality scores corresponding to each pair of
     *                      matched points.
     * @throws IllegalArgumentException if provided quality scores length
     * is smaller than minimum required samples.
     * @throws LockedException if robust solver is locked because an
     * estimation is already in progress.
     */
    public void setQualityScores(double[] qualityScores) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetQualityScores(qualityScores);
    }

    /**
     * Indicates whether solver is ready to find a solution.
     *
     * @return true if solver is ready, false otherwise.
     */
    @Override
    public boolean isReady() {
        return super.isReady() &amp;&amp; mQualityScores != null &amp;&amp;
                mQualityScores.length == mReadings.size();
    }

    /**
     * Robustly estimates position, transmitted power and pathloss exponent for a
     * radio source.
     *
     * @throws LockedException if instance is busy during estimation.
     * @throws NotReadyException if estimator is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     * (i.e. numerical instability, no solution available, etc).
     */
    @Override
    public void estimate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        PROMedSRobustEstimator&lt;Solution&lt;Point2D&gt;&gt; innerEstimator =</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator3D.html#L833">833</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator2D.html#L329">329</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator3D.html#L843">843</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>                initialPathLossExponent, listener);
        internalSetQualityScores(qualityScores);
    }

    /**
     * Returns threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value, the
     * algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algorithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @return stop threshold to stop the algorithm prematurely when a certain
     * accuracy has been reached.
     */
    public double getStopThreshold() {
        return mStopThreshold;
    }

    /**
     * Sets threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value,
     * the algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algorithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @param stopThreshold stop threshold to stop the algorithm prematurely
     *                      when a certain accuracy has been reached.
     * @throws IllegalArgumentException if provided value is zero or negative.
     * @throws LockedException if this solver is locked.
     */
    public void setStopThreshold(double stopThreshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (stopThreshold &lt;= MIN_STOP_THRESHOLD) {
            throw new IllegalArgumentException();
        }

        mStopThreshold = stopThreshold;
    }

    /**
     * Returns quality scores corresponding to each pair of
     * positions and distances (i.e. sample).
     * The larger the score value the better the quality of the sample.
     * This implementation always returns null.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @return quality scores corresponding to each sample.
     */
    @Override
    public double[] getQualityScores() {
        return mQualityScores;
    }

    /**
     * Sets quality scores corresponding to each pair of positions and
     * distances (i.e. sample).
     * The larger the score value the better the quality of the sample.
     * This implementation makes no action.
     * Subclasses using quality scores must implement proper behaviour.
     *
     * @param qualityScores quality scores corresponding to each pair of
     *                      matched points.
     * @throws IllegalArgumentException if provided quality scores length
     * is smaller than minimum required samples.
     * @throws LockedException if robust solver is locked because an
     * estimation is already in progress.
     */
    public void setQualityScores(double[] qualityScores) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetQualityScores(qualityScores);
    }

    /**
     * Indicates whether solver is ready to find a solution.
     *
     * @return true if solver is ready, false otherwise.
     */
    @Override
    public boolean isReady() {
        return super.isReady() &amp;&amp; mQualityScores != null &amp;&amp;
                mQualityScores.length == mReadings.size();
    }

    /**
     * Robustly estimates position, transmitted power and pathloss exponent for a
     * radio source.
     *
     * @throws LockedException if instance is busy during estimation.
     * @throws NotReadyException if estimator is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     * (i.e. numerical instability, no solution available, etc).
     */
    @Override
    public void estimate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        PROMedSRobustEstimator&lt;Solution&lt;Point3D&gt;&gt; innerEstimator =</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/fingerprint/SecondOrderNonLinearFingerprintPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/fingerprint/SecondOrderNonLinearFingerprintPositionEstimator3D.html#L150">150</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/fingerprint/ThirdOrderNonLinearFingerprintPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/fingerprint/ThirdOrderNonLinearFingerprintPositionEstimator3D.html#L147">147</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    }

    /**
     * Evaluates a non-linear multi dimension function at provided point using
     * provided parameters and returns its evaluation and derivatives of the
     * function respect the function parameters.
     * @param i number of sample being evaluated.
     * @param point point where function will be evaluated.
     * @param params initial parameters estimation to be tried. These will
     * change as the Levenberg-Marquard algorithm iterates to the best solution.
     * These are used as input parameters along with point to evaluate function.
     * @param derivatives partial derivatives of the function respect to each
     * provided parameter.
     * @return function evaluation at provided point.
     */
    @Override
    @SuppressWarnings(&quot;Duplicates&quot;)
    protected double evaluate(int i, double[] point, double[] params, double[] derivatives) {
        //This method implements received power at point pi = (xi, yi, zi) and its derivatives

        //Pr(pi) = Pr(p1)
        // - 10*n*(x1 - xa)/(ln(10)*d1a^2)*(xi - x1)
        // - 10*n*(y1 - ya)/(ln(10)*d1a^2)*(yi - y1)
        // - 10*n*(z1 - za)/(ln(10)*d1a^2)*(zi - z1)
        // - 5*n*((y1 - ya)^2 + (z1 - za)^2 - (x1 - xa)^2)/(ln(10)*d1a^4)*(xi - x1)^2
        // - 5*n*((x1 - xa)^2 - (y1 - ya)^2 + (z1 - za)^2)/(ln(10)*d1a^4)*(yi - y1)^2
        // - 5*n*((x1 - xa)^2 + (y1 - ya)^2 - (z1 - za)^2)/(ln(10)*d1a^4)*(zi - z1)^2
        // + 20*n*(x1 - xa)*(y1 - ya)/(ln(10)*d1a^4)*(xi - x1)*(yi - y1)
        // + 20*n*(y1 - ya)*(z1 - za)/(ln(10)*d1a^4)*(yi - y1)*(zi - z1)
        // + 20*n*(x1 - xa)*(z1 - za)/(ln(10)*d1a^4)*(xi - x1)*(zi - z1)

        double xi = params[0];
        double yi = params[1];
        double zi = params[2];

        //received power
        double pr = point[0];

        //fingerprint coordinates
        double x1 = point[1];
        double y1 = point[2];
        double z1 = point[3];

        //radio source coordinates
        double xa = point[4];
        double ya = point[5];
        double za = point[6];

        //path loss exponent
        double n = point[7];

        double ln10 = Math.log(10.0);

        double diffXi1 = xi - x1;
        double diffYi1 = yi - y1;
        double diffZi1 = zi - z1;

        double diffX1a = x1 - xa;
        double diffY1a = y1 - ya;
        double diffZ1a = z1 - za;

        double diffXi12 = diffXi1 * diffXi1;
        double diffYi12 = diffYi1 * diffYi1;
        double diffZi12 = diffZi1 * diffZi1;

        double diffX1a2 = diffX1a * diffX1a;</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/RANSACRobustMixedPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/RANSACRobustMixedPositionEstimator2D.html#L146">146</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/RANSACRobustRangingAndRssiPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/RANSACRobustRangingAndRssiPositionEstimator2D.html#L146">146</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/RANSACRobustRangingPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/RANSACRobustRangingPositionEstimator2D.html#L146">146</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/RANSACRobustRssiPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/RANSACRobustRssiPositionEstimator2D.html#L145">145</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>            RobustMixedPositionEstimatorListener&lt;Point2D&gt; listener) {
        super(listener);
        init();
        internalSetSources(sources);
        internalSetFingerprint(fingerprint);
    }

    /**
     * Gets threshold to determine whether samples are inliers or not when testing
     * possible solutions.
     * The threshold refers to the amount of error on distance between estimated
     * position and distances provided for each sample.
     *
     * @return threshold to determine whether samples are inliers or not.
     */
    public double getThreshold() {
        return ((RANSACRobustLateration2DSolver) mLaterationSolver).
                getThreshold();
    }

    /**
     * Sets threshold to determine whether samples are inliers or not when testing
     * possible solutions.
     * The threshold refers to the amount of error on distance between estimated position
     * and distances provided for each sample.
     *
     * @param threshold threshold to determine whether samples are inliers or not.
     * @throws IllegalArgumentException if provided value is equal or less than zero.
     * @throws LockedException          if this estimator is locked.
     */
    public void setThreshold(double threshold) throws LockedException {
        ((RANSACRobustLateration2DSolver) mLaterationSolver).
                setThreshold(threshold);
    }

    /**
     * Indicates whether inliers must be computed and kept.
     *
     * @return true if inliers must be computed and kept, false if inliers
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepInliersEnabled() {
        return ((RANSACRobustLateration2DSolver) mLaterationSolver).
                isComputeAndKeepInliersEnabled();
    }

    /**
     * Specifies whether inliers must be computed and kept.
     *
     * @param computeAndKeepInliers true if inliers must be computed and kept,
     *                              false if inliers only need to be computed but not
     *                              kept.
     * @throws LockedException if this estimator is locked.
     */
    public void setComputeAndKeepInliersEnabled(boolean computeAndKeepInliers)
            throws LockedException {
        ((RANSACRobustLateration2DSolver) mLaterationSolver).
                setComputeAndKeepInliersEnabled(computeAndKeepInliers);
    }

    /**
     * Indicates whether residuals must be computed and kept.
     *
     * @return true if residuals must be computed and kept, false if residuals
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepResiduals() {
        return ((RANSACRobustLateration2DSolver) mLaterationSolver).
                isComputeAndKeepResiduals();
    }

    /**
     * Specifies whether residuals must be computed and kept.
     *
     * @param computeAndKeepResiduals true if residuals must be computed and kept,
     *                                false if residuals only need to be computed but not kept.
     * @throws LockedException if this estimator is locked.
     */
    public void setComputeAndKeepResidualsEnabled(boolean computeAndKeepResiduals)
            throws LockedException {
        ((RANSACRobustLateration2DSolver) mLaterationSolver).
                setComputeAndKeepResidualsEnabled(computeAndKeepResiduals);
    }

    /**
     * Returns method being used for robust estimation.
     *
     * @return method being used for robust estimation.
     */
    @Override
    public RobustEstimatorMethod getMethod() {
        return RobustEstimatorMethod.RANSAC;
    }

    /**
     * Initializes robust lateration solver.
     */
    private void init() {
        mLaterationSolver = new RANSACRobustLateration2DSolver(
                mTrilaterationSolverListener);
    }
}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/RANSACRobustMixedPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/RANSACRobustMixedPositionEstimator3D.html#L146">146</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/RANSACRobustRangingAndRssiPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/RANSACRobustRangingAndRssiPositionEstimator3D.html#L146">146</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/RANSACRobustRangingPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/RANSACRobustRangingPositionEstimator3D.html#L146">146</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/RANSACRobustRssiPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/RANSACRobustRssiPositionEstimator3D.html#L145">145</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>            RobustMixedPositionEstimatorListener&lt;Point3D&gt; listener) {
        super(listener);
        init();
        internalSetSources(sources);
        internalSetFingerprint(fingerprint);
    }

    /**
     * Gets threshold to determine whether samples are inliers or not when testing
     * possible solutions.
     * The threshold refers to the amount of error on distance between estimated
     * position and distances provided for each sample.
     *
     * @return threshold to determine whether samples are inliers or not.
     */
    public double getThreshold() {
        return ((RANSACRobustLateration3DSolver) mLaterationSolver).
                getThreshold();
    }

    /**
     * Sets threshold to determine whether samples are inliers or not when testing
     * possible solutions.
     * The threshold refers to the amount of error on distance between estimated position
     * and distances provided for each sample.
     *
     * @param threshold threshold to determine whether samples are inliers or not.
     * @throws IllegalArgumentException if provided value is equal or less than zero.
     * @throws LockedException          if this estimator is locked.
     */
    public void setThreshold(double threshold) throws LockedException {
        ((RANSACRobustLateration3DSolver) mLaterationSolver).
                setThreshold(threshold);
    }

    /**
     * Indicates whether inliers must be computed and kept.
     *
     * @return true if inliers must be computed and kept, false if inliers
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepInliersEnabled() {
        return ((RANSACRobustLateration3DSolver) mLaterationSolver).
                isComputeAndKeepInliersEnabled();
    }

    /**
     * Specifies whether inliers must be computed and kept.
     *
     * @param computeAndKeepInliers true if inliers must be computed and kept,
     *                              false if inliers only need to be computed but not
     *                              kept.
     * @throws LockedException if this estimator is locked.
     */
    public void setComputeAndKeepInliersEnabled(boolean computeAndKeepInliers)
            throws LockedException {
        ((RANSACRobustLateration3DSolver) mLaterationSolver).
                setComputeAndKeepInliersEnabled(computeAndKeepInliers);
    }

    /**
     * Indicates whether residuals must be computed and kept.
     *
     * @return true if residuals must be computed and kept, false if residuals
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepResiduals() {
        return ((RANSACRobustLateration3DSolver) mLaterationSolver).
                isComputeAndKeepResiduals();
    }

    /**
     * Specifies whether residuals must be computed and kept.
     *
     * @param computeAndKeepResiduals true if residuals must be computed and kept,
     *                                false if residuals only need to be computed but not kept.
     * @throws LockedException if this estimator is locked.
     */
    public void setComputeAndKeepResidualsEnabled(boolean computeAndKeepResiduals)
            throws LockedException {
        ((RANSACRobustLateration3DSolver) mLaterationSolver).
                setComputeAndKeepResidualsEnabled(computeAndKeepResiduals);
    }

    /**
     * Returns method being used for robust estimation.
     *
     * @return method being used for robust estimation.
     */
    @Override
    public RobustEstimatorMethod getMethod() {
        return RobustEstimatorMethod.RANSAC;
    }

    /**
     * Initializes robust lateration solver.
     */
    private void init() {
        mLaterationSolver = new RANSACRobustLateration3DSolver(
                mTrilaterationSolverListener);
    }
}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator2D.html#L396">396</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator3D.html#L173">173</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator2D.html#L407">407</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                initialPathLossExponent, listener);
    }

    /**
     * Gets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on received power (RSSI) expressed
     * in dBm's between received value that should have been received on estimated
     * isotropical model and actual measured value.
     *
     * @return threshold to determine whether samples are inliers or not.
     */
    public double getThreshold() {
        return mThreshold;
    }

    /**
     * Sets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on received power (RSSI) expressed
     * in dBm's between received value that should have been received on estimated
     * isotropical model and actual measured value.
     *
     * @param threshold threshold to determine whether samples are inliers or not.
     * @throws IllegalArgumentException if provided value is equal or less than zero.
     * @throws LockedException if this estimator is locked.
     */
    public void setThreshold(double threshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (threshold &lt;= MIN_THRESHOLD) {
            throw new IllegalArgumentException();
        }
        mThreshold = threshold;
    }


    /**
     * Indicates whether inliers must be computed and kept.
     *
     * @return true if inliers must be computed and kept, false if inliers
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepInliersEnabled() {
        return mComputeAndKeepInliers;
    }

    /**
     * Specifies whether inliers must be computed and kept.
     *
     * @param computeAndKeepInliers true if inliers must be computed and kept,
     *                              false if inliers only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepInliersEnabled(boolean computeAndKeepInliers)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mComputeAndKeepInliers = computeAndKeepInliers;
    }

    /**
     * Indicates whether residuals must be computed and kept.
     *
     * @return true if residuals must be computed and kept, false if residuals
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepResidualsEnabled() {
        return mComputeAndKeepResiduals;
    }

    /**
     * Specifies whether residuals must be computed and kept.
     *
     * @param computeAndKeepResiduals true if residuals must be computed and kept,
     *                                false if residuals only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepResidualsEnabled(boolean computeAndKeepResiduals)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mComputeAndKeepResiduals = computeAndKeepResiduals;
    }

    /**
     * Robustly estimates position, transmitted power and pathloss exponent for a
     * radio source.
     *
     * @throws LockedException if instance is busy during estimation.
     * @throws NotReadyException if estimator is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     * (i.e. numerical instability, no solution available, etc).
     */
    @Override
    public void estimate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        RANSACRobustEstimator&lt;Solution&lt;Point2D&gt;&gt; innerEstimator =</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator3D.html#L396">396</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator2D.html#L173">173</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator3D.html#L407">407</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>                initialPathLossExponent, listener);
    }

    /**
     * Gets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on received power (RSSI) expressed
     * in dBm's between received value that should have been received on estimated
     * isotropical model and actual measured value.
     *
     * @return threshold to determine whether samples are inliers or not.
     */
    public double getThreshold() {
        return mThreshold;
    }

    /**
     * Sets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on received power (RSSI) expressed
     * in dBm's between received value that should have been received on estimated
     * isotropical model and actual measured value.
     *
     * @param threshold threshold to determine whether samples are inliers or not.
     * @throws IllegalArgumentException if provided value is equal or less than zero.
     * @throws LockedException if this estimator is locked.
     */
    public void setThreshold(double threshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (threshold &lt;= MIN_THRESHOLD) {
            throw new IllegalArgumentException();
        }
        mThreshold = threshold;
    }


    /**
     * Indicates whether inliers must be computed and kept.
     *
     * @return true if inliers must be computed and kept, false if inliers
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepInliersEnabled() {
        return mComputeAndKeepInliers;
    }

    /**
     * Specifies whether inliers must be computed and kept.
     *
     * @param computeAndKeepInliers true if inliers must be computed and kept,
     *                              false if inliers only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepInliersEnabled(boolean computeAndKeepInliers)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mComputeAndKeepInliers = computeAndKeepInliers;
    }

    /**
     * Indicates whether residuals must be computed and kept.
     *
     * @return true if residuals must be computed and kept, false if residuals
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepResidualsEnabled() {
        return mComputeAndKeepResiduals;
    }

    /**
     * Specifies whether residuals must be computed and kept.
     *
     * @param computeAndKeepResiduals true if residuals must be computed and kept,
     *                                false if residuals only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepResidualsEnabled(boolean computeAndKeepResiduals)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mComputeAndKeepResiduals = computeAndKeepResiduals;
    }

    /**
     * Robustly estimates position, transmitted power and pathloss exponent for a
     * radio source.
     *
     * @throws LockedException if instance is busy during estimation.
     * @throws NotReadyException if estimator is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     * (i.e. numerical instability, no solution available, etc).
     */
    @Override
    public void estimate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        RANSACRobustEstimator&lt;Solution&lt;Point3D&gt;&gt; innerEstimator =</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustMixedRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustMixedRadioSourceEstimator.html#L2368">2368</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator.html#L2240">2240</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>            List&lt;? extends ReadingLocated&lt;P&gt;&gt; readings) {
        if (!areValidReadings(readings)) {
            throw new IllegalArgumentException();
        }

        mReadings = readings;
    }

    /**
     * Sets quality scores corresponding to each provided sample.
     * This method is used internally and does not check whether instance is
     * locked or not.
     *
     * @param qualityScores quality scores to be set.
     * @throws IllegalArgumentException if provided quality scores length
     * is smaller than required minimum.
     */
    private void internalSetQualityScores(double[] qualityScores) {
        if (qualityScores == null ||
                qualityScores.length &lt; getMinReadings()) {
            throw new IllegalArgumentException();
        }

        mQualityScores = qualityScores;
    }

    /**
     * Creates a ranging reading from a ranging and RSSI reading.
     *
     * @param reading input reading to convert from.
     * @return a ranging reading containing only the ranging data of input reading.
     */
    private RangingReadingLocated&lt;S, P&gt; createRangingReading(RangingAndRssiReadingLocated&lt;S, P&gt; reading) {
        return new RangingReadingLocated&lt;&gt;(reading.getSource(),
                reading.getDistance(), reading.getPosition(),
                reading.getDistanceStandardDeviation(),
                reading.getPositionCovariance());
    }

    /**
     * Creates an RSSI reading from a ranging and RSSI reading.
     *
     * @param reading input reading to convert from.
     * @return an RSSI reading containing only the RSSI data of input reading.
     */
    private RssiReadingLocated&lt;S, P&gt; createRssiReading(RangingAndRssiReadingLocated&lt;S, P&gt; reading) {
        return new RssiReadingLocated&lt;&gt;(reading.getSource(),
                reading.getRssi(), reading.getPosition(),
                reading.getRssiStandardDeviation(),
                reading.getPositionCovariance());
    }</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator2D.html#L1051">1051</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator2D.html#L541">541</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator2D.html#L1056">1056</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                                    PROSACRobustRangingAndRssiRadioSourceEstimator2D.this, progress);
                        }
                    }
                });

        try {
            mLocked = true;
            mInliersData = null;
            innerEstimator.setComputeAndKeepInliersEnabled(
                    mComputeAndKeepInliers || mRefineResult);
            innerEstimator.setComputeAndKeepResidualsEnabled(
                    mComputeAndKeepResiduals || mRefineResult);
            innerEstimator.setConfidence(mConfidence);
            innerEstimator.setMaxIterations(mMaxIterations);
            innerEstimator.setProgressDelta(mProgressDelta);
            Solution&lt;Point2D&gt; result = innerEstimator.estimate();
            mInliersData = innerEstimator.getInliersData();
            attemptRefine(result);

        } catch (com.irurueta.numerical.LockedException e) {
            throw new LockedException(e);
        } catch (com.irurueta.numerical.NotReadyException e) {
            throw new NotReadyException(e);
        } finally {
            mLocked = false;
        }
    }

    /**
     * Returns method being used for robust estimation.
     *
     * @return method being used for robust estimation.
     */
    @Override
    public RobustEstimatorMethod getMethod() {
        return RobustEstimatorMethod.PROSAC;
    }

    /**
     * Sets quality scores corresponding to each provided sample.
     * This method is used internally and does not check whether instance is
     * locked or not.
     *
     * @param qualityScores quality scores to be set.
     * @throws IllegalArgumentException if provided quality scores length
     * is smaller than required minimum.
     */
    private void internalSetQualityScores(double[] qualityScores) {
        if (qualityScores == null ||
                qualityScores.length &lt; getMinReadings()) {
            throw new IllegalArgumentException();
        }

        mQualityScores = qualityScores;
    }
}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator3D.html#L1051">1051</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator3D.html#L541">541</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator3D.html#L1055">1055</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>                                            PROSACRobustRangingAndRssiRadioSourceEstimator3D.this, progress);
                                }
                            }
                        });

        try {
            mLocked = true;
            mInliersData = null;
            innerEstimator.setComputeAndKeepInliersEnabled(
                    mComputeAndKeepInliers || mRefineResult);
            innerEstimator.setComputeAndKeepResidualsEnabled(
                    mComputeAndKeepResiduals || mRefineResult);
            innerEstimator.setConfidence(mConfidence);
            innerEstimator.setMaxIterations(mMaxIterations);
            innerEstimator.setProgressDelta(mProgressDelta);
            Solution&lt;Point3D&gt; result = innerEstimator.estimate();
            mInliersData = innerEstimator.getInliersData();
            attemptRefine(result);

        } catch (com.irurueta.numerical.LockedException e) {
            throw new LockedException(e);
        } catch (com.irurueta.numerical.NotReadyException e) {
            throw new NotReadyException(e);
        } finally {
            mLocked = false;
        }
    }

    /**
     * Returns method being used for robust estimation.
     *
     * @return method being used for robust estimation.
     */
    @Override
    public RobustEstimatorMethod getMethod() {
        return RobustEstimatorMethod.PROSAC;
    }

    /**
     * Sets quality scores corresponding to each provided sample.
     * This method is used internally and does not check whether instance is
     * locked or not.
     *
     * @param qualityScores quality scores to be set.
     * @throws IllegalArgumentException if provided quality scores length
     * is smaller than required minimum.
     */
    private void internalSetQualityScores(double[] qualityScores) {
        if (qualityScores == null ||
                qualityScores.length &lt; getMinReadings()) {
            throw new IllegalArgumentException();
        }

        mQualityScores = qualityScores;
    }
}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/lateration/HomogeneousLinearLeastSquaresLateration2DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/HomogeneousLinearLeastSquaresLateration2DSolver.html#L119">119</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/lateration/InhomogeneousLinearLeastSquaresLateration2DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/InhomogeneousLinearLeastSquaresLateration2DSolver.html#L119">119</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/lateration/NonLinearLeastSquaresLateration2DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/NonLinearLeastSquaresLateration2DSolver.html#L316">316</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>        internalSetCircles(circles);
    }

    /**
     * Gets number of dimensions of provided points.
     * @return always returns 2 dimensions.
     */
    @Override
    public int getNumberOfDimensions() {
        return Point2D.POINT2D_INHOMOGENEOUS_COORDINATES_LENGTH;
    }

    /**
     * Minimum required number of positions and distances.
     * At least 3 positions and distances will be required to linearly solve a 2D problem.
     * @return minimum required number of positions and distances.
     */
    @Override
    public int getMinRequiredPositionsAndDistances() {
        return Point2D.POINT2D_INHOMOGENEOUS_COORDINATES_LENGTH + 1;
    }

    /**
     * Gets estimated position.
     * @return estimated position.
     */
    @Override
    public Point2D getEstimatedPosition() {
        if (mEstimatedPositionCoordinates == null) {
            return null;
        }

        InhomogeneousPoint2D position = new InhomogeneousPoint2D();
        getEstimatedPosition(position);
        return position;
    }

    /**
     * Internally sets circles defining positions and euclidean distances.
     * @param circles circles defining positions and distances.
     * @throws IllegalArgumentException if circles is null or length of array of circles
     * is less than 3.
     */
    private void internalSetCircles(Circle[] circles) {
        if (circles == null || circles.length &lt; getMinRequiredPositionsAndDistances()) {
            throw new IllegalArgumentException();
        }

        Point2D[] positions = new Point2D[circles.length];
        double[] distances = new double[circles.length];
        for (int i = 0; i &lt; circles.length; i++) {
            Circle circle = circles[i];
            positions[i] = circle.getCenter();
            distances[i] = circle.getRadius();
        }

        internalSetPositionsAndDistances(positions, distances);
    }</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/LMedSRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/LMedSRobustRangingRadioSourceEstimator2D.html#L175">175</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/LMedSRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/LMedSRobustRssiRadioSourceEstimator2D.html#L409">409</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>        super(readings, initialPosition, listener);
    }

    /**
     * Returns threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value, the
     * algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algrithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @return stop threshold to stop the algorithm prematurely when a certain
     * accuracy has been reached.
     */
    public double getStopThreshold() {
        return mStopThreshold;
    }

    /**
     * Sets threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value,
     * the algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algorithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @param stopThreshold stop threshold to stop the algorithm prematurely
     *                      when a certain accuracy has been reached.
     * @throws IllegalArgumentException if provided value is zero or negative.
     * @throws LockedException if this solver is locked.
     */
    public void setStopThreshold(double stopThreshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (stopThreshold &lt;= MIN_STOP_THRESHOLD) {
            throw new IllegalArgumentException();
        }

        mStopThreshold = stopThreshold;
    }

    /**
     * Robustly estimates position for a radio source.
     *
     * @throws LockedException if instance is busy during estimation.
     * @throws NotReadyException if estimator is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     * (i.e. numerical instability, no solution available, etc).
     */
    @Override
    public void estimate() throws LockedException, NotReadyException,
            RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        LMedSRobustEstimator&lt;Solution&lt;Point2D&gt;&gt; innerEstimator =
                new LMedSRobustEstimator&lt;&gt;(
                        new LMedSRobustEstimatorListener&lt;Solution&lt;Point2D&gt;&gt;() {
                    @Override
                    public int getTotalSamples() {
                        return mReadings.size();
                    }

                    @Override
                    public int getSubsetSize() {
                        return Math.max(mPreliminarySubsetSize, getMinReadings());
                    }

                    @Override
                    public void estimatePreliminarSolutions(int[] sampleIndices,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/LMedSRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/LMedSRobustRangingRadioSourceEstimator3D.html#L175">175</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/LMedSRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/LMedSRobustRssiRadioSourceEstimator3D.html#L409">409</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>        super(readings, initialPosition, listener);
    }

    /**
     * Returns threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value, the
     * algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algrithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @return stop threshold to stop the algorithm prematurely when a certain
     * accuracy has been reached.
     */
    public double getStopThreshold() {
        return mStopThreshold;
    }

    /**
     * Sets threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value,
     * the algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algorithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @param stopThreshold stop threshold to stop the algorithm prematurely
     *                      when a certain accuracy has been reached.
     * @throws IllegalArgumentException if provided value is zero or negative.
     * @throws LockedException if this solver is locked.
     */
    public void setStopThreshold(double stopThreshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (stopThreshold &lt;= MIN_STOP_THRESHOLD) {
            throw new IllegalArgumentException();
        }

        mStopThreshold = stopThreshold;
    }

    /**
     * Robustly estimates position for a radio source.
     *
     * @throws LockedException if instance is busy during estimation.
     * @throws NotReadyException if estimator is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     * (i.e. numerical instability, no solution available, etc).
     */
    @Override
    public void estimate() throws LockedException, NotReadyException,
            RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        LMedSRobustEstimator&lt;Solution&lt;Point3D&gt;&gt; innerEstimator =
                new LMedSRobustEstimator&lt;&gt;(
                        new LMedSRobustEstimatorListener&lt;Solution&lt;Point3D&gt;&gt;() {
                    @Override
                    public int getTotalSamples() {
                        return mReadings.size();
                    }

                    @Override
                    public int getSubsetSize() {
                        return Math.max(mPreliminarySubsetSize, getMinReadings());
                    }

                    @Override
                    public void estimatePreliminarSolutions(int[] sampleIndices,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/fingerprint/SecondOrderNonLinearFingerprintPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/fingerprint/SecondOrderNonLinearFingerprintPositionEstimator3D.html#L222">222</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/fingerprint/ThirdOrderNonLinearFingerprintPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/fingerprint/ThirdOrderNonLinearFingerprintPositionEstimator3D.html#L434">434</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>        double value1 = - 10.0 * n * diffX1a / (ln10 * d1a2);
        double value2 = - 10.0 * n * diffY1a / (ln10 * d1a2);
        double value3 = - 10.0 * n * diffZ1a / (ln10 * d1a2);
        double value4 = - 5.0 * n * (-diffX1a2 + diffY1a2 + diffZ1a2) / (ln10 * d1a4);
        double value5 = - 5.0 * n * (diffX1a2 - diffY1a2 + diffZ1a2) / (ln10 * d1a4);
        double value6 = - 5.0 * n * (diffX1a2 + diffY1a2 - diffZ1a2) / (ln10 * d1a4);
        double value7 = 20.0 * n * diffX1a * diffY1a / (ln10 * d1a4);
        double value8 = 20.0 * n * diffY1a * diffZ1a / (ln10 * d1a4);
        double value9 = 20.0 * n * diffX1a * diffZ1a / (ln10 * d1a4);

        double result = pr</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator2D.html#L1024">1024</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator2D.html#L520">520</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator2D.html#L1035">1035</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>                                    PROMedSRobustRangingAndRssiRadioSourceEstimator2D.this, progress);
                        }
                    }
                });

        try {
            mLocked = true;
            mInliersData = null;

            //inlier thresholds are disabled to obtain a less restrictive amount of inliers
            innerEstimator.setUseInlierThresholds(false);

            innerEstimator.setConfidence(mConfidence);
            innerEstimator.setMaxIterations(mMaxIterations);
            innerEstimator.setProgressDelta(mProgressDelta);
            Solution&lt;Point2D&gt; result = innerEstimator.estimate();
            mInliersData = innerEstimator.getInliersData();
            attemptRefine(result);

        } catch (com.irurueta.numerical.LockedException e) {
            throw new LockedException(e);
        } catch (com.irurueta.numerical.NotReadyException e) {
            throw new NotReadyException(e);
        } finally {
            mLocked = false;
        }
    }

    /**
     * Returns method being used for robust estimation.
     *
     * @return method being used for robust estimation.
     */
    @Override
    public RobustEstimatorMethod getMethod() {
        return RobustEstimatorMethod.PROMedS;
    }

    /**
     * Sets quality scores corresponding to each provided sample.
     * This method is used internally and does not check whether instance is
     * locked or not.
     *
     * @param qualityScores quality scores to be set.
     * @throws IllegalArgumentException if provided quality scores length
     * is smaller than 3 samples.
     */
    private void internalSetQualityScores(double[] qualityScores) {
        if (qualityScores == null ||
                qualityScores.length &lt; getMinReadings()) {
            throw new IllegalArgumentException();
        }

        mQualityScores = qualityScores;
    }
}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator3D.html#L1024">1024</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator3D.html#L519">519</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator3D.html#L1034">1034</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                                            PROMedSRobustRangingAndRssiRadioSourceEstimator3D.this, progress);
                                }
                            }
                        });

        try {
            mLocked = true;
            mInliersData = null;

            //inlier thresholds are disabled to obtain a less restrictive amount of inliers
            innerEstimator.setUseInlierThresholds(false);

            innerEstimator.setConfidence(mConfidence);
            innerEstimator.setMaxIterations(mMaxIterations);
            innerEstimator.setProgressDelta(mProgressDelta);
            Solution&lt;Point3D&gt; result = innerEstimator.estimate();
            mInliersData = innerEstimator.getInliersData();
            attemptRefine(result);

        } catch (com.irurueta.numerical.LockedException e) {
            throw new LockedException(e);
        } catch (com.irurueta.numerical.NotReadyException e) {
            throw new NotReadyException(e);
        } finally {
            mLocked = false;
        }
    }

    /**
     * Returns method being used for robust estimation.
     *
     * @return method being used for robust estimation.
     */
    @Override
    public RobustEstimatorMethod getMethod() {
        return RobustEstimatorMethod.PROMedS;
    }

    /**
     * Sets quality scores corresponding to each provided sample.
     * This method is used internally and does not check whether instance is
     * locked or not.
     *
     * @param qualityScores quality scores to be set.
     * @throws IllegalArgumentException if provided quality scores length
     * is smaller than 3 samples.
     */
    private void internalSetQualityScores(double[] qualityScores) {
        if (qualityScores == null ||
                qualityScores.length &lt; getMinReadings()) {
            throw new IllegalArgumentException();
        }

        mQualityScores = qualityScores;
    }
}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/fingerprint/NonLinearFingerprintPositionAndRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/fingerprint/NonLinearFingerprintPositionAndRadioSourceEstimator.html#L462">462</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/fingerprint/NonLinearFingerprintPositionEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/fingerprint/NonLinearFingerprintPositionEstimator.html#L314">314</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>        if (fallbackRssiStandardDeviation &lt; TINY) {
            throw new IllegalArgumentException();
        }
        mFallbackRssiStandardDeviation = fallbackRssiStandardDeviation;
    }

    /**
     * Indicates whether measured RSSI standard deviation of closest fingerprint must be
     * propagated into measured RSSI reading variance at unknown location.
     * @return true to propagate RSSI standard deviation of closest fingerprint,
     * false otherwise.
     */
    public boolean isFingerprintRssiStandardDeviationPropagated() {
        return mPropagateFingerprintRssiStandardDeviation;
    }

    /**
     * Specifies whether measured RSSI standard deviation of closest fingerprint must be
     * propagated into measured RSSI reading variance at unknown location.
     * @param propagateFingerprintRssiStandardDeviation true to propagate RSSI standard
     *                                                  deviation of closest fingerprint,
     *                                                  false otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setFingerprintRssiStandardDeviationPropagated(
            boolean propagateFingerprintRssiStandardDeviation) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mPropagateFingerprintRssiStandardDeviation =
                propagateFingerprintRssiStandardDeviation;
    }

    /**
     * Indicates whether path-loss exponent standard deviation of radio source must be
     * propagated into measured RSSI reading variance at unknown location.
     * @return true to propagate  path-loss exponent standard deviation of radio source,
     * false otherwise.
     */
    public boolean isPathlossExponentStandardDeviationPropagated() {
        return mPropagatePathlossExponentStandardDeviation;
    }

    /**
     * Specifies whether path-loss exponent standard deviation of radio source must be
     * propagated into measured RSSI reading variance at unknown location.
     * @param propagatePathlossExponentStandardDeviation true to propagate path-loss
     *                                                   exponent standard deviation of
     *                                                   radio source, false otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setPathlossExponentStandardDeviationPropagated(
            boolean propagatePathlossExponentStandardDeviation) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mPropagatePathlossExponentStandardDeviation =
                propagatePathlossExponentStandardDeviation;
    }

    /**
     * Indicates whether covariance of closest fingerprint position must be propagated
     * into measured RSSI reading variance at unknown location.
     * @return true to propagate fingerprint position covariance, false otherwise.
     */
    public boolean isFingerprintPositionCovariancePropagated() {
        return mPropagateFingerprintPositionCovariance;
    }

    /**
     * Specifies whether covariance of closest fingerprint position must be propagated
     * into measured RSSI reading variance at unknown location.
     * @param propagateFingerprintPositionCovariance true to propagate fingerprint
     *                                               position covariance, false otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setFingerprintPositionCovariancePropagated(
            boolean propagateFingerprintPositionCovariance) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mPropagateFingerprintPositionCovariance =
                propagateFingerprintPositionCovariance;
    }

    /**
     * Indicates whether covariance of radio source position must be propagated into
     * measured RSSI reading variance at unknown location.
     * @return true to propagate radio source position covariance, false otherwise.
     */
    public boolean isRadioSourcePositionCovariancePropagated() {
        return mPropagateRadioSourcePositionCovariance;
    }

    /**
     * Specifies whether covariance of radio source position must be propagated into
     * measured RSSI reading variance at unknown location.
     * @param propagateRadioSourcePositionCovariance true to propagate radio source
     *                                               position covariance, false otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setRadioSourcePositionCovariancePropagated(
            boolean propagateRadioSourcePositionCovariance) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mPropagateRadioSourcePositionCovariance =
                propagateRadioSourcePositionCovariance;
    }</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/fingerprint/FirstOrderNonLinearFingerprintPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/fingerprint/FirstOrderNonLinearFingerprintPositionEstimator3D.html#L150">150</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/fingerprint/SecondOrderNonLinearFingerprintPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/fingerprint/SecondOrderNonLinearFingerprintPositionEstimator3D.html#L150">150</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/fingerprint/ThirdOrderNonLinearFingerprintPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/fingerprint/ThirdOrderNonLinearFingerprintPositionEstimator3D.html#L147">147</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    }

    /**
     * Evaluates a non-linear multi dimension function at provided point using
     * provided parameters and returns its evaluation and derivatives of the
     * function respect the function parameters.
     * @param i number of sample being evaluated.
     * @param point point where function will be evaluated.
     * @param params initial parameters estimation to be tried. These will
     * change as the Levenberg-Marquard algorithm iterates to the best solution.
     * These are used as input parameters along with point to evaluate function.
     * @param derivatives partial derivatives of the function respect to each
     * provided parameter.
     * @return function evaluation at provided point.
     */
    @Override
    @SuppressWarnings(&quot;Duplicates&quot;)
    protected double evaluate(int i, double[] point, double[] params, double[] derivatives) {
        //This method implements received power at point pi = (xi, yi, zi) and its derivatives

        //Pr(pi) = Pr(p1)
        //  - 10*n*(x1 - xa)/(ln(10)*d1a^2)*(xi - x1)
        //  - 10*n*(y1 - ya)/(ln(10)*d1a^2)*(yi - y1)
        //  - 10*n*(z1 - za)/(ln(10)*d1a^2)*(zi - z1)

        double xi = params[0];
        double yi = params[1];
        double zi = params[2];

        //received power
        double pr = point[0];

        //fingerprint coordinates
        double x1 = point[1];
        double y1 = point[2];
        double z1 = point[3];

        //radio source coordinates
        double xa = point[4];
        double ya = point[5];
        double za = point[6];

        //path loss exponent
        double n = point[7];

        double ln10 = Math.log(10.0);

        double diffXi1 = xi - x1;
        double diffYi1 = yi - y1;
        double diffZi1 = zi - z1;

        double diffX1a = x1 - xa;
        double diffY1a = y1 - ya;
        double diffZ1a = z1 - za;

        double diffX1a2 = diffX1a * diffX1a;</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/PositionEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PositionEstimator.html#L74">74</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/RobustPositionEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/RobustPositionEstimator.html#L137">137</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    public PositionEstimator(L listener) {
        mListener = listener;
    }

    /**
     * Gets located radio sources ussed for lateration.
     *
     * @return located radio sources used for lateration.
     */
    public List&lt;? extends RadioSourceLocated&lt;P&gt;&gt; getSources() {
        return mSources;
    }

    /**
     * Sets located radio sources used for lateration.
     *
     * @param sources located radio sources used for lateration.
     * @throws LockedException          if estimator is locked.
     * @throws IllegalArgumentException if provided value is null or the number of provided
     *                                  sources is less than the required minimum.
     */
    public void setSources(List&lt;? extends RadioSourceLocated&lt;P&gt;&gt; sources)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }

        internalSetSources(sources);
    }

    /**
     * Gets fingerprint containing readings at an unknown location for provided located
     * radio sources.
     *
     * @return  fingerprint containing readings at an unknown location for provided
     *          located radio sources.
     */
    public Fingerprint&lt;? extends RadioSource, ? extends R&gt; getFingerprint() {
        return mFingerprint;
    }

    /**
     * Sets fingerprint containing readings at an unknown location for provided located
     * radio sources.
     * @param fingerprint fingerprint containing readings at an unknown location for
     *                    provided located radio sources.
     * @throws LockedException          if estimator is locked.
     * @throws IllegalArgumentException if provided value is null.
     */
    public void setFingerprint(Fingerprint&lt;? extends RadioSource, ? extends R&gt; fingerprint)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }

        internalSetFingerprint(fingerprint);
    }

    /**
     * Gets listener to be notified of events raised by this instance.
     *
     * @return listener to be notified of events raised by this instance.
     */
    public L getListener() {
        return mListener;
    }

    /**
     * Sets listener to be notified of events raised by this instance.
     *
     * @param listener listener to be notified of events raised by this instance.
     * @throws LockedException if estimator is locked.
     */
    public void setListener(L listener) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mListener = listener;
    }

    /**
     * Gets estimated inhomogeneous position coordinates.
     *
     * @return estimated inhomogeneous position coordinates.
     */
    public double[] getEstimatedPositionCoordinates() {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/fingerprint/NonLinearFingerprintPositionAndRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/fingerprint/NonLinearFingerprintPositionAndRadioSourceEstimator.html#L570">570</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/fingerprint/NonLinearFingerprintPositionEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/fingerprint/NonLinearFingerprintPositionEstimator.html#L438">438</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    }

    /**
     * Estimates position and radio sources based on provided located radio sources and readings of
     * such radio sources at an unknown location.
     * @throws LockedException if estimator is locked.
     * @throws NotReadyException if estimator is not ready.
     * @throws FingerprintEstimationException if estimation fails for some other reason.
     */
    @Override
    @SuppressWarnings(&quot;Duplicates&quot;)
    public void estimate() throws LockedException, NotReadyException,
            FingerprintEstimationException {

        if (!isReady()) {
            throw new NotReadyException();
        }
        if (isLocked()) {
            throw new LockedException();
        }

        try {
            mLocked = true;

            if (mListener != null) {
                mListener.onEstimateStart(this);
            }

            RadioSourceNoMeanKNearestFinder&lt;P, RadioSource&gt; noMeanfinder = null;
            RadioSourceKNearestFinder&lt;P, RadioSource&gt; finder = null;
            if (mUseNoMeanNearestFingerprintFinder) {
                //noinspection unchecked
                noMeanfinder = new RadioSourceNoMeanKNearestFinder&lt;&gt;(
                        (Collection&lt;? extends RssiFingerprintLocated&lt;RadioSource,
                                RssiReading&lt;RadioSource&gt;, P&gt;&gt;)mLocatedFingerprints);
            } else {
                //noinspection unchecked
                finder = new RadioSourceKNearestFinder&lt;&gt;(
                        (Collection&lt;? extends RssiFingerprintLocated&lt;RadioSource,
                                RssiReading&lt;RadioSource&gt;, P&gt;&gt;)mLocatedFingerprints);
            }

            mEstimatedPositionCoordinates = null;
            mCovariance = null;</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustMixedRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustMixedRadioSourceEstimator.html#L2321">2321</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator.html#L2187">2187</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>        }

        mRssiEstimator.setProgressDelta(2.0f * mProgressDelta);
        mRssiEstimator.setConfidence(mRssiConfidence);
        mRssiEstimator.setMaxIterations(mRssiMaxIterations);
        mRssiEstimator.setResultRefined(mRefineResult);
        mRssiEstimator.setCovarianceKept(mKeepCovariance);

        //initial position is not set because position estimated from ranging measures
        //will be later used
        mRssiEstimator.setInitialTransmittedPowerdBm(mInitialTransmittedPowerdBm);
        mRssiEstimator.setInitialPathLossExponent(mInitialPathLossExponent);

        mRssiEstimator.setTransmittedPowerEstimationEnabled(
                mTransmittedPowerEstimationEnabled);
        mRssiEstimator.setPathLossEstimationEnabled(mPathLossEstimationEnabled);

        mRssiEstimator.setListener(new RobustRssiRadioSourceEstimatorListener&lt;S, P&gt;() {
            @Override
            public void onEstimateStart(RobustRssiRadioSourceEstimator&lt;S, P&gt; estimator) { /* not used */ }

            @Override
            public void onEstimateEnd(RobustRssiRadioSourceEstimator&lt;S, P&gt; estimator) { /* not used */ }

            @Override
            public void onEstimateNextIteration(RobustRssiRadioSourceEstimator&lt;S, P&gt; estimator,
                                                int iteration) { /* not used */ }

            @Override
            public void onEstimateProgressChange(RobustRssiRadioSourceEstimator&lt;S, P&gt; estimator, float progress) {
                if (mListener != null) {
                    mListener.onEstimateProgressChange(</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/fingerprint/LinearFingerprintPositionEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/fingerprint/LinearFingerprintPositionEstimator.html#L99">99</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/fingerprint/NonLinearFingerprintPositionAndRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/fingerprint/NonLinearFingerprintPositionAndRadioSourceEstimator.html#L570">570</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/fingerprint/NonLinearFingerprintPositionEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/fingerprint/NonLinearFingerprintPositionEstimator.html#L438">438</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    }

    /**
     * Estimates position based on provided located radio sources and readings of such radio sources at
     * an unknown location.
     * @throws LockedException if estimator is locked.
     * @throws NotReadyException if estimator is not ready.
     * @throws FingerprintEstimationException if estimation fails for some other reason.
     */
    @Override
    @SuppressWarnings(&quot;Duplicates&quot;)
    public void estimate() throws LockedException, NotReadyException,
            FingerprintEstimationException {

        if (!isReady()) {
            throw new NotReadyException();
        }
        if (isLocked()) {
            throw new LockedException();
        }

        try {
            mLocked = true;

            if (mListener != null) {
                mListener.onEstimateStart(this);
            }

            RadioSourceNoMeanKNearestFinder&lt;P, RadioSource&gt; noMeanfinder = null;
            RadioSourceKNearestFinder&lt;P, RadioSource&gt; finder = null;
            if (mUseNoMeanNearestFingerprintFinder) {
                //noinspection unchecked
                noMeanfinder = new RadioSourceNoMeanKNearestFinder&lt;&gt;(
                        (Collection&lt;? extends RssiFingerprintLocated&lt;RadioSource,
                                RssiReading&lt;RadioSource&gt;, P&gt;&gt;)mLocatedFingerprints);
            } else {
                //noinspection unchecked
                finder = new RadioSourceKNearestFinder&lt;&gt;(
                        (Collection&lt;? extends RssiFingerprintLocated&lt;RadioSource,
                                RssiReading&lt;RadioSource&gt;, P&gt;&gt;)mLocatedFingerprints);
            }

            mEstimatedPositionCoordinates = null;</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/MixedRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MixedRadioSourceEstimator.html#L1038">1038</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RangingAndRssiRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RangingAndRssiRadioSourceEstimator.html#L957">957</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public Double getEstimatedTransmittedPowerdBm() {
        return mEstimatedTransmittedPowerdBm;
    }

    /**
     * Gets estimated exponent typically used on free space for path loss propagation in
     * terms of distance.
     * On different environments path loss exponent might have different values:
     * - Free space: 2.0
     * - Urban Area: 2.7 to 3.5
     * - Suburban Area: 3 to 5
     * - Indoor (line-of-sight): 1.6 to 1.8
     * If path loss exponent estimation is not enabled, this value will always be equal to
     * {@link #DEFAULT_PATH_LOSS_EXPONENT}
     * @return estimated path loss exponent.
     */
    public double getEstimatedPathLossExponent() {
        return mEstimatedPathLossExponent;
    }

    /**
     * Gets estimated transmitted power variance.
     * This value will only be available when transmitted power
     * estimation is enabled.
     * @return estimated transmitted power variance or null.
     */
    public Double getEstimatedTransmittedPowerVariance() {
        return mEstimatedTransmittedPowerVariance;
    }

    /**
     * Gets estimated path loss exponent variance.
     * This value will only be available when pathloss
     * exponent estimation is enabled.
     * @return estimated path loss exponent variance or null.
     */
    public Double getEstimatedPathLossExponentVariance() {
        return mEstimatedPathLossExponentVariance;
    }

    /**
     * Creates inner estimators if needed.
     */
    protected abstract void createInnerEstimatorsIfNeeded();

    /**
     * Creates a ranging reading from a ranging and RSSI reading.
     * @param reading input reading to convert from.
     * @return a ranging reading containing only the ranging data of input reading.
     */
    private RangingReadingLocated&lt;S, P&gt; createRangingReading(RangingAndRssiReadingLocated&lt;S, P&gt; reading) {
        return new RangingReadingLocated&lt;&gt;(reading.getSource(),
                reading.getDistance(), reading.getPosition(),
                reading.getDistanceStandardDeviation(),
                reading.getPositionCovariance());
    }

    /**
     * Creates an RSSI reading from a ranging and RSSI reading.
     * @param reading input reading to convert from.
     * @return an RSSI reading containing only the RSSI data of input reading.
     */
    private RssiReadingLocated&lt;S, P&gt; createRssiReading(RangingAndRssiReadingLocated&lt;S, P&gt; reading) {
        return new RssiReadingLocated&lt;&gt;(reading.getSource(),
                reading.getRssi(), reading.getPosition(),
                reading.getRssiStandardDeviation(),
                reading.getPositionCovariance());
    }</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator3D.html#L2776">2776</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RssiRadioSourceEstimator3D.html#L399">399</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    }

    /**
     * Gets estimated located radio source with estimated transmitted power.
     *
     * @return estimated located radio source with estimated transmitted power or null.
     */
    @Override
    @SuppressWarnings(&quot;unchecked&quot;)
    public RadioSourceWithPowerAndLocated&lt;Point3D&gt; getEstimatedRadioSource() {
        List&lt;? extends RssiReadingLocated&lt;S, Point3D&gt;&gt; readings = getReadings();
        if (readings == null || readings.isEmpty()) {
            return null;
        }
        S source = readings.get(0).getSource();

        Point3D estimatedPosition = getEstimatedPosition();
        if (estimatedPosition == null) {
            return null;
        }

        Matrix estimatedPositionCovariance = getEstimatedPositionCovariance();

        Double transmittedPowerVariance =
                getEstimatedTransmittedPowerVariance();
        Double transmittedPowerStandardDeviation = transmittedPowerVariance != null ?
                Math.sqrt(transmittedPowerVariance) : null;

        Double pathlossExponentVariance =
                getEstimatedPathLossExponentVariance();
        Double pathlossExponentStandardDeviation = pathlossExponentVariance != null ?
                Math.sqrt(pathlossExponentVariance) : null;

        if (source instanceof WifiAccessPoint) {
            WifiAccessPoint accessPoint = (WifiAccessPoint) source;
            return new WifiAccessPointWithPowerAndLocated3D(accessPoint.getBssid(),</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/RobustMixedPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/RobustMixedPositionEstimator2D.html#L994">994</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/RobustMixedPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/RobustMixedPositionEstimator3D.html#L998">998</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/RobustRangingAndRssiPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/RobustRangingAndRssiPositionEstimator2D.html#L990">990</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/RobustRangingAndRssiPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/RobustRangingAndRssiPositionEstimator3D.html#L990">990</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/RobustRangingPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/RobustRangingPositionEstimator2D.html#L998">998</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/RobustRangingPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/RobustRangingPositionEstimator3D.html#L999">999</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/RobustRssiPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/RobustRssiPositionEstimator2D.html#L990">990</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/RobustRssiPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/RobustRssiPositionEstimator3D.html#L989">989</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>        Point2D[] positionsArray = new InhomogeneousPoint2D[size];
        positionsArray = positions.toArray(positionsArray);

        double[] distancesArray = new double[size];
        double[] distanceStandardDeviationsArray = new double[size];

        double[] qualityScoresArray = null;
        if (distanceQualityScores != null) {
            qualityScoresArray = new double[size];
        }

        for (int i = 0; i &lt; size; i++) {
            distancesArray[i] = distances.get(i);
            distanceStandardDeviationsArray[i] = distanceStandardDeviations.get(i);

            if (qualityScoresArray != null) {
                qualityScoresArray[i] = distanceQualityScores.get(i);
            }
        }

        try {
            mLaterationSolver.setPositionsDistancesAndStandardDeviations(
                    positionsArray, distancesArray, distanceStandardDeviationsArray);

            if (qualityScoresArray != null) {
                mLaterationSolver.setQualityScores(qualityScoresArray);
            }
        } catch (LockedException e) {
            throw new IllegalArgumentException(e);
        }
    }
}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/PROMedSRobustRssiPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROMedSRobustRssiPositionEstimator3D.html#L357">357</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/PROSACRobustRssiPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROSACRobustRssiPositionEstimator3D.html#L355">355</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public PROMedSRobustRssiPositionEstimator3D(double[] sourceQualityScores,
            double[] fingerprintReadingQualityScores,
            List&lt;? extends RadioSourceLocated&lt;Point3D&gt;&gt; sources,
            RssiFingerprint&lt;? extends RadioSource, ? extends RssiReading&lt;? extends RadioSource&gt;&gt; fingerprint,
            RobustRssiPositionEstimatorListener&lt;Point3D&gt; listener) {
        this(sources, fingerprint, listener);
        internalSetSourceQualityScores(sourceQualityScores);
        internalSetFingerprintReadingsQualityScores(fingerprintReadingQualityScores);
    }

    /**
     * Returns quality scores corresponding to each radio source.
     * The larger the score value the better the quality of the sample.
     *
     * @return quality scores corresponding to each radio source.
     */
    public double[] getSourceQualityScores() {
        return mSourceQualityScores;
    }

    /**
     * Sets quality scores corresponding to each radio source.
     * The larger the score value the better the quality of the radio source.
     *
     * @param sourceQualityScores quality scores corresponding to each radio source.
     * @throws LockedException          if this instance is locked.
     * @throws IllegalArgumentException if provided quality scores length is smaller
     *                                  than minimum required samples.
     */
    public void setSourceQualityScores(double[] sourceQualityScores)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetSourceQualityScores(sourceQualityScores);
    }

    /**
     * Gets quality scores corresponding to each reading within provided fingerprint.
     * The larger the score value the better the quality of the reading.
     * This implementation always returns null.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @return quality scores corresponding to each reading within provided
     * fingerprint.
     */
    public double[] getFingerprintReadingsQualityScores() {
        return mFingerprintReadingsQualityScores;
    }

    /**
     * Sets quality scores corresponding to each reading within provided fingerprint.
     * The larger the score value the better the quality of the reading.
     * This implementation makes no action.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @param fingerprintReadingsQualityScores quality scores corresponding to each
     *                                         reading within provided fingerprint.
     * @throws LockedException          if this instance is locked.
     * @throws IllegalArgumentException if provided quality scores length is smaller
     *                                  than minimum required samples.
     */
    public void setFingerprintReadingsQualityScores(
            double[] fingerprintReadingsQualityScores) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetFingerprintReadingsQualityScores(fingerprintReadingsQualityScores);
    }

    /**
     * Returns threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value, the
     * algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algrithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @return stop threshold to stop the algorithm prematurely when a certain
     * accuracy has been reached.
     */
    public double getStopThreshold() {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L7443">7443</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L7487">7487</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L15618">15618</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>                TimeUnit.SECOND);
    }

    /**
     * Converts provided distance instance into its corresponding value expressed in
     * meters.
     *
     * @param distance distance instance to be converted.
     * @return converted value expressed in meters.
     */
    private static double convertDistanceToDouble(final Distance distance) {
        return DistanceConverter.convert(distance.getValue().doubleValue(),
                distance.getUnit(), DistanceUnit.METER);
    }

    /**
     * Converts provided speed instance into its corresponding value expressed in
     * meters per second.
     *
     * @param speed speed instance to be converted.
     * @return converted value expressed in meters per second.
     */
    private static double convertSpeedToDouble(final Speed speed) {
        return SpeedConverter.convert(speed.getValue().doubleValue(),
                speed.getUnit(), SpeedUnit.METERS_PER_SECOND);
    }

    /**
     * Converts provided acceleration instance into its corresponding value expressed
     * in meters per squared second.
     *
     * @param acceleration acceleration instance to be converted.
     * @return converted value expressed in meters per squared second.
     */
    private static double convertAccelerationToDouble(final Acceleration acceleration) {
        return AccelerationConverter.convert(acceleration.getValue().doubleValue(),
                acceleration.getUnit(), AccelerationUnit.METERS_PER_SQUARED_SECOND);
    }

    /**
     * Converts provided angular speed into its corresponding value expressed in
     * radians per second.
     *
     * @param angularSpeed angular speed instance to be converted.
     * @return converted value expressed in radians per second.
     */
    private static double convertAngularSpeedToDouble(final AngularSpeed angularSpeed) {
        return AngularSpeedConverter.convert(angularSpeed.getValue().doubleValue(),
                angularSpeed.getUnit(), AngularSpeedUnit.RADIANS_PER_SECOND);
    }
}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustMixedRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustMixedRadioSourceEstimator.html#L2240">2240</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator.html#L2127">2127</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>                    rangingReadings.size() &lt; mRangingEstimator.getMinReadings();
        }

        mRangingEstimator.setProgressDelta(2.0f * mProgressDelta);
        mRangingEstimator.setConfidence(mRangingConfidence);
        mRangingEstimator.setMaxIterations(mRangingMaxIterations);
        mRangingEstimator.setResultRefined(mRefineResult);
        mRangingEstimator.setCovarianceKept(mKeepCovariance);
        mRangingEstimator.setUseReadingPositionCovariances(
                mUseReadingPositionCovariances);
        mRangingEstimator.setHomogeneousLinearSolverUsed(
                mUseHomogeneousRangingLinearSolver);

        mRangingEstimator.setInitialPosition(mInitialPosition);

        mRangingEstimator.setListener(new RobustRangingRadioSourceEstimatorListener&lt;S, P&gt;() {
            @Override
            public void onEstimateStart(RobustRangingRadioSourceEstimator&lt;S, P&gt; estimator) {
                //not used
            }

            @Override
            public void onEstimateEnd(RobustRangingRadioSourceEstimator&lt;S, P&gt; estimator) {
                //not used
            }

            @Override
            public void onEstimateNextIteration(RobustRangingRadioSourceEstimator&lt;S, P&gt; estimator,
                                                int iteration) {
                //not used
            }

            @Override
            public void onEstimateProgressChange(RobustRangingRadioSourceEstimator&lt;S, P&gt; estimator, float progress) {
                if (mListener != null) {
                    mListener.onEstimateProgressChange(</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/estimators/ECEFKinematicsEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/estimators/ECEFKinematicsEstimator.html#L1087">1087</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L3704">3704</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>                        new double[]{alphaX, alphaY, alphaZ});

                if (alphaNorm &gt; ALPHA_THRESHOLD) {
                    final double alphaNorm2 = alphaNorm * alphaNorm;
                    final double value1 = (1.0 - Math.cos(alphaNorm)) / alphaNorm2;
                    final double value2 = (1.0 - Math.sin(alphaNorm) / alphaNorm) / alphaNorm2;
                    final Matrix tmp1 = alphaSkew1.multiplyByScalarAndReturnNew(value1);
                    final Matrix tmp2 = alphaSkew1.multiplyByScalarAndReturnNew(value2);
                    tmp2.multiply(alphaSkew1);

                    final Matrix tmp3 = Matrix.identity(ROWS, ROWS);
                    tmp3.add(tmp1);
                    tmp3.add(tmp2);

                    oldCbe.multiply(tmp3);
                }

                final Matrix alphaSkew2 = Utils.skewMatrix(
                        new double[]{0.0, 0.0, alpha});
                alphaSkew2.multiplyByScalar(0.5);
                alphaSkew2.multiply(oldCbe); // 0.5 * alphaSkew2 * oldCbe

                oldCbe.subtract(alphaSkew2); // oldCbe - 0.5 * alphaSkew2 * oldCbe</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustMixedRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustMixedRadioSourceEstimator.html#L66">66</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator.html#L65">65</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>public abstract class SequentialRobustMixedRadioSourceEstimator&lt;S extends RadioSource,
        P extends Point&gt; {

    /**
     * Default robust estimator method for robust position estimation using ranging
     * data when no robust method is provided.
     */
    public static final RobustEstimatorMethod DEFAULT_PANGING_ROBUST_METHOD =
            RobustEstimatorMethod.PROMedS;

    /**
     * Default robust estimator method for pathloss exponent and transmitted power
     * estimation using RSSI data when no robust method is provided.
     */
    public static final RobustEstimatorMethod DEFAULT_RSSI_ROBUST_METHOD =
            RobustEstimatorMethod.PROMedS;

    /**
     * Indicates that result is refined by default using all found inliers.
     */
    public static final boolean DEFAULT_REFINE_RESULT = true;

    /**
     * Indicates that covariance is kept by default after refining result.
     */
    public static final boolean DEFAULT_KEEP_COVARIANCE = true;

    /**
     * Default amount of progress variation before notifying a change in estimation progress.
     * By default this is set to 5%.
     */
    public static final float DEFAULT_PROGRESS_DELTA = 0.05f;

    /**
     * Minimum allowed value for progress delta.
     */
    public static final float MIN_PROGRESS_DELTA = 0.0f;

    /**
     * Maximum allowed value for progress delta.
     */
    public static final float MAX_PROGRESS_DELTA = 1.0f;

    /**
     * Constant defining default confidence of the estimated result, which is
     * 99%. This means that with a probability of 99% estimation will be
     * accurate because chosen subsamples will be inliers.
     */
    public static final double DEFAULT_CONFIDENCE = 0.99;

    /**
     * Default maximum allowed number of iterations.
     */
    public static final int DEFAULT_MAX_ITERATIONS = 5000;

    /**
     * Minimum allowed confidence value.
     */
    public static final double MIN_CONFIDENCE = 0.0;

    /**
     * Maximum allowed confidence value.
     */
    public static final double MAX_CONFIDENCE = 1.0;

    /**
     * Minimum allowed number of iterations.
     */
    public static final int MIN_ITERATIONS = 1;

    /**
     * Indicates that by default position covariances of readings must be taken into account to increase
     * the amount of standard deviation of each ranging measure by the amount of position standard deviation
     * assuming that both measures are statistically independent.
     */
    public static final boolean DEFAULT_USE_READING_POSITION_COVARIANCES = true;

    /**
     * Internal robust estimator for position estimation.
     */
    protected RobustRangingRadioSourceEstimator&lt;S, P&gt; mRangingEstimator;

    /**
     * Internal robust estimator for pathloss exponent and transmitted power
     * estimation.
     */
    protected RobustRssiRadioSourceEstimator&lt;S, P&gt; mRssiEstimator;

    /**
     * Robust method used for robust position estimation using ranging data.
     */
    protected RobustEstimatorMethod mRangingRobustMethod = DEFAULT_PANGING_ROBUST_METHOD;

    /**
     * Robust method used for pathloss exponent and transmitted power estimation
     * using RSSI data.
     */
    protected RobustEstimatorMethod mRssiRobustMethod = DEFAULT_RSSI_ROBUST_METHOD;

    /**
     * Size of subsets to be checked during ranging robust estimation.
     */
    protected int mRangingPreliminarySubsetSize;

    /**
     * Size of subsets to be checked during RSSI robust estimation.
     */
    protected int mRssiPreliminarySubsetSize;

    /**
     * Threshold to determine when samples are inliers or not used during robust
     * position estimation.
     * If not defined, default threshold will be used.
     */
    protected Double mRangingThreshold;

    /**
     * Threshold to determine when samples are inliers or not used during robust
     * pathloss exponent and transmitted power estimation.
     */
    protected Double mRssiThreshold;</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustMixedRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustMixedRadioSourceEstimator2D.html#L903">903</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator2D.html#L886">886</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>                    beacon.getTransmittedPower(), beacon.getFrequency(),
                    beacon.getBluetoothAddress(), beacon.getBeaconTypeCode(),
                    beacon.getManufacturer(), beacon.getServiceUuid(),
                    beacon.getBluetoothName(),
                    getEstimatedPathLossExponent(),
                    transmittedPowerStandardDeviation,
                    pathlossExponentStandardDeviation,
                    estimatedPosition, estimatedPositionCovariance);
        }else {
            return null;
        }
    }

    /**
     * Builds ranging estimator.
     */
    @Override
    protected void buildRangingEstimatorIfNeeded() {
        if (mRangingEstimator == null || mRangingEstimator.getMethod() != mRangingRobustMethod) {
            mRangingEstimator = RobustRangingRadioSourceEstimator2D.create(mRangingRobustMethod);
        }
    }

    /**
     * build RSSI estimator.
     *
     * @throws LockedException if estimator is locked.
     */
    @Override
    protected void buildRssiEstimatorIfNeeded() throws LockedException {
        if (mRssiEstimator == null || mRssiEstimator.getMethod() != mRssiRobustMethod) {
            mRssiEstimator = RobustRssiRadioSourceEstimator2D.create(mRssiRobustMethod);

            // rssi estimator will never need position estimator, but to
            // ensure it is ready we need to provide an initial position
            mRssiEstimator.setPositionEstimationEnabled(false);
            mRssiEstimator.setInitialPosition(Point2D.create());
        }
    }</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustMixedRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustMixedRadioSourceEstimator3D.html#L905">905</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator3D.html#L885">885</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>                    beacon.getTransmittedPower(), beacon.getFrequency(),
                    beacon.getBluetoothAddress(), beacon.getBeaconTypeCode(),
                    beacon.getManufacturer(), beacon.getServiceUuid(),
                    beacon.getBluetoothName(),
                    getEstimatedPathLossExponent(),
                    transmittedPowerStandardDeviation,
                    pathlossExponentStandardDeviation,
                    estimatedPosition, estimatedPositionCovariance);
        }else {
            return null;
        }
    }

    /**
     * Builds ranging estimator.
     */
    @Override
    protected void buildRangingEstimatorIfNeeded() {
        if (mRangingEstimator == null || mRangingEstimator.getMethod() != mRangingRobustMethod) {
            mRangingEstimator = RobustRangingRadioSourceEstimator3D.create(mRangingRobustMethod);
        }
    }

    /**
     * Build RSSI estimator.
     *
     * @throws LockedException if estimator is locked.
     */
    @Override
    protected void buildRssiEstimatorIfNeeded() throws LockedException {
        if (mRssiEstimator == null || mRssiEstimator.getMethod() != mRssiRobustMethod) {
            mRssiEstimator = RobustRssiRadioSourceEstimator3D.create(mRssiRobustMethod);

            // rssi estimator will never need position estimator, but to
            // ensure it is ready we need to provide an initial position
            mRssiEstimator.setPositionEstimationEnabled(false);
            mRssiEstimator.setInitialPosition(Point3D.create());
        }
    }</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator2D.html#L2967">2967</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator3D.html#L2969">2969</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator2D.html#L2943">2943</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator3D.html#L2943">2943</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>                    if (mTransmittedPowerEstimationEnabled) {
                        //transmitted power estimation enabled
                        mEstimatedTransmittedPowerVariance = mCovariance.
                                getElementAt(pos, pos);
                        pos++;
                    } else {
                        //transmitted power estimation disabled
                        mEstimatedTransmittedPowerVariance = null;
                    }

                    if (mPathLossEstimationEnabled) {
                        //pathloss exponent estimation enabled
                        mEstimatedPathLossExponentVariance = mCovariance.
                                getElementAt(pos, pos);
                    } else {
                        //pathloss exponent estimation disabled
                        mEstimatedPathLossExponentVariance = null;
                    }
                } else {
                    mCovariance = null;
                    mEstimatedPositionCovariance = null;
                    mEstimatedTransmittedPowerVariance = null;
                    mEstimatedPathLossExponentVariance = null;
                }

                mEstimatedPosition = mInnerEstimator.getEstimatedPosition();
                mEstimatedTransmittedPowerdBm =
                        mInnerEstimator.getEstimatedTransmittedPowerdBm();
                mEstimatedPathLossExponent =
                        mInnerEstimator.getEstimatedPathLossExponent();
            } catch (Exception e) {
                //refinement failed, so we return input value, and covariance
                //becomes unavailable
                mCovariance = null;
                mEstimatedPositionCovariance = null;
                mEstimatedTransmittedPowerVariance = null;
                mEstimatedPathLossExponentVariance = null;

                mEstimatedPosition = initialPosition;
                mEstimatedTransmittedPowerdBm = initialTransmittedPowerdBm;
                mEstimatedPathLossExponent = initialPathLossExponent;
            }
        } else {
            mCovariance = null;
            mEstimatedPositionCovariance = null;
            mEstimatedTransmittedPowerVariance = null;
            mEstimatedPathLossExponentVariance = null;

            mEstimatedPosition = initialPosition;
            mEstimatedTransmittedPowerdBm = initialTransmittedPowerdBm;
            mEstimatedPathLossExponent = initialPathLossExponent;
        }
    }
}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/NonLinearMixedPositionEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/NonLinearMixedPositionEstimator.html#L349">349</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/NonLinearRangingAndRssiPositionEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/NonLinearRangingAndRssiPositionEstimator.html#L349">349</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/NonLinearRangingPositionEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/NonLinearRangingPositionEstimator.html#L349">349</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/NonLinearRssiPositionEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/NonLinearRssiPositionEstimator.html#L348">348</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>                            NonLinearMixedPositionEstimator.this);
                }
            }
        };
    }

    /**
     * Builds positions, distances and standard deviation of distances for the internal
     * lateration solver.
     */
    @SuppressWarnings(&quot;Duplicates&quot;)
    private void buildPositionsDistancesAndDistanceStandardDeviations() {
        if (mTrilaterationSolver == null) {
            return;
        }

        int min = getMinRequiredSources();
        if (mSources == null || mFingerprint == null ||
                mSources.size() &lt; min ||
                mFingerprint.getReadings() == null ||
                mFingerprint.getReadings().size() &lt; min) {
            return;
        }

        List&lt;P&gt; positions = new ArrayList&lt;&gt;();
        List&lt;Double&gt; distances = new ArrayList&lt;&gt;();
        List&lt;Double&gt; distanceStandardDeviations = new ArrayList&lt;&gt;();
        PositionEstimatorHelper.buildPositionsDistancesAndDistanceStandardDeviations(
                mSources, mFingerprint, mUseRadioSourcePositionCovariance,
                mFallbackDistanceStandardDeviation, positions, distances,
                distanceStandardDeviations);

        setPositionsDistancesAndDistanceStandardDeviations(positions, distances,
                distanceStandardDeviations);
    }
}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/MixedRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MixedRadioSourceEstimator.html#L494">494</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RangingAndRssiRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RangingAndRssiRadioSourceEstimator.html#L484">484</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator.html#L442">442</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator.html#L439">439</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RssiRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RssiRadioSourceEstimator.html#L486">486</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>            MixedRadioSourceEstimatorListener&lt;S, P&gt; listener) {
        this(readings, initialPosition, initialTransmittedPowerdBm, listener);
        mInitialPathLossExponent = initialPathLossExponent;
    }

    /**
     * Gets initial transmitted power to start the estimation of radio source
     * transmitted power (expressed in dBm's).
     * If not defined, average value of received power readings will be used.
     *
     * If transmitted power estimation is enabled, estimation will start at this
     * value and will converte the most appropriate value.
     * If transmitted power estimation is disabled, this value will be assumed to be
     * exact and the estimated transmitted power will be equal to this value
     * (converted to dBm's).
     * @return initial transmitted power to start the estimation of radio source
     * transmitted power.
     */
    public Double getInitialTransmittedPowerdBm() {
        return mInitialTransmittedPowerdBm;
    }

    /**
     * Sets initial transmitted power to start the estimation of radio source
     * transmitted power (expressed in dBm's).
     * If not defined, average value of received power readings will be used.
     *
     * If transmitted power estimation is enabled, estimation will start at this
     * value and will converte the most appropriate value.
     * If transmitted power estimation is disabled, this value will be assumed to be
     * exact and the estimated transmitted power will be equal to this value
     * (converted to dBm's).
     * @param initialTransmittedPowerdBm initial transmitted power to start the
     *                                   estimation of radio source transmitted
     *                                   power.
     * @throws LockedException if estimator is locked.
     */
    public void setInitialTransmittedPowerdBm(Double initialTransmittedPowerdBm)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mInitialTransmittedPowerdBm = initialTransmittedPowerdBm;
    }

    /**
     * Gets initial transmitted power to start the estimation of radio source
     * transmitted power (expressed in mW).
     * If not defined, average value of received power readings will be used.
     *
     * If transmitted power estimation is enabled, estimation will start at this
     * value and will converte the most appropriate value.
     * If transmitted power estimation is disabled, this value will be assumed to be
     * exact and the estimated transmitted power will be equal to this value
     * (converted to dBm's).
     * @return initial transmitted power to start the estimation of radio source
     * transmitted power.
     */
    public Double getInitialTransmittedPower() {
        return mInitialTransmittedPowerdBm != null ?
                Utils.dBmToPower(mInitialTransmittedPowerdBm) : null;
    }

    /**
     * Sets initial transmitted power to start the estimation of radio source
     * transmitted power (expressed in mW).
     * If not defined, average value of received power readings will be used.
     *
     * If transmitted power estimation is enabled, estimation will start at this
     * value and will converte the most appropriate value.
     * If transmitted power estimation is disabled, this value will be assumed to be
     * exact and the estimated transmitted power will be equal to this value
     * (converted to dBm's).
     * @param initialTransmittedPower initial transmitted power to start the
     *                                estimation of radio source transmitted power.
     * @throws LockedException if estimator is locked.
     * @throws IllegalArgumentException if provided value is negative.
     */
    public void setInitialTransmittedPower(Double initialTransmittedPower)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (initialTransmittedPower != null) {
            if (initialTransmittedPower &lt; 0.0) {
                throw new IllegalArgumentException();
            }
            mInitialTransmittedPowerdBm = Utils.powerTodBm(
                    initialTransmittedPower);
        } else {
            mInitialTransmittedPowerdBm = null;
        }
    }

    /**
     * Indicates whether transmitted power estimation is enabled or not.
     * @return true if transmitted power estimation is enabled, false otherwise.
     */
    public boolean isTransmittedPowerEstimationEnabled() {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/estimators/NEDVelocityEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/estimators/NEDVelocityEstimator.html#L2306">2306</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L15604">15604</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    private static double convertTimeToDouble(final Time time) {
        return TimeConverter.convert(time.getValue().doubleValue(), time.getUnit(), TimeUnit.SECOND);
    }

    /**
     * Converts provided angle instance to radians (rad).
     *
     * @param angle angle instance to be converted.
     * @return provided angle value expressed in radians.
     */
    private static double convertAngleToDouble(final Angle angle) {
        return AngleConverter.convert(angle.getValue().doubleValue(), angle.getUnit(), AngleUnit.RADIANS);
    }

    /**
     * Converts provided distance instance to meters (m).
     *
     * @param distance distance instance to be converted.
     * @return provided distance value expressed in meters.
     */
    private static double convertDistanceToDouble(final Distance distance) {
        return DistanceConverter.convert(distance.getValue().doubleValue(), distance.getUnit(),
                DistanceUnit.METER);
    }

    /**
     * Converts provided speed instance to meters per second (m/s).
     *
     * @param speed speed instance to be converted.
     * @return provided speed value expressed in meters per second.
     */
    private static double convertSpeedToDouble(final Speed speed) {
        return SpeedConverter.convert(speed.getValue().doubleValue(), speed.getUnit(),
                SpeedUnit.METERS_PER_SECOND);
    }</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/lateration/NonLinearLeastSquaresLateration2DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/NonLinearLeastSquaresLateration2DSolver.html#L269">269</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/lateration/RobustLateration2DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/RobustLateration2DSolver.html#L237">237</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    }

    /**
     * Gets circles defined by provided positions and distances.
     * @return circles defined by provided positions and distances.
     */
    public Circle[] getCircles() {
        if (mPositions == null) {
            return null;
        }

        Circle[] result = new Circle[mPositions.length];

        for (int i = 0; i &lt; mPositions.length; i++) {
            result[i] = new Circle(mPositions[i], mDistances[i]);
        }
        return result;
    }

    /**
     * Sets circles defining positions and euclidean distances.
     * @param circles circles defining positions and distances.
     * @throws IllegalArgumentException if circles is null or length of array of circles
     * is less than 2.
     * @throws LockedException if instance is busy solving the lateration problem.
     */
    public void setCircles(Circle[] circles) throws LockedException {
        if(isLocked()) {
            throw new LockedException();
        }
        internalSetCircles(circles);
    }

    /**
     * Sets circles defining positions and euclidean distances along with the standard
     * deviations of provided circles radii.
     * @param circles circles defining positions and distances.
     * @param radiusStandardDeviations standard deviations of circles radii.
     * @throws IllegalArgumentException if circles is null, length of arrays is less than
     * 2 or don't have the same length.
     * @throws LockedException if instance is busy solving the lateration problem.
     */
    public void setCirclesAndStandardDeviations(Circle[] circles, double[] radiusStandardDeviations)
            throws LockedException {
        if(isLocked()) {
            throw new LockedException();
        }
        internalSetCirclesAndStandardDeviations(circles, radiusStandardDeviations);
    }</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/lateration/NonLinearLeastSquaresLateration3DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/NonLinearLeastSquaresLateration3DSolver.html#L269">269</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/lateration/RobustLateration3DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/RobustLateration3DSolver.html#L238">238</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    }

    /**
     * Gets spheres defined by provided positions and distances.
     * @return spheres defined by provided positions and distances.
     */
    public Sphere[] getSpheres() {
        if (mPositions == null) {
            return null;
        }

        Sphere[] result = new Sphere[mPositions.length];

        for (int i = 0; i &lt; mPositions.length; i++) {
            result[i] = new Sphere(mPositions[i], mDistances[i]);
        }
        return result;
    }

    /**
     * Sets spheres defining positions and euclidean distances.
     * @param spheres spheres defining positions and distances.
     * @throws IllegalArgumentException if spheres is null or length of array of spheres
     * is less than 2.
     * @throws LockedException if instance is busy solving the lateration problem.
     */
    public void setSpheres(Sphere[] spheres) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetSpheres(spheres);
    }

    /**
     * Sets spheres defining positions and euclidean distances along with the standard
     * deviations of provided spheres radii.
     * @param spheres spheres defining positions and distances.
     * @param radiusStandardDeviations standard deviations of circles radii.
     * @throws IllegalArgumentException if spheres is null, length of arrays is less than
     * 2 or don't have the same length.
     * @throws LockedException if instance is busy solving the lateration problem.
     */
    public void setSpheresAndStandardDeviations(Sphere[] spheres, double[] radiusStandardDeviations)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetSpheresAndStandardDeviations(spheres, radiusStandardDeviations);
    }</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/lateration/PROMedSRobustLateration2DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/PROMedSRobustLateration2DSolver.html#L383">383</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/lateration/PROMedSRobustLateration3DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/PROMedSRobustLateration3DSolver.html#L383">383</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>        super(circles, distanceStandardDeviations, listener);
        internalSetQualityScores(qualityScores);
    }

    /**
     * Returns threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value, the
     * algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algrithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     * @return stop threshold to stop the algorithm prematurely when a certain
     * accuracy has been reached.
     */
    public double getStopThreshold() {
        return mStopThreshold;
    }

    /**
     * Sets threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value,
     * the algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algorithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     * @param stopThreshold stop threshold to stop the algorithm prematurely
     *                      when a certain accuracy has been reached.
     * @throws IllegalArgumentException if provided value is zero or negative.
     * @throws LockedException if this solver is locked.
     */
    public void setStopThreshold(double stopThreshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (stopThreshold &lt;= MIN_STOP_THRESHOLD) {
            throw new IllegalArgumentException();
        }

        mStopThreshold = stopThreshold;
    }

    /**
     * Returns quality scores corresponding to each pair of
     * positions and distances (i.e. sample).
     * The larger the score value the better the quality of the sample.
     * @return quality scores corresponding to each sample.
     */
    @Override
    public double[] getQualityScores() {
        return mQualityScores;
    }

    /**
     * Sets quality scores corresponding to each pair of positions and
     * distances (i.e. sample).
     * The larger the score value the better the quality of the sample.
     * @param qualityScores quality scores corresponding to each pair of
     *                      matched points.
     * @throws IllegalArgumentException if provided quality scores length
     * is smaller than minimum required samples.
     * @throws LockedException if robust solver is locked because an
     * estimation is already in progress.
     */
    @Override
    public void setQualityScores(double[] qualityScores)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetQualityScores(qualityScores);
    }

    /**
     * Indicates whether solver is ready to find a solution.
     * @return true if solver is ready, false otherwise.
     */
    @Override
    public boolean isReady() {
        return super.isReady() &amp;&amp; mQualityScores != null &amp;&amp;
                mQualityScores.length == mDistances.length;
    }

    /**
     * Solves the lateration problem.
     * @return estimated position.
     * @throws LockedException if instance is busy solving the lateration problem.
     * @throws NotReadyException is solver is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     * (i.e. numerical instability, no solution available, etc).
     */
    @Override
    public Point2D solve() throws LockedException, NotReadyException,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/fingerprint/SecondOrderNonLinearFingerprintPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/fingerprint/SecondOrderNonLinearFingerprintPositionEstimator2D.html#L155">155</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/fingerprint/ThirdOrderNonLinearFingerprintPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/fingerprint/ThirdOrderNonLinearFingerprintPositionEstimator2D.html#L155">155</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    }

    /**
     * Evaluates a non-linear multi dimension function at provided point using
     * provided parameters and returns its evaluation and derivatives of the
     * function respect the function parameters.
     * @param i number of sample being evaluated.
     * @param point point where function will be evaluated.
     * @param params initial parameters estimation to be tried. These will
     * change as the Levenberg-Marquard algorithm iterates to the best solution.
     * These are used as input parameters along with point to evaluate function.
     * @param derivatives partial derivatives of the function respect to each
     * provided parameter.
     * @return function evaluation at provided point.
     */
    @Override
    @SuppressWarnings(&quot;Duplicates&quot;)
    protected double evaluate(int i, double[] point, double[] params, double[] derivatives) {
        //This method implements received power at point pi = (xi, yi) and its derivatives

        //Pr(pi) = Pr(p1)
        //  - 10*n*(x1 - xa)/(ln(10)*d1a^2)*(xi - x1)
        //  - 10*n*(y1 - ya)/(ln(10)*d1a^2)*(yi - y1)
        //  - 5*n*((y1 - ya)^2 - (x1 - xa)^2)/(ln(10)*d1a^4)*(xi - x1)^2
        //  - 5*n*((x1 - xa)^2 - (y1 - ya)^2)/(ln(10)*d1a^4)*(yi - y1)^2
        //  + 20*n*(x1 - xa)*(y1 - ya)/(ln(10)*d1a^4))*(xi - x1)*(yi - y1)

        double xi = params[0];
        double yi = params[1];

        //received power
        double pr = point[0];

        //fingerprint coordinates
        double x1 = point[1];
        double y1 = point[2];

        //radio source coordinates
        double xa = point[3];
        double ya = point[4];

        //path loss exponent
        double n = point[5];

        double ln10 = Math.log(10.0);

        double diffXi1 = xi - x1;
        double diffYi1 = yi - y1;

        double diffX1a = x1 - xa;
        double diffY1a = y1 - ya;

        double diffXi12 = diffXi1 * diffXi1;
        double diffYi12 = diffYi1 * diffYi1;

        double diffX1a2 = diffX1a * diffX1a;</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/MixedRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MixedRadioSourceEstimator2D.html#L402">402</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RangingAndRssiRadioSourceEstimator2D.html#L389">389</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>        } else if (source instanceof Beacon) {
            Beacon beacon = (Beacon)source;
            //transmitted power does not need to be estimated for beacons because
            //they broadcast such information
            return new BeaconWithPowerAndLocated2D(beacon.getIdentifiers(),
                    beacon.getTransmittedPower(), beacon.getFrequency(),
                    beacon.getBluetoothAddress(), beacon.getBeaconTypeCode(),
                    beacon.getManufacturer(), beacon.getServiceUuid(),
                    beacon.getBluetoothName(), pathLossExponent,
                    transmittedPowerStandardDeviation,
                    pathLossExponentStandardDeviation, estimatedPosition,
                    estimatedPositionCovariance);
        } else {
            return null;
        }
    }

    /**
     * Creates inner estimators if needed.
     */
    @Override
    protected void createInnerEstimatorsIfNeeded() {
        if (mRangingInnerEstimator == null) {
            mRangingInnerEstimator = new RangingRadioSourceEstimator2D&lt;&gt;();
        }

        if (mRssiInnerEstimator == null &amp;&amp;
                (mTransmittedPowerEstimationEnabled || mPathLossEstimationEnabled)) {
            mRssiInnerEstimator = new RssiRadioSourceEstimator2D&lt;&gt;();
        }
    }
}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/MixedRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MixedRadioSourceEstimator3D.html#L402">402</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RangingAndRssiRadioSourceEstimator3D.html#L389">389</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>        } else if (source instanceof Beacon) {
            Beacon beacon = (Beacon)source;
            //transmitted power does not need to be estimated for beacons because
            //they broadcast such information
            return new BeaconWithPowerAndLocated3D(beacon.getIdentifiers(),
                    beacon.getTransmittedPower(), beacon.getFrequency(),
                    beacon.getBluetoothAddress(), beacon.getBeaconTypeCode(),
                    beacon.getManufacturer(), beacon.getServiceUuid(),
                    beacon.getBluetoothName(), pathLossExponent,
                    transmittedPowerStandardDeviation,
                    pathLossExponentStandardDeviation, estimatedPosition,
                    estimatedPositionCovariance);
        } else {
            return null;
        }
    }

    /**
     * Creates inner estimators if needed.
     */
    @Override
    protected void createInnerEstimatorsIfNeeded() {
        if (mRangingInnerEstimator == null) {
            mRangingInnerEstimator = new RangingRadioSourceEstimator3D&lt;&gt;();
        }

        if (mRssiInnerEstimator == null &amp;&amp;
                (mTransmittedPowerEstimationEnabled || mPathLossEstimationEnabled)) {
            mRssiInnerEstimator = new RssiRadioSourceEstimator3D&lt;&gt;();
        }
    }
}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator2D.html#L562">562</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator2D.html#L334">334</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator2D.html#L573">573</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>                                    RANSACRobustRangingAndRssiRadioSourceEstimator2D.this, progress);
                        }
                    }
                });

        try {
            mLocked = true;
            mInliersData = null;
            innerEstimator.setComputeAndKeepInliersEnabled(
                    mComputeAndKeepInliers || mRefineResult);
            innerEstimator.setComputeAndKeepResidualsEnabled(
                    mComputeAndKeepResiduals || mRefineResult);
            innerEstimator.setConfidence(mConfidence);
            innerEstimator.setMaxIterations(mMaxIterations);
            innerEstimator.setProgressDelta(mProgressDelta);
            Solution&lt;Point2D&gt; result = innerEstimator.estimate();
            mInliersData = innerEstimator.getInliersData();
            attemptRefine(result);

        } catch (com.irurueta.numerical.LockedException e) {
            throw new LockedException(e);
        } catch (com.irurueta.numerical.NotReadyException e) {
            throw new NotReadyException(e);
        } finally {
            mLocked = false;
        }
    }

    /**
     * Returns method being used for robust estimation.
     *
     * @return method being used for robust estimation.
     */
    @Override
    public RobustEstimatorMethod getMethod() {
        return RobustEstimatorMethod.RANSAC;
    }
}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator3D.html#L562">562</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator3D.html#L334">334</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator3D.html#L572">572</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                                            RANSACRobustRangingAndRssiRadioSourceEstimator3D.this, progress);
                                }
                            }
                        });

        try {
            mLocked = true;
            mInliersData = null;
            innerEstimator.setComputeAndKeepInliersEnabled(
                    mComputeAndKeepInliers || mRefineResult);
            innerEstimator.setComputeAndKeepResidualsEnabled(
                    mComputeAndKeepResiduals || mRefineResult);
            innerEstimator.setConfidence(mConfidence);
            innerEstimator.setMaxIterations(mMaxIterations);
            innerEstimator.setProgressDelta(mProgressDelta);
            Solution&lt;Point3D&gt; result = innerEstimator.estimate();
            mInliersData = innerEstimator.getInliersData();
            attemptRefine(result);

        } catch (com.irurueta.numerical.LockedException e) {
            throw new LockedException(e);
        } catch (com.irurueta.numerical.NotReadyException e) {
            throw new NotReadyException(e);
        } finally {
            mLocked = false;
        }
    }

    /**
     * Returns method being used for robust estimation.
     *
     * @return method being used for robust estimation.
     */
    @Override
    public RobustEstimatorMethod getMethod() {
        return RobustEstimatorMethod.RANSAC;
    }
}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RangingRadioSourceEstimator2D.html#L259">259</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RangingRadioSourceEstimator3D.html#L259">259</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>        Point2D[] positionsArray = new InhomogeneousPoint2D[size];
        positionsArray = positions.toArray(positionsArray);

        double[] distancesArray = new double[size];
        double[] distanceStandardDeviationsArray = new double[size];
        for (int i = 0; i &lt; size; i++) {
            distancesArray[i] = distances.get(i);
            distanceStandardDeviationsArray[i] = distanceStandardDeviations.get(i);
        }

        if (mInitialPosition == null || !mNonLinearSolverEnabled) {
            if (mHomogeneousLinearSolver != null) {
                mHomogeneousLinearSolver.setPositionsAndDistances(positionsArray, distancesArray);
            }
            if (mInhomogeneousLinearSolver != null) {
                mInhomogeneousLinearSolver.setPositionsAndDistances(positionsArray, distancesArray);
            }
        }

        if (mNonLinearSolver != null &amp;&amp; mNonLinearSolverEnabled) {
            mNonLinearSolver.setPositionsDistancesAndStandardDeviations(positionsArray,
                    distancesArray, distanceStandardDeviationsArray);
        }
    }
}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/lateration/RobustLateration2DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/RobustLateration2DSolver.html#L1317">1317</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/lateration/RobustLateration3DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/RobustLateration3DSolver.html#L1316">1316</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>            Point2D estimatedPosition = mInitialPosition;
            if (mUseLinearSolver) {
                if (mUseHomogeneousLinearSolver) {
                    mHomogeneousLinearSolver.setPositionsAndDistances(mInnerPositions, mInnerDistances);
                    mHomogeneousLinearSolver.solve();
                    estimatedPosition = mHomogeneousLinearSolver.getEstimatedPosition();
                } else {
                    mInhomogeneousLinearSolver.setPositionsAndDistances(mInnerPositions, mInnerDistances);
                    mInhomogeneousLinearSolver.solve();
                    estimatedPosition = mInhomogeneousLinearSolver.getEstimatedPosition();
                }
            }

            if (mRefinePreliminarySolutions || estimatedPosition == null) {
                mNonLinearSolver.setInitialPosition(estimatedPosition);
                if (mDistanceStandardDeviations != null) {
                    mNonLinearSolver.setPositionsDistancesAndStandardDeviations(mInnerPositions,
                            mInnerDistances, mInnerDistanceStandardDeviations);
                } else {
                    mNonLinearSolver.setPositionsAndDistances(mInnerPositions, mInnerDistances);
                }
                mNonLinearSolver.solve();
                estimatedPosition = mNonLinearSolver.getEstimatedPosition();
            }

            solutions.add(estimatedPosition);
        } catch (NavigationException ignore) {
            //if anything fails, no solution is added
        }
    }

    /**
     * Internally sets circles defining positions and euclidean distances.
     * @param circles circles defining positions and distances.
     * @throws IllegalArgumentException if circles is null or length of array of circles
     * is less than {@link #getMinRequiredPositionsAndDistances}.
     */
    private void internalSetCircles(Circle[] circles) {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/RadioSourceKNearestFinder.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/RadioSourceKNearestFinder.html#L183">183</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/RadioSourceNoMeanKNearestFinder.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/RadioSourceNoMeanKNearestFinder.html#L188">188</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>            double sqrDist = f.sqrDistanceTo(fingerprint);
            if (sqrDist &lt; maxSqrDist || nearestSqrDistances.size() &lt; k) {

                //find insertion point
                int pos = -1;
                int i = 0;
                for(Double sd : nearestSqrDistances) {
                    if (sqrDist &lt; sd) {
                        //insertion point found
                        pos = i;
                        break;
                    }
                    i++;
                }

                if (pos &gt;= 0) {
                    nearestSqrDistances.add(pos, sqrDist);
                    nearestFingerprints.add(pos, f);
                } else {
                    nearestSqrDistances.add(sqrDist);
                    nearestFingerprints.add(f);
                }

                //remove results exceeding required number of k neighbours to be found
                if (nearestFingerprints.size() &gt; k) {
                    nearestSqrDistances.remove(k);
                    nearestFingerprints.remove(k);
                }

                //update maxSqrDist to the largest squared distance value contained in result list distances
                maxSqrDist = nearestSqrDistances.get(nearestSqrDistances.size() - 1);
            }
        }
    }
}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/LinearMixedPositionEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/LinearMixedPositionEstimator.html#L248">248</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/LinearRangingAndRssiPositionEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/LinearRangingAndRssiPositionEstimator.html#L249">249</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/LinearRangingPositionEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/LinearRangingPositionEstimator.html#L246">246</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/LinearRssiPositionEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/LinearRssiPositionEstimator.html#L249">249</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                            LinearMixedPositionEstimator.this);
                }
            }
        };
    }

    /**
     * Builds positions and distances for the internal lateration solver.
     */
    @SuppressWarnings(&quot;Duplicates&quot;)
    private void buildPositionsAndDistances() {
        if ((mUseHomogeneousLinearSolver &amp;&amp; mHomogeneousTrilaterationSolver == null) ||
                (!mUseHomogeneousLinearSolver &amp;&amp; mInhomogeneousTrilaterationSolver == null)) {
            return;
        }

        int min = getMinRequiredSources();
        if (mSources == null || mFingerprint == null ||
                mSources.size() &lt; min ||
                mFingerprint.getReadings() == null ||
                mFingerprint.getReadings().size() &lt; min) {
            return;
        }

        List&lt;P&gt; positions = new ArrayList&lt;&gt;();
        List&lt;Double&gt; distances = new ArrayList&lt;&gt;();
        PositionEstimatorHelper.buildPositionsAndDistances(
                mSources, mFingerprint, positions, distances);

        setPositionsAndDistances(positions, distances);
    }
}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator2D.html#L1051">1051</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator2D.html#L541">541</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator2D.html#L1056">1056</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator2D.html#L562">562</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator2D.html#L334">334</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator2D.html#L573">573</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                                    PROSACRobustRangingAndRssiRadioSourceEstimator2D.this, progress);
                        }
                    }
                });

        try {
            mLocked = true;
            mInliersData = null;
            innerEstimator.setComputeAndKeepInliersEnabled(
                    mComputeAndKeepInliers || mRefineResult);
            innerEstimator.setComputeAndKeepResidualsEnabled(
                    mComputeAndKeepResiduals || mRefineResult);
            innerEstimator.setConfidence(mConfidence);
            innerEstimator.setMaxIterations(mMaxIterations);
            innerEstimator.setProgressDelta(mProgressDelta);
            Solution&lt;Point2D&gt; result = innerEstimator.estimate();
            mInliersData = innerEstimator.getInliersData();
            attemptRefine(result);

        } catch (com.irurueta.numerical.LockedException e) {
            throw new LockedException(e);
        } catch (com.irurueta.numerical.NotReadyException e) {
            throw new NotReadyException(e);
        } finally {
            mLocked = false;
        }
    }

    /**
     * Returns method being used for robust estimation.
     *
     * @return method being used for robust estimation.
     */
    @Override
    public RobustEstimatorMethod getMethod() {
        return RobustEstimatorMethod.PROSAC;</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator3D.html#L1051">1051</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator3D.html#L541">541</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator3D.html#L1055">1055</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator3D.html#L562">562</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator3D.html#L334">334</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator3D.html#L572">572</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                                            PROSACRobustRangingAndRssiRadioSourceEstimator3D.this, progress);
                                }
                            }
                        });

        try {
            mLocked = true;
            mInliersData = null;
            innerEstimator.setComputeAndKeepInliersEnabled(
                    mComputeAndKeepInliers || mRefineResult);
            innerEstimator.setComputeAndKeepResidualsEnabled(
                    mComputeAndKeepResiduals || mRefineResult);
            innerEstimator.setConfidence(mConfidence);
            innerEstimator.setMaxIterations(mMaxIterations);
            innerEstimator.setProgressDelta(mProgressDelta);
            Solution&lt;Point3D&gt; result = innerEstimator.estimate();
            mInliersData = innerEstimator.getInliersData();
            attemptRefine(result);

        } catch (com.irurueta.numerical.LockedException e) {
            throw new LockedException(e);
        } catch (com.irurueta.numerical.NotReadyException e) {
            throw new NotReadyException(e);
        } finally {
            mLocked = false;
        }
    }

    /**
     * Returns method being used for robust estimation.
     *
     * @return method being used for robust estimation.
     */
    @Override
    public RobustEstimatorMethod getMethod() {
        return RobustEstimatorMethod.PROSAC;</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/lateration/RANSACRobustLateration2DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/RANSACRobustLateration2DSolver.html#L194">194</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/lateration/RANSACRobustLateration3DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/RANSACRobustLateration3DSolver.html#L194">194</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>        super(circles, distanceStandardDeviations, listener);
    }

    /**
     * Gets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on distance between estimated position and distances
     * provided for each sample.
     * @return threshold to determine whether samples are inliers or not.
     */
    public double getThreshold() {
        return mThreshold;
    }

    /**
     * Sets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on distance between estimated position and distances
     * provided for each sample.
     * @param threshold threshold to determine whether samples are inliers or not.
     * @throws IllegalArgumentException if provided value is equal or less than zero.
     * @throws LockedException if this solver is locked.
     */
    public void setThreshold(double threshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (threshold &lt;= MIN_THRESHOLD) {
            throw new IllegalArgumentException();
        }
        mThreshold = threshold;
    }

    /**
     * Indicates whether inliers must be computed and kept.
     * @return true if inliers must be computed and kept, false if inliers
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepInliersEnabled() {
        return mComputeAndKeepInliers;
    }

    /**
     * Specifies whether inliers must be computed and kept.
     * @param computeAndKeepInliers true if inliers must be computed and kept,
     *                              false if inliers only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepInliersEnabled(boolean computeAndKeepInliers)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mComputeAndKeepInliers = computeAndKeepInliers;
    }

    /**
     * Indicates whether residuals must be computed and kept.
     * @return true if residuals must be computed and kept, false if residuals
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepResiduals() {
        return mComputeAndKeepResiduals;
    }

    /**
     * Specifies whether residuals must be computed and kept.
     * @param computeAndKeepResiduals true if residuals must be computed and kept,
     *                                false if residuals only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepResidualsEnabled(boolean computeAndKeepResiduals)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mComputeAndKeepResiduals = computeAndKeepResiduals;
    }

    /**
     * Solves the lateration problem.
     * @return estimated position.
     * @throws LockedException if instance is busy solving the lateration problem.
     * @throws NotReadyException is solver is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     * (i.e. numerical instability, no solution available, etc).
     */
    @Override
    public Point2D solve() throws LockedException, NotReadyException, RobustEstimatorException {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator3D.html#L2809">2809</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RssiRadioSourceEstimator3D.html#L408">408</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator3D.html#L849">849</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>        List&lt;? extends RangingAndRssiReadingLocated&lt;S, Point3D&gt;&gt; readings = getReadings();
        if (readings == null || readings.isEmpty()) {
            return null;
        }
        S source = readings.get(0).getSource();

        Point3D estimatedPosition = getEstimatedPosition();
        if (estimatedPosition == null) {
            return null;
        }

        Matrix estimatedPositionCovariance = getEstimatedPositionCovariance();

        Double transmittedPowerVariance =
                getEstimatedTransmittedPowerVariance();
        Double transmittedPowerStandardDeviation = transmittedPowerVariance != null ?
                Math.sqrt(transmittedPowerVariance) : null;

        Double pathlossExponentVariance =
                getEstimatedPathLossExponentVariance();
        Double pathlossExponentStandardDeviation = pathlossExponentVariance != null ?
                Math.sqrt(pathlossExponentVariance) : null;

        if (source instanceof WifiAccessPoint) {
            WifiAccessPoint accessPoint = (WifiAccessPoint) source;
            return new WifiAccessPointWithPowerAndLocated3D(accessPoint.getBssid(),</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/lateration/PROSACRobustLateration2DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/PROSACRobustLateration2DSolver.html#L578">578</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/lateration/RANSACRobustLateration2DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/RANSACRobustLateration2DSolver.html#L346">346</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>                            mListener.onSolveProgressChange(PROSACRobustLateration2DSolver.this,
                                    progress);
                        }
                    }
                });

        try {
            mLocked = true;
            mInliersData = null;
            innerEstimator.setComputeAndKeepInliersEnabled(
                    mComputeAndKeepInliers || mRefineResult);
            innerEstimator.setComputeAndKeepResidualsEnabled(
                    mComputeAndKeepResiduals || mRefineResult);
            innerEstimator.setConfidence(mConfidence);
            innerEstimator.setMaxIterations(mMaxIterations);
            innerEstimator.setProgressDelta(mProgressDelta);
            Point2D result = innerEstimator.estimate();
            mInliersData = innerEstimator.getInliersData();
            return attemptRefine(result);
        } catch (com.irurueta.numerical.LockedException e) {
            throw new LockedException(e);
        } catch (com.irurueta.numerical.NotReadyException e) {
            throw new NotReadyException(e);
        } finally {
            mLocked = false;
        }
    }

    /**
     * Returns method being used for robust estimation.
     * @return method being used for robust estimation.
     */
    @Override
    public RobustEstimatorMethod getMethod() {
        return RobustEstimatorMethod.PROSAC;</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/lateration/PROSACRobustLateration3DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/PROSACRobustLateration3DSolver.html#L578">578</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/lateration/RANSACRobustLateration3DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/RANSACRobustLateration3DSolver.html#L346">346</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>                            mListener.onSolveProgressChange(PROSACRobustLateration3DSolver.this,
                                    progress);
                        }
                    }
                });

        try {
            mLocked = true;
            mInliersData = null;
            innerEstimator.setComputeAndKeepInliersEnabled(
                    mComputeAndKeepInliers || mRefineResult);
            innerEstimator.setComputeAndKeepResidualsEnabled(
                    mComputeAndKeepResiduals || mRefineResult);
            innerEstimator.setConfidence(mConfidence);
            innerEstimator.setMaxIterations(mMaxIterations);
            innerEstimator.setProgressDelta(mProgressDelta);
            Point3D result = innerEstimator.estimate();
            mInliersData = innerEstimator.getInliersData();
            return attemptRefine(result);
        } catch (com.irurueta.numerical.LockedException e) {
            throw new LockedException(e);
        } catch (com.irurueta.numerical.NotReadyException e) {
            throw new NotReadyException(e);
        } finally {
            mLocked = false;
        }
    }

    /**
     * Returns method being used for robust estimation.
     * @return method being used for robust estimation.
     */
    @Override
    public RobustEstimatorMethod getMethod() {
        return RobustEstimatorMethod.PROSAC;</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/Utils.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/Utils.html#L741">741</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/Utils.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/Utils.html#L1904">1904</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>                    jacobian.setElementAtIndex(0, derivativeFingerprintRssi);
                    jacobian.setElementAtIndex(1, derivativePathLossExponent);
                    jacobian.setElementAtIndex(2, derivativeX1);
                    jacobian.setElementAtIndex(3, derivativeY1);
                    jacobian.setElementAtIndex(4, derivativeZ1);
                    jacobian.setElementAtIndex(5, derivativeXa);
                    jacobian.setElementAtIndex(6, derivativeYa);
                    jacobian.setElementAtIndex(7, derivativeZa);
                    jacobian.setElementAtIndex(8, derivativeXi);
                    jacobian.setElementAtIndex(9, derivativeYi);
                    jacobian.setElementAtIndex(10, derivativeZi);
                }

                @Override
                public int getNumberOfVariables() {
                    return 1;
                }
            }, mean, covariance);
        } catch (AlgebraException | StatisticsException e) {
            throw new IndoorException(e);
        }
    }

    /**
     * Propagates provided variances (fingerprint rssi variance, path-loss exponent variance,
     * fingerprint position covariance and radio source position covariance) into
     * rssi variance by considering the 2D 2nd order Taylor expression of received power.
     * Notice that any unknown variance is assumed to be zero.
     * @param fingerprintRssi closest located fingerprint reading RSSI expressed in dBm's.
     * @param pathLossExponent path-loss exponent.
     * @param fingerprintPosition position of closest fingerprint.
     * @param radioSourcePosition radio source position associated to fingerprint reading.
     * @param estimatedPosition  position to be estimated. Usually this is equal to the
     *                           initial position used by a non linear algorithm.
     * @param fingerprintRssiVariance variance of fingerprint RSSI or null if unknown.
     * @param pathLossExponentVariance variance of path-loss exponent or null if unknown.
     * @param fingerprintPositionCovariance covariance of fingerprint position or null if
     *                                      unknown.
     * @param radioSourcePositionCovariance covariance of radio source position or null
     *                                      if unknown.
     * @param estimatedPositionCovariance  covariance of position to be estimated or null
     *                                     if unknown. (This is usually unknown).
     * @return a normal distribution containing expected received RSSI value and its variance.
     * @throws IndoorException if something fails.
     */
    public static MultivariateNormalDist propagateVariancesToRssiVarianceSecondOrderNonLinear2D(</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/Utils.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/Utils.html#L496">496</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/Utils.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/Utils.html#L1192">1192</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/Utils.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/Utils.html#L2146">2146</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/Utils.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/Utils.html#L2556">2556</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>            Double fingerprintRssiVariance,
            Double pathLossExponentVariance,
            Matrix fingerprintPositionCovariance,
            Matrix radioSourcePositionCovariance,
            Matrix estimatedPositionCovariance) throws IndoorException {

        if (fingerprintPosition == null || radioSourcePosition == null ||
                estimatedPosition == null) {
            return null;
        }

        //1st order Taylor expression of received power in 3D:
        //Pr(pi) = Pr(p1)
        //  - 10*n*(x1 - xa)/(ln(10)*d1a^2)*(xi - x1)
        //  - 10*n*(y1 - ya)/(ln(10)*d1a^2)*(yi - y1)
        //  - 10*n*(z1 - za)/(ln(10)*d1a^2)*(zi - z1)
        //where d1a^2 = (x1 - xa)^2 + (y1 - ya)^2 + (z1 - za)^2

        final double x1 = fingerprintPosition.getInhomX();
        final double y1 = fingerprintPosition.getInhomY();
        final double z1 = fingerprintPosition.getInhomZ();

        final double xa = radioSourcePosition.getInhomX();
        final double ya = radioSourcePosition.getInhomY();
        final double za = radioSourcePosition.getInhomZ();

        final double xi = estimatedPosition.getInhomX();
        final double yi = estimatedPosition.getInhomY();
        final double zi = estimatedPosition.getInhomZ();

        double[] mean = new double[] {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRangingRadioSourceEstimator2D.html#L717">717</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRangingRadioSourceEstimator3D.html#L719">719</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>            return new BeaconLocated2D(beacon.getIdentifiers(),
                    beacon.getTransmittedPower(), beacon.getFrequency(),
                    beacon.getBluetoothAddress(), beacon.getBeaconTypeCode(),
                    beacon.getManufacturer(), beacon.getServiceUuid(),
                    beacon.getBluetoothName(), estimatedPosition,
                    estimatedPositionCovariance);
        } else {
            return null;
        }
    }

    /**
     * Indicates whether an homogeneous linear solver is used to estimate an initial
     * position.
     *
     * @return true if homogeneous linear solver is used, false if an inhomogeneous linear
     * one is used instead.
     */
    @Override
    public boolean isHomogeneousLinearSolverUsed() {
        return mInnerEstimator.isHomogeneousLinearSolverUsed();
    }

    /**
     * Specifies whether an homogeneous linear solver is used to estimate an initial
     * position.
     *
     * @param useHomogeneousLinearSolver true if homogeneous linear solver is used, false
     *                                   if an inhomogeneous linear one is used instead.
     * @throws LockedException if estimator is locked.
     */
    @Override
    public void setHomogeneousLinearSolverUsed(
            boolean useHomogeneousLinearSolver) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mInnerEstimator.setHomogeneousLinearSolverUsed(useHomogeneousLinearSolver);
    }

    /**
     * Solves preliminar solution for a subset of samples.
     *
     * @param samplesIndices    indices of subset samples.
     * @param solutions         instance where solution will be stored.
     */
    @Override
    protected void solvePreliminarSolutions(int[] samplesIndices,
            List&lt;Solution&lt;Point2D&gt;&gt; solutions) {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/fingerprint/FirstOrderNonLinearFingerprintPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/fingerprint/FirstOrderNonLinearFingerprintPositionEstimator2D.html#L155">155</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/fingerprint/SecondOrderNonLinearFingerprintPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/fingerprint/SecondOrderNonLinearFingerprintPositionEstimator2D.html#L155">155</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/fingerprint/ThirdOrderNonLinearFingerprintPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/fingerprint/ThirdOrderNonLinearFingerprintPositionEstimator2D.html#L155">155</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    }

    /**
     * Evaluates a non-linear multi dimension function at provided point using
     * provided parameters and returns its evaluation and derivatives of the
     * function respect the function parameters.
     * @param i number of sample being evaluated.
     * @param point point where function will be evaluated.
     * @param params initial parameters estimation to be tried. These will
     * change as the Levenberg-Marquardt algorithm iterates to the best solution.
     * These are used as input parameters along with point to evaluate function.
     * @param derivatives partial derivatives of the function respect to each
     * provided parameter.
     * @return function evaluation at provided point.
     */
    @Override
    @SuppressWarnings(&quot;Duplicates&quot;)
    protected double evaluate(int i, double[] point, double[] params, double[] derivatives) {
        //This method implements received power at point pi = (xi, yi) and its derivatives

        //Pr(pi) = Pr(p1)
        //  - 10*n*(x1 - xa)/(ln(10)*d1a^2)*(xi - x1)
        //  - 10*n*(y1 - ya)/(ln(10)*d1a^2)*(yi - y1)

        double xi = params[0];
        double yi = params[1];

        //received power
        double pr = point[0];

        //fingerprint coordinates
        double x1 = point[1];
        double y1 = point[2];

        //radio source coordinates
        double xa = point[3];
        double ya = point[4];

        //path loss exponent
        double n = point[5];

        double ln10 = Math.log(10.0);

        double diffXi1 = xi - x1;
        double diffYi1 = yi - y1;

        double diffX1a = x1 - xa;
        double diffY1a = y1 - ya;

        double diffX1a2 = diffX1a * diffX1a;</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/estimators/ECEFKinematicsEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/estimators/ECEFKinematicsEstimator.html#L1391">1391</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/estimators/ECEFKinematicsEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/estimators/ECEFKinematicsEstimator.html#L1420">1420</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public static void estimateKinematics(final double timeInterval,
                                          final ECEFFrame frame,
                                          final CoordinateTransformation oldC,
                                          final Speed oldVx, final Speed oldVy, final Speed oldVz,
                                          final BodyKinematics result) {
        estimateKinematics(timeInterval, frame, oldC,
                SpeedConverter.convert(oldVx.getValue().doubleValue(), oldVx.getUnit(), SpeedUnit.METERS_PER_SECOND),
                SpeedConverter.convert(oldVy.getValue().doubleValue(), oldVy.getUnit(), SpeedUnit.METERS_PER_SECOND),
                SpeedConverter.convert(oldVz.getValue().doubleValue(), oldVz.getUnit(), SpeedUnit.METERS_PER_SECOND),
                result);
    }

    /**
     * Estimates body kinematics (specific force applied to a body and its angular rates).
     *
     * @param timeInterval time interval between epochs.
     * @param frame        body ECEF frame containing current position, velocity and
     *                     body-to-ECEF frame coordinate transformation.
     * @param oldC         previous body-to-ECEF-frame coordinate transformation matrix.
     * @param oldVx        previous velocity of body frame x coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldVy        previous velocity of body frame y coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldVz        previous velocity of body frame z coordinate with respect ECEF
     *                     frame, resolved along EVEF-frame axes.
     * @param result       instance where body kinematics estimation will be stored.
     * @throws IllegalArgumentException if provided time interval is negative or coordinated transformation matrices
     *                                  are not ECEF frame valid.
     */
    public static void estimateKinematics(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/estimators/ECEFKinematicsEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/estimators/ECEFKinematicsEstimator.html#L1392">1392</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/estimators/ECIKinematicsEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/estimators/ECIKinematicsEstimator.html#L1277">1277</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                                          final ECEFFrame frame,
                                          final CoordinateTransformation oldC,
                                          final Speed oldVx, final Speed oldVy, final Speed oldVz,
                                          final BodyKinematics result) {
        estimateKinematics(timeInterval, frame, oldC,
                SpeedConverter.convert(oldVx.getValue().doubleValue(), oldVx.getUnit(), SpeedUnit.METERS_PER_SECOND),
                SpeedConverter.convert(oldVy.getValue().doubleValue(), oldVy.getUnit(), SpeedUnit.METERS_PER_SECOND),
                SpeedConverter.convert(oldVz.getValue().doubleValue(), oldVz.getUnit(), SpeedUnit.METERS_PER_SECOND),
                result);
    }

    /**
     * Estimates body kinematics (specific force applied to a body and its angular rates).
     *
     * @param timeInterval time interval between epochs.
     * @param frame        body ECEF frame containing current position, velocity and
     *                     body-to-ECEF frame coordinate transformation.
     * @param oldC         previous body-to-ECEF-frame coordinate transformation matrix.
     * @param oldVx        previous velocity of body frame x coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldVy        previous velocity of body frame y coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldVz        previous velocity of body frame z coordinate with respect ECEF
     *                     frame, resolved along EVEF-frame axes.
     * @param result       instance where body kinematics estimation will be stored.
     * @throws IllegalArgumentException if provided time interval is negative or coordinated transformation matrices
     *                                  are not ECEF frame valid.
     */
    public static void estimateKinematics(final Time timeInterval,
                                          final ECEFFrame frame,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/estimators/ECIKinematicsEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/estimators/ECIKinematicsEstimator.html#L1276">1276</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/estimators/ECIKinematicsEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/estimators/ECIKinematicsEstimator.html#L1305">1305</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public static void estimateKinematics(final double timeInterval,
                                          final ECIFrame frame,
                                          final CoordinateTransformation oldC,
                                          final Speed oldVx, final Speed oldVy, final Speed oldVz,
                                          final BodyKinematics result) {
        estimateKinematics(timeInterval, frame, oldC,
                SpeedConverter.convert(oldVx.getValue().doubleValue(), oldVx.getUnit(), SpeedUnit.METERS_PER_SECOND),
                SpeedConverter.convert(oldVy.getValue().doubleValue(), oldVy.getUnit(), SpeedUnit.METERS_PER_SECOND),
                SpeedConverter.convert(oldVz.getValue().doubleValue(), oldVz.getUnit(), SpeedUnit.METERS_PER_SECOND),
                result);
    }

    /**
     * Estimates body kinematics (specific force applied to a body and its angular rates).
     *
     * @param timeInterval time interval between epochs.
     * @param frame        body ECI frame containing current position, velocity and
     *                     body-to-ECI frame coordinate transformation.
     * @param oldC         previous body-to-ECI-frame coordinate transformation.
     * @param oldVx        x coordinate of previous velocity of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes.
     * @param oldVy        y coordinate of previous velocity of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes.
     * @param oldVz        z coordinate of previous velocity of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes.
     * @param result       instance where estimated body kinematics will be stored.
     * @throws IllegalArgumentException if provided time interval is negative or coordinates transformation matrices
     *                                  are not ECI frame valid.
     */
    public static void estimateKinematics(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/Utils.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/Utils.html#L2088">2088</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/Utils.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/Utils.html#L2314">2314</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                }

                @Override
                public int getNumberOfVariables() {
                    return 1;
                }
            };

            final JacobianEstimator jacobianEstimator = new JacobianEstimator(evaluator);

            return MultivariateNormalDist.propagate(new MultivariateNormalDist.JacobianEvaluator() {
                @Override
                public void evaluate(double[] x, double[] y, Matrix jacobian) {

                    try {
                        evaluator.evaluate(x, y);
                        jacobianEstimator.jacobian(x, jacobian);
                    } catch (EvaluationException ignore) {
                        //never happens
                    }
                }

                @Override
                public int getNumberOfVariables() {
                    return 1;
                }
            }, mean, covariance);
        } catch (AlgebraException | StatisticsException e) {
            throw new IndoorException(e);
        }
    }

    /**
     * Propagates provided variances (fingerprint rssi variance, path-loss exponent variance,
     * fingerprint position covariance and radio source position covariance) into
     * rssi variance by considering the 3D 3rd order Taylor expression of received power.
     * Notice that any unknown variance is assumed to be zero.
     * @param fingerprintRssi closest located fingerprint reading RSSI expressed in dBm's.
     * @param pathLossExponent path-loss exponent.
     * @param fingerprintPosition position of closest fingerprint.
     * @param radioSourcePosition radio source position associated to fingerprint reading.
     * @param estimatedPosition  position to be estimated. Usually this is equal to the
     *                           initial position used by a non linear algorithm.
     * @param fingerprintRssiVariance variance of fingerprint RSSI or null if unknown.
     * @param pathLossExponentVariance variance of path-loss exponent or null if unknown.
     * @param fingerprintPositionCovariance covariance of fingerprint position or null if
     *                                      unknown.
     * @param radioSourcePositionCovariance covariance of radio source position or null
     *                                      if unknown.
     * @param estimatedPositionCovariance  covariance of position to be estimated or null
     *                                     if unknown. (This is usually unknown).
     * @return a normal distribution containing expected received RSSI value and its variance.
     * @throws IndoorException if something fails.
     */
    public static MultivariateNormalDist propagateVariancesToRssiVarianceThirdOrderNonLinear3D(</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/LMedSRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/LMedSRobustRangingRadioSourceEstimator2D.html#L305">305</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/LMedSRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/LMedSRobustRssiRadioSourceEstimator2D.html#L542">542</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                            mListener.onEstimateProgressChange(LMedSRobustRangingRadioSourceEstimator2D.this,
                                    progress);
                        }
                    }
                });

        try {
            mLocked = true;
            mInliersData = null;
            innerEstimator.setConfidence(mConfidence);
            innerEstimator.setMaxIterations(mMaxIterations);
            innerEstimator.setProgressDelta(mProgressDelta);
            Solution&lt;Point2D&gt; result = innerEstimator.estimate();
            mInliersData = innerEstimator.getInliersData();
            attemptRefine(result);

        } catch (com.irurueta.numerical.LockedException e) {
            throw new LockedException(e);
        } catch (com.irurueta.numerical.NotReadyException e) {
            throw new NotReadyException(e);
        } finally {
            mLocked = false;
        }
    }

    /**
     * Returns method being used for robust estimation.
     *
     * @return method being used for robust estimation.
     */
    @Override
    public RobustEstimatorMethod getMethod() {
        return RobustEstimatorMethod.LMedS;
    }
}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/LMedSRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/LMedSRobustRangingRadioSourceEstimator3D.html#L305">305</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/LMedSRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/LMedSRobustRssiRadioSourceEstimator3D.html#L542">542</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                            mListener.onEstimateProgressChange(LMedSRobustRangingRadioSourceEstimator3D.this,
                                progress);
                        }
                    }
                });

        try {
            mLocked = true;
            mInliersData = null;
            innerEstimator.setConfidence(mConfidence);
            innerEstimator.setMaxIterations(mMaxIterations);
            innerEstimator.setProgressDelta(mProgressDelta);
            Solution&lt;Point3D&gt; result = innerEstimator.estimate();
            mInliersData = innerEstimator.getInliersData();
            attemptRefine(result);

        } catch (com.irurueta.numerical.LockedException e) {
            throw new LockedException(e);
        } catch (com.irurueta.numerical.NotReadyException e) {
            throw new NotReadyException(e);
        } finally {
            mLocked = false;
        }
    }

    /**
     * Returns method being used for robust estimation.
     *
     * @return method being used for robust estimation.
     */
    @Override
    public RobustEstimatorMethod getMethod() {
        return RobustEstimatorMethod.LMedS;
    }
}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRangingAndRssiRadioSourceEstimator2D.html#L485">485</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRangingRadioSourceEstimator2D.html#L264">264</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRssiRadioSourceEstimator2D.html#L496">496</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>                                    MSACRobustRangingAndRssiRadioSourceEstimator2D.this, progress);
                        }
                    }
                });

        try {
            mLocked = true;
            mInliersData = null;
            innerEstimator.setConfidence(mConfidence);
            innerEstimator.setMaxIterations(mMaxIterations);
            innerEstimator.setProgressDelta(mProgressDelta);
            Solution&lt;Point2D&gt; result = innerEstimator.estimate();
            mInliersData = innerEstimator.getInliersData();
            attemptRefine(result);

        } catch (com.irurueta.numerical.LockedException e) {
            throw new LockedException(e);
        } catch (com.irurueta.numerical.NotReadyException e) {
            throw new NotReadyException(e);
        } finally {
            mLocked = false;
        }
    }

    /**
     * Returns method being used for robust estimation.
     *
     * @return method being used for robust estimation.
     */
    @Override
    public RobustEstimatorMethod getMethod() {
        return RobustEstimatorMethod.MSAC;
    }
}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRangingAndRssiRadioSourceEstimator3D.html#L485">485</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRangingRadioSourceEstimator3D.html#L264">264</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRssiRadioSourceEstimator3D.html#L496">496</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                                            MSACRobustRangingAndRssiRadioSourceEstimator3D.this, progress);
                                }
                            }
                        });

        try {
            mLocked = true;
            mInliersData = null;
            innerEstimator.setConfidence(mConfidence);
            innerEstimator.setMaxIterations(mMaxIterations);
            innerEstimator.setProgressDelta(mProgressDelta);
            Solution&lt;Point3D&gt; result = innerEstimator.estimate();
            mInliersData = innerEstimator.getInliersData();
            attemptRefine(result);

        } catch (com.irurueta.numerical.LockedException e) {
            throw new LockedException(e);
        } catch (com.irurueta.numerical.NotReadyException e) {
            throw new NotReadyException(e);
        } finally {
            mLocked = false;
        }
    }

    /**
     * Returns method being used for robust estimation.
     *
     * @return method being used for robust estimation.
     */
    @Override
    public RobustEstimatorMethod getMethod() {
        return RobustEstimatorMethod.MSAC;
    }
}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/MixedRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MixedRadioSourceEstimator.html#L497">497</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RangingAndRssiRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RangingAndRssiRadioSourceEstimator.html#L487">487</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RssiRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RssiRadioSourceEstimator.html#L489">489</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustMixedRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustMixedRadioSourceEstimator.html#L1597">1597</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator.html#L1580">1580</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    }

    /**
     * Gets initial transmitted power to start the estimation of radio source
     * transmitted power (expressed in dBm's).
     * If not defined, average value of received power readings will be used.
     *
     * If transmitted power estimation is enabled, estimation will start at this
     * value and will converte the most appropriate value.
     * If transmitted power estimation is disabled, this value will be assumed to be
     * exact and the estimated transmitted power will be equal to this value
     * (converted to dBm's).
     * @return initial transmitted power to start the estimation of radio source
     * transmitted power.
     */
    public Double getInitialTransmittedPowerdBm() {
        return mInitialTransmittedPowerdBm;
    }

    /**
     * Sets initial transmitted power to start the estimation of radio source
     * transmitted power (expressed in dBm's).
     * If not defined, average value of received power readings will be used.
     *
     * If transmitted power estimation is enabled, estimation will start at this
     * value and will converte the most appropriate value.
     * If transmitted power estimation is disabled, this value will be assumed to be
     * exact and the estimated transmitted power will be equal to this value
     * (converted to dBm's).
     * @param initialTransmittedPowerdBm initial transmitted power to start the
     *                                   estimation of radio source transmitted
     *                                   power.
     * @throws LockedException if estimator is locked.
     */
    public void setInitialTransmittedPowerdBm(Double initialTransmittedPowerdBm)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mInitialTransmittedPowerdBm = initialTransmittedPowerdBm;
    }

    /**
     * Gets initial transmitted power to start the estimation of radio source
     * transmitted power (expressed in mW).
     * If not defined, average value of received power readings will be used.
     *
     * If transmitted power estimation is enabled, estimation will start at this
     * value and will converte the most appropriate value.
     * If transmitted power estimation is disabled, this value will be assumed to be
     * exact and the estimated transmitted power will be equal to this value
     * (converted to dBm's).
     * @return initial transmitted power to start the estimation of radio source
     * transmitted power.
     */
    public Double getInitialTransmittedPower() {
        return mInitialTransmittedPowerdBm != null ?
                Utils.dBmToPower(mInitialTransmittedPowerdBm) : null;
    }

    /**
     * Sets initial transmitted power to start the estimation of radio source
     * transmitted power (expressed in mW).
     * If not defined, average value of received power readings will be used.
     *
     * If transmitted power estimation is enabled, estimation will start at this
     * value and will converte the most appropriate value.
     * If transmitted power estimation is disabled, this value will be assumed to be
     * exact and the estimated transmitted power will be equal to this value
     * (converted to dBm's).
     * @param initialTransmittedPower initial transmitted power to start the
     *                                estimation of radio source transmitted power.
     * @throws LockedException if estimator is locked.
     * @throws IllegalArgumentException if provided value is negative.
     */
    public void setInitialTransmittedPower(Double initialTransmittedPower)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (initialTransmittedPower != null) {
            if (initialTransmittedPower &lt; 0.0) {
                throw new IllegalArgumentException();
            }
            mInitialTransmittedPowerdBm = Utils.powerTodBm(
                    initialTransmittedPower);
        } else {
            mInitialTransmittedPowerdBm = null;
        }
    }

    /**
     * Indicates whether transmitted power estimation is enabled or not.
     * @return true if transmitted power estimation is enabled, false otherwise.
     */
    public boolean isTransmittedPowerEstimationEnabled() {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator2D.html#L2917">2917</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator3D.html#L2891">2891</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>        Point2D initialPosition = result.getEstimatedPosition();
        double initialTransmittedPowerdBm =
                result.getEstimatedTransmittedPowerdBm();
        double initialPathLossExponent = result.getEstimatedPathLossExponent();

        if (mRefineResult &amp;&amp; mInliersData != null) {
            BitSet inliers = mInliersData.getInliers();
            int nSamples = mReadings.size();

            mInnerReadings.clear();

            for (int i = 0; i &lt; nSamples; i++) {
                if (inliers.get(i)) {
                    //sample is inlier
                    mInnerReadings.add(mReadings.get(i));
                }
            }

            try {
                mInnerEstimator.setInitialPosition(initialPosition);
                mInnerEstimator.setInitialTransmittedPowerdBm(initialTransmittedPowerdBm);
                mInnerEstimator.setInitialPathLossExponent(initialPathLossExponent);
                mInnerEstimator.setTransmittedPowerEstimationEnabled(
                        mTransmittedPowerEstimationEnabled);
                mInnerEstimator.setPathLossEstimationEnabled(</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator3D.html#L2919">2919</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator2D.html#L2891">2891</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>        Point3D initialPosition = result.getEstimatedPosition();
        double initialTransmittedPowerdBm =
                result.getEstimatedTransmittedPowerdBm();
        double initialPathLossExponent = result.getEstimatedPathLossExponent();

        if (mRefineResult &amp;&amp; mInliersData != null) {
            BitSet inliers = mInliersData.getInliers();
            int nSamples = mReadings.size();

            mInnerReadings.clear();

            for (int i = 0; i &lt; nSamples; i++) {
                if (inliers.get(i)) {
                    //sample is inlier
                    mInnerReadings.add(mReadings.get(i));
                }
            }

            try {
                mInnerEstimator.setInitialPosition(initialPosition);
                mInnerEstimator.setInitialTransmittedPowerdBm(initialTransmittedPowerdBm);
                mInnerEstimator.setInitialPathLossExponent(initialPathLossExponent);
                mInnerEstimator.setTransmittedPowerEstimationEnabled(
                        mTransmittedPowerEstimationEnabled);
                mInnerEstimator.setPathLossEstimationEnabled(</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRangingAndRssiRadioSourceEstimator2D.html#L425">425</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRssiRadioSourceEstimator2D.html#L436">436</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator2D.html#L502">502</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator2D.html#L274">274</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator2D.html#L513">513</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                        new MSACRobustEstimatorListener&lt;Solution&lt;Point2D&gt;&gt;() {
                    @Override
                    public double getThreshold() {
                        return mThreshold;
                    }

                    @Override
                    public int getTotalSamples() {
                        return mReadings.size();
                    }

                    @Override
                    public int getSubsetSize() {
                        return Math.max(mPreliminarySubsetSize, getMinReadings());
                    }

                    @Override
                    public void estimatePreliminarSolutions(int[] samplesIndices,
                            List&lt;Solution&lt;Point2D&gt;&gt; solutions) {
                        solvePreliminarSolutions(samplesIndices, solutions);
                    }

                    @Override
                    public double computeResidual(Solution&lt;Point2D&gt; currentEstimation, int i) {
                        return residual(currentEstimation, i);
                    }

                    @Override
                    public boolean isReady() {
                        return MSACRobustRangingAndRssiRadioSourceEstimator2D.this.isReady();</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRangingAndRssiRadioSourceEstimator3D.html#L425">425</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRssiRadioSourceEstimator3D.html#L436">436</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator3D.html#L502">502</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator3D.html#L274">274</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator3D.html#L512">512</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>                        new MSACRobustEstimatorListener&lt;Solution&lt;Point3D&gt;&gt;() {
                            @Override
                            public double getThreshold() {
                                return mThreshold;
                            }

                            @Override
                            public int getTotalSamples() {
                                return mReadings.size();
                            }

                            @Override
                            public int getSubsetSize() {
                                return Math.max(mPreliminarySubsetSize, getMinReadings());
                            }

                            @Override
                            public void estimatePreliminarSolutions(int[] samplesIndices,
                                                                    List&lt;Solution&lt;Point3D&gt;&gt; solutions) {
                                solvePreliminarSolutions(samplesIndices, solutions);
                            }

                            @Override
                            public double computeResidual(Solution&lt;Point3D&gt; currentEstimation, int i) {
                                return residual(currentEstimation, i);
                            }

                            @Override
                            public boolean isReady() {
                                return MSACRobustRangingAndRssiRadioSourceEstimator3D.this.isReady();</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/estimators/ECEFKinematicsEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/estimators/ECEFKinematicsEstimator.html#L1392">1392</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/estimators/ECIKinematicsEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/estimators/ECIKinematicsEstimator.html#L1306">1306</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>                                          final ECEFFrame frame,
                                          final CoordinateTransformation oldC,
                                          final Speed oldVx, final Speed oldVy, final Speed oldVz,
                                          final BodyKinematics result) {
        estimateKinematics(timeInterval, frame, oldC,
                SpeedConverter.convert(oldVx.getValue().doubleValue(), oldVx.getUnit(), SpeedUnit.METERS_PER_SECOND),
                SpeedConverter.convert(oldVy.getValue().doubleValue(), oldVy.getUnit(), SpeedUnit.METERS_PER_SECOND),
                SpeedConverter.convert(oldVz.getValue().doubleValue(), oldVz.getUnit(), SpeedUnit.METERS_PER_SECOND),
                result);
    }

    /**
     * Estimates body kinematics (specific force applied to a body and its angular rates).
     *
     * @param timeInterval time interval between epochs.
     * @param frame        body ECEF frame containing current position, velocity and
     *                     body-to-ECEF frame coordinate transformation.
     * @param oldC         previous body-to-ECEF-frame coordinate transformation matrix.
     * @param oldVx        previous velocity of body frame x coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldVy        previous velocity of body frame y coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldVz        previous velocity of body frame z coordinate with respect ECEF
     *                     frame, resolved along EVEF-frame axes.
     * @param result       instance where body kinematics estimation will be stored.
     * @throws IllegalArgumentException if provided time interval is negative or coordinated transformation matrices
     *                                  are not ECEF frame valid.
     */
    public static void estimateKinematics(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/estimators/ECEFKinematicsEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/estimators/ECEFKinematicsEstimator.html#L1421">1421</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/estimators/ECIKinematicsEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/estimators/ECIKinematicsEstimator.html#L1277">1277</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>                                          final ECEFFrame frame,
                                          final CoordinateTransformation oldC,
                                          final Speed oldVx, final Speed oldVy, final Speed oldVz,
                                          final BodyKinematics result) {
        estimateKinematics(timeInterval, frame, oldC,
                SpeedConverter.convert(oldVx.getValue().doubleValue(), oldVx.getUnit(), SpeedUnit.METERS_PER_SECOND),
                SpeedConverter.convert(oldVy.getValue().doubleValue(), oldVy.getUnit(), SpeedUnit.METERS_PER_SECOND),
                SpeedConverter.convert(oldVz.getValue().doubleValue(), oldVz.getUnit(), SpeedUnit.METERS_PER_SECOND),
                result);
    }

    /**
     * Estimates body kinematics (specific force applied to a body and its angular rates).
     *
     * @param timeInterval time interval between epochs expressed in seconds (s).
     * @param c            body-to-ECEF frame coordinate transformation matrix.
     * @param oldC         previous body-to-ECEF-frame coordinate transformation matrix.
     * @param vx           velocity of body frame x coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per
     *                     second (m/s).
     * @param vy           velocity of body frame y coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per
     *                     second (m/s).
     * @param vz           velocity of body frame z coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per
     *                     second (m/s).
     * @param oldVx        previous velocity of body frame x coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters
     *                     per second (m/s).
     * @param oldVy        previous velocity of body frame y coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters
     *                     per second (m/s).
     * @param oldVz        previous velocity of body frame z coordinate with respect ECEF
     *                     frame, resolved along EVEF-frame axes and expressed in meters
     *                     per second (m/s).
     * @param position     body position expressed in meters (m) with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param result       instance where body kinematics estimation will be stored.
     * @throws IllegalArgumentException if provided time interval is negative or coordinated transformation matrices
     *                                  are not ECEF frame valid.
     */
    public static void estimateKinematics(final double timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/LMedSRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/LMedSRobustRangingRadioSourceEstimator2D.html#L305">305</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/LMedSRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/LMedSRobustRssiRadioSourceEstimator2D.html#L542">542</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRangingAndRssiRadioSourceEstimator2D.html#L485">485</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRangingRadioSourceEstimator2D.html#L264">264</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRssiRadioSourceEstimator2D.html#L496">496</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                            mListener.onEstimateProgressChange(LMedSRobustRangingRadioSourceEstimator2D.this,
                                    progress);
                        }
                    }
                });

        try {
            mLocked = true;
            mInliersData = null;
            innerEstimator.setConfidence(mConfidence);
            innerEstimator.setMaxIterations(mMaxIterations);
            innerEstimator.setProgressDelta(mProgressDelta);
            Solution&lt;Point2D&gt; result = innerEstimator.estimate();
            mInliersData = innerEstimator.getInliersData();
            attemptRefine(result);

        } catch (com.irurueta.numerical.LockedException e) {
            throw new LockedException(e);
        } catch (com.irurueta.numerical.NotReadyException e) {
            throw new NotReadyException(e);
        } finally {
            mLocked = false;
        }
    }

    /**
     * Returns method being used for robust estimation.
     *
     * @return method being used for robust estimation.
     */
    @Override
    public RobustEstimatorMethod getMethod() {
        return RobustEstimatorMethod.LMedS;</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/LMedSRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/LMedSRobustRangingRadioSourceEstimator3D.html#L305">305</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/LMedSRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/LMedSRobustRssiRadioSourceEstimator3D.html#L542">542</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRangingAndRssiRadioSourceEstimator3D.html#L485">485</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRangingRadioSourceEstimator3D.html#L264">264</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRssiRadioSourceEstimator3D.html#L496">496</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>                            mListener.onEstimateProgressChange(LMedSRobustRangingRadioSourceEstimator3D.this,
                                progress);
                        }
                    }
                });

        try {
            mLocked = true;
            mInliersData = null;
            innerEstimator.setConfidence(mConfidence);
            innerEstimator.setMaxIterations(mMaxIterations);
            innerEstimator.setProgressDelta(mProgressDelta);
            Solution&lt;Point3D&gt; result = innerEstimator.estimate();
            mInliersData = innerEstimator.getInliersData();
            attemptRefine(result);

        } catch (com.irurueta.numerical.LockedException e) {
            throw new LockedException(e);
        } catch (com.irurueta.numerical.NotReadyException e) {
            throw new NotReadyException(e);
        } finally {
            mLocked = false;
        }
    }

    /**
     * Returns method being used for robust estimation.
     *
     * @return method being used for robust estimation.
     */
    @Override
    public RobustEstimatorMethod getMethod() {
        return RobustEstimatorMethod.LMedS;</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator2D.html#L1039">1039</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator3D.html#L1039">1039</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator2D.html#L535">535</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator3D.html#L534">534</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator2D.html#L1050">1050</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator3D.html#L1049">1049</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>            Solution&lt;Point2D&gt; result = innerEstimator.estimate();
            mInliersData = innerEstimator.getInliersData();
            attemptRefine(result);

        } catch (com.irurueta.numerical.LockedException e) {
            throw new LockedException(e);
        } catch (com.irurueta.numerical.NotReadyException e) {
            throw new NotReadyException(e);
        } finally {
            mLocked = false;
        }
    }

    /**
     * Returns method being used for robust estimation.
     *
     * @return method being used for robust estimation.
     */
    @Override
    public RobustEstimatorMethod getMethod() {
        return RobustEstimatorMethod.PROMedS;
    }

    /**
     * Sets quality scores corresponding to each provided sample.
     * This method is used internally and does not check whether instance is
     * locked or not.
     *
     * @param qualityScores quality scores to be set.
     * @throws IllegalArgumentException if provided quality scores length
     * is smaller than 3 samples.
     */
    private void internalSetQualityScores(double[] qualityScores) {
        if (qualityScores == null ||
                qualityScores.length &lt; getMinReadings()) {
            throw new IllegalArgumentException();
        }

        mQualityScores = qualityScores;
    }
}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator2D.html#L913">913</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator3D.html#L913">913</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator2D.html#L404">404</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator3D.html#L404">404</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator2D.html#L918">918</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator3D.html#L917">917</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator2D.html#L429">429</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator3D.html#L429">429</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator2D.html#L202">202</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator3D.html#L202">202</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator2D.html#L440">440</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator3D.html#L440">440</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    }

    /**
     * Indicates whether inliers must be computed and kept.
     *
     * @return true if inliers must be computed and kept, false if inliers
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepInliersEnabled() {
        return mComputeAndKeepInliers;
    }

    /**
     * Specifies whether inliers must be computed and kept.
     *
     * @param computeAndKeepInliers true if inliers must be computed and kept,
     *                              false if inliers only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepInliersEnabled(boolean computeAndKeepInliers)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mComputeAndKeepInliers = computeAndKeepInliers;
    }

    /**
     * Indicates whether residuals must be computed and kept.
     *
     * @return true if residuals must be computed and kept, false if residuals
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepResidualsEnabled() {
        return mComputeAndKeepResiduals;
    }

    /**
     * Specifies whether residuals must be computed and kept.
     *
     * @param computeAndKeepResiduals true if residuals must be computed and kept,
     *                                false if residuals only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepResidualsEnabled(boolean computeAndKeepResiduals)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mComputeAndKeepResiduals = computeAndKeepResiduals;
    }

    /**
     * Robustly estimates position, transmitted power and pathloss exponent for a
     * radio source.
     *
     * @throws LockedException if instance is busy during estimation.
     * @throws NotReadyException if estimator is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     * (i.e. numerical instability, no solution available, etc).
     */
    @Override
    public void estimate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator2D.html#L1066">1066</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator3D.html#L1066">1066</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator2D.html#L556">556</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator3D.html#L556">556</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator2D.html#L1071">1071</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator3D.html#L1070">1070</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>            Solution&lt;Point2D&gt; result = innerEstimator.estimate();
            mInliersData = innerEstimator.getInliersData();
            attemptRefine(result);

        } catch (com.irurueta.numerical.LockedException e) {
            throw new LockedException(e);
        } catch (com.irurueta.numerical.NotReadyException e) {
            throw new NotReadyException(e);
        } finally {
            mLocked = false;
        }
    }

    /**
     * Returns method being used for robust estimation.
     *
     * @return method being used for robust estimation.
     */
    @Override
    public RobustEstimatorMethod getMethod() {
        return RobustEstimatorMethod.PROSAC;
    }

    /**
     * Sets quality scores corresponding to each provided sample.
     * This method is used internally and does not check whether instance is
     * locked or not.
     *
     * @param qualityScores quality scores to be set.
     * @throws IllegalArgumentException if provided quality scores length
     * is smaller than required minimum.
     */
    private void internalSetQualityScores(double[] qualityScores) {
        if (qualityScores == null ||
                qualityScores.length &lt; getMinReadings()) {
            throw new IllegalArgumentException();
        }

        mQualityScores = qualityScores;
    }
}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/lateration/PROMedSRobustLateration2DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/PROMedSRobustLateration2DSolver.html#L574">574</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/lateration/PROMedSRobustLateration3DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/PROMedSRobustLateration3DSolver.html#L574">574</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>            Point2D result = innerEstimator.estimate();
            mInliersData = innerEstimator.getInliersData();
            return attemptRefine(result);
        } catch (com.irurueta.numerical.LockedException e) {
            throw new LockedException(e);
        } catch (com.irurueta.numerical.NotReadyException e) {
            throw new NotReadyException(e);
        } finally {
            mLocked = false;
        }
    }

    /**
     * Returns method being used for robust estimation.
     * @return method being used for robust estimation.
     */
    @Override
    public RobustEstimatorMethod getMethod() {
        return RobustEstimatorMethod.PROMedS;
    }

    /**
     * Sets quality scores corresponding to each provided sample.
     * This method is used internally and does not check whether instance is
     * locked or not.
     * @param qualityScores quality scores to be set.
     * @throws IllegalArgumentException if provided quality scores length
     * is smaller than 3 samples.
     */
    private void internalSetQualityScores(double[] qualityScores) {
        if (qualityScores == null ||
                qualityScores.length &lt; getMinRequiredPositionsAndDistances()) {
            throw new IllegalArgumentException();
        }

        mQualityScores = qualityScores;
    }
}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/lateration/PROSACRobustLateration2DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/PROSACRobustLateration2DSolver.html#L450">450</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/lateration/RANSACRobustLateration2DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/RANSACRobustLateration2DSolver.html#L223">223</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    }

    /**
     * Indicates whether inliers must be computed and kept.
     * @return true if inliers must be computed and kept, false if inliers
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepInliersEnabled() {
        return mComputeAndKeepInliers;
    }

    /**
     * Specifies whether inliers must be computed and kept.
     * @param computeAndKeepInliers true if inliers must be computed and kept,
     *                              false if inliers only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepInliersEnabled(boolean computeAndKeepInliers)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mComputeAndKeepInliers = computeAndKeepInliers;
    }

    /**
     * Indicates whether residuals must be computed and kept.
     * @return true if residuals must be computed and kept, false if residuals
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepResiduals() {
        return mComputeAndKeepResiduals;
    }

    /**
     * Specifies whether residuals must be computed and kept.
     * @param computeAndKeepResiduals true if residuals must be computed and kept,
     *                                false if residuals only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepResidualsEnabled(boolean computeAndKeepResiduals)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mComputeAndKeepResiduals = computeAndKeepResiduals;
    }

    /**
     * Solves the lateration problem.
     * @return estimated position.
     * @throws LockedException if instance is busy solving the lateration problem.
     * @throws NotReadyException is solver is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     * (i.e. numerical instability, no solution available, etc).
     */
    @Override
    public Point2D solve() throws LockedException, NotReadyException,
            RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/lateration/PROSACRobustLateration2DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/PROSACRobustLateration2DSolver.html#L594">594</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/lateration/PROSACRobustLateration3DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/PROSACRobustLateration3DSolver.html#L594">594</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>            Point2D result = innerEstimator.estimate();
            mInliersData = innerEstimator.getInliersData();
            return attemptRefine(result);
        } catch (com.irurueta.numerical.LockedException e) {
            throw new LockedException(e);
        } catch (com.irurueta.numerical.NotReadyException e) {
            throw new NotReadyException(e);
        } finally {
            mLocked = false;
        }
    }

    /**
     * Returns method being used for robust estimation.
     * @return method being used for robust estimation.
     */
    @Override
    public RobustEstimatorMethod getMethod() {
        return RobustEstimatorMethod.PROSAC;
    }

    /**
     * Sets quality scores corresponding to each provided sample.
     * This method is used internally and does not check whether instance is
     * locked or not.
     * @param qualityScores quality scores to be set.
     * @throws IllegalArgumentException if provided quality scores length
     * is smaller than 3 samples.
     */
    private void internalSetQualityScores(double[] qualityScores) {
        if (qualityScores == null ||
                qualityScores.length &lt; getMinRequiredPositionsAndDistances()) {
            throw new IllegalArgumentException();
        }

        mQualityScores = qualityScores;
    }
}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/lateration/PROSACRobustLateration3DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/PROSACRobustLateration3DSolver.html#L450">450</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/lateration/RANSACRobustLateration3DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/RANSACRobustLateration3DSolver.html#L223">223</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    }

    /**
     * Indicates whether inliers must be computed and kept.
     * @return true if inliers must be computed and kept, false if inliers
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepInliersEnabled() {
        return mComputeAndKeepInliers;
    }

    /**
     * Specifies whether inliers must be computed and kept.
     * @param computeAndKeepInliers true if inliers must be computed and kept,
     *                              false if inliers only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepInliersEnabled(boolean computeAndKeepInliers)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mComputeAndKeepInliers = computeAndKeepInliers;
    }

    /**
     * Indicates whether residuals must be computed and kept.
     * @return true if residuals must be computed and kept, false if residuals
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepResiduals() {
        return mComputeAndKeepResiduals;
    }

    /**
     * Specifies whether residuals must be computed and kept.
     * @param computeAndKeepResiduals true if residuals must be computed and kept,
     *                                false if residuals only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepResidualsEnabled(boolean computeAndKeepResiduals)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mComputeAndKeepResiduals = computeAndKeepResiduals;
    }

    /**
     * Solves the lateration problem.
     * @return estimated position.
     * @throws LockedException if instance is busy solving the lateration problem.
     * @throws NotReadyException is solver is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     * (i.e. numerical instability, no solution available, etc).
     */
    @Override
    public Point3D solve() throws LockedException, NotReadyException,
            RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/geodesic/PolygonArea.java</td>
<td><a href="./xref/com/irurueta/navigation/geodesic/PolygonArea.html#L273">273</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/geodesic/PolygonArea.java</td>
<td><a href="./xref/com/irurueta/navigation/geodesic/PolygonArea.html#L339">339</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>        if ((crossings &amp; 1) != 0) {
            tempsum += (tempsum &lt; 0 ? 1 : -1) * mArea0 / 2;
        }

        //area is with the clockwise sense. If !reverse convert to counter-clockwise convention
        if (!reverse) {
            tempsum *= -1;
        }

        //if sign put area in (-area0/2, area0/2], else put area in [0, area0)
        if (sign) {
            if (tempsum &gt; mArea0/2) {
                tempsum -= mArea0;
            } else if (tempsum &lt;= -mArea0/2) {
                tempsum += mArea0;
            }
        } else {
            if (tempsum &gt;= mArea0) {
                tempsum -= mArea0;
            } else if (tempsum &lt; 0) {
                tempsum += mArea0;
            }
        }
        return new PolygonResult(num, perimeter, 0 + tempsum);
    }

    /**
     * Return the results assuming a tentative final test point is added via an azimuth and distance;
     * however, the data for the test point is not saved.
     * This lets you report a running result for the perimeter and area as the user moves the mouse
     * cursor. Ordinary floating point arithmetic is used to accumulate the data for the test point;
     * thus the area and perimeter returned are less accurate than if addPoint and compute are used.
     * @param azi azimuth at current point (degrees).
     * @param s distance from current point to final test point (meters).
     * @param reverse if true then clockwise (instead of counter-clockwise) traversal counts as a
     *                positive area.
     * @param sign if true then return a signed result for the area if the polygon is traversed in
     *             the &quot;wrong&quot; direction instead of returning the area for the rest of the earth.
     * @return PolygonResult(&lt;i&gt;num&lt;/i&gt;, &lt;i&gt;perimeter&lt;/i&gt;, &lt;i&gt;area&lt;/i&gt;) where &lt;i&gt;num&lt;/i&gt; is the
     * number of vertices, &lt;i&gt;perimeter&lt;/i&gt; is the perimeter of the polygon or the length of the
     * polyline (meters), and &lt;i&gt;area&lt;/i&gt; is the area of the polygon (meters&lt;sup&gt;2&lt;/sup&gt;) or
     * Double.NaN of &lt;i&gt;polyline&lt;/i&gt; is true in the constructor.
     */
    public PolygonResult testEdge(double azi, double s, boolean reverse, boolean sign) {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/LMedSRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/LMedSRobustRangingAndRssiRadioSourceEstimator2D.html#L396">396</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/LMedSRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/LMedSRobustRssiRadioSourceEstimator2D.html#L407">407</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>            RobustRangingAndRssiRadioSourceEstimatorListener&lt;S, Point2D&gt; listener) {
        super(readings, initialPosition, initialTransmittedPowerdBm,
                initialPathLossExponent, listener);
    }

    /**
     * Returns threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value, the
     * algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algrithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @return stop threshold to stop the algorithm prematurely when a certain
     * accuracy has been reached.
     */
    public double getStopThreshold() {
        return mStopThreshold;
    }

    /**
     * Sets threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value,
     * the algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algorithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @param stopThreshold stop threshold to stop the algorithm prematurely
     *                      when a certain accuracy has been reached.
     * @throws IllegalArgumentException if provided value is zero or negative.
     * @throws LockedException if this solver is locked.
     */
    public void setStopThreshold(double stopThreshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (stopThreshold &lt;= MIN_STOP_THRESHOLD) {
            throw new IllegalArgumentException();
        }

        mStopThreshold = stopThreshold;
    }

    /**
     * Robustly estimates position, transmitted power and pathloss exponent for a
     * radio source.
     *
     * @throws LockedException if instance is busy during estimation.
     * @throws NotReadyException if estimator is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     * (i.e. numerical instability, no solution available, etc).
     */
    @Override
    public void estimate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        LMedSRobustEstimator&lt;RobustRangingAndRssiRadioSourceEstimator.Solution&lt;Point2D&gt;&gt; innerEstimator =</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/LMedSRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/LMedSRobustRangingAndRssiRadioSourceEstimator2D.html#L396">396</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/LMedSRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/LMedSRobustRangingAndRssiRadioSourceEstimator3D.html#L396">396</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>            RobustRangingAndRssiRadioSourceEstimatorListener&lt;S, Point2D&gt; listener) {
        super(readings, initialPosition, initialTransmittedPowerdBm,
                initialPathLossExponent, listener);
    }

    /**
     * Returns threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value, the
     * algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algrithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @return stop threshold to stop the algorithm prematurely when a certain
     * accuracy has been reached.
     */
    public double getStopThreshold() {
        return mStopThreshold;
    }

    /**
     * Sets threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value,
     * the algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algorithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @param stopThreshold stop threshold to stop the algorithm prematurely
     *                      when a certain accuracy has been reached.
     * @throws IllegalArgumentException if provided value is zero or negative.
     * @throws LockedException if this solver is locked.
     */
    public void setStopThreshold(double stopThreshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (stopThreshold &lt;= MIN_STOP_THRESHOLD) {
            throw new IllegalArgumentException();
        }

        mStopThreshold = stopThreshold;
    }

    /**
     * Robustly estimates position, transmitted power and pathloss exponent for a
     * radio source.
     *
     * @throws LockedException if instance is busy during estimation.
     * @throws NotReadyException if estimator is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     * (i.e. numerical instability, no solution available, etc).
     */
    @Override
    public void estimate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        LMedSRobustEstimator&lt;RobustRangingAndRssiRadioSourceEstimator.Solution&lt;Point2D&gt;&gt; innerEstimator =</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/LMedSRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/LMedSRobustRangingAndRssiRadioSourceEstimator3D.html#L396">396</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/LMedSRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/LMedSRobustRssiRadioSourceEstimator3D.html#L407">407</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>            RobustRangingAndRssiRadioSourceEstimatorListener&lt;S, Point3D&gt; listener) {
        super(readings, initialPosition, initialTransmittedPowerdBm,
                initialPathLossExponent, listener);
    }

    /**
     * Returns threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value, the
     * algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algrithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @return stop threshold to stop the algorithm prematurely when a certain
     * accuracy has been reached.
     */
    public double getStopThreshold() {
        return mStopThreshold;
    }

    /**
     * Sets threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value,
     * the algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algorithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @param stopThreshold stop threshold to stop the algorithm prematurely
     *                      when a certain accuracy has been reached.
     * @throws IllegalArgumentException if provided value is zero or negative.
     * @throws LockedException if this solver is locked.
     */
    public void setStopThreshold(double stopThreshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (stopThreshold &lt;= MIN_STOP_THRESHOLD) {
            throw new IllegalArgumentException();
        }

        mStopThreshold = stopThreshold;
    }

    /**
     * Robustly estimates position, transmitted power and pathloss exponent for a
     * radio source.
     *
     * @throws LockedException if instance is busy during estimation.
     * @throws NotReadyException if estimator is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     * (i.e. numerical instability, no solution available, etc).
     */
    @Override
    public void estimate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        LMedSRobustEstimator&lt;RobustRangingAndRssiRadioSourceEstimator.Solution&lt;Point3D&gt;&gt; innerEstimator =</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/estimators/ECEFKinematicsEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/estimators/ECEFKinematicsEstimator.html#L1233">1233</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/estimators/ECIKinematicsEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/estimators/ECIKinematicsEstimator.html#L1118">1118</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>                                          final ECEFFrame frame,
                                          final CoordinateTransformation oldC,
                                          final double oldVx, final double oldVy, final double oldVz,
                                          final BodyKinematics result) {
        estimateKinematics(TimeConverter.convert(timeInterval.getValue().doubleValue(),
                timeInterval.getUnit(), TimeUnit.SECOND),
                frame.getCoordinateTransformation(),
                oldC, frame.getVx(), frame.getVy(), frame.getVz(),
                oldVx, oldVy, oldVz, frame.getX(), frame.getY(), frame.getZ(), result);
    }

    /**
     * Estimates body kinematics (specific force applied to a body and its angular rates).
     *
     * @param timeInterval time interval between epochs expressed in seconds (s).
     * @param frame        body ECEF frame containing current position, velocity and
     *                     body-to-ECEF frame coordinate transformation.
     * @param oldFrame     body ECEF frame containing previous position, velocity and
     *                     body-to-ECEF frame coordinate transformation. Notice that
     *                     previous position contained in this frame is ignored.
     * @param result       instance where body kinematics estimation will be stored.
     * @throws IllegalArgumentException if provided time interval is negative.
     */
    public static void estimateKinematics(final double timeInterval,
                                          final ECEFFrame frame, final ECEFFrame oldFrame,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/PROMedSRobustMixedPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROMedSRobustMixedPositionEstimator2D.html#L358">358</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/PROMedSRobustMixedPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROMedSRobustMixedPositionEstimator3D.html#L358">358</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/PROMedSRobustRangingAndRssiPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROMedSRobustRangingAndRssiPositionEstimator2D.html#L358">358</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/PROMedSRobustRangingAndRssiPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROMedSRobustRangingAndRssiPositionEstimator3D.html#L358">358</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/PROMedSRobustRangingPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROMedSRobustRangingPositionEstimator2D.html#L357">357</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/PROMedSRobustRangingPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROMedSRobustRangingPositionEstimator3D.html#L357">357</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/PROMedSRobustRssiPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROMedSRobustRssiPositionEstimator2D.html#L356">356</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>            RobustMixedPositionEstimatorListener&lt;Point2D&gt; listener) {
        this(sources, fingerprint, listener);
        internalSetSourceQualityScores(sourceQualityScores);
        internalSetFingerprintReadingsQualityScores(fingerprintReadingsQualityScores);
    }

    /**
     * Returns quality scores corresponding to each radio source.
     * The larger the score value the better the quality of the sample.
     *
     * @return quality scores corresponding to each radio source.
     */
    public double[] getSourceQualityScores() {
        return mSourceQualityScores;
    }

    /**
     * Sets quality scores corresponding to each radio source.
     * The larger the score value the better the quality of the radio source.
     *
     * @param sourceQualityScores quality scores corresponding to each radio source.
     * @throws LockedException          if this instance is locked.
     * @throws IllegalArgumentException if provided quality scores length is smaller
     *                                  than minimum required samples.
     */
    public void setSourceQualityScores(double[] sourceQualityScores)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetSourceQualityScores(sourceQualityScores);
    }

    /**
     * Gets quality scores corresponding to each reading within provided fingerprint.
     * The larger the score value the better the quality of the reading.
     * This implementation always returns null.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @return quality scores corresponding to each reading within provided
     * fingerprint.
     */
    public double[] getFingerprintReadingsQualityScores() {
        return mFingerprintReadingsQualityScores;
    }

    /**
     * Sets quality scores corresponding to each reading within provided fingerprint.
     * The larger the score value the better the quality of the reading.
     * This implementation makes no action.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @param fingerprintReadingsQualityScores quality scores corresponding to each
     *                                         reading within provided fingerprint.
     * @throws LockedException          if this instance is locked.
     * @throws IllegalArgumentException if provided quality scores length is smaller
     *                                  than minimum required samples.
     */
    public void setFingerprintReadingsQualityScores(
            double[] fingerprintReadingsQualityScores) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetFingerprintReadingsQualityScores(fingerprintReadingsQualityScores);
    }

    /**
     * Returns threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value, the
     * algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algrithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @return stop threshold to stop the algorithm prematurely when a certain
     * accuracy has been reached.
     */
    public double getStopThreshold() {
        return ((PROMedSRobustLateration2DSolver) mLaterationSolver).</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/PROSACRobustMixedPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROSACRobustMixedPositionEstimator2D.html#L357">357</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/PROSACRobustMixedPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROSACRobustMixedPositionEstimator3D.html#L357">357</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/PROSACRobustRangingAndRssiPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROSACRobustRangingAndRssiPositionEstimator2D.html#L361">361</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/PROSACRobustRangingAndRssiPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROSACRobustRangingAndRssiPositionEstimator3D.html#L361">361</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/PROSACRobustRangingPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROSACRobustRangingPositionEstimator2D.html#L357">357</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/PROSACRobustRangingPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROSACRobustRangingPositionEstimator3D.html#L357">357</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/PROSACRobustRssiPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROSACRobustRssiPositionEstimator2D.html#L359">359</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/PROSACRobustRssiPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROSACRobustRssiPositionEstimator3D.html#L359">359</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>            RobustMixedPositionEstimatorListener&lt;Point2D&gt; listener) {
        this(sources, fingerprint, listener);
        internalSetSourceQualityScores(sourceQualityScores);
        internalSetFingerprintReadingsQualityScores(fingerprintReadingQualityScores);
    }

    /**
     * Returns quality scores corresponding to each radio source.
     * The larger the score value the better the quality of the sample.
     *
     * @return quality scores corresponding to each radio source.
     */
    public double[] getSourceQualityScores() {
        return mSourceQualityScores;
    }

    /**
     * Sets quality scores corresponding to each radio source.
     * The larger the score value the better the quality of the radio source.
     *
     * @param sourceQualityScores quality scores corresponding to each radio source.
     * @throws LockedException          if this instance is locked.
     * @throws IllegalArgumentException if provided quality scores length is smaller
     *                                  than minimum required samples.
     */
    public void setSourceQualityScores(double[] sourceQualityScores)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetSourceQualityScores(sourceQualityScores);
    }

    /**
     * Gets quality scores corresponding to each reading within provided fingerprint.
     * The larger the score value the better the quality of the reading.
     * This implementation always returns null.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @return quality scores corresponding to each reading within provided
     * fingerprint.
     */
    public double[] getFingerprintReadingsQualityScores() {
        return mFingerprintReadingsQualityScores;
    }

    /**
     * Sets quality scores corresponding to each reading within provided fingerprint.
     * The larger the score value the better the quality of the reading.
     * This implementation makes no action.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @param fingerprintReadingsQualityScores quality scores corresponding to each
     *                                         reading within provided fingerprint.
     * @throws LockedException          if this instance is locked.
     * @throws IllegalArgumentException if provided quality scores length is smaller
     *                                  than minimum required samples.
     */
    public void setFingerprintReadingsQualityScores(
            double[] fingerprintReadingsQualityScores) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetFingerprintReadingsQualityScores(fingerprintReadingsQualityScores);
    }

    /**
     * Gets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on distance between estimated position and distances
     * provided for each sample.
     * @return threshold to determine whether samples are inliers or not.
     */
    public double getThreshold() {
        return ((PROSACRobustLateration2DSolver) mLaterationSolver).</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/SequentialRobustMixedPositionEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/SequentialRobustMixedPositionEstimator.html#L1499">1499</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/SequentialRobustRangingAndRssiPositionEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/SequentialRobustRangingAndRssiPositionEstimator.html#L1473">1473</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>            Fingerprint&lt;? extends RadioSource, ? extends Reading&lt;? extends RadioSource&gt;&gt; fingerprint)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }

        internalSetFingerprint(fingerprint);
    }

    /**
     * Returns quality scores corresponding to each radio source.
     * The larger the score value the better the quality of the radio source.
     *
     * @return quality scores corresponding to each radio source.
     */
    public double[] getSourceQualityScores() {
        return mSourceQualityScores;
    }

    /**
     * Sets quality scores corresponding to each radio source.
     * The larger the score value the better the quality of the radio source.
     *
     * @param sourceQualityScores quality scores corresponding to each radio source.
     * @throws LockedException          if this instance is locked.
     * @throws IllegalArgumentException if provided quality scores length is smaller
     *                                  than minimum required samples.
     */
    public void setSourceQualityScores(double[] sourceQualityScores)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetSourceQualityScores(sourceQualityScores);
    }

    /**
     * Gets quality scores corresponding to each reading within provided fingerprint.
     * The larger the score value the better the quality of the reading.
     *
     * @return quality scores corresponding to each reading within provided fingerprint.
     */
    public double[] getFingerprintReadingsQualityScores() {
        return mFingerprintReadingsQualityScores;
    }

    /**
     * Sets quality scores corresponding to each reading within provided fingerprint.
     * The larger the score value the better the quality of the reading.
     *
     * @param fingerprintReadingsQualityScores  quality scores corresponding to each
     *                                          reading within provided fingerprint.
     * @throws LockedException          if this instance is locked.
     * @throws IllegalArgumentException if provided quality scores length is smaller
     *                                  than minimum required samples.
     */
    public void setFingerprintReadingsQualityScores(
            double[] fingerprintReadingsQualityScores) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetFingerprintReadingsQualityScores(fingerprintReadingsQualityScores);
    }

    /**
     * Gets listener to be notified of events raised by this instance.
     *
     * @return listener to be notified of events raised by this instance.
     */
    public SequentialRobustMixedPositionEstimatorListener&lt;P&gt; getListener() {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator3D.html#L2835">2835</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator3D.html#L2812">2812</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RssiRadioSourceEstimator3D.html#L434">434</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator3D.html#L875">875</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                    source.getFrequency(), accessPoint.getSsid(),
                    getEstimatedTransmittedPowerdBm(),
                    transmittedPowerStandardDeviation,
                    getEstimatedPathLossExponent(),
                    pathlossExponentStandardDeviation,
                    estimatedPosition,
                    estimatedPositionCovariance);
        } else if(source instanceof Beacon) {
            Beacon beacon = (Beacon) source;
            return new BeaconWithPowerAndLocated3D(beacon.getIdentifiers(),
                    getEstimatedTransmittedPowerdBm(), beacon.getFrequency(),
                    beacon.getBluetoothAddress(), beacon.getBeaconTypeCode(),
                    beacon.getManufacturer(), beacon.getServiceUuid(),
                    beacon.getBluetoothName(),
                    getEstimatedPathLossExponent(),
                    transmittedPowerStandardDeviation,
                    pathlossExponentStandardDeviation,
                    estimatedPosition, estimatedPositionCovariance);
        }else {
            return null;
        }
    }</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/lateration/LMedSRobustLateration2DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/LMedSRobustLateration2DSolver.html#L320">320</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/lateration/MSACRobustLateration2DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/MSACRobustLateration2DSolver.html#L276">276</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                            mListener.onSolveProgressChange(LMedSRobustLateration2DSolver.this,
                                    progress);
                        }
                    }
                });

        try {
            mLocked = true;
            mInliersData = null;
            innerEstimator.setConfidence(mConfidence);
            innerEstimator.setMaxIterations(mMaxIterations);
            innerEstimator.setProgressDelta(mProgressDelta);
            Point2D result = innerEstimator.estimate();
            mInliersData = innerEstimator.getInliersData();
            return attemptRefine(result);
        } catch (com.irurueta.numerical.LockedException e) {
            throw new LockedException(e);
        } catch (com.irurueta.numerical.NotReadyException e) {
            throw new NotReadyException(e);
        } finally {
            mLocked = false;
        }
    }

    /**
     * Returns method being used for robust estimation.
     * @return method being used for robust estimation.
     */
    @Override
    public RobustEstimatorMethod getMethod() {
        return RobustEstimatorMethod.LMedS;</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/lateration/LMedSRobustLateration3DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/LMedSRobustLateration3DSolver.html#L320">320</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/lateration/MSACRobustLateration3DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/MSACRobustLateration3DSolver.html#L276">276</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                            mListener.onSolveProgressChange(LMedSRobustLateration3DSolver.this, progress);
                        }
                    }
                });

        try {
            mLocked = true;
            mInliersData = null;
            innerEstimator.setConfidence(mConfidence);
            innerEstimator.setMaxIterations(mMaxIterations);
            innerEstimator.setProgressDelta(mProgressDelta);
            Point3D result = innerEstimator.estimate();
            mInliersData = innerEstimator.getInliersData();
            return attemptRefine(result);
        } catch (com.irurueta.numerical.LockedException e) {
            throw new LockedException(e);
        } catch (com.irurueta.numerical.NotReadyException e) {
            throw new NotReadyException(e);
        } finally {
            mLocked = false;
        }
    }

    /**
     * Returns method being used for robust estimation.
     * @return method being used for robust estimation.
     */
    @Override
    public RobustEstimatorMethod getMethod() {
        return RobustEstimatorMethod.LMedS;</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/LMedSRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/LMedSRobustRssiRadioSourceEstimator2D.html#L407">407</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/LMedSRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/LMedSRobustRssiRadioSourceEstimator3D.html#L407">407</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>            RobustRssiRadioSourceEstimatorListener&lt;S, Point2D&gt; listener) {
        super(readings, initialPosition, initialTransmittedPowerdBm,
                initialPathLossExponent, listener);
    }

    /**
     * Returns threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value, the
     * algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algorithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @return stop threshold to stop the algorithm prematurely when a certain
     * accuracy has been reached.
     */
    public double getStopThreshold() {
        return mStopThreshold;
    }

    /**
     * Sets threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value,
     * the algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algorithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @param stopThreshold stop threshold to stop the algorithm prematurely
     *                      when a certain accuracy has been reached.
     * @throws IllegalArgumentException if provided value is zero or negative.
     * @throws LockedException if this solver is locked.
     */
    public void setStopThreshold(double stopThreshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (stopThreshold &lt;= MIN_STOP_THRESHOLD) {
            throw new IllegalArgumentException();
        }

        mStopThreshold = stopThreshold;
    }

    /**
     * Robustly estimates position, transmitted power and pathloss exponent for a
     * radio source.
     *
     * @throws LockedException if instance is busy during estimation.
     * @throws NotReadyException if estimator is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     * (i.e. numerical instability, no solution available, etc).
     */
    @Override
    public void estimate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        LMedSRobustEstimator&lt;Solution&lt;Point2D&gt;&gt; innerEstimator =</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRangingAndRssiRadioSourceEstimator2D.html#L372">372</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRangingAndRssiRadioSourceEstimator3D.html#L372">372</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRssiRadioSourceEstimator2D.html#L383">383</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRssiRadioSourceEstimator3D.html#L383">383</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>            RobustRangingAndRssiRadioSourceEstimatorListener&lt;S, Point2D&gt; listener) {
        super(readings, initialPosition, initialTransmittedPowerdBm,
                initialPathLossExponent, listener);
    }

    /**
     * Returns threshold to determine whether samples are inliers or not.
     *
     * @return threshold to determine whether samples are inliers or not.
     */
    public double getThreshold() {
        return mThreshold;
    }

    /**
     * Sets threshold to determine whether samples are inliers or not.
     *
     * @param threshold threshold to be set.
     * @throws IllegalArgumentException if provided value is equal or less than
     * zero.
     * @throws LockedException if robust estimator is locked because an
     * estimation is already in progress.
     */
    public void setThreshold(double threshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (threshold &lt;= MIN_THRESHOLD) {
            throw new IllegalArgumentException();
        }
        mThreshold = threshold;
    }

    /**
     * Robustly estimates position, transmitted power and pathloss exponent for a
     * radio source.
     *
     * @throws LockedException if instance is busy during estimation.
     * @throws NotReadyException if estimator is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     * (i.e. numerical instability, no solution available, etc).
     */
    @Override
    public void estimate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        MSACRobustEstimator&lt;Solution&lt;Point2D&gt;&gt; innerEstimator =</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RangingAndRssiRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RangingAndRssiRadioSourceEstimator.html#L1007">1007</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator.html#L2272">2272</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    private RangingReadingLocated&lt;S, P&gt; createRangingReading(RangingAndRssiReadingLocated&lt;S, P&gt; reading) {
        return new RangingReadingLocated&lt;&gt;(reading.getSource(),
                reading.getDistance(), reading.getPosition(),
                reading.getDistanceStandardDeviation(),
                reading.getPositionCovariance());
    }

    /**
     * Creates an RSSI reading from a ranging and RSSI reading.
     * @param reading input reading to convert from.
     * @return an RSSI reading containing only the RSSI data of input reading.
     */
    private RssiReadingLocated&lt;S, P&gt; createRssiReading(RangingAndRssiReadingLocated&lt;S, P&gt; reading) {
        return new RssiReadingLocated&lt;&gt;(reading.getSource(),
                reading.getRssi(), reading.getPosition(),
                reading.getRssiStandardDeviation(),
                reading.getPositionCovariance());
    }
}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L4599">4599</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L4659">4659</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public static void navigateECI(final double timeInterval,
                                   final double oldX,
                                   final double oldY,
                                   final double oldZ,
                                   final CoordinateTransformation oldC,
                                   final double oldVx,
                                   final double oldVy,
                                   final double oldVz,
                                   final Acceleration fx,
                                   final Acceleration fy,
                                   final Acceleration fz,
                                   final double angularRateX,
                                   final double angularRateY,
                                   final double angularRateZ,
                                   final ECIFrame result)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        navigateECI(timeInterval, oldX, oldY, oldZ, oldC, oldVx, oldVy, oldVz,
                convertAccelerationToDouble(fx), convertAccelerationToDouble(fy),
                convertAccelerationToDouble(fz), angularRateX, angularRateY,
                angularRateZ, result);
    }

    /**
     * Runs precision ECI-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldX         previous cartesian x-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldY         previous cartesian y-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldZ         previous cartesian z-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldC         previous body-to-ECI-frame coordinate transformation.
     * @param oldVx        previous velocity x-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param oldVy        previous velocity y-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param oldVz        previous velocity z-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param fx           specific force x-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fy           specific force y-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fz           specific force z-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateX angular rate x-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param result       instance where new estimated ECI frame containing new body position,
     *                     velocity and coordinate transformation matrix will be stored.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-ECI-frame coordinate transformation matrix are invalid.
     */
    public static void navigateECI(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/MixedRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MixedRadioSourceEstimator.html#L1088">1088</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator.html#L2272">2272</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    private RangingReadingLocated&lt;S, P&gt; createRangingReading(RangingAndRssiReadingLocated&lt;S, P&gt; reading) {
        return new RangingReadingLocated&lt;&gt;(reading.getSource(),
                reading.getDistance(), reading.getPosition(),
                reading.getDistanceStandardDeviation(),
                reading.getPositionCovariance());
    }

    /**
     * Creates an RSSI reading from a ranging and RSSI reading.
     * @param reading input reading to convert from.
     * @return an RSSI reading containing only the RSSI data of input reading.
     */
    private RssiReadingLocated&lt;S, P&gt; createRssiReading(RangingAndRssiReadingLocated&lt;S, P&gt; reading) {
        return new RssiReadingLocated&lt;&gt;(reading.getSource(),
                reading.getRssi(), reading.getPosition(),
                reading.getRssiStandardDeviation(),
                reading.getPositionCovariance());
    }</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RangingAndRssiRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RangingAndRssiRadioSourceEstimator.html#L1007">1007</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustMixedRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustMixedRadioSourceEstimator.html#L2400">2400</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    private RangingReadingLocated&lt;S, P&gt; createRangingReading(RangingAndRssiReadingLocated&lt;S, P&gt; reading) {
        return new RangingReadingLocated&lt;&gt;(reading.getSource(),
                reading.getDistance(), reading.getPosition(),
                reading.getDistanceStandardDeviation(),
                reading.getPositionCovariance());
    }

    /**
     * Creates an RSSI reading from a ranging and RSSI reading.
     * @param reading input reading to convert from.
     * @return an RSSI reading containing only the RSSI data of input reading.
     */
    private RssiReadingLocated&lt;S, P&gt; createRssiReading(RangingAndRssiReadingLocated&lt;S, P&gt; reading) {
        return new RssiReadingLocated&lt;&gt;(reading.getSource(),
                reading.getRssi(), reading.getPosition(),
                reading.getRssiStandardDeviation(),
                reading.getPositionCovariance());
    }</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/lateration/HomogeneousLinearLeastSquaresLaterationSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/HomogeneousLinearLeastSquaresLaterationSolver.html#L66">66</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/lateration/InhomogeneousLinearLeastSquaresLaterationSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/InhomogeneousLinearLeastSquaresLaterationSolver.html#L70">70</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public HomogeneousLinearLeastSquaresLaterationSolver(P[] positions, double[] distances,
                                                         LaterationSolverListener&lt;P&gt; listener) {
        super(positions, distances, listener);
    }

    /**
     * Solves the lateration problem.
     * @throws LaterationException if lateration fails.
     * @throws NotReadyException if solver is not ready.
     * @throws LockedException if instance is busy solving the lateration problem.
     */
    @Override
    @SuppressWarnings(&quot;Duplicates&quot;)
    public void solve() throws LaterationException, NotReadyException,
            LockedException {
        // The implementation on this method follows the algorithm  bellow.

        // Having 3 2D circles:
        // c1x, c1y, r1
        // c2x, c2y, r2
        // c3x, c3y, r3
        // where (c1x, c1y) are the coordinates of 1st circle center and r1 is its radius.
        // (c2x, c2y) are the coordinates of 2nd circle center and r2 is its radius.
        // (c3x, c3y) are the coordinates of 3rd circle center and r3 is its radius.

        // The equations of the circles are as follows:
        // (x - c1x)^2 + (y - c1y)^2 = r1^2
        // (x - c2x)^2 + (y - c2y)^2 = r2^2
        // (x - c3x)^2 + (y - c3y)^2 = r3^2

        // x^2 - 2*c1x*x + c1x^2 + y^2 - 2*c1y*y + c1y^2 = r1^2
        // x^2 - 2*c2x*x + c2x^2 + y^2 - 2*c2y*y + c2y^2 = r2^2
        // x^2 - 2*c3x*x + c3x^2 + y^2 - 2*c3y*y + c3y^2 = r3^2

        // remove 1st equation from others (we use 1st point as reference)

        // x^2 - 2*c2x*x + c2x^2 + y^2 - 2*c2y*y + c2y^2 - (x^2 - 2*c1x*x + c1x^2 + y^2 - 2*c1y*y + c1y^2) = r2^2 - r1^2
        // x^2 - 2*c3x*x + c3x^2 + y^2 - 2*c3y*y + c3y^2 - (x^2 - 2*c1x*x + c1x^2 + y^2 - 2*c1y*y + c1y^2) = r3^2 - r1^2

        // - 2*c2x*x + c2x^2 - 2*c2y*y + c2y^2 + 2*c1x*x - c1x^2 + 2*c1y*y - c1y^2 = r2^2 - r1^2
        // - 2*c3x*x + c3x^2 - 2*c3y*y + c3y^2 + 2*c1x*x - c1x^2 + 2*c1y*y - c1y^2 = r3^2 - r1^2

        // 2*(c1x - c2x)*x + c2x^2 + 2*(c1y - c2y)*y + c2y^2 - c1x^2 - c1y^2 = r2^2 - r1^2
        // 2*(c1x - c3x)*x + c3x^2 + 2*(c1y - c3y)*y + c3y^2 - c1x^2 - c1y^2 = r3^2 - r1^2

        // 2*(c1x - c2x)*x + 2*(c1y - c2y)*y = r2^2 - r1^2 + c1x^2 + c1y^2 - c2x^2 - c2y^2
        // 2*(c1x - c3x)*x + 2*(c1y - c3y)*y = r3^2 - r1^2 + c1x^2 + c1y^2 - c3x^2 - c3y^2

        // x and y are the inhomogeneous coordinates of the point (x,y) we want to find, we
        // substitute such point by the corresponding homogeneous coordinates (x,y) = (x'/w', y'/w')

        // Hence
        // 2*(c1x - c2x)*x'/w' + 2*(c1y - c2y)*y'/w' = r2^2 - r1^2 + c1x^2 + c1y^2 - c2x^2 - c2y^2
        // 2*(c1x - c3x)*x'/w' + 2*(c1y - c3y)*y'/w' = r3^2 - r1^2 + c1x^2 + c1y^2 - c3x^2 - c3y^2

        // Multiplitying by w' at both sides...
        // 2*(c1x - c2x)*x' + 2*(c1y - c2y)*y' = (r2^2 - r1^2 + c1x^2 + c1y^2 - c2x^2 - c2y^2)*w'
        // 2*(c1x - c3x)*x' + 2*(c1y - c3y)*y' = (r3^2 - r1^2 + c1x^2 + c1y^2 - c3x^2 - c3y^2)*w'

        // Obtaining the following homogeneous equations
        // 2*(c1x - c2x)*x' + 2*(c1y - c2y)*y' - (r2^2 - r1^2 + c1x^2 + c1y^2 - c2x^2 - c2y^2)*w' = 0
        // 2*(c1x - c3x)*x' + 2*(c1y - c3y)*y' - (r3^2 - r1^2 + c1x^2 + c1y^2 - c3x^2 - c3y^2)*w' = 0

        // Fixing signs...
        // 2*(c1x - c2x)*x' + 2*(c1y - c2y)*y' + (r1^2 - r2^2 + c2x^2 + c2y^2 - c1x^2 - c1y^2)*w' = 0
        // 2*(c1x - c3x)*x' + 2*(c1y - c3y)*y' + (r1^2 - r3^2 + c3x^2 + c3y^2 - c1x^2 - c1y^2)*w' = 0


        // The homogeneous equations can be expressed as a linear system of homogeneous equations A*x = 0
        // where the unknowns to be solved are (x', y', w') up to scale.

        // [2*(c1x - c2x)   2*(c1y - c2y)    r1^2 - r2^2 + c2x^2 + c2y^2 - c1x^2 - c1y^2][x'] = 0
        // [2*(c1x - c3x)   2*(c1y - c3y)    r1^2 - r3^2 + c3x^2 + c3y^2 - c1x^2 - c1y^2][y'] = 0
        //                                                                               [w']

        // This can be solved by using the SVD decomposition of matrix A and picking the last column of
        // resulting V matrix. At least 2 equations are required to find a solution, since 1 additional
        // point is used as a reference, at least 3 points are required.

        // For spheres the solution is analogous

        // Having 4 3D spheres:
        // c1x, c1y, c1z, r1
        // c2x, c2y, c2z, r2
        // c3x, c3y, c3z, r3
        // c4x, c4y, c4z, r4
        // where (c1x, c1y, c1z) are the coordinates of 1st sphere center and r1 is its radius.
        // (c2x, c2y, c2z) are the coordinates of 2nd sphere center and r2 is its radius.
        // (c3x, c3y, c3z) are the coordinates of 3rd sphere center and r3 is its radius.
        // (c4x, c4y, c4z) are the coordinates of 4th sphere center and r4 is its radius.

        // The equations of the spheres are as follows:
        // (x - c1x)^2 + (y - c1y)^2 + (z - c1z)^2 = r1^2
        // (x - c2x)^2 + (y - c2y)^2 + (z - c2z)^2 = r2^2
        // (x - c3x)^2 + (y - c3y)^2 + (z - c3z)^2 = r3^2
        // (x - c4x)^2 + (y - c4y)^2 + (z - c4z)^2 = r4^2

        // x^2 - 2*c1x*x + c1x^2 + y^2 - 2*c1y*y + c1y^2 + z^2 - 2*c1z*z + c1z^2 = r1^2
        // x^2 - 2*c2x*x + c2x^2 + y^2 - 2*c2y*y + c2y^2 + z^2 - 2*c2z*z + c2z^2 = r2^2
        // x^2 - 2*c3x*x + c3x^2 + y^2 - 2*c3y*y + c3y^3 + z^2 - 2*c3z*z + c3z^2 = r3^2
        // x^2 - 2*c4x*x + c4x^2 + y^2 - 2*c4y*y + c4y^2 + z^2 - 2*c4z*z + c4z^2 = r4^2

        // remove 1st equation from others (we use 1st point as reference)
        // x^2 - 2*c2x*x + c2x^2 + y^2 - 2*c2y*y + c2y^2 + z^2 - 2*c2z*z + c2z^2 - (x^2 - 2*c1x*x + c1x^2 + y^2 - 2*c1y*y + c1y^2 + z^2 - 2*c1z*z + c1z^2) = r2^2 - r1^2
        // x^2 - 2*c3x*x + c3x^2 + y^2 - 2*c3y*y + c3y^3 + z^2 - 2*c3z*z + c3z^2 - (x^2 - 2*c1x*x + c1x^2 + y^2 - 2*c1y*y + c1y^2 + z^2 - 2*c1z*z + c1z^2) = r3^2 - r1^2
        // x^2 - 2*c4x*x + c4x^2 + y^2 - 2*c4y*y + c4y^2 + z^2 - 2*c4z*z + c4z^2 - (x^2 - 2*c1x*x + c1x^2 + y^2 - 2*c1y*y + c1y^2 + z^2 - 2*c1z*z + c1z^2) = r4^2 - r1^2

        // - 2*c2x*x + c2x^2 - 2*c2y*y + c2y^2 - 2*c2z*z + c2z^2 + 2*c1x*x - c1x^2 + 2*c1y*y - c1y^2 + 2*c1z*z - c1z^2 = r2^2 - r1^2
        // - 2*c3x*x + c3x^2 - 2*c3y*y + c3y^3 - 2*c3z*z + c3z^2 + 2*c1x*x - c1x^2 + 2*c1y*y - c1y^2 + 2*c1z*z - c1z^2 = r3^2 - r1^2
        // - 2*c4x*x + c4x^2 - 2*c4y*y + c4y^2 - 2*c4z*z + c4z^2 + 2*c1x*x - c1x^2 + 2*c1y*y - c1y^2 + 2*c1z*z - c1z^2 = r4^2 - r1^2

        // 2*(c1x - c2x)*x + c2x^2 + 2*(c1y - c2y)*y + c2y^2 + 2*(c1z - c2z)*z + c2z^2 - c1x^2 - c1y^2 - c1z^2 = r2^2 - r1^2
        // 2*(c1x - c3x)*x + c3x^2 + 2*(c1y - c3y)*y + c3y^3 + 2*(c1z - c3z)*z + c3z^2 - c1x^2 - c1y^2 - c1z^2 = r3^2 - r1^2
        // 2*(c1x - c4x)*x + c4x^2 + 2*(c1y - c4y)*y + c4y^2 + 2*(c1z - c4z)*z + c4z^2 - c1x^2 - c1y^2 - c1z^2 = r4^2 - r1^2

        // 2*(c1x - c2x)*x + 2*(c1y - c2y)*y + 2*(c1z - c2z)*z = r2^2 - r1^2 + c1x^2 + c1y^2 + c1z^2 - c2x^2 - c2y^2 - c2z^2
        // 2*(c1x - c3x)*x + 2*(c1y - c3y)*y + 2*(c1z - c3z)*z = r3^2 - r1^2 + c1x^2 + c1y^2 + c1z^2 - c3x^2 - c3y^3 - c3z^2
        // 2*(c1x - c4x)*x + 2*(c1y - c4y)*y + 2*(c1z - c4z)*z = r4^2 - r1^2 + c1x^2 + c1y^2 + c1z^2 - c4x^2 - c4y^2 - c4z^2

        // x, y and z the inhomogeneous coordinates of the point (x,y,z) we want to find,
        // we substitute such point by the corresponding homogeneous coordinates
        // (x, y, z) = (x'/w', y'/w', z'/w')

        // Hence
        // 2*(c1x - c2x)*x'/w' + 2*(c1y - c2y)*y'/w' + 2*(c1z - c2z)*z'/w' = r2^2 - r1^2 + c1x^2 + c1y^2 + c1z^2 - c2x^2 - c2y^2 - c2z^2
        // 2*(c1x - c3x)*x'/w' + 2*(c1y - c3y)*y'/w' + 2*(c1z - c3z)*z'/w' = r3^2 - r1^2 + c1x^2 + c1y^2 + c1z^2 - c3x^2 - c3y^3 - c3z^2
        // 2*(c1x - c4x)*x'/w' + 2*(c1y - c4y)*y'/w' + 2*(c1z - c4z)*z'/w' = r4^2 - r1^2 + c1x^2 + c1y^2 + c1z^2 - c4x^2 - c4y^2 - c4z^2

        // Multipliying by w' at both sides...
        // 2*(c1x - c2x)*x' + 2*(c1y - c2y)*y' + 2*(c1z - c2z)*z' = (r2^2 - r1^2 + c1x^2 + c1y^2 + c1z^2 - c2x^2 - c2y^2 - c2z^2)*w'
        // 2*(c1x - c3x)*x' + 2*(c1y - c3y)*y' + 2*(c1z - c3z)*z' = (r3^2 - r1^2 + c1x^2 + c1y^2 + c1z^2 - c3x^2 - c3y^3 - c3z^2)*w'
        // 2*(c1x - c4x)*x' + 2*(c1y - c4y)*y' + 2*(c1z - c4z)*z' = (r4^2 - r1^2 + c1x^2 + c1y^2 + c1z^2 - c4x^2 - c4y^2 - c4z^2)*w'

        // Obtaining the following homogeneous equations
        // 2*(c1x - c2x)*x' + 2*(c1y - c2y)*y' + 2*(c1z - c2z)*z' - (r2^2 - r1^2 + c1x^2 + c1y^2 + c1z^2 - c2x^2 - c2y^2 - c2z^2)*w' = 0
        // 2*(c1x - c3x)*x' + 2*(c1y - c3y)*y' + 2*(c1z - c3z)*z' - (r3^2 - r1^2 + c1x^2 + c1y^2 + c1z^2 - c3x^2 - c3y^3 - c3z^2)*w' = 0
        // 2*(c1x - c4x)*x' + 2*(c1y - c4y)*y' + 2*(c1z - c4z)*z' - (r4^2 - r1^2 + c1x^2 + c1y^2 + c1z^2 - c4x^2 - c4y^2 - c4z^2)*w' = 0

        // Fixing signs...
        // 2*(c1x - c2x)*x' + 2*(c1y - c2y)*y' + 2*(c1z - c2z)*z' + (r1^2 - r2^2 + c2x^2 + c2y^2 + c2z^2 - c1x^2 - c1y^2 - c1z^2)*w' = 0
        // 2*(c1x - c3x)*x' + 2*(c1y - c3y)*y' + 2*(c1z - c3z)*z' + (r1^2 - r3^2 + c3x^2 + c3y^3 + c3z^2 - c1x^2 - c1y^2 - c1z^2)*w' = 0
        // 2*(c1x - c4x)*x' + 2*(c1y - c4y)*y' + 2*(c1z - c4z)*z' + (r1^2 - r4^2 + c4x^2 + c4y^2 + c4z^2 - c1x^2 - c1y^2 - c1z^2)*w' = 0

        // The homogeneous equastions can be expressed as a linear system of homogeneous equations
        // where the unknowns to be solved are (x', y', z', w') up to scale.

        // [2*(c1x - c2x)   2*(c1y - c2y)   2*(c1z - c2z)   r1^2 - r2^2 + c2x^2 + c2y^2 + c2z^2 - c1x^2 - c1y^2 - c1z^2][x'] = 0
        // [2*(c1x - c3x)   2*(c1y - c3y)   2*(c1z - c3z)   r1^2 - r3^2 + c3x^2 + c3y^3 + c3z^2 - c1x^2 - c1y^2 - c1z^2][y'] = 0
        // [2*(c1x - c4x)   2*(c1y - c4y)   2*(c1z - c4z)   r1^2 - r4^2 + c4x^2 + c4y^2 + c4z^2 - c1x^2 - c1y^2 - c1z^2][z'] = 0
        //                                                                                                              [w']

        // This can be solved by using the SVD decomposition of matrix A and picking the last column of
        // resulting V matrix. At least 3 equations are required to find a solution, since 1 additional
        // point is used as a reference, at least 4 points are required.

        if (!isReady()) {
            throw new NotReadyException();
        }
        if (isLocked()) {
            throw new LockedException();
        }

        try {
            mLocked = true;

            if (mListener != null) {
                mListener.onSolveStart(this);
            }

            int numberOfPositions = mPositions.length;
            int numberOfPositionsMinus1 = numberOfPositions - 1;
            int dims = getNumberOfDimensions();</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/LMedSRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/LMedSRobustRangingAndRssiRadioSourceEstimator2D.html#L396">396</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/LMedSRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/LMedSRobustRssiRadioSourceEstimator3D.html#L407">407</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>            RobustRangingAndRssiRadioSourceEstimatorListener&lt;S, Point2D&gt; listener) {
        super(readings, initialPosition, initialTransmittedPowerdBm,
                initialPathLossExponent, listener);
    }

    /**
     * Returns threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value, the
     * algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algrithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @return stop threshold to stop the algorithm prematurely when a certain
     * accuracy has been reached.
     */
    public double getStopThreshold() {
        return mStopThreshold;
    }

    /**
     * Sets threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value,
     * the algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algorithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @param stopThreshold stop threshold to stop the algorithm prematurely
     *                      when a certain accuracy has been reached.
     * @throws IllegalArgumentException if provided value is zero or negative.
     * @throws LockedException if this solver is locked.
     */
    public void setStopThreshold(double stopThreshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (stopThreshold &lt;= MIN_STOP_THRESHOLD) {
            throw new IllegalArgumentException();
        }

        mStopThreshold = stopThreshold;
    }

    /**
     * Robustly estimates position, transmitted power and pathloss exponent for a
     * radio source.
     *
     * @throws LockedException if instance is busy during estimation.
     * @throws NotReadyException if estimator is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     * (i.e. numerical instability, no solution available, etc).
     */
    @Override
    public void estimate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        LMedSRobustEstimator&lt;RobustRangingAndRssiRadioSourceEstimator.Solution&lt;Point2D&gt;&gt; innerEstimator =</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/LMedSRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/LMedSRobustRangingAndRssiRadioSourceEstimator3D.html#L396">396</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/LMedSRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/LMedSRobustRssiRadioSourceEstimator2D.html#L407">407</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>            RobustRangingAndRssiRadioSourceEstimatorListener&lt;S, Point3D&gt; listener) {
        super(readings, initialPosition, initialTransmittedPowerdBm,
                initialPathLossExponent, listener);
    }

    /**
     * Returns threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value, the
     * algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algrithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @return stop threshold to stop the algorithm prematurely when a certain
     * accuracy has been reached.
     */
    public double getStopThreshold() {
        return mStopThreshold;
    }

    /**
     * Sets threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value,
     * the algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algorithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @param stopThreshold stop threshold to stop the algorithm prematurely
     *                      when a certain accuracy has been reached.
     * @throws IllegalArgumentException if provided value is zero or negative.
     * @throws LockedException if this solver is locked.
     */
    public void setStopThreshold(double stopThreshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (stopThreshold &lt;= MIN_STOP_THRESHOLD) {
            throw new IllegalArgumentException();
        }

        mStopThreshold = stopThreshold;
    }

    /**
     * Robustly estimates position, transmitted power and pathloss exponent for a
     * radio source.
     *
     * @throws LockedException if instance is busy during estimation.
     * @throws NotReadyException if estimator is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     * (i.e. numerical instability, no solution available, etc).
     */
    @Override
    public void estimate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        LMedSRobustEstimator&lt;RobustRangingAndRssiRadioSourceEstimator.Solution&lt;Point3D&gt;&gt; innerEstimator =</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RssiRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RssiRadioSourceEstimator.html#L1321">1321</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RssiRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RssiRadioSourceEstimator.html#L1445">1445</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>            }
        });

        int numReadings = mReadings.size();
        try {
            Matrix x = new Matrix(numReadings, dimsPlus1);
            double[] y = new double[numReadings];
            double[] standardDeviations = new double[numReadings];
            for (int i = 0; i &lt; numReadings; i++) {
                reading = mReadings.get(i);
                P position = reading.getPosition();

                for (int j = 0; j &lt; dims; j++) {
                    x.setElementAt(i, j, position.getInhomogeneousCoordinate(j));
                }
                x.setElementAt(i, dims, initialTransmittedPowerdBm);</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/lateration/MSACRobustLateration2DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/MSACRobustLateration2DSolver.html#L220">220</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/lateration/RANSACRobustLateration2DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/RANSACRobustLateration2DSolver.html#L289">289</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                new MSACRobustEstimator&lt;&gt;(new MSACRobustEstimatorListener&lt;Point2D&gt;() {
                    @Override
                    public double getThreshold() {
                        return mThreshold;
                    }

                    @Override
                    public int getTotalSamples() {
                        return mDistances.length;
                    }

                    @Override
                    public int getSubsetSize() {
                        return mPreliminarySubsetSize;
                    }

                    @Override
                    public void estimatePreliminarSolutions(int[] samplesIndices, List&lt;Point2D&gt; solutions) {
                        solvePreliminarSolutions(samplesIndices, solutions);
                    }

                    @Override
                    public double computeResidual(Point2D currentEstimation, int i) {
                        return Math.abs(currentEstimation.distanceTo(mPositions[i]) - mDistances[i]);
                    }

                    @Override
                    public boolean isReady() {
                        return MSACRobustLateration2DSolver.this.isReady();</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/lateration/MSACRobustLateration3DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/MSACRobustLateration3DSolver.html#L220">220</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/lateration/RANSACRobustLateration3DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/RANSACRobustLateration3DSolver.html#L289">289</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>            new MSACRobustEstimator&lt;&gt;(new MSACRobustEstimatorListener&lt;Point3D&gt;() {
                @Override
                public double getThreshold() {
                    return mThreshold;
                }

                @Override
                public int getTotalSamples() {
                    return mDistances.length;
                }

                @Override
                public int getSubsetSize() {
                    return mPreliminarySubsetSize;
                }

                @Override
                public void estimatePreliminarSolutions(int[] samplesIndices, List&lt;Point3D&gt; solutions) {
                    solvePreliminarSolutions(samplesIndices, solutions);
                }

                @Override
                public double computeResidual(Point3D currentEstimation, int i) {
                    return Math.abs(currentEstimation.distanceTo(mPositions[i]) - mDistances[i]);
                }

                @Override
                public boolean isReady() {
                    return MSACRobustLateration3DSolver.this.isReady();</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/Utils.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/Utils.html#L344">344</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/Utils.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/Utils.html#L593">593</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                    y[0] = fingerprintRssi
                            - 10.0 * pathLossExponent * crossDiff / (ln10 * d1a2);

                    //compute gradient (is a jacobian having 1 row and 8 columns)


                    //derivative of rssi respect to fingerprint rssi
                    double derivativeFingerprintRssi = 1.0;

                    //derivative of rssi respect to path-loss exponent

                    //diff(Pr(pi))/diff(n) = -10*(x1 - xa)/(ln(10)*d1a^2)*(xi - x1)
                    //  -10*(y1 - ya)/(ln(10)*d1a^2)*(yi - y1)
                    double derivativePathLossExponent = - 10.0 * crossDiff /
                            (ln10 * d1a2);


                    //derivative of rssi respect to x1

                    //We have
                    //Pr(pi) = Pr(p1) -10*n*((x1 - xa)*(xi - x1) + (y1 - ya)*(yi - y1))/
                    //      (ln(10)*((x1 - xa)^2 + (y1 - ya)^2))

                    //and we know that: (f(x)/g(x))' = (f'(x)*g(x) - f(x)*g'(x))/g(x)^2
                    //and also that (f(x)*g(x))' = f'(x)*g(x) + f(x)*g'(x)

                    //Hence
                    //diff((x1 - xa)*(xi - x1) + (y1 - ya)*(yi - y1))/diff(x1) =
                    //  diff(x1*xi -xa*xi -x1^2 + xa*x1)/diff(x1) =
                    //  diff(-x1^2 + (xi + xa)*x1 - xa*xi)/diff(x1) =
                    //  -2*x1 + xi + xa

                    //diff(Pr(pi))/diff(x1) = -10*n/ln(10)*((-2*x1 + xi + xa)*((x1 - xa)^2 + (y1 - ya)^2) - ((x1 - xa)*(xi - x1) + (y1 - ya)*(yi - y1))*2*(x1 - xa))/((x1 - xa)^2 + (y1 - ya)^2)^2
                    //diff(Pr(pi))/diff(x1) = -10*n/ln(10)*((-2*x1 + xi + xa)*d1a^2 - ((x1 - xa)*(xi - x1) + (y1 - ya)*(yi - y1))*2*(x1 - xa))/d1a^4
                    double tmpX = 2.0 * crossDiff * diffX1a;
                    double derivativeX1 = -10.0 * pathLossExponent / ln10 * ((-2.0 * x1 + xi + xa) * d1a2
                            - tmpX) / d1a4;

                    //derivative of rssi respect to y1

                    //diff((x1 - xa)*(xi - x1) + (y1 - ya)*(yi - y1))/diff(y1) =
                    //  diff(y1*yi -ya*yi -y1^2 + ya*y1)/diff(y1) =
                    //  diff(-y1^2 + (yi + ya)*y1 - ya*yi)/diff(y1) =
                    //  -2*y1 + yi + ya

                    //diff(Pr(pi))/diff(y1) = -10*n/ln(10)*((-2*y1 + yi + ya)*((x1 - xa)^2 + (y1 - ya)^2) - ((x1 - xa)*(xi - x1) + (y1 - ya)*(yi - y1))*2*(y1 - ya))/((x1 - xa)^2 + (y1 - ya)^2)^2
                    //diff(Pr(pi))/diff(y1) = -10*n/ln(10)*((-2*y1 + yi + ya)*d1a^2 - ((x1 - xa)*(xi - x1) + (y1 - ya)*(yi - y1))*2*(y1 - ya))/d1a^4
                    double tmpY = 2.0 * crossDiff * diffY1a;
                    double derivativeY1 = -10.0 * pathLossExponent / ln10 * ((-2.0 * y1 + yi + ya) * d1a2
                            - tmpY) / d1a4;


                    //derivative of rssi respect to xa

                    //diff((x1 - xa)*(xi - x1) + (y1 - ya)*(yi - y1))/diff(xa) =
                    //  diff(x1*xi -xa*xi -x1^2 + xa*x1)/diff(xa) =
                    //  x1 - xi

                    //diff(Pr(pi))/diff(xa) = -10*n/ln(10)*((x1 - xi)*((x1 - xa)^2 + (y1 - ya)^2) - ((x1 - xa)*(xi - x1) + (y1 - ya)*(yi - y1))*-2*(x1 - xa))/((x1 - xa)^2 + (y1 - ya)^2)^2
                    //diff(Pr(pi))/diff(xa) = -10*n/ln(10)*(-(xi - x1)*d1a^2 + ((x1 - xa)*(xi - x1) + (y1 - ya)*(yi - y1))*2*(x1 - xa))/d1a^4
                    double derivativeXa = -10.0 * pathLossExponent / ln10 * (-diffXi1 * d1a2</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L5632">5632</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L5694">5694</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public static ECEFFrame navigateECEFAndReturnNew(final double timeInterval,
                                                     final double oldX,
                                                     final double oldY,
                                                     final double oldZ,
                                                     final CoordinateTransformation oldC,
                                                     final double oldVx,
                                                     final double oldVy,
                                                     final double oldVz,
                                                     final double fx,
                                                     final double fy,
                                                     final double fz,
                                                     final double angularRateX,
                                                     final double angularRateY,
                                                     final double angularRateZ)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        final ECEFFrame result = new ECEFFrame();
        navigateECEF(timeInterval, oldX, oldY, oldZ, oldC, oldVx, oldVy, oldVz,
                fx, fy, fz, angularRateX, angularRateY, angularRateZ, result);
        return result;
    }

    /**
     * Runs precision ECEF-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldX         previous cartesian x-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldY         previous cartesian y-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldZ         previous cartesian z-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldC         previous body-to-ECEF-frame coordinate transformation.
     * @param oldVx        previous velocity x-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param oldVy        previous velocity y-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param oldVz        previous velocity z-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @return estimated ECEF frame containing new body position, velocity and coordinate
     * transformation matrix.
     * @throws InertialNavigatorException if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     * body-to-ECEF-frame coordinate transformation matrix are invalid.
     */
    public static ECEFFrame navigateECEFAndReturnNew(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L6020">6020</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L6082">6082</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public static ECEFFrame navigateECEFAndReturnNew(final double timeInterval,
                                                     final Distance oldX,
                                                     final Distance oldY,
                                                     final Distance oldZ,
                                                     final CoordinateTransformation oldC,
                                                     final double oldVx,
                                                     final double oldVy,
                                                     final double oldVz,
                                                     final double fx,
                                                     final double fy,
                                                     final double fz,
                                                     final double angularRateX,
                                                     final double angularRateY,
                                                     final double angularRateZ)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        final ECEFFrame result = new ECEFFrame();
        navigateECEF(timeInterval, oldX, oldY, oldZ, oldC, oldVx, oldVy, oldVz, fx, fy, fz,
                angularRateX, angularRateY, angularRateZ, result);
        return result;
    }

    /**
     * Runs precision ECEF-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldX         previous cartesian x-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldY         previous cartesian y-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldZ         previous cartesian z-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldC         previous body-to-ECEF-frame coordinate transformation.
     * @param oldVx        previous velocity x-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param oldVy        previous velocity y-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param oldVz        previous velocity z-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @return estimated ECEF frame containing new body position, velocity and coordinate
     * transformation matrix.
     * @throws InertialNavigatorException if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     * body-to-ECEF-frame coordinate transformation matrix are invalid.
     */
    public static ECEFFrame navigateECEFAndReturnNew(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L6226">6226</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L6288">6288</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public static ECEFFrame navigateECEFAndReturnNew(final double timeInterval,
                                                     final double oldX,
                                                     final double oldY,
                                                     final double oldZ,
                                                     final CoordinateTransformation oldC,
                                                     final Speed oldSpeedX,
                                                     final Speed oldSpeedY,
                                                     final Speed oldSpeedZ,
                                                     final double fx,
                                                     final double fy,
                                                     final double fz,
                                                     final double angularRateX,
                                                     final double angularRateY,
                                                     final double angularRateZ)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        final ECEFFrame result = new ECEFFrame();
        navigateECEF(timeInterval, oldX, oldY, oldZ, oldC, oldSpeedX, oldSpeedY,
                oldSpeedZ, fx, fy, fz, angularRateX, angularRateY, angularRateZ, result);
        return result;
    }

    /**
     * Runs precision ECEF-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldX         previous cartesian x-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldY         previous cartesian y-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldZ         previous cartesian z-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldC         previous body-to-ECEF-frame coordinate transformation.
     * @param oldSpeedX    previous velocity x-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param oldSpeedY    previous velocity y-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param oldSpeedZ    previous velocity z-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @return estimated ECEF frame containing new body position, velocity and coordinate
     * transformation matrix.
     * @throws InertialNavigatorException if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     * body-to-ECEF-frame coordinate transformation matrix are invalid.
     */
    public static ECEFFrame navigateECEFAndReturnNew(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L6429">6429</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L6488">6488</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public static ECEFFrame navigateECEFAndReturnNew(final double timeInterval,
                                                     final double oldX,
                                                     final double oldY,
                                                     final double oldZ,
                                                     final CoordinateTransformation oldC,
                                                     final double oldVx,
                                                     final double oldVy,
                                                     final double oldVz,
                                                     final Acceleration fx,
                                                     final Acceleration fy,
                                                     final Acceleration fz,
                                                     final double angularRateX,
                                                     final double angularRateY,
                                                     final double angularRateZ)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        final ECEFFrame result = new ECEFFrame();
        navigateECEF(timeInterval, oldX, oldY, oldZ, oldC, oldVx, oldVy, oldVz, fx, fy,
                fz, angularRateX, angularRateY, angularRateZ, result);
        return result;
    }

    /**
     * Runs precision ECEF-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldX         previous cartesian x-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldY         previous cartesian y-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldZ         previous cartesian z-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldC         previous body-to-ECEF-frame coordinate transformation.
     * @param oldVx        previous velocity x-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param oldVy        previous velocity y-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param oldVz        previous velocity z-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @return estimated ECEF frame containing new body position, velocity and coordinate
     * transformation matrix.
     * @throws InertialNavigatorException if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     * body-to-ECEF-frame coordinate transformation matrix are invalid.
     */
    public static ECEFFrame navigateECEFAndReturnNew(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L6547">6547</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L6606">6606</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public static ECEFFrame navigateECEFAndReturnNew(final double timeInterval,
                                                     final double oldX,
                                                     final double oldY,
                                                     final double oldZ,
                                                     final CoordinateTransformation oldC,
                                                     final double oldVx,
                                                     final double oldVy,
                                                     final double oldVz,
                                                     final double fx,
                                                     final double fy,
                                                     final double fz,
                                                     final AngularSpeed angularRateX,
                                                     final AngularSpeed angularRateY,
                                                     final AngularSpeed angularRateZ)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        final ECEFFrame result = new ECEFFrame();
        navigateECEF(timeInterval, oldX, oldY, oldZ, oldC, oldVx, oldVy, oldVz, fx, fy,
                fz, angularRateX, angularRateY, angularRateZ, result);
        return result;
    }

    /**
     * Runs precision ECEF-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldX         previous cartesian x-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldY         previous cartesian y-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldZ         previous cartesian z-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldC         previous body-to-ECEF-frame coordinate transformation.
     * @param oldVx        previous velocity x-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param oldVy        previous velocity y-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param oldVz        previous velocity z-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @return estimated ECEF frame containing new body position, velocity and coordinate
     * transformation matrix.
     * @throws InertialNavigatorException if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     * body-to-ECEF-frame coordinate transformation matrix are invalid.
     */
    public static ECEFFrame navigateECEFAndReturnNew(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L6668">6668</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L6731">6731</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public static ECEFFrame navigateECEFAndReturnNew(final double timeInterval,
                                                     final Distance oldX,
                                                     final Distance oldY,
                                                     final Distance oldZ,
                                                     final CoordinateTransformation oldC,
                                                     final Speed oldSpeedX,
                                                     final Speed oldSpeedY,
                                                     final Speed oldSpeedZ,
                                                     final double fx,
                                                     final double fy,
                                                     final double fz,
                                                     final double angularRateX,
                                                     final double angularRateY,
                                                     final double angularRateZ)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        final ECEFFrame result = new ECEFFrame();
        navigateECEF(timeInterval, oldX, oldY, oldZ, oldC, oldSpeedX, oldSpeedY,
                oldSpeedZ, fx, fy, fz, angularRateX, angularRateY, angularRateZ,
                result);
        return result;
    }

    /**
     * Runs precision ECEF-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldX         previous cartesian x-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldY         previous cartesian y-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldZ         previous cartesian z-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldC         previous body-to-ECEF-frame coordinate transformation.
     * @param oldSpeedX    previous velocity x-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param oldSpeedY    previous velocity y-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param oldSpeedZ    previous velocity z-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @return estimated ECEF frame containing new body position, velocity and coordinate
     * transformation matrix.
     * @throws InertialNavigatorException if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     * body-to-ECEF-frame coordinate transformation matrix are invalid.
     */
    public static ECEFFrame navigateECEFAndReturnNew(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L6788">6788</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L6845">6845</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public static ECEFFrame navigateECEFAndReturnNew(final double timeInterval,
                                                     final Distance oldX,
                                                     final Distance oldY,
                                                     final Distance oldZ,
                                                     final CoordinateTransformation oldC,
                                                     final Speed oldSpeedX,
                                                     final Speed oldSpeedY,
                                                     final Speed oldSpeedZ,
                                                     final Acceleration fx,
                                                     final Acceleration fy,
                                                     final Acceleration fz,
                                                     final AngularSpeed angularRateX,
                                                     final AngularSpeed angularRateY,
                                                     final AngularSpeed angularRateZ)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        final ECEFFrame result = new ECEFFrame();
        navigateECEF(timeInterval, oldX, oldY, oldZ, oldC, oldSpeedX, oldSpeedY,
                oldSpeedZ, fx, fy, fz, angularRateX, angularRateY, angularRateZ,
                result);
        return result;
    }

    /**
     * Runs precision ECEF-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldX         previous cartesian x-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldY         previous cartesian y-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldZ         previous cartesian z-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldC         previous body-to-ECEF-frame coordinate transformation.
     * @param oldSpeedX    previous velocity x-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param oldSpeedY    previous velocity y-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param oldSpeedZ    previous velocity z-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @return estimated ECEF frame containing new body position, velocity and coordinate
     * transformation matrix.
     * @throws InertialNavigatorException if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     * body-to-ECEF-frame coordinate transformation matrix are invalid.
     */
    public static ECEFFrame navigateECEFAndReturnNew(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L6902">6902</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L6958">6958</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public static ECEFFrame navigateECEFAndReturnNew(final double timeInterval,
                                                     final double oldX,
                                                     final double oldY,
                                                     final double oldZ,
                                                     final CoordinateTransformation oldC,
                                                     final double oldVx,
                                                     final double oldVy,
                                                     final double oldVz,
                                                     final Acceleration fx,
                                                     final Acceleration fy,
                                                     final Acceleration fz,
                                                     final AngularSpeed angularRateX,
                                                     final AngularSpeed angularRateY,
                                                     final AngularSpeed angularRateZ)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        final ECEFFrame result = new ECEFFrame();
        navigateECEF(timeInterval, oldX, oldY, oldZ, oldC, oldVx, oldVy, oldVz, fx,
                fy, fz, angularRateX, angularRateY, angularRateZ, result);
        return result;
    }

    /**
     * Runs precision ECEF-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldX         previous cartesian x-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldY         previous cartesian y-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldZ         previous cartesian z-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldC         previous body-to-ECEF-frame coordinate transformation.
     * @param oldVx        previous velocity x-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param oldVy        previous velocity y-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param oldVz        previous velocity z-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @return estimated ECEF frame containing new body position, velocity and coordinate
     * transformation matrix.
     * @throws InertialNavigatorException if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     * body-to-ECEF-frame coordinate transformation matrix are invalid.
     */
    public static ECEFFrame navigateECEFAndReturnNew(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L5667">5667</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L5730">5730</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public static ECIFrame navigateECIAndReturnNew(final double timeInterval,
                                                   final double oldX,
                                                   final double oldY,
                                                   final double oldZ,
                                                   final CoordinateTransformation oldC,
                                                   final double oldVx,
                                                   final double oldVy,
                                                   final double oldVz,
                                                   final double fx,
                                                   final double fy,
                                                   final double fz,
                                                   final double angularRateX,
                                                   final double angularRateY,
                                                   final double angularRateZ)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        final ECIFrame result = new ECIFrame();
        navigateECI(timeInterval, oldX, oldY, oldZ, oldC, oldVx, oldVy, oldVz,
                fx, fy, fz, angularRateX, angularRateY, angularRateZ, result);
        return result;
    }

    /**
     * Runs precision ECI-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldX         previous cartesian x-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldY         previous cartesian y-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldZ         previous cartesian z-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldC         previous body-to-ECI-frame coordinate transformation.
     * @param oldVx        previous velocity x-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param oldVy        previous velocity y-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param oldVz        previous velocity z-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param fx           specific force x-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @return estimated ECI frame containing new body position, velocity and coordinate
     * transformation matrix.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-ECI-frame coordinate transformation matrix are
     *                                                       invalid.
     */
    public static ECIFrame navigateECIAndReturnNew(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L6062">6062</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L6124">6124</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public static ECIFrame navigateECIAndReturnNew(final double timeInterval,
                                                   final Distance oldX,
                                                   final Distance oldY,
                                                   final Distance oldZ,
                                                   final CoordinateTransformation oldC,
                                                   final double oldVx,
                                                   final double oldVy,
                                                   final double oldVz,
                                                   final double fx,
                                                   final double fy,
                                                   final double fz,
                                                   final double angularRateX,
                                                   final double angularRateY,
                                                   final double angularRateZ)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        final ECIFrame result = new ECIFrame();
        navigateECI(timeInterval, oldX, oldY, oldZ, oldC, oldVx, oldVy, oldVz,
                fx, fy, fz, angularRateX, angularRateY, angularRateZ, result);
        return result;
    }

    /**
     * Runs precision ECI-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldX         previous cartesian x-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes.
     * @param oldY         previous cartesian y-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes.
     * @param oldZ         previous cartesian z-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes.
     * @param oldC         previous body-to-ECI-frame coordinate transformation.
     * @param oldVx        previous velocity x-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param oldVy        previous velocity y-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param oldVz        previous velocity z-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param fx           specific force x-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @return estimated ECI frame containing new body position, velocity and coordinate
     * transformation matrix.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-ECI-frame coordinate transformation matrix are invalid.
     */
    public static ECIFrame navigateECIAndReturnNew(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L6270">6270</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L6332">6332</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public static ECIFrame navigateECIAndReturnNew(final double timeInterval,
                                                   final double oldX,
                                                   final double oldY,
                                                   final double oldZ,
                                                   final CoordinateTransformation oldC,
                                                   final Speed oldSpeedX,
                                                   final Speed oldSpeedY,
                                                   final Speed oldSpeedZ,
                                                   final double fx,
                                                   final double fy,
                                                   final double fz,
                                                   final double angularRateX,
                                                   final double angularRateY,
                                                   final double angularRateZ)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        final ECIFrame result = new ECIFrame();
        navigateECI(timeInterval, oldX, oldY, oldZ, oldC, oldSpeedX, oldSpeedY, oldSpeedZ,
                fx, fy, fz, angularRateX, angularRateY, angularRateZ, result);
        return result;
    }

    /**
     * Runs precision ECI-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldX         previous cartesian x-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldY         previous cartesian y-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldZ         previous cartesian z-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldC         previous body-to-ECI-frame coordinate transformation.
     * @param oldSpeedX    previous velocity x-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes.
     * @param oldSpeedY    previous velocity y-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes.
     * @param oldSpeedZ    previous velocity z-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes.
     * @param fx           specific force x-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @return estimated ECI frame containing new body position, velocity and coordinate
     * transformation matrix.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-ECI-frame coordinate transformation matrix are invalid.
     */
    public static ECIFrame navigateECIAndReturnNew(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L6475">6475</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L6534">6534</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public static ECIFrame navigateECIAndReturnNew(final double timeInterval,
                                                   final double oldX,
                                                   final double oldY,
                                                   final double oldZ,
                                                   final CoordinateTransformation oldC,
                                                   final double oldVx,
                                                   final double oldVy,
                                                   final double oldVz,
                                                   final Acceleration fx,
                                                   final Acceleration fy,
                                                   final Acceleration fz,
                                                   final double angularRateX,
                                                   final double angularRateY,
                                                   final double angularRateZ)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        final ECIFrame result = new ECIFrame();
        navigateECI(timeInterval, oldX, oldY, oldZ, oldC, oldVx, oldVy, oldVz,
                fx, fy, fz, angularRateX, angularRateY, angularRateZ, result);
        return result;
    }

    /**
     * Runs precision ECI-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldX         previous cartesian x-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldY         previous cartesian y-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldZ         previous cartesian z-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldC         previous body-to-ECI-frame coordinate transformation.
     * @param oldVx        previous velocity x-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param oldVy        previous velocity y-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param oldVz        previous velocity z-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param fx           specific force x-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fy           specific force y-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fz           specific force z-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateX angular rate x-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @return estimated ECI frame containing new body position, velocity and coordinate
     * transformation matrix.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-ECI-frame coordinate transformation matrix are invalid.
     */
    public static ECIFrame navigateECIAndReturnNew(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L6593">6593</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L6652">6652</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public static ECIFrame navigateECIAndReturnNew(final double timeInterval,
                                                   final double oldX,
                                                   final double oldY,
                                                   final double oldZ,
                                                   final CoordinateTransformation oldC,
                                                   final double oldVx,
                                                   final double oldVy,
                                                   final double oldVz,
                                                   final double fx,
                                                   final double fy,
                                                   final double fz,
                                                   final AngularSpeed angularRateX,
                                                   final AngularSpeed angularRateY,
                                                   final AngularSpeed angularRateZ)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        final ECIFrame result = new ECIFrame();
        navigateECI(timeInterval, oldX, oldY, oldZ, oldC, oldVx, oldVy, oldVz,
                fx, fy, fz, angularRateX, angularRateY, angularRateZ, result);
        return result;
    }

    /**
     * Runs precision ECI-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldX         previous cartesian x-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldY         previous cartesian y-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldZ         previous cartesian z-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldC         previous body-to-ECI-frame coordinate transformation.
     * @param oldVx        previous velocity x-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param oldVy        previous velocity y-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param oldVz        previous velocity z-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param fx           specific force x-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateY angular rate y-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @return estimated ECI frame containing new body position, velocity and coordinate
     * transformation matrix.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-ECI-frame coordinate transformation matrix are invalid.
     */
    public static ECIFrame navigateECIAndReturnNew(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L6714">6714</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L6776">6776</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public static ECIFrame navigateECIAndReturnNew(final double timeInterval,
                                                   final Distance oldX,
                                                   final Distance oldY,
                                                   final Distance oldZ,
                                                   final CoordinateTransformation oldC,
                                                   final Speed oldSpeedX,
                                                   final Speed oldSpeedY,
                                                   final Speed oldSpeedZ,
                                                   final double fx,
                                                   final double fy,
                                                   final double fz,
                                                   final double angularRateX,
                                                   final double angularRateY,
                                                   final double angularRateZ)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        final ECIFrame result = new ECIFrame();
        navigateECI(timeInterval, oldX, oldY, oldZ, oldC, oldSpeedX, oldSpeedY, oldSpeedZ,
                fx, fy, fz, angularRateX, angularRateY, angularRateZ, result);
        return result;
    }

    /**
     * Runs precision ECI-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldX         previous cartesian x-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes.
     * @param oldY         previous cartesian y-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes.
     * @param oldZ         previous cartesian z-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes.
     * @param oldC         previous body-to-ECI-frame coordinate transformation.
     * @param oldSpeedX    previous velocity x-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes.
     * @param oldSpeedY    previous velocity y-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes.
     * @param oldSpeedZ    previous velocity z-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes.
     * @param fx           specific force x-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @return estimated ECI frame containing new body position, velocity and coordinate
     * transformation matrix.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-ECI-frame coordinate transformation matrix are invalid.
     */
    public static ECIFrame navigateECIAndReturnNew(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L6832">6832</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L6888">6888</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public static ECIFrame navigateECIAndReturnNew(final double timeInterval,
                                                   final Distance oldX,
                                                   final Distance oldY,
                                                   final Distance oldZ,
                                                   final CoordinateTransformation oldC,
                                                   final Speed oldSpeedX,
                                                   final Speed oldSpeedY,
                                                   final Speed oldSpeedZ,
                                                   final Acceleration fx,
                                                   final Acceleration fy,
                                                   final Acceleration fz,
                                                   final AngularSpeed angularRateX,
                                                   final AngularSpeed angularRateY,
                                                   final AngularSpeed angularRateZ)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        final ECIFrame result = new ECIFrame();
        navigateECI(timeInterval, oldX, oldY, oldZ, oldC, oldSpeedX, oldSpeedY, oldSpeedZ,
                fx, fy, fz, angularRateX, angularRateY, angularRateZ, result);
        return result;
    }

    /**
     * Runs precision ECI-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldX         previous cartesian x-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes.
     * @param oldY         previous cartesian y-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes.
     * @param oldZ         previous cartesian z-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes.
     * @param oldC         previous body-to-ECI-frame coordinate transformation.
     * @param oldSpeedX    previous velocity x-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes.
     * @param oldSpeedY    previous velocity y-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes.
     * @param oldSpeedZ    previous velocity z-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes.
     * @param fx           specific force x-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fy           specific force y-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fz           specific force z-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateX angular rate x-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateY angular rate y-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @return estimated ECI frame containing new body position, velocity and coordinate
     * transformation matrix.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-ECI-frame coordinate transformation matrix are invalid.
     */
    public static ECIFrame navigateECIAndReturnNew(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L6944">6944</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L7000">7000</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public static ECIFrame navigateECIAndReturnNew(final double timeInterval,
                                                   final double oldX,
                                                   final double oldY,
                                                   final double oldZ,
                                                   final CoordinateTransformation oldC,
                                                   final double oldVx,
                                                   final double oldVy,
                                                   final double oldVz,
                                                   final Acceleration fx,
                                                   final Acceleration fy,
                                                   final Acceleration fz,
                                                   final AngularSpeed angularRateX,
                                                   final AngularSpeed angularRateY,
                                                   final AngularSpeed angularRateZ)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        final ECIFrame result = new ECIFrame();
        navigateECI(timeInterval, oldX, oldY, oldZ, oldC, oldVx, oldVy, oldVz,
                fx, fy, fz, angularRateX, angularRateY, angularRateZ, result);
        return result;
    }

    /**
     * Runs precision ECI-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldX         previous cartesian x-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldY         previous cartesian y-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldZ         previous cartesian z-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldC         previous body-to-ECI-frame coordinate transformation.
     * @param oldVx        previous velocity x-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param oldVy        previous velocity y-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param oldVz        previous velocity z-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param fx           specific force x-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fy           specific force y-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fz           specific force z-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateX angular rate x-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateY angular rate y-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @return estimated ECI frame containing new body position, velocity and coordinate
     * transformation matrix.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-ECI-frame coordinate transformation matrix are invalid.
     */
    public static ECIFrame navigateECIAndReturnNew(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L11739">11739</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L11802">11802</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public static NEDFrame navigateNEDAndReturnNew(final double timeInterval,
                                                   final double oldLatitude,
                                                   final double oldLongitude,
                                                   final double oldHeight,
                                                   final CoordinateTransformation oldC,
                                                   final double oldVn,
                                                   final double oldVe,
                                                   final double oldVd,
                                                   final double fx,
                                                   final double fy,
                                                   final double fz,
                                                   final double angularRateX,
                                                   final double angularRateY,
                                                   final double angularRateZ)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        final NEDFrame result = new NEDFrame();
        navigateNED(timeInterval, oldLatitude, oldLongitude, oldHeight, oldC,
                oldVn, oldVe, oldVd, fx, fy, fz, angularRateX, angularRateY,
                angularRateZ, result);
        return result;
    }

    /**
     * Runs precision local-navigation-frame inertial navigation equations.
     * NOTE: only the attitude update and specific force frame transformation
     * phases are precise.
     *
     * @param timeInterval time interval between epochs.
     * @param oldLatitude  previous latitude expressed in radians (rad).
     * @param oldLongitude previous longitude expressed in radians (rad).
     * @param oldHeight    previous height expressed in meters (m).
     * @param oldC         previous body-to-NED coordinate transformation.
     * @param oldVn        previous velocity north-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param oldVe        previous velocity east-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param oldVd        previous velocity down-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @return estimated NED frame containing new body position, velocity and coordinate
     * transformation matrix.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-NED-frame coordinate transformation matrix are
     *                                                       invalid.
     */
    public static NEDFrame navigateNEDAndReturnNew(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L12493">12493</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L12556">12556</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public static NEDFrame navigateNEDAndReturnNew(final double timeInterval,
                                                   final Angle oldLatitude,
                                                   final Angle oldLongitude,
                                                   final Distance oldHeight,
                                                   final CoordinateTransformation oldC,
                                                   final double oldVn,
                                                   final double oldVe,
                                                   final double oldVd,
                                                   final double fx,
                                                   final double fy,
                                                   final double fz,
                                                   final double angularRateX,
                                                   final double angularRateY,
                                                   final double angularRateZ)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        final NEDFrame result = new NEDFrame();
        navigateNED(timeInterval, oldLatitude, oldLongitude, oldHeight, oldC,
                oldVn, oldVe, oldVd, fx, fy, fz, angularRateX, angularRateY, angularRateZ,
                result);
        return result;
    }

    /**
     * Runs precision local-navigation-frame inertial navigation equations.
     * NOTE: only the attitude update and specific force frame transformation
     * phases are precise.
     *
     * @param timeInterval time interval between epochs.
     * @param oldLatitude  previous latitude angle.
     * @param oldLongitude previous longitude angle.
     * @param oldHeight    previous height.
     * @param oldC         previous body-to-NED coordinate transformation.
     * @param oldVn        previous velocity north-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param oldVe        previous velocity east-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param oldVd        previous velocity down-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @return estimated NED frame containing new body position, velocity and coordinate
     * transformation matrix.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-NED-frame coordinate transformation matrix are
     *                                                       invalid.
     */
    public static NEDFrame navigateNEDAndReturnNew(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L12885">12885</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L12948">12948</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public static NEDFrame navigateNEDAndReturnNew(final double timeInterval,
                                                   final double oldLatitude,
                                                   final double oldLongitude,
                                                   final double oldHeight,
                                                   final CoordinateTransformation oldC,
                                                   final Speed oldSpeedN,
                                                   final Speed oldSpeedE,
                                                   final Speed oldSpeedD,
                                                   final double fx,
                                                   final double fy,
                                                   final double fz,
                                                   final double angularRateX,
                                                   final double angularRateY,
                                                   final double angularRateZ)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        final NEDFrame result = new NEDFrame();
        navigateNED(timeInterval, oldLatitude, oldLongitude, oldHeight, oldC,
                oldSpeedN, oldSpeedE, oldSpeedD, fx, fy, fz, angularRateX,
                angularRateY, angularRateZ, result);
        return result;
    }

    /**
     * Runs precision local-navigation-frame inertial navigation equations.
     * NOTE: only the attitude update and specific force frame transformation
     * phases are precise.
     *
     * @param timeInterval time interval between epochs.
     * @param oldLatitude  previous latitude expressed in radians (rad).
     * @param oldLongitude previous longitude expressed in radians (rad).
     * @param oldHeight    previous height expressed in meters (m).
     * @param oldC         previous body-to-NED coordinate transformation.
     * @param oldSpeedN    previous velocity north-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes.
     * @param oldSpeedE    previous velocity east-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes.
     * @param oldSpeedD    previous velocity down-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes.
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @return estimated NED frame containing new body position, velocity and coordinate
     * transformation matrix.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-NED-frame coordinate transformation matrix are
     *                                                       invalid.
     */
    public static NEDFrame navigateNEDAndReturnNew(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L13284">13284</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L13344">13344</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public static NEDFrame navigateNEDAndReturnNew(final double timeInterval,
                                                   final double oldLatitude,
                                                   final double oldLongitude,
                                                   final double oldHeight,
                                                   final CoordinateTransformation oldC,
                                                   final double oldVn,
                                                   final double oldVe,
                                                   final double oldVd,
                                                   final Acceleration fx,
                                                   final Acceleration fy,
                                                   final Acceleration fz,
                                                   final double angularRateX,
                                                   final double angularRateY,
                                                   final double angularRateZ)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        final NEDFrame result = new NEDFrame();
        navigateNED(timeInterval, oldLatitude, oldLongitude, oldHeight, oldC,
                oldVn, oldVe, oldVd, fx, fy, fz,
                angularRateX, angularRateY, angularRateZ, result);
        return result;
    }

    /**
     * Runs precision local-navigation-frame inertial navigation equations.
     * NOTE: only the attitude update and specific force frame transformation
     * phases are precise.
     *
     * @param timeInterval time interval between epochs.
     * @param oldLatitude  previous latitude expressed in radians (rad).
     * @param oldLongitude previous longitude expressed in radians (rad).
     * @param oldHeight    previous height expressed in meters (m).
     * @param oldC         previous body-to-NED coordinate transformation.
     * @param oldVn        previous velocity north-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param oldVe        previous velocity east-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param oldVd        previous velocity down-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @return estimated NED frame containing new body position, velocity and coordinate
     * transformation matrix.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-NED-frame coordinate transformation matrix are
     *                                                       invalid.
     */
    public static NEDFrame navigateNEDAndReturnNew(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L13724">13724</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L13784">13784</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public static NEDFrame navigateNEDAndReturnNew(final double timeInterval,
                                                   final double oldLatitude,
                                                   final double oldLongitude,
                                                   final double oldHeight,
                                                   final CoordinateTransformation oldC,
                                                   final double oldVn,
                                                   final double oldVe,
                                                   final double oldVd,
                                                   final double fx,
                                                   final double fy,
                                                   final double fz,
                                                   final AngularSpeed angularRateX,
                                                   final AngularSpeed angularRateY,
                                                   final AngularSpeed angularRateZ)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        final NEDFrame result = new NEDFrame();
        navigateNED(timeInterval, oldLatitude, oldLongitude, oldHeight, oldC,
                oldVn, oldVe, oldVd, fx, fy, fz,
                angularRateX, angularRateY, angularRateZ, result);
        return result;
    }

    /**
     * Runs precision local-navigation-frame inertial navigation equations.
     * NOTE: only the attitude update and specific force frame transformation
     * phases are precise.
     *
     * @param timeInterval time interval between epochs.
     * @param oldLatitude  previous latitude expressed in radians (rad).
     * @param oldLongitude previous longitude expressed in radians (rad).
     * @param oldHeight    previous height expressed in meters (m).
     * @param oldC         previous body-to-NED coordinate transformation.
     * @param oldVn        previous velocity north-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param oldVe        previous velocity east-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param oldVd        previous velocity down-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @return estimated NED frame containing new body position, velocity and coordinate
     * transformation matrix.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-NED-frame coordinate transformation matrix are
     *                                                       invalid.
     */
    public static NEDFrame navigateNEDAndReturnNew(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L14167">14167</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L14230">14230</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public static NEDFrame navigateNEDAndReturnNew(final double timeInterval,
                                                   final Angle oldLatitude,
                                                   final Angle oldLongitude,
                                                   final Distance oldHeight,
                                                   final CoordinateTransformation oldC,
                                                   final Speed oldSpeedN,
                                                   final Speed oldSpeedE,
                                                   final Speed oldSpeedD,
                                                   final double fx,
                                                   final double fy,
                                                   final double fz,
                                                   final double angularRateX,
                                                   final double angularRateY,
                                                   final double angularRateZ)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        final NEDFrame result = new NEDFrame();
        navigateNED(timeInterval, oldLatitude, oldLongitude, oldHeight,
                oldC, oldSpeedN, oldSpeedE, oldSpeedD, fx, fy, fz,
                angularRateX, angularRateY, angularRateZ, result);
        return result;
    }

    /**
     * Runs precision local-navigation-frame inertial navigation equations.
     * NOTE: only the attitude update and specific force frame transformation
     * phases are precise.
     *
     * @param timeInterval time interval between epochs.
     * @param oldLatitude  previous latitude angle.
     * @param oldLongitude previous longitude angle.
     * @param oldHeight    previous height.
     * @param oldC         previous body-to-NED coordinate transformation.
     * @param oldSpeedN    previous velocity north-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes.
     * @param oldSpeedE    previous velocity east-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes.
     * @param oldSpeedD    previous velocity down-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes.
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @return estimated NED frame containing new body position, velocity and coordinate
     * transformation matrix.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-NED-frame coordinate transformation matrix are
     *                                                       invalid.
     */
    public static NEDFrame navigateNEDAndReturnNew(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L14287">14287</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L14344">14344</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public static NEDFrame navigateNEDAndReturnNew(final double timeInterval,
                                                   final Angle oldLatitude,
                                                   final Angle oldLongitude,
                                                   final Distance oldHeight,
                                                   final CoordinateTransformation oldC,
                                                   final Speed oldSpeedN,
                                                   final Speed oldSpeedE,
                                                   final Speed oldSpeedD,
                                                   final Acceleration fx,
                                                   final Acceleration fy,
                                                   final Acceleration fz,
                                                   final AngularSpeed angularRateX,
                                                   final AngularSpeed angularRateY,
                                                   final AngularSpeed angularRateZ)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        final NEDFrame result = new NEDFrame();
        navigateNED(timeInterval, oldLatitude, oldLongitude, oldHeight,
                oldC, oldSpeedN, oldSpeedE, oldSpeedD, fx, fy, fz,
                angularRateX, angularRateY, angularRateZ, result);
        return result;
    }

    /**
     * Runs precision local-navigation-frame inertial navigation equations.
     * NOTE: only the attitude update and specific force frame transformation
     * phases are precise.
     *
     * @param timeInterval time interval between epochs.
     * @param oldLatitude  previous latitude angle.
     * @param oldLongitude previous longitude angle.
     * @param oldHeight    previous height.
     * @param oldC         previous body-to-NED coordinate transformation.
     * @param oldSpeedN    previous velocity north-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes.
     * @param oldSpeedE    previous velocity east-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes.
     * @param oldSpeedD    previous velocity down-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes.
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @return estimated NED frame containing new body position, velocity and coordinate
     * transformation matrix.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-NED-frame coordinate transformation matrix are
     *                                                       invalid.
     */
    public static NEDFrame navigateNEDAndReturnNew(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L14401">14401</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L14458">14458</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public static NEDFrame navigateNEDAndReturnNew(final double timeInterval,
                                                   final double oldLatitude,
                                                   final double oldLongitude,
                                                   final double oldHeight,
                                                   final CoordinateTransformation oldC,
                                                   final Speed oldSpeedN,
                                                   final Speed oldSpeedE,
                                                   final Speed oldSpeedD,
                                                   final Acceleration fx,
                                                   final Acceleration fy,
                                                   final Acceleration fz,
                                                   final AngularSpeed angularRateX,
                                                   final AngularSpeed angularRateY,
                                                   final AngularSpeed angularRateZ)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        final NEDFrame result = new NEDFrame();
        navigateNED(timeInterval, oldLatitude, oldLongitude, oldHeight, oldC,
                oldSpeedN, oldSpeedE, oldSpeedD, fx, fy, fz, angularRateX,
                angularRateY, angularRateZ, result);
        return result;
    }

    /**
     * Runs precision local-navigation-frame inertial navigation equations.
     * NOTE: only the attitude update and specific force frame transformation
     * phases are precise.
     *
     * @param timeInterval time interval between epochs.
     * @param oldLatitude  previous latitude expressed in radians (rad).
     * @param oldLongitude previous longitude expressed in radians (rad).
     * @param oldHeight    previous height expressed in meters (m).
     * @param oldC         previous body-to-NED coordinate transformation.
     * @param oldSpeedN    previous velocity north-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes.
     * @param oldSpeedE    previous velocity east-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes.
     * @param oldSpeedD    previous velocity down-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes.
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @return estimated NED frame containing new body position, velocity and coordinate
     * transformation matrix.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-NED-frame coordinate transformation matrix are
     *                                                       invalid.
     */
    public static NEDFrame navigateNEDAndReturnNew(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L14817">14817</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L14874">14874</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public static NEDFrame navigateNEDAndReturnNew(final double timeInterval,
                                                   final Angle oldLatitude,
                                                   final Angle oldLongitude,
                                                   final Distance oldHeight,
                                                   final CoordinateTransformation oldC,
                                                   final double oldVn,
                                                   final double oldVe,
                                                   final double oldVd,
                                                   final Acceleration fx,
                                                   final Acceleration fy,
                                                   final Acceleration fz,
                                                   final AngularSpeed angularRateX,
                                                   final AngularSpeed angularRateY,
                                                   final AngularSpeed angularRateZ)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        final NEDFrame result = new NEDFrame();
        navigateNED(timeInterval, oldLatitude, oldLongitude, oldHeight,
                oldC, oldVn, oldVe, oldVd, fx, fy, fz,
                angularRateX, angularRateY, angularRateZ, result);
        return result;
    }

    /**
     * Runs precision local-navigation-frame inertial navigation equations.
     * NOTE: only the attitude update and specific force frame transformation
     * phases are precise.
     *
     * @param timeInterval time interval between epochs.
     * @param oldLatitude  previous latitude angle.
     * @param oldLongitude previous longitude angle.
     * @param oldHeight    previous height.
     * @param oldC         previous body-to-NED coordinate transformation.
     * @param oldVn        previous velocity north-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param oldVe        previous velocity east-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param oldVd        previous velocity down-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @return estimated NED frame containing new body position, velocity and coordinate
     * transformation matrix.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-NED-frame coordinate transformation matrix are
     *                                                       invalid.
     */
    public static NEDFrame navigateNEDAndReturnNew(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L15037">15037</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L15094">15094</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public static NEDFrame navigateNEDAndReturnNew(final double timeInterval,
                                                   final double oldLatitude,
                                                   final double oldLongitude,
                                                   final double oldHeight,
                                                   final CoordinateTransformation oldC,
                                                   final double oldVn,
                                                   final double oldVe,
                                                   final double oldVd,
                                                   final Acceleration fx,
                                                   final Acceleration fy,
                                                   final Acceleration fz,
                                                   final AngularSpeed angularRateX,
                                                   final AngularSpeed angularRateY,
                                                   final AngularSpeed angularRateZ)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        final NEDFrame result = new NEDFrame();
        navigateNED(timeInterval, oldLatitude, oldLongitude, oldHeight, oldC,
                oldVn, oldVe, oldVd, fx, fy, fz, angularRateX, angularRateY, angularRateZ,
                result);
        return result;
    }

    /**
     * Runs precision local-navigation-frame inertial navigation equations.
     * NOTE: only the attitude update and specific force frame transformation
     * phases are precise.
     *
     * @param timeInterval time interval between epochs.
     * @param oldLatitude  previous latitude expressed in radians (rad).
     * @param oldLongitude previous longitude expressed in radians (rad).
     * @param oldHeight    previous height expressed in meters (m).
     * @param oldC         previous body-to-NED coordinate transformation.
     * @param oldVn        previous velocity north-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param oldVe        previous velocity east-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param oldVd        previous velocity down-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @return estimated NED frame containing new body position, velocity and coordinate
     * transformation matrix.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-NED-frame coordinate transformation matrix are
     *                                                       invalid.
     */
    public static NEDFrame navigateNEDAndReturnNew(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/lateration/LaterationSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/LaterationSolver.html#L223">223</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/lateration/RobustLaterationSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/RobustLaterationSolver.html#L738">738</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public abstract int getMinRequiredPositionsAndDistances();

    /**
     * Internally sets known positions and euclidean distances.
     * If any distance value is zero or negative, it will be fixed assuming an EPSILON value.
     * @param positions known positios of static nodes.
     * @param distances euclidean distances from static nodes to mobile node.
     * @throws IllegalArgumentException if either positions or distances are null, don't have the same length or their
     * length is smaller than required (2 points).
     */
    protected void internalSetPositionsAndDistances(P[] positions, double[] distances) {
        if(positions == null || distances == null) {
            throw new IllegalArgumentException();
        }

        if (positions.length &lt; getMinRequiredPositionsAndDistances()) {
            throw new IllegalArgumentException();
        }

        if (positions.length != distances.length) {
            throw new IllegalArgumentException();
        }

        mPositions = positions;
        mDistances = distances;

        //fix distances if needed
        for (int i = 0; i &lt; mDistances.length; i++) {
            if (mDistances[i] &lt; EPSILON) {
                mDistances[i] = EPSILON;
            }
        }
    }</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/PROMedSRobustRssiPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROMedSRobustRssiPositionEstimator3D.html#L361">361</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/PROSACRobustMixedPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROSACRobustMixedPositionEstimator3D.html#L357">357</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/PROSACRobustRangingAndRssiPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROSACRobustRangingAndRssiPositionEstimator3D.html#L361">361</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/PROSACRobustRangingPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROSACRobustRangingPositionEstimator3D.html#L357">357</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>            RobustRssiPositionEstimatorListener&lt;Point3D&gt; listener) {
        this(sources, fingerprint, listener);
        internalSetSourceQualityScores(sourceQualityScores);
        internalSetFingerprintReadingsQualityScores(fingerprintReadingQualityScores);
    }

    /**
     * Returns quality scores corresponding to each radio source.
     * The larger the score value the better the quality of the sample.
     *
     * @return quality scores corresponding to each radio source.
     */
    public double[] getSourceQualityScores() {
        return mSourceQualityScores;
    }

    /**
     * Sets quality scores corresponding to each radio source.
     * The larger the score value the better the quality of the radio source.
     *
     * @param sourceQualityScores quality scores corresponding to each radio source.
     * @throws LockedException          if this instance is locked.
     * @throws IllegalArgumentException if provided quality scores length is smaller
     *                                  than minimum required samples.
     */
    public void setSourceQualityScores(double[] sourceQualityScores)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetSourceQualityScores(sourceQualityScores);
    }

    /**
     * Gets quality scores corresponding to each reading within provided fingerprint.
     * The larger the score value the better the quality of the reading.
     * This implementation always returns null.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @return quality scores corresponding to each reading within provided
     * fingerprint.
     */
    public double[] getFingerprintReadingsQualityScores() {
        return mFingerprintReadingsQualityScores;
    }

    /**
     * Sets quality scores corresponding to each reading within provided fingerprint.
     * The larger the score value the better the quality of the reading.
     * This implementation makes no action.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @param fingerprintReadingsQualityScores quality scores corresponding to each
     *                                         reading within provided fingerprint.
     * @throws LockedException          if this instance is locked.
     * @throws IllegalArgumentException if provided quality scores length is smaller
     *                                  than minimum required samples.
     */
    public void setFingerprintReadingsQualityScores(
            double[] fingerprintReadingsQualityScores) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetFingerprintReadingsQualityScores(fingerprintReadingsQualityScores);
    }

    /**
     * Returns threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value, the
     * algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algrithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @return stop threshold to stop the algorithm prematurely when a certain
     * accuracy has been reached.
     */
    public double getStopThreshold() {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/LMedSRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/LMedSRobustRangingRadioSourceEstimator2D.html#L174">174</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/LMedSRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/LMedSRobustRangingRadioSourceEstimator3D.html#L174">174</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>            RobustRangingRadioSourceEstimatorListener&lt;S, Point2D&gt; listener) {
        super(readings, initialPosition, listener);
    }

    /**
     * Returns threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value, the
     * algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algrithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @return stop threshold to stop the algorithm prematurely when a certain
     * accuracy has been reached.
     */
    public double getStopThreshold() {
        return mStopThreshold;
    }

    /**
     * Sets threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value,
     * the algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algorithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @param stopThreshold stop threshold to stop the algorithm prematurely
     *                      when a certain accuracy has been reached.
     * @throws IllegalArgumentException if provided value is zero or negative.
     * @throws LockedException if this solver is locked.
     */
    public void setStopThreshold(double stopThreshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (stopThreshold &lt;= MIN_STOP_THRESHOLD) {
            throw new IllegalArgumentException();
        }

        mStopThreshold = stopThreshold;
    }

    /**
     * Robustly estimates position for a radio source.
     *
     * @throws LockedException if instance is busy during estimation.
     * @throws NotReadyException if estimator is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     * (i.e. numerical instability, no solution available, etc).
     */
    @Override
    public void estimate() throws LockedException, NotReadyException,
            RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        LMedSRobustEstimator&lt;Solution&lt;Point2D&gt;&gt; innerEstimator =</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRangingAndRssiRadioSourceEstimator2D.html#L426">426</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRssiRadioSourceEstimator2D.html#L437">437</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator2D.html#L992">992</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator2D.html#L482">482</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator2D.html#L997">997</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator2D.html#L503">503</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator2D.html#L275">275</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator2D.html#L514">514</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                    @Override
                    public double getThreshold() {
                        return mThreshold;
                    }

                    @Override
                    public int getTotalSamples() {
                        return mReadings.size();
                    }

                    @Override
                    public int getSubsetSize() {
                        return Math.max(mPreliminarySubsetSize, getMinReadings());
                    }

                    @Override
                    public void estimatePreliminarSolutions(int[] samplesIndices,
                            List&lt;Solution&lt;Point2D&gt;&gt; solutions) {
                        solvePreliminarSolutions(samplesIndices, solutions);
                    }

                    @Override
                    public double computeResidual(Solution&lt;Point2D&gt; currentEstimation, int i) {
                        return residual(currentEstimation, i);
                    }

                    @Override
                    public boolean isReady() {
                        return MSACRobustRangingAndRssiRadioSourceEstimator2D.this.isReady();</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRangingAndRssiRadioSourceEstimator3D.html#L426">426</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRssiRadioSourceEstimator3D.html#L437">437</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator3D.html#L992">992</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator3D.html#L482">482</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator3D.html#L996">996</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator3D.html#L503">503</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator3D.html#L275">275</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator3D.html#L513">513</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                            @Override
                            public double getThreshold() {
                                return mThreshold;
                            }

                            @Override
                            public int getTotalSamples() {
                                return mReadings.size();
                            }

                            @Override
                            public int getSubsetSize() {
                                return Math.max(mPreliminarySubsetSize, getMinReadings());
                            }

                            @Override
                            public void estimatePreliminarSolutions(int[] samplesIndices,
                                                                    List&lt;Solution&lt;Point3D&gt;&gt; solutions) {
                                solvePreliminarSolutions(samplesIndices, solutions);
                            }

                            @Override
                            public double computeResidual(Solution&lt;Point3D&gt; currentEstimation, int i) {
                                return residual(currentEstimation, i);
                            }

                            @Override
                            public boolean isReady() {
                                return MSACRobustRangingAndRssiRadioSourceEstimator3D.this.isReady();</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRangingRadioSourceEstimator2D.html#L150">150</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRangingRadioSourceEstimator3D.html#L150">150</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>            RobustRangingRadioSourceEstimatorListener&lt;S, Point2D&gt; listener) {
        super(readings, initialPosition, listener);
    }

    /**
     * Returns threshold to determine whether samples are inliers or not.
     *
     * @return threshold to determine whether samples are inliers or not.
     */
    public double getThreshold() {
        return mThreshold;
    }

    /**
     * Sets threshold to determine whether samples are inliers or not.
     *
     * @param threshold threshold to be set.
     * @throws IllegalArgumentException if provided value is equal or less than
     * zero.
     * @throws LockedException if robust estimator is locked because an
     * estimation is already in progress.
     */
    public void setThreshold(double threshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (threshold &lt;= MIN_THRESHOLD) {
            throw new IllegalArgumentException();
        }
        mThreshold = threshold;
    }

    /**
     * Robustly estimates position for a radio source.
     *
     * @throws LockedException if instance is busy during estimation.
     * @throws NotReadyException if estimator is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     * (i.e. numerical instability, no solution available, etc).
     */
    @Override
    public void estimate() throws LockedException, NotReadyException,
            RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        MSACRobustEstimator&lt;Solution&lt;Point2D&gt;&gt; innerEstimator =</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L5240">5240</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L5374">5374</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                                    final double fz,
                                    final double angularRateX,
                                    final double angularRateY,
                                    final double angularRateZ,
                                    final ECEFFrame result)
            throws InertialNavigatorException {
        try {
            navigateECEF(timeInterval, oldFrame.getX(), oldFrame.getY(), oldFrame.getZ(),
                    oldFrame.getCoordinateTransformation(),
                    oldFrame.getVx(), oldFrame.getVy(), oldFrame.getVz(), fx, fy, fz,
                    angularRateX, angularRateY, angularRateZ, result);
        } catch (final InvalidSourceAndDestinationFrameTypeException ignore) {
            // never happens
        }
    }

    /**
     * Runs precision ECEF-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldFrame     previous ECEF frame containing body position, velocity and
     *                     coordinate transformation matrix.
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param result       instance where new estimated ECEF frame containing new body
     *                     position, velocity and coordinate transformation matrix will be stored.
     * @throws InertialNavigatorException if navigation fails due to numerical instabilities.
     */
    public static void navigateECEF(final Time timeInterval,
                                    final ECEFFrame oldFrame,
                                    final double fx,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L5243">5243</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L5461">5461</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                                    final double angularRateZ,
                                    final ECEFFrame result)
            throws InertialNavigatorException {
        try {
            navigateECEF(timeInterval, oldFrame.getX(), oldFrame.getY(), oldFrame.getZ(),
                    oldFrame.getCoordinateTransformation(),
                    oldFrame.getVx(), oldFrame.getVy(), oldFrame.getVz(), fx, fy, fz,
                    angularRateX, angularRateY, angularRateZ, result);
        } catch (final InvalidSourceAndDestinationFrameTypeException ignore) {
            // never happens
        }
    }

    /**
     * Runs precision ECEF-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldFrame     previous ECEF frame containing body position, velocity and
     *                     coordinate transformation matrix.
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param result       instance where new estimated ECEF frame containing new body
     *                     position, velocity and coordinate transformation matrix will be stored.
     * @throws InertialNavigatorException if navigation fails due to numerical instabilities.
     */
    public static void navigateECEF(final Time timeInterval,
                                    final ECEFFrame oldFrame,
                                    final double fx,
                                    final double fy,
                                    final double fz,
                                    final double angularRateX,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L5377">5377</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L5542">5542</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                                    final double angularRateZ,
                                    final ECEFFrame result)
            throws InertialNavigatorException {
        try {
            navigateECEF(timeInterval, oldFrame.getX(), oldFrame.getY(), oldFrame.getZ(),
                    oldFrame.getCoordinateTransformation(),
                    oldFrame.getVx(), oldFrame.getVy(), oldFrame.getVz(), fx, fy, fz,
                    angularRateX, angularRateY, angularRateZ, result);
        } catch (final InvalidSourceAndDestinationFrameTypeException ignore) {
            // never happens
        }
    }

    /**
     * Runs precision ECEF-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldFrame     previous ECEF frame containing body position, velocity and
     *                     coordinate transformation matrix.
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param result       instance where new estimated ECEF frame containing new body
     *                     position, velocity and coordinate transformation matrix will be stored.
     * @throws InertialNavigatorException if navigation fails due to numerical instabilities.
     */
    public static void navigateECEF(final Time timeInterval,
                                    final ECEFFrame oldFrame,
                                    final Acceleration fx,
                                    final Acceleration fy,
                                    final Acceleration fz,
                                    final double angularRateX,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L5458">5458</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L5539">5539</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                                    final double fz,
                                    final AngularSpeed angularRateX,
                                    final AngularSpeed angularRateY,
                                    final AngularSpeed angularRateZ,
                                    final ECEFFrame result)
            throws InertialNavigatorException {
        try {
            navigateECEF(timeInterval, oldFrame.getX(), oldFrame.getY(), oldFrame.getZ(),
                    oldFrame.getCoordinateTransformation(),
                    oldFrame.getVx(), oldFrame.getVy(), oldFrame.getVz(), fx, fy, fz,
                    angularRateX, angularRateY, angularRateZ, result);
        } catch (final InvalidSourceAndDestinationFrameTypeException ignore) {
            // never happens
        }
    }

    /**
     * Runs precision ECEF-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldFrame     previous ECEF frame containing body position, velocity and
     *                     coordinate transformation matrix.
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param result       instance where new estimated ECEF frame containing new body
     *                     position, velocity and coordinate transformation matrix will be stored.
     * @throws InertialNavigatorException if navigation fails due to numerical instabilities.
     */
    public static void navigateECEF(final Time timeInterval,
                                    final ECEFFrame oldFrame,
                                    final double fx,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L5275">5275</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L5409">5409</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                                   final double fz,
                                   final double angularRateX,
                                   final double angularRateY,
                                   final double angularRateZ,
                                   final ECIFrame result)
            throws InertialNavigatorException {
        try {
            navigateECI(timeInterval, oldFrame.getX(), oldFrame.getY(), oldFrame.getZ(),
                    oldFrame.getCoordinateTransformation(),
                    oldFrame.getVx(), oldFrame.getVy(), oldFrame.getVz(), fx, fy, fz,
                    angularRateX, angularRateY, angularRateZ, result);
        } catch (final InvalidSourceAndDestinationFrameTypeException ignore) {
            // never happens
        }
    }

    /**
     * Runs precision ECI-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldFrame     previous ECI frame containing body position, velocity and
     *                     coordinate transformation matrix.
     * @param fx           specific force x-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param result       instance where new estimated ECI frame containing new body position,
     *                     velocity and coordinate transformation matrix will be stored.
     * @throws InertialNavigatorException if navigation fails due to numerical instabilities.
     */
    public static void navigateECI(final Time timeInterval,
                                   final ECIFrame oldFrame,
                                   final double fx,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L5278">5278</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L5496">5496</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                                   final double angularRateZ,
                                   final ECIFrame result)
            throws InertialNavigatorException {
        try {
            navigateECI(timeInterval, oldFrame.getX(), oldFrame.getY(), oldFrame.getZ(),
                    oldFrame.getCoordinateTransformation(),
                    oldFrame.getVx(), oldFrame.getVy(), oldFrame.getVz(), fx, fy, fz,
                    angularRateX, angularRateY, angularRateZ, result);
        } catch (final InvalidSourceAndDestinationFrameTypeException ignore) {
            // never happens
        }
    }

    /**
     * Runs precision ECI-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldFrame     previous ECI frame containing body position, velocity and
     *                     coordinate transformation matrix.
     * @param fx           specific force x-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param result       instance where new estimated ECI frame containing new body position,
     *                     velocity and coordinate transformation matrix will be stored.
     * @throws InertialNavigatorException if navigation fails due to numerical instabilities.
     */
    public static void navigateECI(final Time timeInterval,
                                   final ECIFrame oldFrame,
                                   final double fx,
                                   final double fy,
                                   final double fz,
                                   final double angularRateX,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L5412">5412</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L5577">5577</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                                   final double angularRateZ,
                                   final ECIFrame result)
            throws InertialNavigatorException {
        try {
            navigateECI(timeInterval, oldFrame.getX(), oldFrame.getY(), oldFrame.getZ(),
                    oldFrame.getCoordinateTransformation(),
                    oldFrame.getVx(), oldFrame.getVy(), oldFrame.getVz(), fx, fy, fz,
                    angularRateX, angularRateY, angularRateZ, result);
        } catch (final InvalidSourceAndDestinationFrameTypeException ignore) {
            // never happens
        }
    }

    /**
     * Runs precision ECI-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldFrame     previous ECI frame containing body position, velocity and
     *                     coordinate transformation matrix.
     * @param fx           specific force x-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fy           specific force y-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fz           specific force z-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateX angular rate x-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param result       instance where new estimated ECI frame containing new body position,
     *                     velocity and coordinate transformation matrix will be stored.
     * @throws InertialNavigatorException if navigation fails due to numerical instabilities.
     */
    public static void navigateECI(final Time timeInterval,
                                   final ECIFrame oldFrame,
                                   final Acceleration fx,
                                   final Acceleration fy,
                                   final Acceleration fz,
                                   final double angularRateX,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L5493">5493</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L5574">5574</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                                   final double fz,
                                   final AngularSpeed angularRateX,
                                   final AngularSpeed angularRateY,
                                   final AngularSpeed angularRateZ,
                                   final ECIFrame result)
            throws InertialNavigatorException {
        try {
            navigateECI(timeInterval, oldFrame.getX(), oldFrame.getY(), oldFrame.getZ(),
                    oldFrame.getCoordinateTransformation(),
                    oldFrame.getVx(), oldFrame.getVy(), oldFrame.getVz(), fx, fy, fz,
                    angularRateX, angularRateY, angularRateZ, result);
        } catch (final InvalidSourceAndDestinationFrameTypeException ignore) {
            // never happens
        }
    }

    /**
     * Runs precision ECI-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldFrame     previous ECI frame containing body position, velocity and
     *                     coordinate transformation matrix.
     * @param fx           specific force x-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateY angular rate y-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param result       instance where new estimated ECI frame containing new body position,
     *                     velocity and coordinate transformation matrix will be stored.
     * @throws InertialNavigatorException if navigation fails due to numerical instabilities.
     */
    public static void navigateECI(final Time timeInterval,
                                   final ECIFrame oldFrame,
                                   final double fx,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L11320">11320</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L11462">11462</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                                   final double fz,
                                   final double angularRateX,
                                   final double angularRateY,
                                   final double angularRateZ,
                                   final NEDFrame result)
            throws InertialNavigatorException {
        try {
            navigateNED(timeInterval, oldFrame.getLatitude(), oldFrame.getLongitude(),
                    oldFrame.getHeight(), oldFrame.getCoordinateTransformation(),
                    oldFrame.getVn(), oldFrame.getVe(), oldFrame.getVd(),
                    fx, fy, fz, angularRateX, angularRateY, angularRateZ, result);
        } catch (final InvalidSourceAndDestinationFrameTypeException ignore) {
            // never happens
        }
    }

    /**
     * Runs precision local-navigation-frame inertial navigation equations.
     * NOTE: only the attitude update and specific force frame transformation
     * phases are precise.
     *
     * @param timeInterval time interval between epochs.
     * @param oldFrame     previous NED frame containing body position, velocity and
     *                     coordinate transformation matrix.
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param result       instance where new estimated NED frame containing new body position,
     *                     velocity and coordinate transformation matrix will be stored.
     * @throws InertialNavigatorException if navigation fails due to numerical instabilities.
     */
    public static void navigateNED(final Time timeInterval,
                                   final NEDFrame oldFrame,
                                   final double fx,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L11323">11323</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L11553">11553</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                                   final double angularRateZ,
                                   final NEDFrame result)
            throws InertialNavigatorException {
        try {
            navigateNED(timeInterval, oldFrame.getLatitude(), oldFrame.getLongitude(),
                    oldFrame.getHeight(), oldFrame.getCoordinateTransformation(),
                    oldFrame.getVn(), oldFrame.getVe(), oldFrame.getVd(),
                    fx, fy, fz, angularRateX, angularRateY, angularRateZ, result);
        } catch (final InvalidSourceAndDestinationFrameTypeException ignore) {
            // never happens
        }
    }

    /**
     * Runs precision local-navigation-frame inertial navigation equations.
     * NOTE: only the attitude update and specific force frame transformation
     * phases are precise.
     *
     * @param timeInterval time interval between epochs.
     * @param oldFrame     previous NED frame containing body position, velocity and
     *                     coordinate transformation matrix.
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param result       instance where new estimated NED frame containing new body position,
     *                     velocity and coordinate transformation matrix will be stored.
     * @throws InertialNavigatorException if navigation fails due to numerical instabilities.
     */
    public static void navigateNED(final Time timeInterval,
                                   final NEDFrame oldFrame,
                                   final double fx,
                                   final double fy,
                                   final double fz,
                                   final double angularRateX,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L3969">3969</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L4024">4024</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public static void navigateECEF(final double timeInterval,
                                    final Point3D oldPosition,
                                    final CoordinateTransformation oldC,
                                    final double oldVx,
                                    final double oldVy,
                                    final double oldVz,
                                    final double fx,
                                    final double fy,
                                    final double fz,
                                    final double angularRateX,
                                    final double angularRateY,
                                    final double angularRateZ,
                                    final ECEFFrame result)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        navigateECEF(timeInterval, oldPosition.getInhomX(), oldPosition.getInhomY(), oldPosition.getInhomZ(),
                oldC, oldVx, oldVy, oldVz, fx, fy, fz, angularRateX, angularRateY, angularRateZ, result);
    }

    /**
     * Runs precision ECEF-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldPosition  previous cartesian position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldC         previous body-to-ECEF-frame coordinate transformation.
     * @param oldVx        previous velocity x-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param oldVy        previous velocity y-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param oldVz        previous velocity z-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param result       instance where new estimated ECEF frame containing new body
     *                     position, velocity and coordinate transformation matrix will be stored.
     * @throws InertialNavigatorException if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     * body-to-ECEF-frame coordinate transformation matrix are invalid.
     */
    public static void navigateECEF(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L4262">4262</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L4304">4304</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public static void navigateECEF(final double timeInterval,
                                    final Distance oldX,
                                    final Distance oldY,
                                    final Distance oldZ,
                                    final CoordinateTransformation oldC,
                                    final double oldVx,
                                    final double oldVy,
                                    final double oldVz,
                                    final BodyKinematics kinematics,
                                    final ECEFFrame result)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        navigateECEF(timeInterval, oldX, oldY, oldZ, oldC, oldVx, oldVy, oldVz,
                kinematics.getFx(), kinematics.getFy(), kinematics.getFz(),
                kinematics.getAngularRateX(), kinematics.getAngularRateY(),
                kinematics.getAngularRateZ(), result);
    }

    /**
     * Runs precision ECEF-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldX         previous cartesian x-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldY         previous cartesian y-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldZ         previous cartesian z-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldC         previous body-to-ECEF-frame coordinate transformation.
     * @param oldVx        previous velocity x-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param oldVy        previous velocity y-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param oldVz        previous velocity z-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param kinematics   body kinematics containing specific forces and angular rates applied to
     *                     the body.
     * @param result       instance where new estimated ECEF frame containing new body
     *                     position, velocity and coordinate transformation matrix will be stored.
     * @throws InertialNavigatorException if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     * body-to-ECEF-frame coordinate transformation matrix are invalid.
     */
    public static void navigateECEF(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L3995">3995</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L4051">4051</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public static void navigateECI(final double timeInterval,
                                   final Point3D oldPosition,
                                   final CoordinateTransformation oldC,
                                   final double oldVx,
                                   final double oldVy,
                                   final double oldVz,
                                   final double fx,
                                   final double fy,
                                   final double fz,
                                   final double angularRateX,
                                   final double angularRateY,
                                   final double angularRateZ,
                                   final ECIFrame result)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        navigateECI(timeInterval, oldPosition.getInhomX(), oldPosition.getInhomY(), oldPosition.getInhomZ(),
                oldC, oldVx, oldVy, oldVz, fx, fy, fz, angularRateX, angularRateY, angularRateZ, result);
    }

    /**
     * Runs precision ECI-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldPosition  previous cartesian position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldC         previous body-to-ECI-frame coordinate transformation.
     * @param oldVx        previous velocity x-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param oldVy        previous velocity y-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param oldVz        previous velocity z-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param fx           specific force x-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param result       instance where new estimated ECI frame containing new body position,
     *                     velocity and coordinate transformation matrix will be stored.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-ECI-frame coordinate transformation matrix are
     *                                                       invalid.
     */
    public static void navigateECI(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L4292">4292</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L4335">4335</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public static void navigateECI(final double timeInterval,
                                   final Distance oldX,
                                   final Distance oldY,
                                   final Distance oldZ,
                                   final CoordinateTransformation oldC,
                                   final double oldVx,
                                   final double oldVy,
                                   final double oldVz,
                                   final BodyKinematics kinematics,
                                   final ECIFrame result)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        navigateECI(timeInterval, oldX, oldY, oldZ, oldC, oldVx, oldVy, oldVz,
                kinematics.getFx(), kinematics.getFy(), kinematics.getFz(),
                kinematics.getAngularRateX(), kinematics.getAngularRateY(),
                kinematics.getAngularRateZ(), result);
    }

    /**
     * Runs precision ECI-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldX         previous cartesian x-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes.
     * @param oldY         previous cartesian y-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes.
     * @param oldZ         previous cartesian z-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes.
     * @param oldC         previous body-to-ECI-frame coordinate transformation.
     * @param oldVx        previous velocity x-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param oldVy        previous velocity y-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param oldVz        previous velocity z-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param kinematics   body kinematics containing specific forces and angular rates applied to
     *                     the body.
     * @param result       instance where new estimated ECI frame containing new body position,
     *                     velocity and coordinate transformation matrix will be stored.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-ECI-frame coordinate transformation matrix are
     *                                                       invalid.
     */
    public static void navigateECI(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/lateration/HomogeneousLinearLeastSquaresLateration2DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/HomogeneousLinearLeastSquaresLateration2DSolver.html#L154">154</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/lateration/InhomogeneousLinearLeastSquaresLateration2DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/InhomogeneousLinearLeastSquaresLateration2DSolver.html#L154">154</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/lateration/RobustLateration2DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/RobustLateration2DSolver.html#L1346">1346</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    }

    /**
     * Internally sets circles defining positions and euclidean distances.
     * @param circles circles defining positions and distances.
     * @throws IllegalArgumentException if circles is null or length of array of circles
     * is less than 3.
     */
    private void internalSetCircles(Circle[] circles) {
        if (circles == null || circles.length &lt; getMinRequiredPositionsAndDistances()) {
            throw new IllegalArgumentException();
        }

        Point2D[] positions = new Point2D[circles.length];
        double[] distances = new double[circles.length];
        for (int i = 0; i &lt; circles.length; i++) {
            Circle circle = circles[i];
            positions[i] = circle.getCenter();
            distances[i] = circle.getRadius();
        }

        internalSetPositionsAndDistances(positions, distances);
    }</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/lateration/HomogeneousLinearLeastSquaresLateration3DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/HomogeneousLinearLeastSquaresLateration3DSolver.html#L154">154</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/lateration/InhomogeneousLinearLeastSquaresLateration3DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/InhomogeneousLinearLeastSquaresLateration3DSolver.html#L154">154</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/lateration/RobustLateration3DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/RobustLateration3DSolver.html#L1345">1345</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    }

    /**
     * Internally sets spheres defining positions and euclidean distances.
     * @param spheres spheres defining positions and distances.
     * @throws IllegalArgumentException if spheres is null or length of array of spheres
     * is less than 4.
     */
    private void internalSetSpheres(Sphere[] spheres) {
        if (spheres == null || spheres.length &lt; getMinRequiredPositionsAndDistances()) {
            throw new IllegalArgumentException();
        }

        Point3D[] positions = new Point3D[spheres.length];
        double[] distances = new double[spheres.length];
        for (int i = 0; i &lt; spheres.length; i++) {
            Sphere sphere = spheres[i];
            positions[i] = sphere.getCenter();
            distances[i] = sphere.getRadius();
        }

        internalSetPositionsAndDistances(positions, distances);
    }</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/PROMedSRobustRssiPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROMedSRobustRssiPositionEstimator3D.html#L361">361</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/PROSACRobustMixedPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROSACRobustMixedPositionEstimator2D.html#L357">357</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/PROSACRobustRangingAndRssiPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROSACRobustRangingAndRssiPositionEstimator2D.html#L361">361</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/PROSACRobustRangingPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROSACRobustRangingPositionEstimator2D.html#L357">357</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/PROSACRobustRssiPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROSACRobustRssiPositionEstimator2D.html#L359">359</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>            RobustRssiPositionEstimatorListener&lt;Point3D&gt; listener) {
        this(sources, fingerprint, listener);
        internalSetSourceQualityScores(sourceQualityScores);
        internalSetFingerprintReadingsQualityScores(fingerprintReadingQualityScores);
    }

    /**
     * Returns quality scores corresponding to each radio source.
     * The larger the score value the better the quality of the sample.
     *
     * @return quality scores corresponding to each radio source.
     */
    public double[] getSourceQualityScores() {
        return mSourceQualityScores;
    }

    /**
     * Sets quality scores corresponding to each radio source.
     * The larger the score value the better the quality of the radio source.
     *
     * @param sourceQualityScores quality scores corresponding to each radio source.
     * @throws LockedException          if this instance is locked.
     * @throws IllegalArgumentException if provided quality scores length is smaller
     *                                  than minimum required samples.
     */
    public void setSourceQualityScores(double[] sourceQualityScores)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetSourceQualityScores(sourceQualityScores);
    }

    /**
     * Gets quality scores corresponding to each reading within provided fingerprint.
     * The larger the score value the better the quality of the reading.
     * This implementation always returns null.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @return quality scores corresponding to each reading within provided
     * fingerprint.
     */
    public double[] getFingerprintReadingsQualityScores() {
        return mFingerprintReadingsQualityScores;
    }

    /**
     * Sets quality scores corresponding to each reading within provided fingerprint.
     * The larger the score value the better the quality of the reading.
     * This implementation makes no action.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @param fingerprintReadingsQualityScores quality scores corresponding to each
     *                                         reading within provided fingerprint.
     * @throws LockedException          if this instance is locked.
     * @throws IllegalArgumentException if provided quality scores length is smaller
     *                                  than minimum required samples.
     */
    public void setFingerprintReadingsQualityScores(
            double[] fingerprintReadingsQualityScores) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetFingerprintReadingsQualityScores(fingerprintReadingsQualityScores);
    }

    /**
     * Returns threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value, the
     * algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algrithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @return stop threshold to stop the algorithm prematurely when a certain
     * accuracy has been reached.
     */
    public double getStopThreshold() {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator2D.html#L1092">1092</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator2D.html#L1900">1900</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>            List&lt;? extends RangingAndRssiReadingLocated&lt;S, Point2D&gt;&gt; readings,
            Point2D initialPosition, Double initialTransmittedPowerdBm,
            double initialPathLossExponent,
            RobustRangingAndRssiRadioSourceEstimatorListener&lt;S, Point2D&gt; listener,
            RobustEstimatorMethod method) {
        switch (method) {
            case RANSAC:
                return new RANSACRobustRangingAndRssiRadioSourceEstimator2D&lt;&gt;(
                        readings, initialPosition, initialTransmittedPowerdBm,
                        initialPathLossExponent, listener);
            case LMedS:
                return new LMedSRobustRangingAndRssiRadioSourceEstimator2D&lt;&gt;(
                        readings, initialPosition, initialTransmittedPowerdBm,
                        initialPathLossExponent, listener);
            case MSAC:
                return new MSACRobustRangingAndRssiRadioSourceEstimator2D&lt;&gt;(
                        readings, initialPosition, initialTransmittedPowerdBm,
                        initialPathLossExponent, listener);
            case PROSAC:
                return new PROSACRobustRangingAndRssiRadioSourceEstimator2D&lt;&gt;(</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator3D.html#L1092">1092</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator3D.html#L1900">1900</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>            List&lt;? extends RangingAndRssiReadingLocated&lt;S, Point3D&gt;&gt; readings,
            Point3D initialPosition, Double initialTransmittedPowerdBm,
            double initialPathLossExponent,
            RobustRangingAndRssiRadioSourceEstimatorListener&lt;S, Point3D&gt; listener,
            RobustEstimatorMethod method) {
        switch (method) {
            case RANSAC:
                return new RANSACRobustRangingAndRssiRadioSourceEstimator3D&lt;&gt;(
                        readings, initialPosition, initialTransmittedPowerdBm,
                        initialPathLossExponent, listener);
            case LMedS:
                return new LMedSRobustRangingAndRssiRadioSourceEstimator3D&lt;&gt;(
                        readings, initialPosition, initialTransmittedPowerdBm,
                        initialPathLossExponent, listener);
            case MSAC:
                return new MSACRobustRangingAndRssiRadioSourceEstimator3D&lt;&gt;(
                        readings, initialPosition, initialTransmittedPowerdBm,
                        initialPathLossExponent, listener);
            case PROSAC:
                return new PROSACRobustRangingAndRssiRadioSourceEstimator3D&lt;&gt;(</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator2D.html#L1095">1095</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator2D.html#L1903">1903</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>            List&lt;? extends RssiReadingLocated&lt;S, Point2D&gt;&gt; readings,
            Point2D initialPosition, Double initialTransmittedPowerdBm,
            double initialPathLossExponent,
            RobustRssiRadioSourceEstimatorListener&lt;S, Point2D&gt; listener,
            RobustEstimatorMethod method) {
        switch (method) {
            case RANSAC:
                return new RANSACRobustRssiRadioSourceEstimator2D&lt;&gt;(
                        readings, initialPosition, initialTransmittedPowerdBm,
                        initialPathLossExponent, listener);
            case LMedS:
                return new LMedSRobustRssiRadioSourceEstimator2D&lt;&gt;(
                        readings, initialPosition, initialTransmittedPowerdBm,
                        initialPathLossExponent, listener);
            case MSAC:
                return new MSACRobustRssiRadioSourceEstimator2D&lt;&gt;(
                        readings, initialPosition, initialTransmittedPowerdBm,
                        initialPathLossExponent, listener);
            case PROSAC:
                return new PROSACRobustRssiRadioSourceEstimator2D&lt;&gt;(</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator3D.html#L1095">1095</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator3D.html#L1903">1903</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>            List&lt;? extends RssiReadingLocated&lt;S, Point3D&gt;&gt; readings,
            Point3D initialPosition, Double initialTransmittedPowerdBm,
            double initialPathLossExponent,
            RobustRssiRadioSourceEstimatorListener&lt;S, Point3D&gt; listener,
            RobustEstimatorMethod method) {
        switch (method) {
            case RANSAC:
                return new RANSACRobustRssiRadioSourceEstimator3D&lt;&gt;(
                        readings, initialPosition, initialTransmittedPowerdBm,
                        initialPathLossExponent, listener);
            case LMedS:
                return new LMedSRobustRssiRadioSourceEstimator3D&lt;&gt;(
                        readings, initialPosition, initialTransmittedPowerdBm,
                        initialPathLossExponent, listener);
            case MSAC:
                return new MSACRobustRssiRadioSourceEstimator3D&lt;&gt;(
                        readings, initialPosition, initialTransmittedPowerdBm,
                        initialPathLossExponent, listener);
            case PROSAC:
                return new PROSACRobustRssiRadioSourceEstimator3D&lt;&gt;(</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/MixedRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MixedRadioSourceEstimator.html#L857">857</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RangingAndRssiRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RangingAndRssiRadioSourceEstimator.html#L803">803</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>        return areValidReadings(mReadings);
    }

    /**
     * Estimate position, transmitted power and path loss exponent.
     * @throws RadioSourceEstimationException if estimation fails.
     * @throws NotReadyException if estimator is not ready.
     * @throws LockedException if estimator is locked.
     */
    @Override
    public void estimate() throws RadioSourceEstimationException, NotReadyException,
            LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        try {
            mLocked = true;

            if (mListener != null) {
                mListener.onEstimateStart(this);
            }

            createInnerEstimatorsIfNeeded();

            List&lt;RangingReadingLocated&lt;S, P&gt;&gt; rangingReadings = new ArrayList&lt;&gt;();
            List&lt;RssiReadingLocated&lt;S, P&gt;&gt; rssiReadings = new ArrayList&lt;&gt;();
            for (ReadingLocated&lt;P&gt; reading : mReadings) {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/lateration/HomogeneousLinearLeastSquaresLateration3DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/HomogeneousLinearLeastSquaresLateration3DSolver.html#L162">162</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/lateration/InhomogeneousLinearLeastSquaresLateration3DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/InhomogeneousLinearLeastSquaresLateration3DSolver.html#L162">162</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/lateration/NonLinearLeastSquaresLateration3DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/NonLinearLeastSquaresLateration3DSolver.html#L359">359</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    private void internalSetSpheres(Sphere[] spheres) {
        if (spheres == null || spheres.length &lt; getMinRequiredPositionsAndDistances()) {
            throw new IllegalArgumentException();
        }

        Point3D[] positions = new Point3D[spheres.length];
        double[] distances = new double[spheres.length];
        for (int i = 0; i &lt; spheres.length; i++) {
            Sphere sphere = spheres[i];
            positions[i] = sphere.getCenter();
            distances[i] = sphere.getRadius();
        }

        internalSetPositionsAndDistances(positions, distances);
    }</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/NonLinearMixedPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/NonLinearMixedPositionEstimator2D.html#L324">324</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/NonLinearMixedPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/NonLinearMixedPositionEstimator3D.html#L327">327</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/NonLinearRangingAndRssiPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/NonLinearRangingAndRssiPositionEstimator2D.html#L323">323</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/NonLinearRangingAndRssiPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/NonLinearRangingAndRssiPositionEstimator3D.html#L327">327</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/NonLinearRangingPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/NonLinearRangingPositionEstimator2D.html#L324">324</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/NonLinearRangingPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/NonLinearRangingPositionEstimator3D.html#L324">324</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/NonLinearRssiPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/NonLinearRssiPositionEstimator2D.html#L325">325</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/NonLinearRssiPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/NonLinearRssiPositionEstimator3D.html#L326">326</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>        Point2D[] positionsArray = new InhomogeneousPoint2D[size];
        positionsArray = positions.toArray(positionsArray);

        double[] distancesArray = new double[size];
        double[] distanceStandardDeviationsArray = new double[size];
        for (int i = 0; i &lt; size; i++) {
            distancesArray[i] = distances.get(i);
            distanceStandardDeviationsArray[i] = distanceStandardDeviations.get(i);
        }

        try {
            mTrilaterationSolver.setPositionsDistancesAndStandardDeviations(
                    positionsArray, distancesArray, distanceStandardDeviationsArray);
        } catch (LockedException e) {
            throw new IllegalArgumentException(e);
        }
    }

    /**
     * Initializes lateration solver.
     */
    private void init() {
        mTrilaterationSolver = new NonLinearLeastSquaresLateration2DSolver(</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L3714">3714</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L7812">7812</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>            final Matrix skewAlpha = Utils.skewMatrix(alphaIbb);

            // Obtain coordinate transformation matrix from the new attitude to the old
            // using Rodrigues' formula, (5.73)
            final Matrix cNewOld = Matrix.identity(ROWS, ROWS);
            if (magAlpha &gt; ALPHA_THRESHOLD) {
                final double magAlpha2 = magAlpha * magAlpha;
                final double value1 = Math.sin(magAlpha) / magAlpha;
                final double value2 = (1.0 - Math.cos(magAlpha)) / magAlpha2;

                final Matrix tmp1 = skewAlpha.multiplyByScalarAndReturnNew(value1);
                final Matrix tmp2 = skewAlpha.multiplyByScalarAndReturnNew(value2);
                tmp2.multiply(skewAlpha);

                cNewOld.add(tmp1);
                cNewOld.add(tmp2);
            } else {
                cNewOld.add(skewAlpha);
            }</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/lateration/MSACRobustLateration2DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/MSACRobustLateration2DSolver.html#L221">221</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/lateration/PROSACRobustLateration2DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/PROSACRobustLateration2DSolver.html#L523">523</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/lateration/RANSACRobustLateration2DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/RANSACRobustLateration2DSolver.html#L291">291</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>                    @Override
                    public double getThreshold() {
                        return mThreshold;
                    }

                    @Override
                    public int getTotalSamples() {
                        return mDistances.length;
                    }

                    @Override
                    public int getSubsetSize() {
                        return mPreliminarySubsetSize;
                    }

                    @Override
                    public void estimatePreliminarSolutions(int[] samplesIndices, List&lt;Point2D&gt; solutions) {
                        solvePreliminarSolutions(samplesIndices, solutions);
                    }

                    @Override
                    public double computeResidual(Point2D currentEstimation, int i) {
                        return Math.abs(currentEstimation.distanceTo(mPositions[i]) - mDistances[i]);
                    }

                    @Override
                    public boolean isReady() {
                        return MSACRobustLateration2DSolver.this.isReady();</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/lateration/MSACRobustLateration3DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/MSACRobustLateration3DSolver.html#L221">221</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/lateration/PROSACRobustLateration3DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/PROSACRobustLateration3DSolver.html#L523">523</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/lateration/RANSACRobustLateration3DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/RANSACRobustLateration3DSolver.html#L291">291</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                @Override
                public double getThreshold() {
                    return mThreshold;
                }

                @Override
                public int getTotalSamples() {
                    return mDistances.length;
                }

                @Override
                public int getSubsetSize() {
                    return mPreliminarySubsetSize;
                }

                @Override
                public void estimatePreliminarSolutions(int[] samplesIndices, List&lt;Point3D&gt; solutions) {
                    solvePreliminarSolutions(samplesIndices, solutions);
                }

                @Override
                public double computeResidual(Point3D currentEstimation, int i) {
                    return Math.abs(currentEstimation.distanceTo(mPositions[i]) - mDistances[i]);
                }

                @Override
                public boolean isReady() {
                    return MSACRobustLateration3DSolver.this.isReady();</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/Utils.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/Utils.html#L450">450</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/Utils.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/Utils.html#L1146">1146</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                    jacobian.setElementAtIndex(0, derivativeFingerprintRssi);
                    jacobian.setElementAtIndex(1, derivativePathLossExponent);
                    jacobian.setElementAtIndex(2, derivativeX1);
                    jacobian.setElementAtIndex(3, derivativeY1);
                    jacobian.setElementAtIndex(4, derivativeXa);
                    jacobian.setElementAtIndex(5, derivativeYa);
                    jacobian.setElementAtIndex(6, derivativeXi);
                    jacobian.setElementAtIndex(7, derivativeYi);
                }

                @Override
                public int getNumberOfVariables() {
                    return 1;
                }
            }, mean, covariance);
        } catch (AlgebraException | StatisticsException e) {
            throw new IndoorException(e);
        }
    }

    /**
     * Propagates provided variances (fingerprint rssi variance, path-loss exponent variance,
     * fingerprint position covariance and radio source position covariance) into
     * rssi variance by considering the 3D 1st order Taylor expression of received power.
     * Notice that any unknown variance is assumed to be zero.
     * @param fingerprintRssi closest located fingerprint reading RSSI expressed in dBm's.
     * @param pathLossExponent path-loss exponent.
     * @param fingerprintPosition position of closest fingerprint.
     * @param radioSourcePosition radio source position associated to fingerprint reading.
     * @param estimatedPosition  position to be estimated. Usually this is equal to the
     *                           initial position used by a non linear algorithm.
     * @param fingerprintRssiVariance variance of fingerprint RSSI or null if unknown.
     * @param pathLossExponentVariance variance of path-loss exponent or null if unknown.
     * @param fingerprintPositionCovariance covariance of fingerprint position or null if
     *                                      unknown.
     * @param radioSourcePositionCovariance covariance of radio source position or null
     *                                      if unknown.
     * @param estimatedPositionCovariance  covariance of position to be estimated or null
     *                                     if unknown. (This is usually unknown).
     * @return a normal distribution containing expected received RSSI value and its variance.
     * @throws IndoorException if something fails.
     */
    public static MultivariateNormalDist propagateVariancesToRssiVarianceFirstOrderNonLinear3D(</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/MixedRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MixedRadioSourceEstimator.html#L980">980</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RangingAndRssiRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RangingAndRssiRadioSourceEstimator.html#L900">900</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                    Matrix rssiCov = mRssiInnerEstimator.getEstimatedCovariance();
                    if (mEstimatedPositionCovariance != null &amp;&amp; rssiCov != null) {
                        int dims = getNumberOfDimensions();
                        int n = dims;
                        if (mTransmittedPowerEstimationEnabled) {
                            n++;
                        }
                        if (mPathLossEstimationEnabled) {
                            n++;
                        }

                        int dimsMinus1 = dims - 1;
                        int nMinus1 = n - 1;
                        mEstimatedCovariance = new Matrix(n, n);
                        mEstimatedCovariance.setSubmatrix(0, 0,
                                dimsMinus1, dimsMinus1,
                                mEstimatedPositionCovariance);
                        mEstimatedCovariance.setSubmatrix(dims, dims,
                                nMinus1, nMinus1, rssiCov);
                    } else {
                        mEstimatedCovariance = null;
                    }
                }</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustMixedRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustMixedRadioSourceEstimator.html#L2118">2118</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator.html#L2021">2021</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                    Matrix rssiCov = mRssiEstimator.getCovariance();
                    if (mEstimatedPositionCovariance != null &amp;&amp; rssiCov != null) {
                        int dims = getNumberOfDimensions();
                        int n = dims;
                        if (mTransmittedPowerEstimationEnabled) {
                            n++;
                        }
                        if (mPathLossEstimationEnabled) {
                            n++;
                        }

                        int dimsMinus1 = dims - 1;
                        int nMinus1 = n - 1;
                        mCovariance = new Matrix(n, n);
                        mCovariance.setSubmatrix(0, 0,
                                dimsMinus1, dimsMinus1,
                                mEstimatedPositionCovariance);
                        mCovariance.setSubmatrix(dims, dims,
                                nMinus1, nMinus1, rssiCov);
                    } else {
                        mCovariance = null;
                    }
                }</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L99">99</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L160">160</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public void navigate(final double timeInterval,
                         final double oldX,
                         final double oldY,
                         final double oldZ,
                         final CoordinateTransformation oldC,
                         final double oldVx,
                         final double oldVy,
                         final double oldVz,
                         final double fx,
                         final double fy,
                         final double fz,
                         final double angularRateX,
                         final double angularRateY,
                         final double angularRateZ,
                         final ECEFFrame result) throws InertialNavigatorException,
            InvalidSourceAndDestinationFrameTypeException {
        navigateECEF(timeInterval, oldX, oldY, oldZ, oldC, oldVx, oldVy, oldVz,
                fx, fy, fz, angularRateX, angularRateY, angularRateZ, result);
    }

    /**
     * Runs precision ECEF-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldX         previous cartesian x-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldY         previous cartesian y-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldZ         previous cartesian z-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldC         previous body-to-ECEF-frame coordinate transformation.
     * @param oldVx        previous velocity x-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param oldVy        previous velocity y-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param oldVz        previous velocity z-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param result       instance where new estimated ECEF frame containing new body
     *                     position, velocity and coordinate transformation matrix will be stored.
     * @throws InertialNavigatorException if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     * body-to-ECEF-frame coordinate transformation matrix are invalid.
     */
    public void navigate(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L479">479</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L540">540</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public void navigate(final double timeInterval,
                         final Distance oldX,
                         final Distance oldY,
                         final Distance oldZ,
                         final CoordinateTransformation oldC,
                         final double oldVx,
                         final double oldVy,
                         final double oldVz,
                         final double fx,
                         final double fy,
                         final double fz,
                         final double angularRateX,
                         final double angularRateY,
                         final double angularRateZ,
                         final ECEFFrame result) throws InertialNavigatorException,
            InvalidSourceAndDestinationFrameTypeException {
        navigateECEF(timeInterval, oldX, oldY, oldZ, oldC, oldVx, oldVy, oldVz,
                fx, fy, fz, angularRateX, angularRateY, angularRateZ, result);
    }

    /**
     * Runs precision ECEF-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldX         previous cartesian x-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldY         previous cartesian y-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldZ         previous cartesian z-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldC         previous body-to-ECEF-frame coordinate transformation.
     * @param oldVx        previous velocity x-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param oldVy        previous velocity y-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param oldVz        previous velocity z-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param result       instance where new estimated ECEF frame containing new body
     *                     position, velocity and coordinate transformation matrix will be stored.
     * @throws InertialNavigatorException if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     * body-to-ECEF-frame coordinate transformation matrix are invalid.
     */
    public void navigate(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L681">681</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L743">743</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public void navigate(final double timeInterval,
                         final double oldX,
                         final double oldY,
                         final double oldZ,
                         final CoordinateTransformation oldC,
                         final Speed oldSpeedX,
                         final Speed oldSpeedY,
                         final Speed oldSpeedZ,
                         final double fx,
                         final double fy,
                         final double fz,
                         final double angularRateX,
                         final double angularRateY,
                         final double angularRateZ,
                         final ECEFFrame result) throws InertialNavigatorException,
            InvalidSourceAndDestinationFrameTypeException {
        navigateECEF(timeInterval, oldX, oldY, oldZ, oldC, oldSpeedX, oldSpeedY,
                oldSpeedZ, fx, fy, fz, angularRateX, angularRateY, angularRateZ,
                result);
    }

    /**
     * Runs precision ECEF-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldX         previous cartesian x-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldY         previous cartesian y-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldZ         previous cartesian z-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldC         previous body-to-ECEF-frame coordinate transformation.
     * @param oldSpeedX    previous velocity x-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param oldSpeedY    previous velocity y-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param oldSpeedZ    previous velocity z-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param result       instance where new estimated ECEF frame containing new body
     *                     position, velocity and coordinate transformation matrix will be stored.
     * @throws InertialNavigatorException if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     * body-to-ECEF-frame coordinate transformation matrix are invalid.
     */
    public void navigate(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L882">882</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L940">940</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public void navigate(final double timeInterval,
                         final double oldX,
                         final double oldY,
                         final double oldZ,
                         final CoordinateTransformation oldC,
                         final double oldVx,
                         final double oldVy,
                         final double oldVz,
                         final Acceleration fx,
                         final Acceleration fy,
                         final Acceleration fz,
                         final double angularRateX,
                         final double angularRateY,
                         final double angularRateZ,
                         final ECEFFrame result) throws InertialNavigatorException,
            InvalidSourceAndDestinationFrameTypeException {
        navigateECEF(timeInterval, oldX, oldY, oldZ, oldC, oldVx, oldVy, oldVz,
                fx, fy, fz, angularRateX, angularRateY, angularRateZ, result);
    }

    /**
     * Runs precision ECEF-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldX         previous cartesian x-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldY         previous cartesian y-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldZ         previous cartesian z-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldC         previous body-to-ECEF-frame coordinate transformation.
     * @param oldVx        previous velocity x-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param oldVy        previous velocity y-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param oldVz        previous velocity z-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param result       instance where new estimated ECEF frame containing new body
     *                     position, velocity and coordinate transformation matrix will be stored.
     * @throws InertialNavigatorException if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     * body-to-ECEF-frame coordinate transformation matrix are invalid.
     */
    public void navigate(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L998">998</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L1056">1056</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public void navigate(final double timeInterval,
                         final double oldX,
                         final double oldY,
                         final double oldZ,
                         final CoordinateTransformation oldC,
                         final double oldVx,
                         final double oldVy,
                         final double oldVz,
                         final double fx,
                         final double fy,
                         final double fz,
                         final AngularSpeed angularRateX,
                         final AngularSpeed angularRateY,
                         final AngularSpeed angularRateZ,
                         final ECEFFrame result) throws InertialNavigatorException,
            InvalidSourceAndDestinationFrameTypeException {
        navigateECEF(timeInterval, oldX, oldY, oldZ, oldC, oldVx, oldVy, oldVz,
                fx, fy, fz, angularRateX, angularRateY, angularRateZ, result);
    }

    /**
     * Runs precision ECEF-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldX         previous cartesian x-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldY         previous cartesian y-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldZ         previous cartesian z-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldC         previous body-to-ECEF-frame coordinate transformation.
     * @param oldVx        previous velocity x-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param oldVy        previous velocity y-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param oldVz        previous velocity z-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param result       instance where new estimated ECEF frame containing new body
     *                     position, velocity and coordinate transformation matrix will be stored.
     * @throws InertialNavigatorException if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     * body-to-ECEF-frame coordinate transformation matrix are invalid.
     */
    public void navigate(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L1117">1117</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L1179">1179</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public void navigate(final double timeInterval,
                         final Distance oldX,
                         final Distance oldY,
                         final Distance oldZ,
                         final CoordinateTransformation oldC,
                         final Speed oldSpeedX,
                         final Speed oldSpeedY,
                         final Speed oldSpeedZ,
                         final double fx,
                         final double fy,
                         final double fz,
                         final double angularRateX,
                         final double angularRateY,
                         final double angularRateZ,
                         final ECEFFrame result) throws InertialNavigatorException,
            InvalidSourceAndDestinationFrameTypeException {
        navigateECEF(timeInterval, oldX, oldY, oldZ, oldC, oldSpeedX, oldSpeedY,
                oldSpeedZ, fx, fy, fz, angularRateX, angularRateY, angularRateZ,
                result);
    }

    /**
     * Runs precision ECEF-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldX         previous cartesian x-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldY         previous cartesian y-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldZ         previous cartesian z-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldC         previous body-to-ECEF-frame coordinate transformation.
     * @param oldSpeedX    previous velocity x-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param oldSpeedY    previous velocity y-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param oldSpeedZ    previous velocity z-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param result       instance where new estimated ECEF frame containing new body
     *                     position, velocity and coordinate transformation matrix will be stored.
     * @throws InertialNavigatorException if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     * body-to-ECEF-frame coordinate transformation matrix are invalid.
     */
    public void navigate(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L1235">1235</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L1291">1291</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public void navigate(final double timeInterval,
                         final Distance oldX,
                         final Distance oldY,
                         final Distance oldZ,
                         final CoordinateTransformation oldC,
                         final Speed oldSpeedX,
                         final Speed oldSpeedY,
                         final Speed oldSpeedZ,
                         final Acceleration fx,
                         final Acceleration fy,
                         final Acceleration fz,
                         final AngularSpeed angularRateX,
                         final AngularSpeed angularRateY,
                         final AngularSpeed angularRateZ,
                         final ECEFFrame result) throws InertialNavigatorException,
            InvalidSourceAndDestinationFrameTypeException {
        navigateECEF(timeInterval, oldX, oldY, oldZ, oldC, oldSpeedX, oldSpeedY,
                oldSpeedZ, fx, fy, fz, angularRateX, angularRateY, angularRateZ,
                result);
    }

    /**
     * Runs precision ECEF-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldX         previous cartesian x-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldY         previous cartesian y-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldZ         previous cartesian z-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldC         previous body-to-ECEF-frame coordinate transformation.
     * @param oldSpeedX    previous velocity x-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param oldSpeedY    previous velocity y-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param oldSpeedZ    previous velocity z-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param result       instance where new estimated ECEF frame containing new body
     *                     position, velocity and coordinate transformation matrix will be stored.
     * @throws InertialNavigatorException if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     * body-to-ECEF-frame coordinate transformation matrix are invalid.
     */
    public void navigate(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L1347">1347</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L1402">1402</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public void navigate(final double timeInterval,
                         final double oldX,
                         final double oldY,
                         final double oldZ,
                         final CoordinateTransformation oldC,
                         final double oldVx,
                         final double oldVy,
                         final double oldVz,
                         final Acceleration fx,
                         final Acceleration fy,
                         final Acceleration fz,
                         final AngularSpeed angularRateX,
                         final AngularSpeed angularRateY,
                         final AngularSpeed angularRateZ,
                         final ECEFFrame result) throws InertialNavigatorException,
            InvalidSourceAndDestinationFrameTypeException {
        navigateECEF(timeInterval, oldX, oldY, oldZ, oldC, oldVx, oldVy, oldVz,
                fx, fy, fz, angularRateX, angularRateY, angularRateZ, result);
    }

    /**
     * Runs precision ECEF-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldX         previous cartesian x-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldY         previous cartesian y-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldZ         previous cartesian z-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldC         previous body-to-ECEF-frame coordinate transformation.
     * @param oldVx        previous velocity x-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param oldVy        previous velocity y-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param oldVz        previous velocity z-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param result       instance where new estimated ECEF frame containing new body
     *                     position, velocity and coordinate transformation matrix will be stored.
     * @throws InertialNavigatorException if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     * body-to-ECEF-frame coordinate transformation matrix are invalid.
     */
    public void navigate(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L91">91</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L153">153</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public void navigate(final double timeInterval,
                         final double oldX,
                         final double oldY,
                         final double oldZ,
                         final CoordinateTransformation oldC,
                         final double oldVx,
                         final double oldVy,
                         final double oldVz,
                         final double fx,
                         final double fy,
                         final double fz,
                         final double angularRateX,
                         final double angularRateY,
                         final double angularRateZ,
                         final ECIFrame result)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        navigateECI(timeInterval, oldX, oldY, oldZ, oldC, oldVx, oldVy, oldVz,
                fx, fy, fz, angularRateX, angularRateY, angularRateZ, result);
    }

    /**
     * Runs precision ECI-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldX         previous cartesian x-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldY         previous cartesian y-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldZ         previous cartesian z-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldC         previous body-to-ECI-frame coordinate transformation.
     * @param oldVx        previous velocity x-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param oldVy        previous velocity y-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param oldVz        previous velocity z-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param fx           specific force x-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param result       instance where new estimated ECI frame containing new body position,
     *                     velocity and coordinate transformation matrix will be stored.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-ECI-frame coordinate transformation matrix are
     *                                                       invalid.
     */
    public void navigate(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L478">478</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L539">539</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public void navigate(final double timeInterval,
                         final Distance oldX,
                         final Distance oldY,
                         final Distance oldZ,
                         final CoordinateTransformation oldC,
                         final double oldVx,
                         final double oldVy,
                         final double oldVz,
                         final double fx,
                         final double fy,
                         final double fz,
                         final double angularRateX,
                         final double angularRateY,
                         final double angularRateZ,
                         final ECIFrame result)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        navigateECI(timeInterval, oldX, oldY, oldZ, oldC, oldVx, oldVy, oldVz,
                fx, fy, fz, angularRateX, angularRateY, angularRateZ, result);
    }

    /**
     * Runs precision ECI-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldX         previous cartesian x-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes.
     * @param oldY         previous cartesian y-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes.
     * @param oldZ         previous cartesian z-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes.
     * @param oldC         previous body-to-ECI-frame coordinate transformation.
     * @param oldVx        previous velocity x-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param oldVy        previous velocity y-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param oldVz        previous velocity z-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param fx           specific force x-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param result       instance where new estimated ECI frame containing new body position,
     *                     velocity and coordinate transformation matrix will be stored.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-ECI-frame coordinate transformation matrix are invalid.
     */
    public void navigate(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L682">682</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L744">744</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public void navigate(final double timeInterval,
                         final double oldX,
                         final double oldY,
                         final double oldZ,
                         final CoordinateTransformation oldC,
                         final Speed oldSpeedX,
                         final Speed oldSpeedY,
                         final Speed oldSpeedZ,
                         final double fx,
                         final double fy,
                         final double fz,
                         final double angularRateX,
                         final double angularRateY,
                         final double angularRateZ,
                         final ECIFrame result)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        navigateECI(timeInterval, oldX, oldY, oldZ, oldC,
                oldSpeedX, oldSpeedY, oldSpeedZ, fx, fy, fz,
                angularRateX, angularRateY, angularRateZ, result);
    }

    /**
     * Runs precision ECI-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldX         previous cartesian x-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldY         previous cartesian y-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldZ         previous cartesian z-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldC         previous body-to-ECI-frame coordinate transformation.
     * @param oldSpeedX    previous velocity x-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes.
     * @param oldSpeedY    previous velocity y-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes.
     * @param oldSpeedZ    previous velocity z-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes.
     * @param fx           specific force x-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param result       instance where new estimated ECI frame containing new body position,
     *                     velocity and coordinate transformation matrix will be stored.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-ECI-frame coordinate transformation matrix are invalid.
     */
    public void navigate(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L885">885</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L943">943</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public void navigate(final double timeInterval,
                         final double oldX,
                         final double oldY,
                         final double oldZ,
                         final CoordinateTransformation oldC,
                         final double oldVx,
                         final double oldVy,
                         final double oldVz,
                         final Acceleration fx,
                         final Acceleration fy,
                         final Acceleration fz,
                         final double angularRateX,
                         final double angularRateY,
                         final double angularRateZ,
                         final ECIFrame result)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        navigateECI(timeInterval, oldX, oldY, oldZ, oldC, oldVx, oldVy, oldVz,
                fx, fy, fz, angularRateX, angularRateY, angularRateZ, result);
    }

    /**
     * Runs precision ECI-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldX         previous cartesian x-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldY         previous cartesian y-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldZ         previous cartesian z-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldC         previous body-to-ECI-frame coordinate transformation.
     * @param oldVx        previous velocity x-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param oldVy        previous velocity y-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param oldVz        previous velocity z-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param fx           specific force x-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fy           specific force y-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fz           specific force z-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateX angular rate x-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param result       instance where new estimated ECI frame containing new body position,
     *                     velocity and coordinate transformation matrix will be stored.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-ECI-frame coordinate transformation matrix are invalid.
     */
    public void navigate(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L1001">1001</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L1059">1059</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public void navigate(final double timeInterval,
                         final double oldX,
                         final double oldY,
                         final double oldZ,
                         final CoordinateTransformation oldC,
                         final double oldVx,
                         final double oldVy,
                         final double oldVz,
                         final double fx,
                         final double fy,
                         final double fz,
                         final AngularSpeed angularRateX,
                         final AngularSpeed angularRateY,
                         final AngularSpeed angularRateZ,
                         final ECIFrame result)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        navigateECI(timeInterval, oldX, oldY, oldZ, oldC, oldVx, oldVy, oldVz,
                fx, fy, fz, angularRateX, angularRateY, angularRateZ, result);
    }

    /**
     * Runs precision ECI-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldX         previous cartesian x-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldY         previous cartesian y-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldZ         previous cartesian z-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldC         previous body-to-ECI-frame coordinate transformation.
     * @param oldVx        previous velocity x-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param oldVy        previous velocity y-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param oldVz        previous velocity z-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param fx           specific force x-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateY angular rate y-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param result       instance where new estimated ECI frame containing new body position,
     *                     velocity and coordinate transformation matrix will be stored.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-ECI-frame coordinate transformation matrix are invalid.
     */
    public void navigate(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L1120">1120</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L1182">1182</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public void navigate(final double timeInterval,
                         final Distance oldX,
                         final Distance oldY,
                         final Distance oldZ,
                         final CoordinateTransformation oldC,
                         final Speed oldSpeedX,
                         final Speed oldSpeedY,
                         final Speed oldSpeedZ,
                         final double fx,
                         final double fy,
                         final double fz,
                         final double angularRateX,
                         final double angularRateY,
                         final double angularRateZ,
                         final ECIFrame result)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        navigateECI(timeInterval, oldX, oldY, oldZ, oldC,
                oldSpeedX, oldSpeedY, oldSpeedZ, fx, fy, fz,
                angularRateX, angularRateY, angularRateZ, result);
    }

    /**
     * Runs precision ECI-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldX         previous cartesian x-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes.
     * @param oldY         previous cartesian y-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes.
     * @param oldZ         previous cartesian z-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes.
     * @param oldC         previous body-to-ECI-frame coordinate transformation.
     * @param oldSpeedX    previous velocity x-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes.
     * @param oldSpeedY    previous velocity y-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes.
     * @param oldSpeedZ    previous velocity z-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes.
     * @param fx           specific force x-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param result       instance where new estimated ECI frame containing new body position,
     *                     velocity and coordinate transformation matrix will be stored.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-ECI-frame coordinate transformation matrix are invalid.
     */
    public void navigate(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L1238">1238</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L1294">1294</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public void navigate(final double timeInterval,
                         final Distance oldX,
                         final Distance oldY,
                         final Distance oldZ,
                         final CoordinateTransformation oldC,
                         final Speed oldSpeedX,
                         final Speed oldSpeedY,
                         final Speed oldSpeedZ,
                         final Acceleration fx,
                         final Acceleration fy,
                         final Acceleration fz,
                         final AngularSpeed angularRateX,
                         final AngularSpeed angularRateY,
                         final AngularSpeed angularRateZ,
                         final ECIFrame result)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        navigateECI(timeInterval, oldX, oldY, oldZ, oldC,
                oldSpeedX, oldSpeedY, oldSpeedZ, fx, fy, fz,
                angularRateX, angularRateY, angularRateZ, result);
    }

    /**
     * Runs precision ECI-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldX         previous cartesian x-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes.
     * @param oldY         previous cartesian y-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes.
     * @param oldZ         previous cartesian z-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes.
     * @param oldC         previous body-to-ECI-frame coordinate transformation.
     * @param oldSpeedX    previous velocity x-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes.
     * @param oldSpeedY    previous velocity y-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes.
     * @param oldSpeedZ    previous velocity z-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes.
     * @param fx           specific force x-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fy           specific force y-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fz           specific force z-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateX angular rate x-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateY angular rate y-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param result       instance where new estimated ECI frame containing new body position,
     *                     velocity and coordinate transformation matrix will be stored.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-ECI-frame coordinate transformation matrix are invalid.
     */
    public void navigate(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L1350">1350</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L1405">1405</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public void navigate(final double timeInterval,
                         final double oldX,
                         final double oldY,
                         final double oldZ,
                         final CoordinateTransformation oldC,
                         final double oldVx,
                         final double oldVy,
                         final double oldVz,
                         final Acceleration fx,
                         final Acceleration fy,
                         final Acceleration fz,
                         final AngularSpeed angularRateX,
                         final AngularSpeed angularRateY,
                         final AngularSpeed angularRateZ,
                         final ECIFrame result)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        navigateECI(timeInterval, oldX, oldY, oldZ, oldC, oldVx, oldVy, oldVz,
                fx, fy, fz, angularRateX, angularRateY, angularRateZ, result);
    }

    /**
     * Runs precision ECI-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldX         previous cartesian x-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldY         previous cartesian y-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldZ         previous cartesian z-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldC         previous body-to-ECI-frame coordinate transformation.
     * @param oldVx        previous velocity x-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param oldVy        previous velocity y-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param oldVz        previous velocity z-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param fx           specific force x-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fy           specific force y-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fz           specific force z-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateX angular rate x-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateY angular rate y-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param result       instance where new estimated ECI frame containing new body position,
     *                     velocity and coordinate transformation matrix will be stored.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-ECI-frame coordinate transformation matrix are invalid.
     */
    public void navigate(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L101">101</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L163">163</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public void navigate(final double timeInterval,
                         final double oldLatitude,
                         final double oldLongitude,
                         final double oldHeight,
                         final CoordinateTransformation oldC,
                         final double oldVn,
                         final double oldVe,
                         final double oldVd,
                         final double fx,
                         final double fy,
                         final double fz,
                         final double angularRateX,
                         final double angularRateY,
                         final double angularRateZ,
                         final NEDFrame result)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        navigateNED(timeInterval, oldLatitude, oldLongitude, oldHeight, oldC,
                oldVn, oldVe, oldVd, fx, fy, fz,
                angularRateX, angularRateY, angularRateZ, result);
    }

    /**
     * Runs precision local-navigation-frame inertial navigation equations.
     * NOTE: only the attitude update and specific force frame transformation
     * phases are precise.
     *
     * @param timeInterval time interval between epochs.
     * @param oldLatitude  previous latitude expressed in radians (rad).
     * @param oldLongitude previous longitude expressed in radians (rad).
     * @param oldHeight    previous height expressed in meters (m).
     * @param oldC         previous body-to-NED coordinate transformation.
     * @param oldVn        previous velocity north-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param oldVe        previous velocity east-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param oldVd        previous velocity down-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param result       instance where new estimated NED frame containing new body position,
     *                     velocity and coordinate transformation matrix will be stored.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-NED-frame coordinate transformation matrix are
     *                                                       invalid.
     */
    public void navigate(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L841">841</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L903">903</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public void navigate(final double timeInterval,
                         final Angle oldLatitude,
                         final Angle oldLongitude,
                         final Distance oldHeight,
                         final CoordinateTransformation oldC,
                         final double oldVn,
                         final double oldVe,
                         final double oldVd,
                         final double fx,
                         final double fy,
                         final double fz,
                         final double angularRateX,
                         final double angularRateY,
                         final double angularRateZ,
                         final NEDFrame result)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        navigateNED(timeInterval, oldLatitude, oldLongitude, oldHeight, oldC,
                oldVn, oldVe, oldVd, fx, fy, fz,
                angularRateX, angularRateY, angularRateZ, result);
    }

    /**
     * Runs precision local-navigation-frame inertial navigation equations.
     * NOTE: only the attitude update and specific force frame transformation
     * phases are precise.
     *
     * @param timeInterval time interval between epochs.
     * @param oldLatitude  previous latitude angle.
     * @param oldLongitude previous longitude angle.
     * @param oldHeight    previous height.
     * @param oldC         previous body-to-NED coordinate transformation.
     * @param oldVn        previous velocity north-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param oldVe        previous velocity east-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param oldVd        previous velocity down-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param result       instance where new estimated NED frame containing new body position,
     *                     velocity and coordinate transformation matrix will be stored.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-NED-frame coordinate transformation matrix are
     *                                                       invalid.
     */
    public void navigate(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L1225">1225</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L1287">1287</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public void navigate(final double timeInterval,
                         final double oldLatitude,
                         final double oldLongitude,
                         final double oldHeight,
                         final CoordinateTransformation oldC,
                         final Speed oldSpeedN,
                         final Speed oldSpeedE,
                         final Speed oldSpeedD,
                         final double fx,
                         final double fy,
                         final double fz,
                         final double angularRateX,
                         final double angularRateY,
                         final double angularRateZ,
                         final NEDFrame result)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        navigateNED(timeInterval, oldLatitude, oldLongitude, oldHeight, oldC,
                oldSpeedN, oldSpeedE, oldSpeedD, fx, fy, fz,
                angularRateX, angularRateY, angularRateZ, result);
    }

    /**
     * Runs precision local-navigation-frame inertial navigation equations.
     * NOTE: only the attitude update and specific force frame transformation
     * phases are precise.
     *
     * @param timeInterval time interval between epochs.
     * @param oldLatitude  previous latitude expressed in radians (rad).
     * @param oldLongitude previous longitude expressed in radians (rad).
     * @param oldHeight    previous height expressed in meters (m).
     * @param oldC         previous body-to-NED coordinate transformation.
     * @param oldSpeedN    previous velocity north-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes.
     * @param oldSpeedE    previous velocity east-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes.
     * @param oldSpeedD    previous velocity down-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes.
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param result       instance where new estimated NED frame containing new body position,
     *                     velocity and coordinate transformation matrix will be stored.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-NED-frame coordinate transformation matrix are
     *                                                       invalid.
     */
    public void navigate(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L1616">1616</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L1675">1675</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public void navigate(final double timeInterval,
                         final double oldLatitude,
                         final double oldLongitude,
                         final double oldHeight,
                         final CoordinateTransformation oldC,
                         final double oldVn,
                         final double oldVe,
                         final double oldVd,
                         final Acceleration fx,
                         final Acceleration fy,
                         final Acceleration fz,
                         final double angularRateX,
                         final double angularRateY,
                         final double angularRateZ,
                         final NEDFrame result)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        navigateNED(timeInterval, oldLatitude, oldLongitude, oldHeight, oldC,
                oldVn, oldVe, oldVd, fx, fy, fz,
                angularRateX, angularRateY, angularRateZ, result);
    }

    /**
     * Runs precision local-navigation-frame inertial navigation equations.
     * NOTE: only the attitude update and specific force frame transformation
     * phases are precise.
     *
     * @param timeInterval time interval between epochs.
     * @param oldLatitude  previous latitude expressed in radians (rad).
     * @param oldLongitude previous longitude expressed in radians (rad).
     * @param oldHeight    previous height expressed in meters (m).
     * @param oldC         previous body-to-NED coordinate transformation.
     * @param oldVn        previous velocity north-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param oldVe        previous velocity east-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param oldVd        previous velocity down-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param result       instance where new estimated NED frame containing new body position,
     *                     velocity and coordinate transformation matrix will be stored.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-NED-frame coordinate transformation matrix are
     *                                                       invalid.
     */
    public void navigate(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L2048">2048</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L2107">2107</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public void navigate(final double timeInterval,
                         final double oldLatitude,
                         final double oldLongitude,
                         final double oldHeight,
                         final CoordinateTransformation oldC,
                         final double oldVn,
                         final double oldVe,
                         final double oldVd,
                         final double fx,
                         final double fy,
                         final double fz,
                         final AngularSpeed angularRateX,
                         final AngularSpeed angularRateY,
                         final AngularSpeed angularRateZ,
                         final NEDFrame result)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        navigateNED(timeInterval, oldLatitude, oldLongitude, oldHeight, oldC,
                oldVn, oldVe, oldVd, fx, fy, fz,
                angularRateX, angularRateY, angularRateZ, result);
    }

    /**
     * Runs precision local-navigation-frame inertial navigation equations.
     * NOTE: only the attitude update and specific force frame transformation
     * phases are precise.
     *
     * @param timeInterval time interval between epochs.
     * @param oldLatitude  previous latitude expressed in radians (rad).
     * @param oldLongitude previous longitude expressed in radians (rad).
     * @param oldHeight    previous height expressed in meters (m).
     * @param oldC         previous body-to-NED coordinate transformation.
     * @param oldVn        previous velocity north-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param oldVe        previous velocity east-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param oldVd        previous velocity down-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param result       instance where new estimated NED frame containing new body position,
     *                     velocity and coordinate transformation matrix will be stored.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-NED-frame coordinate transformation matrix are
     *                                                       invalid.
     */
    public void navigate(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L2483">2483</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L2545">2545</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public void navigate(final double timeInterval,
                         final Angle oldLatitude,
                         final Angle oldLongitude,
                         final Distance oldHeight,
                         final CoordinateTransformation oldC,
                         final Speed oldSpeedN,
                         final Speed oldSpeedE,
                         final Speed oldSpeedD,
                         final double fx,
                         final double fy,
                         final double fz,
                         final double angularRateX,
                         final double angularRateY,
                         final double angularRateZ,
                         final NEDFrame result)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        navigateNED(timeInterval, oldLatitude, oldLongitude, oldHeight, oldC,
                oldSpeedN, oldSpeedE, oldSpeedD, fx, fy, fz,
                angularRateX, angularRateY, angularRateZ, result);
    }

    /**
     * Runs precision local-navigation-frame inertial navigation equations.
     * NOTE: only the attitude update and specific force frame transformation
     * phases are precise.
     *
     * @param timeInterval time interval between epochs.
     * @param oldLatitude  previous latitude angle.
     * @param oldLongitude previous longitude angle.
     * @param oldHeight    previous height.
     * @param oldC         previous body-to-NED coordinate transformation.
     * @param oldSpeedN    previous velocity north-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes.
     * @param oldSpeedE    previous velocity east-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes.
     * @param oldSpeedD    previous velocity down-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes.
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param result       instance where new estimated NED frame containing new body position,
     *                     velocity and coordinate transformation matrix will be stored.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-NED-frame coordinate transformation matrix are
     *                                                       invalid.
     */
    public void navigate(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L2601">2601</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L2657">2657</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public void navigate(final double timeInterval,
                         final Angle oldLatitude,
                         final Angle oldLongitude,
                         final Distance oldHeight,
                         final CoordinateTransformation oldC,
                         final Speed oldSpeedN,
                         final Speed oldSpeedE,
                         final Speed oldSpeedD,
                         final Acceleration fx,
                         final Acceleration fy,
                         final Acceleration fz,
                         final AngularSpeed angularRateX,
                         final AngularSpeed angularRateY,
                         final AngularSpeed angularRateZ,
                         final NEDFrame result)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        navigateNED(timeInterval, oldLatitude, oldLongitude, oldHeight, oldC,
                oldSpeedN, oldSpeedE, oldSpeedD, fx, fy, fz,
                angularRateX, angularRateY, angularRateZ, result);
    }

    /**
     * Runs precision local-navigation-frame inertial navigation equations.
     * NOTE: only the attitude update and specific force frame transformation
     * phases are precise.
     *
     * @param timeInterval time interval between epochs.
     * @param oldLatitude  previous latitude angle.
     * @param oldLongitude previous longitude angle.
     * @param oldHeight    previous height.
     * @param oldC         previous body-to-NED coordinate transformation.
     * @param oldSpeedN    previous velocity north-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes.
     * @param oldSpeedE    previous velocity east-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes.
     * @param oldSpeedD    previous velocity down-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes.
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param result       instance where new estimated NED frame containing new body position,
     *                     velocity and coordinate transformation matrix will be stored.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-NED-frame coordinate transformation matrix are
     *                                                       invalid.
     */
    public void navigate(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L2713">2713</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L2769">2769</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public void navigate(final double timeInterval,
                         final double oldLatitude,
                         final double oldLongitude,
                         final double oldHeight,
                         final CoordinateTransformation oldC,
                         final Speed oldSpeedN,
                         final Speed oldSpeedE,
                         final Speed oldSpeedD,
                         final Acceleration fx,
                         final Acceleration fy,
                         final Acceleration fz,
                         final AngularSpeed angularRateX,
                         final AngularSpeed angularRateY,
                         final AngularSpeed angularRateZ,
                         final NEDFrame result)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        navigateNED(timeInterval, oldLatitude, oldLongitude, oldHeight, oldC,
                oldSpeedN, oldSpeedE, oldSpeedD, fx, fy, fz,
                angularRateX, angularRateY, angularRateZ, result);
    }

    /**
     * Runs precision local-navigation-frame inertial navigation equations.
     * NOTE: only the attitude update and specific force frame transformation
     * phases are precise.
     *
     * @param timeInterval time interval between epochs.
     * @param oldLatitude  previous latitude expressed in radians (rad).
     * @param oldLongitude previous longitude expressed in radians (rad).
     * @param oldHeight    previous height expressed in meters (m).
     * @param oldC         previous body-to-NED coordinate transformation.
     * @param oldSpeedN    previous velocity north-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes.
     * @param oldSpeedE    previous velocity east-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes.
     * @param oldSpeedD    previous velocity down-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes.
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param result       instance where new estimated NED frame containing new body position,
     *                     velocity and coordinate transformation matrix will be stored.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-NED-frame coordinate transformation matrix are
     *                                                       invalid.
     */
    public void navigate(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L3121">3121</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L3177">3177</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public void navigate(final double timeInterval,
                         final Angle oldLatitude,
                         final Angle oldLongitude,
                         final Distance oldHeight,
                         final CoordinateTransformation oldC,
                         final double oldVn,
                         final double oldVe,
                         final double oldVd,
                         final Acceleration fx,
                         final Acceleration fy,
                         final Acceleration fz,
                         final AngularSpeed angularRateX,
                         final AngularSpeed angularRateY,
                         final AngularSpeed angularRateZ,
                         final NEDFrame result)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        navigateNED(timeInterval, oldLatitude, oldLongitude, oldHeight, oldC,
                oldVn, oldVe, oldVd, fx, fy, fz,
                angularRateX, angularRateY, angularRateZ, result);
    }

    /**
     * Runs precision local-navigation-frame inertial navigation equations.
     * NOTE: only the attitude update and specific force frame transformation
     * phases are precise.
     *
     * @param timeInterval time interval between epochs.
     * @param oldLatitude  previous latitude angle.
     * @param oldLongitude previous longitude angle.
     * @param oldHeight    previous height.
     * @param oldC         previous body-to-NED coordinate transformation.
     * @param oldVn        previous velocity north-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param oldVe        previous velocity east-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param oldVd        previous velocity down-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param result       instance where new estimated NED frame containing new body position,
     *                     velocity and coordinate transformation matrix will be stored.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-NED-frame coordinate transformation matrix are
     *                                                       invalid.
     */
    public void navigate(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L3337">3337</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L3393">3393</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public void navigate(final double timeInterval,
                         final double oldLatitude,
                         final double oldLongitude,
                         final double oldHeight,
                         final CoordinateTransformation oldC,
                         final double oldVn,
                         final double oldVe,
                         final double oldVd,
                         final Acceleration fx,
                         final Acceleration fy,
                         final Acceleration fz,
                         final AngularSpeed angularRateX,
                         final AngularSpeed angularRateY,
                         final AngularSpeed angularRateZ,
                         final NEDFrame result)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        navigateNED(timeInterval, oldLatitude, oldLongitude, oldHeight, oldC,
                oldVn, oldVe, oldVd, fx, fy, fz,
                angularRateX, angularRateY, angularRateZ, result);
    }

    /**
     * Runs precision local-navigation-frame inertial navigation equations.
     * NOTE: only the attitude update and specific force frame transformation
     * phases are precise.
     *
     * @param timeInterval time interval between epochs.
     * @param oldLatitude  previous latitude expressed in radians (rad).
     * @param oldLongitude previous longitude expressed in radians (rad).
     * @param oldHeight    previous height expressed in meters (m).
     * @param oldC         previous body-to-NED coordinate transformation.
     * @param oldVn        previous velocity north-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param oldVe        previous velocity east-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param oldVd        previous velocity down-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param result       instance where new estimated NED frame containing new body position,
     *                     velocity and coordinate transformation matrix will be stored.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-NED-frame coordinate transformation matrix are
     *                                                       invalid.
     */
    public void navigate(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L5635">5635</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L6023">6023</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                                                     final double oldZ,
                                                     final CoordinateTransformation oldC,
                                                     final double oldVx,
                                                     final double oldVy,
                                                     final double oldVz,
                                                     final double fx,
                                                     final double fy,
                                                     final double fz,
                                                     final double angularRateX,
                                                     final double angularRateY,
                                                     final double angularRateZ)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        final ECEFFrame result = new ECEFFrame();
        navigateECEF(timeInterval, oldX, oldY, oldZ, oldC, oldVx, oldVy, oldVz,
                fx, fy, fz, angularRateX, angularRateY, angularRateZ, result);
        return result;
    }

    /**
     * Runs precision ECEF-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldX         previous cartesian x-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldY         previous cartesian y-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldZ         previous cartesian z-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldC         previous body-to-ECEF-frame coordinate transformation.
     * @param oldVx        previous velocity x-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param oldVy        previous velocity y-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param oldVz        previous velocity z-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @return estimated ECEF frame containing new body position, velocity and coordinate
     * transformation matrix.
     * @throws InertialNavigatorException if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     * body-to-ECEF-frame coordinate transformation matrix are invalid.
     */
    public static ECEFFrame navigateECEFAndReturnNew(final Time timeInterval,
                                                     final double oldX,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L5642">5642</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L6439">6439</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                                                     final double fz,
                                                     final double angularRateX,
                                                     final double angularRateY,
                                                     final double angularRateZ)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        final ECEFFrame result = new ECEFFrame();
        navigateECEF(timeInterval, oldX, oldY, oldZ, oldC, oldVx, oldVy, oldVz,
                fx, fy, fz, angularRateX, angularRateY, angularRateZ, result);
        return result;
    }

    /**
     * Runs precision ECEF-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldX         previous cartesian x-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldY         previous cartesian y-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldZ         previous cartesian z-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldC         previous body-to-ECEF-frame coordinate transformation.
     * @param oldVx        previous velocity x-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param oldVy        previous velocity y-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param oldVz        previous velocity z-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @return estimated ECEF frame containing new body position, velocity and coordinate
     * transformation matrix.
     * @throws InertialNavigatorException if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     * body-to-ECEF-frame coordinate transformation matrix are invalid.
     */
    public static ECEFFrame navigateECEFAndReturnNew(final Time timeInterval,
                                                     final double oldX,
                                                     final double oldY,
                                                     final double oldZ,
                                                     final CoordinateTransformation oldC,
                                                     final double oldVx,
                                                     final double oldVy,
                                                     final double oldVz,
                                                     final double fx,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L5645">5645</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L6560">6560</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                                                     final double angularRateZ)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        final ECEFFrame result = new ECEFFrame();
        navigateECEF(timeInterval, oldX, oldY, oldZ, oldC, oldVx, oldVy, oldVz,
                fx, fy, fz, angularRateX, angularRateY, angularRateZ, result);
        return result;
    }

    /**
     * Runs precision ECEF-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldX         previous cartesian x-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldY         previous cartesian y-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldZ         previous cartesian z-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldC         previous body-to-ECEF-frame coordinate transformation.
     * @param oldVx        previous velocity x-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param oldVy        previous velocity y-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param oldVz        previous velocity z-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @return estimated ECEF frame containing new body position, velocity and coordinate
     * transformation matrix.
     * @throws InertialNavigatorException if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     * body-to-ECEF-frame coordinate transformation matrix are invalid.
     */
    public static ECEFFrame navigateECEFAndReturnNew(final Time timeInterval,
                                                     final double oldX,
                                                     final double oldY,
                                                     final double oldZ,
                                                     final CoordinateTransformation oldC,
                                                     final double oldVx,
                                                     final double oldVy,
                                                     final double oldVz,
                                                     final double fx,
                                                     final double fy,
                                                     final double fz,
                                                     final double angularRateX,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L5697">5697</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L6085">6085</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                                                     final double oldZ,
                                                     final CoordinateTransformation oldC,
                                                     final double oldVx,
                                                     final double oldVy,
                                                     final double oldVz,
                                                     final double fx,
                                                     final double fy,
                                                     final double fz,
                                                     final double angularRateX,
                                                     final double angularRateY,
                                                     final double angularRateZ)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        final ECEFFrame result = new ECEFFrame();
        navigateECEF(timeInterval, oldX, oldY, oldZ, oldC, oldVx, oldVy, oldVz,
                fx, fy, fz, angularRateX, angularRateY, angularRateZ, result);
        return result;
    }

    /**
     * Runs precision ECEF-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs expressed in seconds (s).
     * @param oldX         previous cartesian x-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldY         previous cartesian y-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldZ         previous cartesian z-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldC         previous body-to-ECEF-frame coordinate transformation.
     * @param oldVx        previous velocity x-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param oldVy        previous velocity y-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param oldVz        previous velocity z-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param kinematics   body kinematics containing specific forces and angular rates applied to
     *                     the body.
     * @return estimated ECEF frame containing new body position, velocity and coordinate
     * transformation matrix.
     * @throws InertialNavigatorException if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     * body-to-ECEF-frame coordinate transformation matrix are invalid.
     */
    public static ECEFFrame navigateECEFAndReturnNew(final double timeInterval,
                                                     final double oldX,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L5704">5704</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L6498">6498</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                                                     final double fz,
                                                     final double angularRateX,
                                                     final double angularRateY,
                                                     final double angularRateZ)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        final ECEFFrame result = new ECEFFrame();
        navigateECEF(timeInterval, oldX, oldY, oldZ, oldC, oldVx, oldVy, oldVz,
                fx, fy, fz, angularRateX, angularRateY, angularRateZ, result);
        return result;
    }

    /**
     * Runs precision ECEF-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs expressed in seconds (s).
     * @param oldX         previous cartesian x-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldY         previous cartesian y-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldZ         previous cartesian z-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldC         previous body-to-ECEF-frame coordinate transformation.
     * @param oldVx        previous velocity x-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param oldVy        previous velocity y-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param oldVz        previous velocity z-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param kinematics   body kinematics containing specific forces and angular rates applied to
     *                     the body.
     * @return estimated ECEF frame containing new body position, velocity and coordinate
     * transformation matrix.
     * @throws InertialNavigatorException if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     * body-to-ECEF-frame coordinate transformation matrix are invalid.
     */
    public static ECEFFrame navigateECEFAndReturnNew(final double timeInterval,
                                                     final double oldX,
                                                     final double oldY,
                                                     final double oldZ,
                                                     final CoordinateTransformation oldC,
                                                     final double oldVx,
                                                     final double oldVy,
                                                     final double oldVz,
                                                     final BodyKinematics kinematics)</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L6229">6229</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L6671">6671</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                                                     final double oldZ,
                                                     final CoordinateTransformation oldC,
                                                     final Speed oldSpeedX,
                                                     final Speed oldSpeedY,
                                                     final Speed oldSpeedZ,
                                                     final double fx,
                                                     final double fy,
                                                     final double fz,
                                                     final double angularRateX,
                                                     final double angularRateY,
                                                     final double angularRateZ)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        final ECEFFrame result = new ECEFFrame();
        navigateECEF(timeInterval, oldX, oldY, oldZ, oldC, oldSpeedX, oldSpeedY,
                oldSpeedZ, fx, fy, fz, angularRateX, angularRateY, angularRateZ, result);
        return result;
    }

    /**
     * Runs precision ECEF-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldX         previous cartesian x-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldY         previous cartesian y-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldZ         previous cartesian z-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldC         previous body-to-ECEF-frame coordinate transformation.
     * @param oldSpeedX    previous velocity x-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param oldSpeedY    previous velocity y-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param oldSpeedZ    previous velocity z-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @return estimated ECEF frame containing new body position, velocity and coordinate
     * transformation matrix.
     * @throws InertialNavigatorException if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     * body-to-ECEF-frame coordinate transformation matrix are invalid.
     */
    public static ECEFFrame navigateECEFAndReturnNew(final Time timeInterval,
                                                     final double oldX,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L6291">6291</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L6734">6734</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                                                     final double oldZ,
                                                     final CoordinateTransformation oldC,
                                                     final Speed oldSpeedX,
                                                     final Speed oldSpeedY,
                                                     final Speed oldSpeedZ,
                                                     final double fx,
                                                     final double fy,
                                                     final double fz,
                                                     final double angularRateX,
                                                     final double angularRateY,
                                                     final double angularRateZ)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        final ECEFFrame result = new ECEFFrame();
        navigateECEF(timeInterval, oldX, oldY, oldZ, oldC, oldSpeedX, oldSpeedY,
                oldSpeedZ, fx, fy, fz, angularRateX, angularRateY, angularRateZ, result);
        return result;
    }

    /**
     * Runs precision ECEF-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs expressed in seconds (s).
     * @param oldX         previous cartesian x-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldY         previous cartesian y-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldZ         previous cartesian z-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldC         previous body-to-ECEF-frame coordinate transformation.
     * @param oldSpeedX    previous velocity x-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param oldSpeedY    previous velocity y-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param oldSpeedZ    previous velocity z-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param kinematics   body kinematics containing specific forces and angular rates applied to
     *                     the body.
     * @return estimated ECEF frame containing new body position, velocity and coordinate
     * transformation matrix.
     * @throws InertialNavigatorException if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     * body-to-ECEF-frame coordinate transformation matrix are invalid.
     */
    public static ECEFFrame navigateECEFAndReturnNew(final double timeInterval,
                                                     final double oldX,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L6442">6442</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L6915">6915</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                                                     final double angularRateZ)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        final ECEFFrame result = new ECEFFrame();
        navigateECEF(timeInterval, oldX, oldY, oldZ, oldC, oldVx, oldVy, oldVz, fx, fy,
                fz, angularRateX, angularRateY, angularRateZ, result);
        return result;
    }

    /**
     * Runs precision ECEF-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldX         previous cartesian x-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldY         previous cartesian y-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldZ         previous cartesian z-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldC         previous body-to-ECEF-frame coordinate transformation.
     * @param oldVx        previous velocity x-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param oldVy        previous velocity y-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param oldVz        previous velocity z-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @return estimated ECEF frame containing new body position, velocity and coordinate
     * transformation matrix.
     * @throws InertialNavigatorException if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     * body-to-ECEF-frame coordinate transformation matrix are invalid.
     */
    public static ECEFFrame navigateECEFAndReturnNew(final Time timeInterval,
                                                     final double oldX,
                                                     final double oldY,
                                                     final double oldZ,
                                                     final CoordinateTransformation oldC,
                                                     final double oldVx,
                                                     final double oldVy,
                                                     final double oldVz,
                                                     final Acceleration fx,
                                                     final Acceleration fy,
                                                     final Acceleration fz,
                                                     final double angularRateX,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L6557">6557</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L6912">6912</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                                                     final double fz,
                                                     final AngularSpeed angularRateX,
                                                     final AngularSpeed angularRateY,
                                                     final AngularSpeed angularRateZ)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        final ECEFFrame result = new ECEFFrame();
        navigateECEF(timeInterval, oldX, oldY, oldZ, oldC, oldVx, oldVy, oldVz, fx, fy,
                fz, angularRateX, angularRateY, angularRateZ, result);
        return result;
    }

    /**
     * Runs precision ECEF-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldX         previous cartesian x-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldY         previous cartesian y-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldZ         previous cartesian z-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldC         previous body-to-ECEF-frame coordinate transformation.
     * @param oldVx        previous velocity x-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param oldVy        previous velocity y-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param oldVz        previous velocity z-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @return estimated ECEF frame containing new body position, velocity and coordinate
     * transformation matrix.
     * @throws InertialNavigatorException if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     * body-to-ECEF-frame coordinate transformation matrix are invalid.
     */
    public static ECEFFrame navigateECEFAndReturnNew(final Time timeInterval,
                                                     final double oldX,
                                                     final double oldY,
                                                     final double oldZ,
                                                     final CoordinateTransformation oldC,
                                                     final double oldVx,
                                                     final double oldVy,
                                                     final double oldVz,
                                                     final double fx,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L6616">6616</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L6968">6968</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                                                     final double fz,
                                                     final AngularSpeed angularRateX,
                                                     final AngularSpeed angularRateY,
                                                     final AngularSpeed angularRateZ)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        final ECEFFrame result = new ECEFFrame();
        navigateECEF(timeInterval, oldX, oldY, oldZ, oldC, oldVx, oldVy, oldVz, fx, fy,
                fz, angularRateX, angularRateY, angularRateZ, result);
        return result;
    }

    /**
     * Runs precision ECEF-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs expressed in seconds (s).
     * @param oldX         previous cartesian x-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldY         previous cartesian y-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldZ         previous cartesian z-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldC         previous body-to-ECEF-frame coordinate transformation.
     * @param oldSpeedX    previous velocity x-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param oldSpeedY    previous velocity y-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param oldSpeedZ    previous velocity z-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @return estimated ECEF frame containing new body position, velocity and coordinate
     * transformation matrix.
     * @throws InertialNavigatorException if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     * body-to-ECEF-frame coordinate transformation matrix are invalid.
     */
    public static ECEFFrame navigateECEFAndReturnNew(final double timeInterval,
                                                     final Distance oldX,
                                                     final Distance oldY,
                                                     final Distance oldZ,
                                                     final CoordinateTransformation oldC,
                                                     final Speed oldSpeedX,
                                                     final Speed oldSpeedY,
                                                     final Speed oldSpeedZ,
                                                     final double fx,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L5670">5670</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L6065">6065</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                                                   final double oldZ,
                                                   final CoordinateTransformation oldC,
                                                   final double oldVx,
                                                   final double oldVy,
                                                   final double oldVz,
                                                   final double fx,
                                                   final double fy,
                                                   final double fz,
                                                   final double angularRateX,
                                                   final double angularRateY,
                                                   final double angularRateZ)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        final ECIFrame result = new ECIFrame();
        navigateECI(timeInterval, oldX, oldY, oldZ, oldC, oldVx, oldVy, oldVz,
                fx, fy, fz, angularRateX, angularRateY, angularRateZ, result);
        return result;
    }

    /**
     * Runs precision ECI-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldX         previous cartesian x-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldY         previous cartesian y-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldZ         previous cartesian z-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldC         previous body-to-ECI-frame coordinate transformation.
     * @param oldVx        previous velocity x-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param oldVy        previous velocity y-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param oldVz        previous velocity z-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param fx           specific force x-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @return estimated ECI frame containing new body position, velocity and coordinate
     * transformation matrix.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-ECI-frame coordinate transformation matrix are
     *                                                       invalid.
     */
    public static ECIFrame navigateECIAndReturnNew(final Time timeInterval,
                                                   final double oldX,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L5677">5677</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L6485">6485</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                                                   final double fz,
                                                   final double angularRateX,
                                                   final double angularRateY,
                                                   final double angularRateZ)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        final ECIFrame result = new ECIFrame();
        navigateECI(timeInterval, oldX, oldY, oldZ, oldC, oldVx, oldVy, oldVz,
                fx, fy, fz, angularRateX, angularRateY, angularRateZ, result);
        return result;
    }

    /**
     * Runs precision ECI-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldX         previous cartesian x-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldY         previous cartesian y-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldZ         previous cartesian z-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldC         previous body-to-ECI-frame coordinate transformation.
     * @param oldVx        previous velocity x-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param oldVy        previous velocity y-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param oldVz        previous velocity z-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param fx           specific force x-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @return estimated ECI frame containing new body position, velocity and coordinate
     * transformation matrix.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-ECI-frame coordinate transformation matrix are
     *                                                       invalid.
     */
    public static ECIFrame navigateECIAndReturnNew(final Time timeInterval,
                                                   final double oldX,
                                                   final double oldY,
                                                   final double oldZ,
                                                   final CoordinateTransformation oldC,
                                                   final double oldVx,
                                                   final double oldVy,
                                                   final double oldVz,
                                                   final double fx,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L5680">5680</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L6606">6606</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                                                   final double angularRateZ)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        final ECIFrame result = new ECIFrame();
        navigateECI(timeInterval, oldX, oldY, oldZ, oldC, oldVx, oldVy, oldVz,
                fx, fy, fz, angularRateX, angularRateY, angularRateZ, result);
        return result;
    }

    /**
     * Runs precision ECI-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldX         previous cartesian x-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldY         previous cartesian y-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldZ         previous cartesian z-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldC         previous body-to-ECI-frame coordinate transformation.
     * @param oldVx        previous velocity x-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param oldVy        previous velocity y-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param oldVz        previous velocity z-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param fx           specific force x-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @return estimated ECI frame containing new body position, velocity and coordinate
     * transformation matrix.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-ECI-frame coordinate transformation matrix are
     *                                                       invalid.
     */
    public static ECIFrame navigateECIAndReturnNew(final Time timeInterval,
                                                   final double oldX,
                                                   final double oldY,
                                                   final double oldZ,
                                                   final CoordinateTransformation oldC,
                                                   final double oldVx,
                                                   final double oldVy,
                                                   final double oldVz,
                                                   final double fx,
                                                   final double fy,
                                                   final double fz,
                                                   final double angularRateX,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L5733">5733</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L6127">6127</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                                                   final double oldZ,
                                                   final CoordinateTransformation oldC,
                                                   final double oldVx,
                                                   final double oldVy,
                                                   final double oldVz,
                                                   final double fx,
                                                   final double fy,
                                                   final double fz,
                                                   final double angularRateX,
                                                   final double angularRateY,
                                                   final double angularRateZ)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        final ECIFrame result = new ECIFrame();
        navigateECI(timeInterval, oldX, oldY, oldZ, oldC, oldVx, oldVy, oldVz,
                fx, fy, fz, angularRateX, angularRateY, angularRateZ, result);
        return result;
    }

    /**
     * Runs precision ECI-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs expressed in seconds (s).
     * @param oldX         previous cartesian x-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldY         previous cartesian y-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldZ         previous cartesian z-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldC         previous body-to-ECI-frame coordinate transformation.
     * @param oldVx        previous velocity x-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param oldVy        previous velocity y-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param oldVz        previous velocity z-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param kinematics   body kinematics containing specific forces and angular rates applied to
     *                     the body.
     * @return estimated ECI frame containing new body position, velocity and coordinate
     * transformation matrix.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-ECI-frame coordinate transformation matrix are
     *                                                       invalid.
     */
    public static ECIFrame navigateECIAndReturnNew(final double timeInterval,
                                                   final double oldX,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L5740">5740</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L6544">6544</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                                                   final double fz,
                                                   final double angularRateX,
                                                   final double angularRateY,
                                                   final double angularRateZ)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        final ECIFrame result = new ECIFrame();
        navigateECI(timeInterval, oldX, oldY, oldZ, oldC, oldVx, oldVy, oldVz,
                fx, fy, fz, angularRateX, angularRateY, angularRateZ, result);
        return result;
    }

    /**
     * Runs precision ECI-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs expressed in seconds (s).
     * @param oldX         previous cartesian x-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldY         previous cartesian y-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldZ         previous cartesian z-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldC         previous body-to-ECI-frame coordinate transformation.
     * @param oldVx        previous velocity x-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param oldVy        previous velocity y-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param oldVz        previous velocity z-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param kinematics   body kinematics containing specific forces and angular rates applied to
     *                     the body.
     * @return estimated ECI frame containing new body position, velocity and coordinate
     * transformation matrix.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-ECI-frame coordinate transformation matrix are
     *                                                       invalid.
     */
    public static ECIFrame navigateECIAndReturnNew(final double timeInterval,
                                                   final double oldX,
                                                   final double oldY,
                                                   final double oldZ,
                                                   final CoordinateTransformation oldC,
                                                   final double oldVx,
                                                   final double oldVy,
                                                   final double oldVz,
                                                   final BodyKinematics kinematics)</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L6273">6273</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L6717">6717</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                                                   final double oldZ,
                                                   final CoordinateTransformation oldC,
                                                   final Speed oldSpeedX,
                                                   final Speed oldSpeedY,
                                                   final Speed oldSpeedZ,
                                                   final double fx,
                                                   final double fy,
                                                   final double fz,
                                                   final double angularRateX,
                                                   final double angularRateY,
                                                   final double angularRateZ)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        final ECIFrame result = new ECIFrame();
        navigateECI(timeInterval, oldX, oldY, oldZ, oldC, oldSpeedX, oldSpeedY, oldSpeedZ,
                fx, fy, fz, angularRateX, angularRateY, angularRateZ, result);
        return result;
    }

    /**
     * Runs precision ECI-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldX         previous cartesian x-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldY         previous cartesian y-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldZ         previous cartesian z-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldC         previous body-to-ECI-frame coordinate transformation.
     * @param oldSpeedX    previous velocity x-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes.
     * @param oldSpeedY    previous velocity y-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes.
     * @param oldSpeedZ    previous velocity z-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes.
     * @param fx           specific force x-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @return estimated ECI frame containing new body position, velocity and coordinate
     * transformation matrix.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-ECI-frame coordinate transformation matrix are invalid.
     */
    public static ECIFrame navigateECIAndReturnNew(final Time timeInterval,
                                                   final double oldX,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L6335">6335</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L6779">6779</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                                                   final double oldZ,
                                                   final CoordinateTransformation oldC,
                                                   final Speed oldSpeedX,
                                                   final Speed oldSpeedY,
                                                   final Speed oldSpeedZ,
                                                   final double fx,
                                                   final double fy,
                                                   final double fz,
                                                   final double angularRateX,
                                                   final double angularRateY,
                                                   final double angularRateZ)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        final ECIFrame result = new ECIFrame();
        navigateECI(timeInterval, oldX, oldY, oldZ, oldC, oldSpeedX, oldSpeedY, oldSpeedZ,
                fx, fy, fz, angularRateX, angularRateY, angularRateZ, result);
        return result;
    }

    /**
     * Runs precision ECI-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs expressed in seconds (s).
     * @param oldX         previous cartesian x-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldY         previous cartesian y-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldZ         previous cartesian z-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldC         previous body-to-ECI-frame coordinate transformation.
     * @param oldSpeedX    previous velocity x-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes.
     * @param oldSpeedY    previous velocity y-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes.
     * @param oldSpeedZ    previous velocity z-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes.
     * @param kinematics   body kinematics containing specific forces and angular rates applied to
     *                     the body.
     * @return estimated ECI frame containing new body position, velocity and coordinate
     * transformation matrix.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-ECI-frame coordinate transformation matrix are
     *                                                       invalid.
     */
    public static ECIFrame navigateECIAndReturnNew(final double timeInterval,
                                                   final double oldX,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L6488">6488</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L6957">6957</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                                                   final double angularRateZ)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        final ECIFrame result = new ECIFrame();
        navigateECI(timeInterval, oldX, oldY, oldZ, oldC, oldVx, oldVy, oldVz,
                fx, fy, fz, angularRateX, angularRateY, angularRateZ, result);
        return result;
    }

    /**
     * Runs precision ECI-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldX         previous cartesian x-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldY         previous cartesian y-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldZ         previous cartesian z-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldC         previous body-to-ECI-frame coordinate transformation.
     * @param oldVx        previous velocity x-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param oldVy        previous velocity y-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param oldVz        previous velocity z-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param fx           specific force x-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fy           specific force y-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fz           specific force z-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateX angular rate x-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @return estimated ECI frame containing new body position, velocity and coordinate
     * transformation matrix.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-ECI-frame coordinate transformation matrix are invalid.
     */
    public static ECIFrame navigateECIAndReturnNew(final Time timeInterval,
                                                   final double oldX,
                                                   final double oldY,
                                                   final double oldZ,
                                                   final CoordinateTransformation oldC,
                                                   final double oldVx,
                                                   final double oldVy,
                                                   final double oldVz,
                                                   final Acceleration fx,
                                                   final Acceleration fy,
                                                   final Acceleration fz,
                                                   final double angularRateX,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L6603">6603</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L6954">6954</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                                                   final double fz,
                                                   final AngularSpeed angularRateX,
                                                   final AngularSpeed angularRateY,
                                                   final AngularSpeed angularRateZ)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        final ECIFrame result = new ECIFrame();
        navigateECI(timeInterval, oldX, oldY, oldZ, oldC, oldVx, oldVy, oldVz,
                fx, fy, fz, angularRateX, angularRateY, angularRateZ, result);
        return result;
    }

    /**
     * Runs precision ECI-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldX         previous cartesian x-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldY         previous cartesian y-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldZ         previous cartesian z-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldC         previous body-to-ECI-frame coordinate transformation.
     * @param oldVx        previous velocity x-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param oldVy        previous velocity y-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param oldVz        previous velocity z-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param fx           specific force x-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateY angular rate y-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @return estimated ECI frame containing new body position, velocity and coordinate
     * transformation matrix.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-ECI-frame coordinate transformation matrix are invalid.
     */
    public static ECIFrame navigateECIAndReturnNew(final Time timeInterval,
                                                   final double oldX,
                                                   final double oldY,
                                                   final double oldZ,
                                                   final CoordinateTransformation oldC,
                                                   final double oldVx,
                                                   final double oldVy,
                                                   final double oldVz,
                                                   final double fx,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L6662">6662</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L7010">7010</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                                                   final double fz,
                                                   final AngularSpeed angularRateX,
                                                   final AngularSpeed angularRateY,
                                                   final AngularSpeed angularRateZ)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        final ECIFrame result = new ECIFrame();
        navigateECI(timeInterval, oldX, oldY, oldZ, oldC, oldVx, oldVy, oldVz,
                fx, fy, fz, angularRateX, angularRateY, angularRateZ, result);
        return result;
    }

    /**
     * Runs precision ECI-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs expressed in seconds (s).
     * @param oldX         previous cartesian x-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes.
     * @param oldY         previous cartesian y-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes.
     * @param oldZ         previous cartesian z-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes.
     * @param oldC         previous body-to-ECI-frame coordinate transformation.
     * @param oldSpeedX    previous velocity x-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes.
     * @param oldSpeedY    previous velocity y-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes.
     * @param oldSpeedZ    previous velocity z-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes.
     * @param fx           specific force x-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @return estimated ECI frame containing new body position, velocity and coordinate
     * transformation matrix.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-ECI-frame coordinate transformation matrix are invalid.
     */
    public static ECIFrame navigateECIAndReturnNew(final double timeInterval,
                                                   final Distance oldX,
                                                   final Distance oldY,
                                                   final Distance oldZ,
                                                   final CoordinateTransformation oldC,
                                                   final Speed oldSpeedX,
                                                   final Speed oldSpeedY,
                                                   final Speed oldSpeedZ,
                                                   final double fx,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L11742">11742</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L12496">12496</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                                                   final double oldHeight,
                                                   final CoordinateTransformation oldC,
                                                   final double oldVn,
                                                   final double oldVe,
                                                   final double oldVd,
                                                   final double fx,
                                                   final double fy,
                                                   final double fz,
                                                   final double angularRateX,
                                                   final double angularRateY,
                                                   final double angularRateZ)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        final NEDFrame result = new NEDFrame();
        navigateNED(timeInterval, oldLatitude, oldLongitude, oldHeight, oldC,
                oldVn, oldVe, oldVd, fx, fy, fz, angularRateX, angularRateY,
                angularRateZ, result);
        return result;
    }

    /**
     * Runs precision local-navigation-frame inertial navigation equations.
     * NOTE: only the attitude update and specific force frame transformation
     * phases are precise.
     *
     * @param timeInterval time interval between epochs.
     * @param oldLatitude  previous latitude expressed in radians (rad).
     * @param oldLongitude previous longitude expressed in radians (rad).
     * @param oldHeight    previous height expressed in meters (m).
     * @param oldC         previous body-to-NED coordinate transformation.
     * @param oldVn        previous velocity north-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param oldVe        previous velocity east-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param oldVd        previous velocity down-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @return estimated NED frame containing new body position, velocity and coordinate
     * transformation matrix.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-NED-frame coordinate transformation matrix are
     *                                                       invalid.
     */
    public static NEDFrame navigateNEDAndReturnNew(final Time timeInterval,
                                                   final double oldLatitude,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L11749">11749</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L13294">13294</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                                                   final double fz,
                                                   final double angularRateX,
                                                   final double angularRateY,
                                                   final double angularRateZ)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        final NEDFrame result = new NEDFrame();
        navigateNED(timeInterval, oldLatitude, oldLongitude, oldHeight, oldC,
                oldVn, oldVe, oldVd, fx, fy, fz, angularRateX, angularRateY,
                angularRateZ, result);
        return result;
    }

    /**
     * Runs precision local-navigation-frame inertial navigation equations.
     * NOTE: only the attitude update and specific force frame transformation
     * phases are precise.
     *
     * @param timeInterval time interval between epochs.
     * @param oldLatitude  previous latitude expressed in radians (rad).
     * @param oldLongitude previous longitude expressed in radians (rad).
     * @param oldHeight    previous height expressed in meters (m).
     * @param oldC         previous body-to-NED coordinate transformation.
     * @param oldVn        previous velocity north-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param oldVe        previous velocity east-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param oldVd        previous velocity down-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @return estimated NED frame containing new body position, velocity and coordinate
     * transformation matrix.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-NED-frame coordinate transformation matrix are
     *                                                       invalid.
     */
    public static NEDFrame navigateNEDAndReturnNew(final Time timeInterval,
                                                   final double oldLatitude,
                                                   final double oldLongitude,
                                                   final double oldHeight,
                                                   final CoordinateTransformation oldC,
                                                   final double oldVn,
                                                   final double oldVe,
                                                   final double oldVd,
                                                   final double fx,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L11752">11752</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L13737">13737</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                                                   final double angularRateZ)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        final NEDFrame result = new NEDFrame();
        navigateNED(timeInterval, oldLatitude, oldLongitude, oldHeight, oldC,
                oldVn, oldVe, oldVd, fx, fy, fz, angularRateX, angularRateY,
                angularRateZ, result);
        return result;
    }

    /**
     * Runs precision local-navigation-frame inertial navigation equations.
     * NOTE: only the attitude update and specific force frame transformation
     * phases are precise.
     *
     * @param timeInterval time interval between epochs.
     * @param oldLatitude  previous latitude expressed in radians (rad).
     * @param oldLongitude previous longitude expressed in radians (rad).
     * @param oldHeight    previous height expressed in meters (m).
     * @param oldC         previous body-to-NED coordinate transformation.
     * @param oldVn        previous velocity north-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param oldVe        previous velocity east-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param oldVd        previous velocity down-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @return estimated NED frame containing new body position, velocity and coordinate
     * transformation matrix.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-NED-frame coordinate transformation matrix are
     *                                                       invalid.
     */
    public static NEDFrame navigateNEDAndReturnNew(final Time timeInterval,
                                                   final double oldLatitude,
                                                   final double oldLongitude,
                                                   final double oldHeight,
                                                   final CoordinateTransformation oldC,
                                                   final double oldVn,
                                                   final double oldVe,
                                                   final double oldVd,
                                                   final double fx,
                                                   final double fy,
                                                   final double fz,
                                                   final double angularRateX,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L11805">11805</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L12559">12559</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                                                   final double oldHeight,
                                                   final CoordinateTransformation oldC,
                                                   final double oldVn,
                                                   final double oldVe,
                                                   final double oldVd,
                                                   final double fx,
                                                   final double fy,
                                                   final double fz,
                                                   final double angularRateX,
                                                   final double angularRateY,
                                                   final double angularRateZ)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        final NEDFrame result = new NEDFrame();
        navigateNED(timeInterval, oldLatitude, oldLongitude, oldHeight,
                oldC, oldVn, oldVe, oldVd, fx, fy, fz, angularRateX, angularRateY, angularRateZ,
                result);
        return result;
    }

    /**
     * Runs precision local-navigation-frame inertial navigation equations.
     * NOTE: only the attitude update and specific force frame transformation
     * phases are precise.
     *
     * @param timeInterval time interval between epochs expressed in seconds (s).
     * @param oldPosition  previous curvilinear position expressed in terms of latitude,
     *                     longitude and height.
     * @param oldC         previous body-to-NED coordinate transformation.
     * @param oldVn        previous velocity north-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param oldVe        previous velocity east-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param oldVd        previous velocity down-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @return estimated NED frame containing new body position, velocity and coordinate
     * transformation matrix.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-NED-frame coordinate transformation matrix are
     *                                                       invalid.
     */
    public static NEDFrame navigateNEDAndReturnNew(final double timeInterval,
                                                   final NEDPosition oldPosition,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L12888">12888</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L14170">14170</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                                                   final double oldHeight,
                                                   final CoordinateTransformation oldC,
                                                   final Speed oldSpeedN,
                                                   final Speed oldSpeedE,
                                                   final Speed oldSpeedD,
                                                   final double fx,
                                                   final double fy,
                                                   final double fz,
                                                   final double angularRateX,
                                                   final double angularRateY,
                                                   final double angularRateZ)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        final NEDFrame result = new NEDFrame();
        navigateNED(timeInterval, oldLatitude, oldLongitude, oldHeight, oldC,
                oldSpeedN, oldSpeedE, oldSpeedD, fx, fy, fz, angularRateX,
                angularRateY, angularRateZ, result);
        return result;
    }

    /**
     * Runs precision local-navigation-frame inertial navigation equations.
     * NOTE: only the attitude update and specific force frame transformation
     * phases are precise.
     *
     * @param timeInterval time interval between epochs.
     * @param oldLatitude  previous latitude expressed in radians (rad).
     * @param oldLongitude previous longitude expressed in radians (rad).
     * @param oldHeight    previous height expressed in meters (m).
     * @param oldC         previous body-to-NED coordinate transformation.
     * @param oldSpeedN    previous velocity north-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes.
     * @param oldSpeedE    previous velocity east-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes.
     * @param oldSpeedD    previous velocity down-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes.
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @return estimated NED frame containing new body position, velocity and coordinate
     * transformation matrix.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-NED-frame coordinate transformation matrix are
     *                                                       invalid.
     */
    public static NEDFrame navigateNEDAndReturnNew(final Time timeInterval,
                                                   final double oldLatitude,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L12951">12951</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L14233">14233</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                                                   final double oldHeight,
                                                   final CoordinateTransformation oldC,
                                                   final Speed oldSpeedN,
                                                   final Speed oldSpeedE,
                                                   final Speed oldSpeedD,
                                                   final double fx,
                                                   final double fy,
                                                   final double fz,
                                                   final double angularRateX,
                                                   final double angularRateY,
                                                   final double angularRateZ)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        final NEDFrame result = new NEDFrame();
        navigateNED(timeInterval, oldLatitude, oldLongitude, oldHeight,
                oldC, oldSpeedN, oldSpeedE, oldSpeedD, fx, fy, fz, angularRateX,
                angularRateY, angularRateZ, result);
        return result;
    }

    /**
     * Runs precision local-navigation-frame inertial navigation equations.
     * NOTE: only the attitude update and specific force frame transformation
     * phases are precise.
     *
     * @param timeInterval time interval between epochs expressed in seconds (s).
     * @param oldPosition  previous curvilinear position expressed in terms of latitude,
     *                     longitude and height.
     * @param oldC         previous body-to-NED coordinate transformation.
     * @param oldSpeedN    previous velocity north-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes.
     * @param oldSpeedE    previous velocity east-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes.
     * @param oldSpeedD    previous velocity down-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes.
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @return estimated NED frame containing new body position, velocity and coordinate
     * transformation matrix.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-NED-frame coordinate transformation matrix are
     *                                                       invalid.
     */
    public static NEDFrame navigateNEDAndReturnNew(final double timeInterval,
                                                   final NEDPosition oldPosition,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L13297">13297</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L15050">15050</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                                                   final double angularRateZ)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        final NEDFrame result = new NEDFrame();
        navigateNED(timeInterval, oldLatitude, oldLongitude, oldHeight, oldC,
                oldVn, oldVe, oldVd, fx, fy, fz,
                angularRateX, angularRateY, angularRateZ, result);
        return result;
    }

    /**
     * Runs precision local-navigation-frame inertial navigation equations.
     * NOTE: only the attitude update and specific force frame transformation
     * phases are precise.
     *
     * @param timeInterval time interval between epochs.
     * @param oldLatitude  previous latitude expressed in radians (rad).
     * @param oldLongitude previous longitude expressed in radians (rad).
     * @param oldHeight    previous height expressed in meters (m).
     * @param oldC         previous body-to-NED coordinate transformation.
     * @param oldVn        previous velocity north-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param oldVe        previous velocity east-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param oldVd        previous velocity down-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @return estimated NED frame containing new body position, velocity and coordinate
     * transformation matrix.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-NED-frame coordinate transformation matrix are
     *                                                       invalid.
     */
    public static NEDFrame navigateNEDAndReturnNew(final Time timeInterval,
                                                   final double oldLatitude,
                                                   final double oldLongitude,
                                                   final double oldHeight,
                                                   final CoordinateTransformation oldC,
                                                   final double oldVn,
                                                   final double oldVe,
                                                   final double oldVd,
                                                   final Acceleration fx,
                                                   final Acceleration fy,
                                                   final Acceleration fz,
                                                   final double angularRateX,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L13734">13734</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L15047">15047</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                                                   final double fz,
                                                   final AngularSpeed angularRateX,
                                                   final AngularSpeed angularRateY,
                                                   final AngularSpeed angularRateZ)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        final NEDFrame result = new NEDFrame();
        navigateNED(timeInterval, oldLatitude, oldLongitude, oldHeight, oldC,
                oldVn, oldVe, oldVd, fx, fy, fz,
                angularRateX, angularRateY, angularRateZ, result);
        return result;
    }

    /**
     * Runs precision local-navigation-frame inertial navigation equations.
     * NOTE: only the attitude update and specific force frame transformation
     * phases are precise.
     *
     * @param timeInterval time interval between epochs.
     * @param oldLatitude  previous latitude expressed in radians (rad).
     * @param oldLongitude previous longitude expressed in radians (rad).
     * @param oldHeight    previous height expressed in meters (m).
     * @param oldC         previous body-to-NED coordinate transformation.
     * @param oldVn        previous velocity north-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param oldVe        previous velocity east-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param oldVd        previous velocity down-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @return estimated NED frame containing new body position, velocity and coordinate
     * transformation matrix.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-NED-frame coordinate transformation matrix are
     *                                                       invalid.
     */
    public static NEDFrame navigateNEDAndReturnNew(final Time timeInterval,
                                                   final double oldLatitude,
                                                   final double oldLongitude,
                                                   final double oldHeight,
                                                   final CoordinateTransformation oldC,
                                                   final double oldVn,
                                                   final double oldVe,
                                                   final double oldVd,
                                                   final double fx,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L14290">14290</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L14404">14404</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                                                   final Distance oldHeight,
                                                   final CoordinateTransformation oldC,
                                                   final Speed oldSpeedN,
                                                   final Speed oldSpeedE,
                                                   final Speed oldSpeedD,
                                                   final Acceleration fx,
                                                   final Acceleration fy,
                                                   final Acceleration fz,
                                                   final AngularSpeed angularRateX,
                                                   final AngularSpeed angularRateY,
                                                   final AngularSpeed angularRateZ)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        final NEDFrame result = new NEDFrame();
        navigateNED(timeInterval, oldLatitude, oldLongitude, oldHeight,
                oldC, oldSpeedN, oldSpeedE, oldSpeedD, fx, fy, fz,
                angularRateX, angularRateY, angularRateZ, result);
        return result;
    }

    /**
     * Runs precision local-navigation-frame inertial navigation equations.
     * NOTE: only the attitude update and specific force frame transformation
     * phases are precise.
     *
     * @param timeInterval time interval between epochs.
     * @param oldLatitude  previous latitude angle.
     * @param oldLongitude previous longitude angle.
     * @param oldHeight    previous height.
     * @param oldC         previous body-to-NED coordinate transformation.
     * @param oldSpeedN    previous velocity north-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes.
     * @param oldSpeedE    previous velocity east-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes.
     * @param oldSpeedD    previous velocity down-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes.
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @return estimated NED frame containing new body position, velocity and coordinate
     * transformation matrix.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-NED-frame coordinate transformation matrix are
     *                                                       invalid.
     */
    public static NEDFrame navigateNEDAndReturnNew(final Time timeInterval,
                                                   final Angle oldLatitude,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L14347">14347</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L14461">14461</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                                                   final Distance oldHeight,
                                                   final CoordinateTransformation oldC,
                                                   final Speed oldSpeedN,
                                                   final Speed oldSpeedE,
                                                   final Speed oldSpeedD,
                                                   final Acceleration fx,
                                                   final Acceleration fy,
                                                   final Acceleration fz,
                                                   final AngularSpeed angularRateX,
                                                   final AngularSpeed angularRateY,
                                                   final AngularSpeed angularRateZ)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        final NEDFrame result = new NEDFrame();
        navigateNED(timeInterval, oldLatitude, oldLongitude, oldHeight,
                oldC, oldSpeedN, oldSpeedE, oldSpeedD, fx, fy, fz, angularRateX,
                angularRateY, angularRateZ, result);
        return result;
    }

    /**
     * Runs precision local-navigation-frame inertial navigation equations.
     * NOTE: only the attitude update and specific force frame transformation
     * phases are precise.
     *
     * @param timeInterval time interval between epochs expressed in seconds (s).
     * @param oldLatitude  previous latitude expressed in radians (rad).
     * @param oldLongitude previous longitude expressed in radians (rad).
     * @param oldHeight    previous height expressed in meters (m).
     * @param oldC         previous body-to-NED coordinate transformation.
     * @param oldSpeedN    previous velocity north-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes.
     * @param oldSpeedE    previous velocity east-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes.
     * @param oldSpeedD    previous velocity down-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes.
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @return estimated NED frame containing new body position, velocity and coordinate
     * transformation matrix.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-NED-frame coordinate transformation matrix are
     *                                                       invalid.
     */
    public static NEDFrame navigateNEDAndReturnNew(final double timeInterval,
                                                   final double oldLatitude,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L14820">14820</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L15040">15040</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                                                   final Distance oldHeight,
                                                   final CoordinateTransformation oldC,
                                                   final double oldVn,
                                                   final double oldVe,
                                                   final double oldVd,
                                                   final Acceleration fx,
                                                   final Acceleration fy,
                                                   final Acceleration fz,
                                                   final AngularSpeed angularRateX,
                                                   final AngularSpeed angularRateY,
                                                   final AngularSpeed angularRateZ)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        final NEDFrame result = new NEDFrame();
        navigateNED(timeInterval, oldLatitude, oldLongitude, oldHeight,
                oldC, oldVn, oldVe, oldVd, fx, fy, fz,
                angularRateX, angularRateY, angularRateZ, result);
        return result;
    }

    /**
     * Runs precision local-navigation-frame inertial navigation equations.
     * NOTE: only the attitude update and specific force frame transformation
     * phases are precise.
     *
     * @param timeInterval time interval between epochs.
     * @param oldLatitude  previous latitude angle.
     * @param oldLongitude previous longitude angle.
     * @param oldHeight    previous height.
     * @param oldC         previous body-to-NED coordinate transformation.
     * @param oldVn        previous velocity north-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param oldVe        previous velocity east-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param oldVd        previous velocity down-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @return estimated NED frame containing new body position, velocity and coordinate
     * transformation matrix.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-NED-frame coordinate transformation matrix are
     *                                                       invalid.
     */
    public static NEDFrame navigateNEDAndReturnNew(final Time timeInterval,
                                                   final Angle oldLatitude,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L14877">14877</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L15097">15097</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                                                   final Distance oldHeight,
                                                   final CoordinateTransformation oldC,
                                                   final double oldVn,
                                                   final double oldVe,
                                                   final double oldVd,
                                                   final Acceleration fx,
                                                   final Acceleration fy,
                                                   final Acceleration fz,
                                                   final AngularSpeed angularRateX,
                                                   final AngularSpeed angularRateY,
                                                   final AngularSpeed angularRateZ)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        final NEDFrame result = new NEDFrame();
        navigateNED(timeInterval, oldLatitude, oldLongitude, oldHeight,
                oldC, oldVn, oldVe, oldVd, fx, fy, fz, angularRateX, angularRateY,
                angularRateZ, result);
        return result;
    }

    /**
     * Runs precision local-navigation-frame inertial navigation equations.
     * NOTE: only the attitude update and specific force frame transformation
     * phases are precise.
     *
     * @param timeInterval time interval between epochs expressed in seconds (s).
     * @param oldPosition  previous curvilinear position expressed in terms of latitude,
     *                     longitude and height.
     * @param oldC         previous body-to-NED coordinate transformation.
     * @param oldVn        previous velocity north-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param oldVe        previous velocity east-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param oldVd        previous velocity down-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @return estimated NED frame containing new body position, velocity and coordinate
     * transformation matrix.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-NED-frame coordinate transformation matrix are
     *                                                       invalid.
     */
    public static NEDFrame navigateNEDAndReturnNew(final double timeInterval,
                                                   final NEDPosition oldPosition,</pre></div></td></tr></table></div>
      </div>
    </div>
    <div class="clear">
      <hr/>
    </div>
    <div id="footer">
      <div class="xright">
        Copyright &#169;      2018&#x2013;2019.All rights reserved.      </div>
      <div class="clear">
        <hr/>
      </div>
    </div>
  </body>
</html>
