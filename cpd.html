<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- Generated by Apache Maven Doxia Site Renderer 1.8.1 from org.apache.maven.plugins:maven-pmd-plugin:3.10.0:cpd at 2020-02-09 -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>com.irurueta:irurueta-navigation &#x2013; CPD Results</title>
    <style type="text/css" media="all">
      @import url("./css/maven-base.css");
      @import url("./css/maven-theme.css");
      @import url("./css/site.css");
    </style>
    <link rel="stylesheet" href="./css/print.css" type="text/css" media="print" />
    <meta http-equiv="Content-Language" content="en" />
    
  </head>
  <body class="composite">
    <div id="banner">
<div id="bannerLeft">
com.irurueta:irurueta-navigation
</div>
      <div class="clear">
        <hr/>
      </div>
    </div>
    <div id="breadcrumbs">
      <div class="xleft">
        <span id="publishDate">Last Published: 2020-02-09</span>
          &nbsp;| <span id="projectVersion">Version: 1.0-SNAPSHOT</span>
      </div>
      <div class="xright"><a href="./" title="com.irurueta:irurueta-navigation">com.irurueta:irurueta-navigation</a>      </div>
      <div class="clear">
        <hr/>
      </div>
    </div>
    <div id="leftColumn">
      <div id="navcolumn">
       <h5>Project Documentation</h5>
    <ul>
     <li class="collapsed"><a href="project-info.html" title="Project Information">Project Information</a></li>
     <li class="expanded"><a href="project-reports.html" title="Project Reports">Project Reports</a>
      <ul>
       <li class="none"><a href="apidocs/index.html" title="Javadoc">Javadoc</a></li>
       <li class="none"><a href="testapidocs/index.html" title="Test Javadoc">Test Javadoc</a></li>
       <li class="none"><a href="surefire-report.html" title="Surefire Report">Surefire Report</a></li>
       <li class="none"><a href="checkstyle.html" title="Checkstyle">Checkstyle</a></li>
       <li class="none"><a href="findbugs.html" title="FindBugs">FindBugs</a></li>
       <li class="none"><strong>CPD</strong></li>
       <li class="none"><a href="pmd.html" title="PMD">PMD</a></li>
       <li class="none"><a href="xref/index.html" title="Source Xref">Source Xref</a></li>
       <li class="none"><a href="xref-test/index.html" title="Test Source Xref">Test Source Xref</a></li>
      </ul></li>
    </ul>
      <a href="http://maven.apache.org/" title="Built by Maven" class="poweredBy">
        <img class="poweredBy" alt="Built by Maven" src="./images/logos/maven-feather.png" />
      </a>
      </div>
    </div>
    <div id="bodyColumn">
      <div id="contentBox">
<div class="section">
<h2><a name="CPD_Results"></a>CPD Results</h2>
<p>The following document contains the results of PMD's  <a class="externalLink" href="http://pmd.sourceforge.net/cpd.html">CPD</a> 6.4.0.</p></div>
<div class="section">
<h2><a name="Duplications"></a>Duplications</h2>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/INSLooselyCoupledKalmanState.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/INSLooselyCoupledKalmanState.html#L1193">1193</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/INSTightlyCoupledKalmanState.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/INSTightlyCoupledKalmanState.html#L1366">1366</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    }

    /**
     * Gets Kalman filter error covariance matrix.
     * Notice that covariance is expressed in terms of ECEF coordinates.
     * If accuracy of position, attitude or velocity needs to be expressed in terms
     * of NED coordinates, their respective submatrices of this covariance matrix
     * must be rotated, taking into account the Jacobian of the matrix transformation
     * relating both coordinates, the covariance can be expressed following the law
     * of propagation of uncertainties (https://en.wikipedia.org/wiki/Propagation_of_uncertainty)
     * as: cov(f(x)) = J*cov(x)*J'.
     *
     * @param result instance where result data will be copied to.
     * @return true if result data has been copied, false otherwise.
     */
    public boolean getCovariance(final Matrix result) {
        if (mCovariance != null) {
            mCovariance.copyTo(result);
            return true;
        } else {
            return false;
        }
    }

    /**
     * Gets Kalman filter error covariance matrix.
     * Notice that covariance is expressed in terms of ECEF coordinates.
     * If accuracy of position, attitude or velocity needs to be expressed in terms
     * of NED coordinates, their respective submatrices of this covariance matrix
     * must be rotated, taking into account the Jacobian of the matrix transformation
     * relating both coordinates, the covariance can be expressed following the law
     * of propagation of uncertainties (https://en.wikipedia.org/wiki/Propagation_of_uncertainty)
     * as: cov(f(x)) = J*cov(x)*J'.
     *
     * @return Kalman filter error covariance matrix.
     */
    public Matrix getCovariance() {
        return mCovariance;
    }

    /**
     * Sets Kalman filter error covariance matrix.
     *
     * @param covariance Kalman filter error covariance matrix to be set.
     * @throws IllegalArgumentException if provided covariance matrix is not 15x15.
     */
    public void setCovariance(final Matrix covariance) {
        if (covariance.getRows() != NUM_PARAMS ||
                covariance.getColumns() != NUM_PARAMS) {
            throw new IllegalArgumentException();
        }

        mCovariance = covariance;
    }

    /**
     * Gets body to ECEF coordinate transformation.
     *
     * @return body to ECEF coordinate transformation.
     * @throws InvalidRotationMatrixException if current body to ECEF transformation matrix is
     *                                        not valid (is not a 3x3 orthonormal matrix).
     */
    public CoordinateTransformation getC() throws InvalidRotationMatrixException {
        return mBodyToEcefCoordinateTransformationMatrix != null ?
                new CoordinateTransformation(mBodyToEcefCoordinateTransformationMatrix,
                        FrameType.BODY_FRAME, FrameType.EARTH_CENTERED_EARTH_FIXED_FRAME) : null;
    }

    /**
     * Gets body to ECEF coordinate transformation.
     *
     * @param threshold threshold to determine whether current body to ECEF transformation
     *                  matrix is valid or not (to check that matrix is 3x3 orthonormal).
     * @return body to ECEF coordinate transformation.
     * @throws InvalidRotationMatrixException if current body to ECEF transformation matrix
     *                                        is considered not valid (is not a 3x3 orthonormal matrix) with provided threshold.
     */
    public CoordinateTransformation getC(final double threshold) throws InvalidRotationMatrixException {
        return mBodyToEcefCoordinateTransformationMatrix != null ?
                new CoordinateTransformation(mBodyToEcefCoordinateTransformationMatrix,
                        FrameType.BODY_FRAME, FrameType.EARTH_CENTERED_EARTH_FIXED_FRAME, threshold) : null;
    }

    /**
     * Gets body to ECEF coordinate transformation.
     *
     * @param result instance where body to ECEF coordinate transformation will be stored.
     * @return true if result instance was updated, false otherwise.
     * @throws InvalidRotationMatrixException if current body to ECEF transformation matrix
     *                                        is not valid (is not a 3x3 orthonormal matrix).
     */
    public boolean getC(final CoordinateTransformation result) throws InvalidRotationMatrixException {
        if (mBodyToEcefCoordinateTransformationMatrix != null) {
            result.setSourceType(FrameType.BODY_FRAME);
            result.setDestinationType(FrameType.EARTH_CENTERED_EARTH_FIXED_FRAME);
            result.setMatrix(mBodyToEcefCoordinateTransformationMatrix);
            return true;
        } else {
            return false;
        }
    }

    /**
     * Gets body to ECEF coordinate transformation.
     *
     * @param result    instance where body to ECEF coordinate transformation will be stored.
     * @param threshold threshold to determine whether current body to ECEF transformation
     *                  matrix is valid or not (to check that matrix is 3x3 orthonormal).
     * @return true if result instance was updated, false otherwise.
     * @throws InvalidRotationMatrixException if current body to ECEF transformation matrix
     *                                        is not valid (is not a 3x3 orthonormal matrix) with provided threshold.
     */
    public boolean getC(final CoordinateTransformation result,
                        final double threshold) throws InvalidRotationMatrixException {
        if (mBodyToEcefCoordinateTransformationMatrix != null) {
            result.setSourceType(FrameType.BODY_FRAME);
            result.setDestinationType(FrameType.EARTH_CENTERED_EARTH_FIXED_FRAME);
            result.setMatrix(mBodyToEcefCoordinateTransformationMatrix, threshold);
            return true;
        } else {
            return false;
        }
    }

    /**
     * Sets body to ECEF coordinate transformation.
     *
     * @param c body to ECEF coordinate transformation to be set.
     * @throws IllegalArgumentException if provided coordinate transformation is
     * not null and is not a body to ECEF transformation.
     */
    public void setC(final CoordinateTransformation c) {
        if (c == null) {
            mBodyToEcefCoordinateTransformationMatrix = null;

        } else {

            if (c.getSourceType() != FrameType.BODY_FRAME ||
                    c.getDestinationType() != FrameType.EARTH_CENTERED_EARTH_FIXED_FRAME) {
                throw new IllegalArgumentException();
            }

            if (mBodyToEcefCoordinateTransformationMatrix != null) {
                c.getMatrix(mBodyToEcefCoordinateTransformationMatrix);
            } else {
                mBodyToEcefCoordinateTransformationMatrix = c.getMatrix();
            }
        }
    }

    /**
     * Gets estimated ECEF user velocity resolved around x axis.
     *
     * @param result instance where estimated ECEF user velocity resolved around x axis will be stored.
     */
    public void getSpeedX(final Speed result) {
        result.setValue(mVx);
        result.setUnit(SpeedUnit.METERS_PER_SECOND);
    }

    /**
     * Gets estimated ECEF user velocity resolved around x axis.
     *
     * @return estimated ECEF user velocity resolved around x axis.
     */
    public Speed getSpeedX() {
        return new Speed(mVx, SpeedUnit.METERS_PER_SECOND);
    }

    /**
     * Sets estimated ECEF user velocity resolved around x axis.
     *
     * @param vx estimated ECEF user velocity resolved around x axis.
     */
    public void setSpeedX(final Speed vx) {
        mVx = SpeedConverter.convert(vx.getValue().doubleValue(),
                vx.getUnit(), SpeedUnit.METERS_PER_SECOND);
    }

    /**
     * Gets estimated ECEF user velocity resolved around y axis.
     *
     * @param result instance where estimated ECEF user velocity resolved around y axis will be stored.
     */
    public void getSpeedY(final Speed result) {
        result.setValue(mVy);
        result.setUnit(SpeedUnit.METERS_PER_SECOND);
    }

    /**
     * Gets estimated ECEF user velocity resolved around y axis.
     *
     * @return estimated ECEF velocity resolved around y axis.
     */
    public Speed getSpeedY() {
        return new Speed(mVy, SpeedUnit.METERS_PER_SECOND);
    }

    /**
     * Sets estimated ECEF user velocity resolved around y axis.
     *
     * @param vy estimated ECEF user velocity resolved around y axis.
     */
    public void setSpeedY(final Speed vy) {
        mVy = SpeedConverter.convert(vy.getValue().doubleValue(),
                vy.getUnit(), SpeedUnit.METERS_PER_SECOND);
    }

    /**
     * Gets estimated ECEF user velocity resolved around z axis.
     *
     * @param result instance where estimated ECEF user velocity resolved around z axis will be stored.
     */
    public void getSpeedZ(final Speed result) {
        result.setValue(mVz);
        result.setUnit(SpeedUnit.METERS_PER_SECOND);
    }

    /**
     * Gets estimated ECEF user velocity resolved around z axis.
     *
     * @return estimated ECEF velocity resolved around z axis.
     */
    public Speed getSpeedZ() {
        return new Speed(mVz, SpeedUnit.METERS_PER_SECOND);
    }

    /**
     * Sets estimated ECEF user velocity resolved around z axis.
     *
     * @param vz estimated ECEF velocity resolved around z axis.
     */
    public void setSpeedZ(final Speed vz) {
        mVz = SpeedConverter.convert(vz.getValue().doubleValue(),
                vz.getUnit(), SpeedUnit.METERS_PER_SECOND);
    }

    /**
     * Sets estimated ECEF user velocity.
     *
     * @param vx estimated ECEF velocity resolved around x axis.
     * @param vy estimated ECEF velocity resolved around y axis.
     * @param vz estimated ECEF velocity resolved around z axis.
     */
    public void setVelocityCoordinates(
            final Speed vx, final Speed vy, final Speed vz) {
        setSpeedX(vx);
        setSpeedY(vy);
        setSpeedZ(vz);
    }

    /**
     * Gets estimated ECEF user velocity.
     *
     * @param result instance where estimated ECEF user velocity will be stored.
     */
    public void getEcefVelocity(final ECEFVelocity result) {
        result.setCoordinates(mVx, mVy, mVz);
    }

    /**
     * Gets estimated ECEF user velocity.
     *
     * @return estimated ECEF user velocity.
     */
    public ECEFVelocity getEcefVelocity() {
        return new ECEFVelocity(mVx, mVy, mVz);
    }

    /**
     * Sets estimated ECEF user velocity.
     *
     * @param ecefVelocity estimated ECEF user velocity.
     */
    public void setEcefVelocity(final ECEFVelocity ecefVelocity) {
        mVx = ecefVelocity.getVx();
        mVy = ecefVelocity.getVy();
        mVz = ecefVelocity.getVz();
    }

    /**
     * Gets x coordinate of estimated ECEF user position.
     *
     * @param result instance where x coordinate of estimated ECEF user position
     *               will be stored.
     */
    public void getDistanceX(final Distance result) {
        result.setValue(mX);
        result.setUnit(DistanceUnit.METER);
    }

    /**
     * Gets x coordinate of estimated ECEF user position.
     *
     * @return x coordinate of estimated ECEF user position.
     */
    public Distance getDistanceX() {
        return new Distance(mX, DistanceUnit.METER);
    }

    /**
     * Sets x coordinate of estimated ECEF user position.
     *
     * @param x x coordinate of estimated ECEF user position.
     */
    public void setDistanceX(final Distance x) {
        mX = DistanceConverter.convert(x.getValue().doubleValue(),
                x.getUnit(), DistanceUnit.METER);
    }

    /**
     * Gets y coordinate of estimated ECEF user position.
     *
     * @param result instance where y coordinate of estimated ECEF user position
     *               will be stored.
     */
    public void getDistanceY(final Distance result) {
        result.setValue(mY);
        result.setUnit(DistanceUnit.METER);
    }

    /**
     * Gets y coordinate of estimated ECEF user position.
     *
     * @return y coordinate of estimated ECEF user position.
     */
    public Distance getDistanceY() {
        return new Distance(mY, DistanceUnit.METER);
    }

    /**
     * Sets y coordinate of estimated ECEF user position.
     *
     * @param y y coordinate of estimated ECEF user position.
     */
    public void setDistanceY(final Distance y) {
        mY = DistanceConverter.convert(y.getValue().doubleValue(),
                y.getUnit(), DistanceUnit.METER);
    }

    /**
     * Gets z coordinate of estimated ECEF user position.
     *
     * @param result instance where z coordinate of estimated ECEF user position
     *               will be stored.
     */
    public void getDistanceZ(final Distance result) {
        result.setValue(mZ);
        result.setUnit(DistanceUnit.METER);
    }

    /**
     * Gets z coordinate of estimated ECEF user position.
     *
     * @return z coordinate of estimated ECEF user position.
     */
    public Distance getDistanceZ() {
        return new Distance(mZ, DistanceUnit.METER);
    }

    /**
     * Sets z coordinate of estimated ECEF user position.
     *
     * @param z z coordinate of estimated ECEF user position.
     */
    public void setDistanceZ(final Distance z) {
        mZ = DistanceConverter.convert(z.getValue().doubleValue(),
                z.getUnit(), DistanceUnit.METER);
    }

    /**
     * Sets coordinates of estimated ECEF user position.
     *
     * @param x x coordinate of estimated ECEF user position.
     * @param y y coordinate of estimated ECEF user position.
     * @param z z coordinate of estimated ECEF user position.
     */
    public void setPositionCoordinates(final Distance x, final Distance y, final Distance z) {
        setDistanceX(x);
        setDistanceY(y);
        setDistanceZ(z);
    }

    /**
     * Gets estimated ECEF user position expressed in meters (m).
     *
     * @param result instance where estimated ECEF user position expressed
     *               in meters (m) will be stored.
     */
    public void getPosition(final Point3D result) {
        result.setInhomogeneousCoordinates(mX, mY, mZ);
    }

    /**
     * Gets estimated ECEF user position expressed in meters (m).
     *
     * @return estimated ECEF user position expressed in meters (m).
     */
    public Point3D getPosition() {
        return new InhomogeneousPoint3D(mX, mY, mZ);
    }

    /**
     * Sets estimated ECEF user position expressed in meters (m).
     *
     * @param position estimated ECEF user position expressed in
     *                 meters (m).
     */
    public void setPosition(final Point3D position) {
        mX = position.getInhomX();
        mY = position.getInhomY();
        mZ = position.getInhomZ();
    }

    /**
     * Gets estimated ECEF user position.
     *
     * @param result instance where estimated ECEF user position
     *               will be stored.
     */
    public void getEcefPosition(final ECEFPosition result) {
        result.setCoordinates(mX, mY, mZ);
    }

    /**
     * Gets estimated ECEF user position.
     *
     * @return estimated ECEF user position.
     */
    public ECEFPosition getEcefPosition() {
        return new ECEFPosition(mX, mY, mZ);
    }

    /**
     * Sets estimated ECEF user position.
     *
     * @param ecefPosition estimated ECEF user position.
     */
    public void setEcefPosition(final ECEFPosition ecefPosition) {
        mX = ecefPosition.getX();
        mY = ecefPosition.getY();
        mZ = ecefPosition.getZ();
    }

    /**
     * Gets estimated ECEF user position and velocity.
     *
     * @param result instance where estimated ECEF user position and velocity
     *               will be stored.
     */
    public void getPositionAndVelocity(final ECEFPositionAndVelocity result) {
        result.setPositionCoordinates(mX, mY, mZ);
        result.setVelocityCoordinates(mVx, mVy, mVz);
    }

    /**
     * Gets estimated ECEF user position and velocity.
     *
     * @return estimated ECEF user position and velocity.
     */
    public ECEFPositionAndVelocity getPositionAndVelocity() {
        return new ECEFPositionAndVelocity(mX, mY, mZ, mVx, mVy, mVz);
    }

    /**
     * Sets estimated ECEF user position and velocity.
     *
     * @param positionAndVelocity estimated ECEF user position and velocity.
     */
    public void setPositionAndVelocity(final ECEFPositionAndVelocity positionAndVelocity) {
        mX = positionAndVelocity.getX();
        mY = positionAndVelocity.getY();
        mZ = positionAndVelocity.getZ();
        mVx = positionAndVelocity.getVx();
        mVy = positionAndVelocity.getVy();
        mVz = positionAndVelocity.getVz();
    }

    /**
     * Gets body to ECEF frame containing coordinate transformation, position and
     * velocity.
     *
     * @param result instance where body to ECEF frame will be stored.
     * @return true if result was updated, false otherwise.
     */
    public boolean getFrame(ECEFFrame result) {
        if (mBodyToEcefCoordinateTransformationMatrix != null) {
            try {
                result.setCoordinateTransformation(getC());
            } catch (final InvalidSourceAndDestinationFrameTypeException
                    | InvalidRotationMatrixException e) {
                return false;
            }
            result.setCoordinates(mX, mY, mZ);
            result.setVelocityCoordinates(mVx, mVy, mVz);
            return true;
        } else {
            return false;
        }
    }

    /**
     * Gets body to ECEF frame containing coordinate transformation, position and
     * velocity.
     *
     * @return body to ECEF frame.
     */
    public ECEFFrame getFrame() {
        if (mBodyToEcefCoordinateTransformationMatrix != null) {
            try {
                return new ECEFFrame(mX, mY, mZ, mVx, mVy, mVz, getC());
            } catch (final InvalidSourceAndDestinationFrameTypeException
                    | InvalidRotationMatrixException e) {
                return null;
            }
        } else {
            return null;
        }
    }

    /**
     * Sets body to ECEF frame containing coordinate transformation, position and
     * velocity.
     *
     * @param frame body to ECEF frame to be set.
     */
    public void setFrame(final ECEFFrame frame) {
        mX = frame.getX();
        mY = frame.getY();
        mZ = frame.getZ();

        mVx = frame.getVx();
        mVy = frame.getVy();
        mVz = frame.getVz();

        if (mBodyToEcefCoordinateTransformationMatrix != null) {
            frame.getCoordinateTransformationMatrix(mBodyToEcefCoordinateTransformationMatrix);
        } else {
            mBodyToEcefCoordinateTransformationMatrix = frame.getCoordinateTransformationMatrix();
        }
    }

    /**
     * Gets estimated accelerometer bias resolved around x axis.
     *
     * @param result instance where estimated accelerometer bias resolved around
     *               x axis will be stored.
     */
    public void getAccelerationBiasXAsAcceleration(final Acceleration result) {
        result.setValue(mAccelerationBiasX);
        result.setUnit(AccelerationUnit.METERS_PER_SQUARED_SECOND);
    }

    /**
     * Gets estimated accelerometer bias resolved around x axis.
     *
     * @return estimated accelerometer bias resolved around x axis.
     */
    public Acceleration getAccelerationBiasXAsAcceleration() {
        return new Acceleration(mAccelerationBiasX,
                AccelerationUnit.METERS_PER_SQUARED_SECOND);
    }

    /**
     * Sets estimated accelerometer bias resolved around x axis.
     *
     * @param accelerationBiasX estimated accelerometer bias resolved
     *                          around x axis.
     */
    public void setAccelerationBiasX(final Acceleration accelerationBiasX) {
        mAccelerationBiasX = AccelerationConverter.convert(
                accelerationBiasX.getValue().doubleValue(),
                accelerationBiasX.getUnit(),
                AccelerationUnit.METERS_PER_SQUARED_SECOND);
    }

    /**
     * Gets estimated accelerometer bias resolved around y axis.
     *
     * @param result instance where estimated accelerometer bias resolved around
     *               y axis will be stored.
     */
    public void getAccelerationBiasYAsAcceleration(final Acceleration result) {
        result.setValue(mAccelerationBiasY);
        result.setUnit(AccelerationUnit.METERS_PER_SQUARED_SECOND);
    }

    /**
     * Gets estimated accelerometer bias resolved around y axis.
     *
     * @return estimated accelerometer bias resolved around y axis.
     */
    public Acceleration getAccelerationBiasYAsAcceleration() {
        return new Acceleration(mAccelerationBiasY,
                AccelerationUnit.METERS_PER_SQUARED_SECOND);
    }

    /**
     * Sets estimated accelerometer bias resolved around y axis.
     *
     * @param accelerationBiasY estimated accelerometer bias resolved
     *                          around y axis.
     */
    public void setAccelerationBiasY(final Acceleration accelerationBiasY) {
        mAccelerationBiasY = AccelerationConverter.convert(
                accelerationBiasY.getValue().doubleValue(),
                accelerationBiasY.getUnit(),
                AccelerationUnit.METERS_PER_SQUARED_SECOND);
    }

    /**
     * Gets estimated accelerometer bias resolved around z axis.
     *
     * @param result instance where estimated accelerometer bias resolved around
     *               z axis will be stored.
     */
    public void getAccelerationBiasZAsAcceleration(final Acceleration result) {
        result.setValue(mAccelerationBiasZ);
        result.setUnit(AccelerationUnit.METERS_PER_SQUARED_SECOND);
    }

    /**
     * Gets estimated accelerometer bias resolved around z axis.
     *
     * @return estimated accelerometer bias resolved around z axis.
     */
    public Acceleration getAccelerationBiasZAsAcceleration() {
        return new Acceleration(mAccelerationBiasZ,
                AccelerationUnit.METERS_PER_SQUARED_SECOND);
    }

    /**
     * Sets estimated accelerometer bias resolved around z axis.
     *
     * @param accelerationBiasZ estimated accelerometer bias resolved
     *                          around z axis.
     */
    public void setAccelerationBiasZ(final Acceleration accelerationBiasZ) {
        mAccelerationBiasZ = AccelerationConverter.convert(
                accelerationBiasZ.getValue().doubleValue(),
                accelerationBiasZ.getUnit(),
                AccelerationUnit.METERS_PER_SQUARED_SECOND);
    }

    /**
     * Sets estimated accelerometer bias coordinates.
     *
     * @param accelerationBiasX estimated accelerometer bias resolved around x axis.
     * @param accelerationBiasY estimated accelerometer bias resolved around y axis.
     * @param accelerationBiasZ estimated accelerometer bias resolved around z axis.
     */
    public void setAccelerationBiasCoordinates(
            final Acceleration accelerationBiasX, final Acceleration accelerationBiasY,
            final Acceleration accelerationBiasZ) {
        setAccelerationBiasX(accelerationBiasX);
        setAccelerationBiasY(accelerationBiasY);
        setAccelerationBiasZ(accelerationBiasZ);
    }

    /**
     * Gets estimated gyroscope bias resolved around x axis.
     *
     * @param result instance where estimated gyroscope bias resolved around x axis will
     *               be stored.
     */
    public void getAngularSpeedGyroBiasX(final AngularSpeed result) {
        result.setValue(mGyroBiasX);
        result.setUnit(AngularSpeedUnit.RADIANS_PER_SECOND);
    }

    /**
     * Gets estimated gyroscope bias resolved around x axis.
     *
     * @return estimated gyroscope bias resolved around x axis.
     */
    public AngularSpeed getAngularSpeedGyroBiasX() {
        return new AngularSpeed(mGyroBiasX, AngularSpeedUnit.RADIANS_PER_SECOND);
    }

    /**
     * Sets estimated gyroscope bias resolved around x axis.
     *
     * @param gyroBiasX estimated gyroscope bias resolved around x axis.
     */
    public void setGyroBiasX(final AngularSpeed gyroBiasX) {
        mGyroBiasX = AngularSpeedConverter.convert(
                gyroBiasX.getValue().doubleValue(),
                gyroBiasX.getUnit(), AngularSpeedUnit.RADIANS_PER_SECOND);
    }

    /**
     * Gets estimated gyroscope bias resolved around y axis.
     *
     * @param result instance where estimated gyroscope bias resolved around y axis will
     *               be stored.
     */
    public void getAngularSpeedGyroBiasY(final AngularSpeed result) {
        result.setValue(mGyroBiasY);
        result.setUnit(AngularSpeedUnit.RADIANS_PER_SECOND);
    }

    /**
     * Gets estimated gyroscope bias resolved around y axis.
     *
     * @return estimated gyroscope bias resolved around y axis.
     */
    public AngularSpeed getAngularSpeedGyroBiasY() {
        return new AngularSpeed(mGyroBiasY, AngularSpeedUnit.RADIANS_PER_SECOND);
    }

    /**
     * Sets estimated gyroscope bias resolved around y axis.
     *
     * @param gyroBiasY estimated gyroscope bias resolved around y axis.
     */
    public void setGyroBiasY(final AngularSpeed gyroBiasY) {
        mGyroBiasY = AngularSpeedConverter.convert(
                gyroBiasY.getValue().doubleValue(),
                gyroBiasY.getUnit(), AngularSpeedUnit.RADIANS_PER_SECOND);
    }

    /**
     * Gets estimated gyroscope bias resolved around z axis.
     *
     * @param result instance where estimated gyroscope bias resolved around z axis will
     *               be stored.
     */
    public void getAngularSpeedGyroBiasZ(final AngularSpeed result) {
        result.setValue(mGyroBiasZ);
        result.setUnit(AngularSpeedUnit.RADIANS_PER_SECOND);
    }

    /**
     * Gets estimated gyroscope bias resolved around z axis.
     *
     * @return estimated gyroscope bias resolved around z axis.
     */
    public AngularSpeed getAngularSpeedGyroBiasZ() {
        return new AngularSpeed(mGyroBiasZ, AngularSpeedUnit.RADIANS_PER_SECOND);
    }

    /**
     * Sets estimated gyroscope bias resolved around z axis.
     *
     * @param gyroBiasZ estimated gyroscope bias resolved around z axis.
     */
    public void setGyroBiasZ(final AngularSpeed gyroBiasZ) {
        mGyroBiasZ = AngularSpeedConverter.convert(
                gyroBiasZ.getValue().doubleValue(),
                gyroBiasZ.getUnit(), AngularSpeedUnit.RADIANS_PER_SECOND);
    }

    /**
     * Sets estimated gyroscope bias coordinates.
     *
     * @param gyroBiasX estimated gyroscope bias resolved around x axis.
     * @param gyroBiasY estimated gyroscope bias resolved around y axis.
     * @param gyroBiasZ estimated gyroscope bias resolved around z axis.
     */
    public void setGyroBiasCoordinates(
            final AngularSpeed gyroBiasX, final AngularSpeed gyroBiasY,
            final AngularSpeed gyroBiasZ) {
        setGyroBiasX(gyroBiasX);
        setGyroBiasY(gyroBiasY);
        setGyroBiasZ(gyroBiasZ);
    }

    /**
     * Copies this instance data into provided instance.
     *
     * @param output destination instance where data will be copied to.
     */
    public void copyTo(final INSLooselyCoupledKalmanState output) {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/SequentialRobustMixedPositionEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/SequentialRobustMixedPositionEstimator.html#L714">714</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/SequentialRobustRangingAndRssiPositionEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/SequentialRobustRangingAndRssiPositionEstimator.html#L688">688</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>            SequentialRobustMixedPositionEstimatorListener&lt;P&gt; listener) {
        this(sourceQualityScores, fingerprintReadingQualityScores, sources,
                fingerprint);
        mListener = listener;
    }

    /**
     * Gets robust method used for robust position estimation using ranging data.
     *
     * @return robust method used for robust position estimation using ranging data.
     */
    public RobustEstimatorMethod getRangingRobustMethod() {
        return mRangingRobustMethod;
    }

    /**
     * Sets robust method for robust position estimation using ranging data.
     *
     * @param rangingRobustMethod   robust method used for robust position estimation
     *                              using ranging data.
     * @throws LockedException  if this instance is locked.
     */
    public void setRangingRobustMethod(RobustEstimatorMethod rangingRobustMethod)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }

        mRangingRobustMethod = rangingRobustMethod;
    }

    /**
     * Gets robust method used for coarse robust position estimation using RSSI data.
     *
     * @return robust method used for coarse robust position estimation using RSSI
     * data.
     */
    public RobustEstimatorMethod getRssiRobustMethod() {
        return mRssiRobustMethod;
    }

    /**
     * Sets robust method used for coarse robust position estimation using RSSI data.
     *
     * @param rssiRobustMethod  robust method used for coarse robust position estimation
     *                          using RSSI data.
     * @throws LockedException  if this instance is locked.
     */
    public void setRssiRobustMethod(RobustEstimatorMethod rssiRobustMethod)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }

        mRssiRobustMethod = rssiRobustMethod;
    }

    /**
     * Indicates whether located radio source position covariance is taken into account
     * (if available) to determine distance standard deviation for ranging measurements.
     * @return true to take into account radio source position covariance during ranging
     * position estimation, false otherwise.
     */
    public boolean isRangingRadioSourcePositionCovarianceUsed() {
        return mUseRangingRadioSourcePositionCovariance;
    }

    /**
     * Specifies whether located radio source position covariance is taken into account
     * (if available) to determine distance standard deviation for ranging measurements.
     * @param useRangingRadioSourcePositionCovariance   true to take into account radio
     *                                                  source position covariance during
     *                                                  ranging position estimation,
     *                                                  false otherwise.
     * @throws LockedException  if this instance is locked.
     */
    public void setRangingRadioSourcePositionCovarianceUsed(
            boolean useRangingRadioSourcePositionCovariance) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }

        mUseRangingRadioSourcePositionCovariance =
                useRangingRadioSourcePositionCovariance;
    }

    /**
     * Indicates whether located radio source position covariance is taken into account
     * (if available) to determine distance standard deviation for RSSI measurements.
     *
     * @return true to take into account radio source position covariance during RSSI
     * position estimation, false otherwise.
     */
    public boolean isRssiRadioSourcePositionCovarianceUsed() {
        return mUseRssiRadioSourcePositionCovariance;
    }

    /**
     * Specifies whether located radio source position covariance is taken into account
     * (if available) to determine distance standard deviation for RSSI measurements.
     * @param useRssiRadioSourcePositionCovariance  true to take into account radio
     *                                              source position covariance during
     *                                              RSSI position estimation, false
     *                                              otherwise.
     * @throws LockedException if this instance is locked.
     */
    public void setRssiRadioSourcePositionCovarianceUsed(
            boolean useRssiRadioSourcePositionCovariance) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }

        mUseRssiRadioSourcePositionCovariance = useRssiRadioSourcePositionCovariance;
    }

    /**
     * Indicates whether ranging readings are evenly distributed among radio sources
     * taking into account quality scores of both radio sources and ranging readings.
     *
     * @return true if ranging readings are evenly distributed among radio sources,
     * false otherwise.
     */
    public boolean isRangingReadingsEvenlyDistributed() {
        return mEvenlyDistributeRangingReadings;
    }

    /**
     * Specifies whether ranging readings are evenly distributed among radio sources
     * taking into account quality scores of both radio sources and ranging readings.
     *
     * @param evenlyDistributeRangingReadings   true if ranging readings are evenly
     *                                          distributed among radio sources, false
     *                                          otherwise.
     * @throws LockedException if this instance is locked.
     */
    public void setRangingReadingsEvenlyDistributed(
            boolean evenlyDistributeRangingReadings) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }

        mEvenlyDistributeRangingReadings = evenlyDistributeRangingReadings;
    }

    /**
     * Gets distance standard deviation fallback value to use when none can be
     * determined from provided RSSI measurements.
     *
     * @return distance standard deviation fallback value to use when none can be
     * determined from provided RSSI measurements.
     */
    public double getRssiFallbackDistanceStandardDeviation() {
        return mRssiFallbackDistanceStandardDeviation;
    }

    /**
     * Sets distance standard deviation fallback value to use when none can be
     * determined from provided RSSI measurements.
     *
     * @param rssiFallbackDistanceStandardDeviation distance standard deviation fallback
     *                                              value to use when none can be
     *                                              determined from provided RSSI
     *                                              measurements.
     * @throws LockedException if this instance is locked.
     */
    public void setRssiFallbackDistanceStandardDeviation(
            double rssiFallbackDistanceStandardDeviation) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mRssiFallbackDistanceStandardDeviation = rssiFallbackDistanceStandardDeviation;
    }

    /**
     * Gets distance standard deviation fallback value to use when none can be
     * determined from provided ranging measurements.
     *
     * @return distance standard deviation fallback value to use when none can be
     * determined from provided ranging measurements.
     */
    public double getRangingFallbackDistanceStandardDeviation() {
        return mRangingFallbackDistanceStandardDeviation;
    }

    /**
     * Sets distance standard deviation fallback value to use when none can be
     * determined from provided ranging measurements.
     *
     * @param rangingFallbackDistanceStandardDeviation  distance standard deviation
     *                                                  fallback value to use when none
     *                                                  can be determined from provided
     *                                                  ranging measurements.
     * @throws LockedException if this instance is locked.
     */
    public void setRangingFallbackDistanceStandardDeviation(
            double rangingFallbackDistanceStandardDeviation) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mRangingFallbackDistanceStandardDeviation =
                rangingFallbackDistanceStandardDeviation;
    }

    /**
     * Indicates whether RSSI readings are evenly distributed among radio sources
     * taking into account quality scores of both radio sources and RSSI readings.
     *
     * @return true if RSSI readings are evenly distributed among radio sources,
     * false otherwise.
     */
    public boolean isRssiReadingsEvenlyDistributed() {
        return mEvenlyDistributeRssiReadings;
    }

    /**
     * Specifies whether RSSI readings are evenly distributed among radio sources
     * taking into account quality scores of both radio sources and RSSI readings.
     *
     * @param evenlyDistributeRssiReadings  true if RSSI readings are evenly distributed
     *                                      among radio sources, false otherwise.
     * @throws LockedException if this instance is locked.
     */
    public void setRssiReadingsEvenlyDistributed(
            boolean evenlyDistributeRssiReadings) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }

        mEvenlyDistributeRssiReadings = evenlyDistributeRssiReadings;
    }

    /**
     * Gets amount of progress variation before notifying a progress change during
     * estimation.
     *
     * @return amount of progress variation before notifying a progress change during
     * estimation.
     */
    public float getProgressDelta() {
        return mProgressDelta;
    }

    /**
     * Sets amount of progress variation before notifying a progress change during
     * estimation.
     *
     * @param progressDelta amount of progress variation before notifying a progress
     *                      change during estimation.
     * @throws IllegalArgumentException if progress delta is less than zero or
     * greater than 1.
     * @throws LockedException          if this instance is locked.
     */
    public void setProgressDelta(float progressDelta) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (progressDelta &lt; MIN_PROGRESS_DELTA || progressDelta &gt; MAX_PROGRESS_DELTA) {
            throw new IllegalArgumentException();
        }
        mProgressDelta = progressDelta;
    }

    /**
     * Returns amount of confidence expressed as a value between 0.0 and 1.0 (which
     * is equivalent to 100%) for robust position estimation on ranging data. The
     * amount of confidence indicates the probability that the estimated result is
     * correct. Usually this value will be close to 1.0, but not exactly 1.0.
     *
     * @return amount of confidence for robust position estimation as a value between
     * 0.0 and 1.0.
     */
    public double getRangingConfidence() {
        return mRangingConfidence;
    }

    /**
     * Sets amount of confidence expressed as a value between 0.0 and 1.0 (which is
     * equivalent to 100%) for robust position estimation on ranging data. The amount
     * of confidence indicates the probability that the estimated result is correct.
     * Usually this value will be close to 1.0, but not exactly 1.0.
     *
     * @param rangingConfidence confidence to be set for robust position estimation as
     *                          a value between 0.0 and 1.0.
     * @throws IllegalArgumentException if provided value is not between 0.0 and 1.0.
     * @throws LockedException          if estimator is locked.
     */
    public void setRangingConfidence(double rangingConfidence) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (rangingConfidence &lt; MIN_CONFIDENCE || rangingConfidence &gt; MAX_CONFIDENCE) {
            throw new IllegalArgumentException();
        }
        mRangingConfidence = rangingConfidence;
    }

    /**
     * Returns amount of confidence expressed as a value between 0.0 and 1.0 (which is
     * equivalent to 100%) for robust position estimation on RSSI data. The amount of
     * confidence indicates the probability that the estimated result is correct.
     * Usually this value will be close to 1.0, but not exactly 1.0.
     *
     * @return amount of confidence for robust position estimation as a value between
     * 0.0 and 1.0.
     */
    public double getRssiConfidence() {
        return mRssiConfidence;
    }

    /**
     * Sets amount of confidence expressed as a value between 0.0 and 1.0 (which is
     * equivalent to 100%) for robust position estimation on RSSI data. The amount
     * of confidence indicates the probability that the estimated result is correct.
     * Usually this value will be close to 1.0, but not exactly 1.0.
     *
     * @param rssiConfidence    amount of confidence for robust position estimation as
     *                          a value between 0.0 and 1.0.
     * @throws IllegalArgumentException if provided value is not between 0.0 and 1.0.
     * @throws LockedException          if estimator is locked.
     */
    public void setRssiConfidence(double rssiConfidence) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (rssiConfidence &lt; MIN_CONFIDENCE || rssiConfidence &gt; MAX_CONFIDENCE) {
            throw new IllegalArgumentException();
        }
        mRssiConfidence = rssiConfidence;
    }

    /**
     * Gets maximum allowed number of iterations for robust ranging position estimation.
     * When the maximum number of iterations is exceeded, an approximate result might
     * be available for retrieval.
     *
     * @return maximum allowed number of iterations for position estimation.
     */
    public int getRangingMaxIterations() {
        return mRangingMaxIterations;
    }

    /**
     * Sets maximum allowed number of iterations for robust ranging position
     * estimation.
     * When the maximum number of iterations is exceeded, an approximate result might
     * be available for retrieval.
     *
     * @param rangingMaxIterations  maximum allowed number of iterations to be set for
     *                              position estimation.
     * @throws IllegalArgumentException if provided value is less than 1.
     * @throws LockedException          if estimator is locked.
     */
    public void setRangingMaxIterations(int rangingMaxIterations)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (rangingMaxIterations &lt; MIN_ITERATIONS) {
            throw new IllegalArgumentException();
        }
        mRangingMaxIterations = rangingMaxIterations;
    }

    /**
     * Gets maximum allowed number of iterations for robust RSSI position estimation.
     * When the maximum number of iterations is exceeded, an approximate result might
     * be available for retrieval.
     *
     * @return maximum allowed number of iterations for position estimation.
     */
    public int getRssiMaxIterations() {
        return mRssiMaxIterations;
    }

    /**
     * Sets maximum allowed number of iterations for robust RSSI position estimation.
     * When the maximum number of iterations is exceeded, an approximate result might
     * be available for retrieval.
     *
     * @param rssiMaxIterations maximum allowed number of iterations to be set for
     *                          position estimation.
     * @throws IllegalArgumentException if provided value is less than 1.
     * @throws LockedException          if estimator is locked.
     */
    public void setRssiMaxIterations(int rssiMaxIterations) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (rssiMaxIterations &lt; MIN_ITERATIONS) {
            throw new IllegalArgumentException();
        }
        mRssiMaxIterations = rssiMaxIterations;
    }

    /**
     * Indicates whether result is refined using all found inliers.
     *
     * @return true if result is refined, false otherwise.
     */
    public boolean isResultRefined() {
        return mRefineResult;
    }

    /**
     * Specifies whether result is refined using all found inliers.
     *
     * @param refineResult true if result is refined, false otherwise.
     * @throws LockedException if this instance is locked.
     */
    public void setResultRefined(boolean refineResult) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }

        mRefineResult = refineResult;
    }

    /**
     * Indicates whether covariance must be kept after refining result.
     * This setting is only taken into account if result is refined.
     *
     * @return true if covariance must be kept after refining result, false otherwise.
     */
    public boolean isCovarianceKept() {
        return mKeepCovariance;
    }

    /**
     * Specifies whether covariance must be kept after refining result.
     * This setting is only taken into account if result is refined.
     *
     * @param keepCovariance true if covariance must be kept after refining result,
     *                       false otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setCovarianceKept(boolean keepCovariance) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mKeepCovariance = keepCovariance;
    }

    /**
     * Indicates whether a linear solver is used for preliminary solution estimation
     * using ranging measurements.
     * The result obtained on each preliminary solution might be later refined.
     *
     * @return true if a linear solver is used for preliminary solution estimation on
     * ranging readings.
     */
    public boolean isRangingLinearSolverUsed() {
        return mUseRangingLinearSolver;
    }

    /**
     * Specifies whether a linear solver is used for preliminary solution estimation
     * using ranging measurements.
     * The result obtained on each preliminary solution might be later refined.
     *
     * @param useRangingLinearSolver    true if a linear solver is used for preliminary
     *                                  solution estimation on ranging readings.
     * @throws LockedException if estimator is locked.
     */
    public void setRangingLinearSolverUsed(boolean useRangingLinearSolver)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mUseRangingLinearSolver = useRangingLinearSolver;
    }

    /**
     * Indicates whether a linear solver is used for preliminary solution estimation
     * using RSSI measurements.
     * The result obtained on each preliminary solution might be later refined.
     *
     * @return true if a linear solver is used for preliminary solution estimation on
     * RSSI readings.
     */
    public boolean isRssiLinearSolverUsed() {
        return mUseRssiLinearSolver;
    }

    /**
     * Specifies whether a linear solver is used for preliminary solution estimation
     * using RSSI measurements.
     * The result obtained on each preliminary solution might be later refined.
     *
     * @param useRssiLinearSolver   true if a linear solver is used for preliminary
     *                              solution estimation on RSSI readings.
     * @throws LockedException if estimator is locked.
     */
    public void setRssiLinearSolverUsed(boolean useRssiLinearSolver)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mUseRssiLinearSolver = useRssiLinearSolver;
    }

    /**
     * Indicates whether an homogeneous linear solver is used either to estimate
     * preliminary solutions or an initial solution for preliminary solutions that
     * will be later refined on the ranging fine estimation.
     *
     * @return true to use an homogeneous linear solver for preliminary solutions
     * during ranging fine position estimation.
     */
    public boolean isRangingHomogeneousLinearSolverUsed() {
        return mUseRangingHomogeneousLinearSolver;
    }

    /**
     * Specifies whether an homogeneous linear solver is used either to estimate
     * preliminary solutions or an initial solution for preliminary solutions that
     * will be later refined on the ranging fine estimation.
     *
     * @param useRangingHomogeneousLinearSolver true to use an homogeneous linear
     *                                          solver for preliminary solutions during
     *                                          ranging fine position estimation.
     * @throws LockedException if estimator is locked.
     */
    public void setRangingHomogeneousLinearSolverUsed(
            boolean useRangingHomogeneousLinearSolver) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mUseRangingHomogeneousLinearSolver = useRangingHomogeneousLinearSolver;
    }

    /**
     * Indicates whether an homogeneous linear solver is used either to estimate
     * preliminary solutions or an initial solution for preliminary solutions that
     * will be later refined on the RSSI coarse estimation.
     *
     * @return true to use an homogeneous linear solver for preliminary solutions
     * during RSSI coarse position estimation.
     */
    public boolean isRssiHomogeneousLinearSolverUsed() {
        return mUseRssiHomogeneousLinearSolver;
    }

    /**
     * Specifies whether an homogeneous linear solver is used either to estimate
     * preliminary solutions or an initial solution for preliminary solutions that
     * will be later refined on the RSSI coarse estimation.
     *
     * @param useRssiHomogeneousLinearSolver    true to use an homogeneous linear
     *                                          solver for preliminary solutions during
     *                                          RSSI fine position estimation.
     * @throws LockedException if estimator is locked.
     */
    public void setRssiHomogeneousLinearSolverUsed(
            boolean useRssiHomogeneousLinearSolver) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mUseRssiHomogeneousLinearSolver = useRssiHomogeneousLinearSolver;
    }

    /**
     * Indicates whether preliminary ranging solutions are refined after an initial
     * linear solution is found.
     * If no initial preliminary solution is found using a linear solver, a non
     * linear solver will be used regardless of this value using an average solution
     * as the initial value to be refined.
     *
     * @return true if preliminary ranging solutions must be refined after an initial
     * linear solution, false otherwise.
     */
    public boolean isRangingPreliminarySolutionRefined() {
        return mRefineRangingPreliminarySolutions;
    }

    /**
     * Specifies whether preliminary ranging solutions are refined after an initial
     * linear solution is found.
     * If no initial preliminary solution is found using a linear solver, a non
     * linear solver will be used regardless of this value using an average solution
     * as the initial value to be refined.
     *
     * @param refineRangingPreliminarySolutions true if preliminary ranging solutions
     *                                          must be refined after an initial linear
     *                                          solution, false otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setRangingPreliminarySolutionRefined(
            boolean refineRangingPreliminarySolutions) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mRefineRangingPreliminarySolutions = refineRangingPreliminarySolutions;
    }

    /**
     * Indicates whether preliminary RSSI solutions are refined after an initial
     * linear solution is found.
     * If no initial preliminary solution is found using a linear solver, a non
     * linear solver will be used regardless of this value using an average solution
     * as the initial value to be refined.
     *
     * @return true if preliminary RSSI solutions must be refined after an initial
     * linear solution, false otherwise.
     */
    public boolean isRssiPreliminarySolutionRefined() {
        return mRefineRssiPreliminarySolutions;
    }

    /**
     * Specifies whether preliminary RSSI solutions are refined after an initial
     * linear solution is found.
     * If no initial preliminary solution is found using a linear solver, a non
     * linear solver will be used regardless of this value using an average solution
     * as the initial value ot be refined.
     *
     * @param refineRssiPreliminarySolutions    true if preliminary RSSI solutions must
     *                                          be refined after an initial linear
     *                                          solution, false otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setRssiPreliminarySolutionRefined(
            boolean refineRssiPreliminarySolutions) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mRefineRssiPreliminarySolutions = refineRssiPreliminarySolutions;
    }

    /**
     * Gets size of subsets to be checked during ranging robust estimation.
     *
     * @return size of subsets to be checked during ranging robust estimation.
     */
    public int getRangingPreliminarySubsetSize() {
        return mRangingPreliminarySubsetSize;
    }

    /**
     * Sets size of subsets to be checked during ranging robust estimation.
     *
     * @param rangingPreliminarySubsetSize  size of subsets to be checked during
     *                                      ranging robust estimation.
     * @throws LockedException  if estimator is locked.
     * @throws IllegalArgumentException if provided value is less than {@link #getMinRequiredSources()}.
     */
    public void setRangingPreliminarySubsetSize(int rangingPreliminarySubsetSize)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (rangingPreliminarySubsetSize &lt; getMinRequiredSources()) {
            throw new IllegalArgumentException();
        }

        mRangingPreliminarySubsetSize = rangingPreliminarySubsetSize;
    }

    /**
     * Gets size of subsets to be checked during RSSI robust estimation.
     *
     * @return size of subsets to be checked during RSSI robust estimation.
     */
    public int getRssiPreliminarySubsetSize() {
        return mRssiPreliminarySubsetSize;
    }

    /**
     * Sets size of subsets to be checked during RSSI robust estimation.
     *
     * @param rssiPreliminarySubsetSize size of subsets to be checked during
     *                                  RSSI robust estimation.
     * @throws LockedException if estimator is locked.
     * @throws IllegalArgumentException if provided value is less than {@link #getMinRequiredSources()}.
     */
    public void setRssiPreliminarySubsetSize(int rssiPreliminarySubsetSize)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (rssiPreliminarySubsetSize &lt; getMinRequiredSources()) {
            throw new IllegalArgumentException();
        }

        mRssiPreliminarySubsetSize = rssiPreliminarySubsetSize;
    }

    /**
     * Gets threshold to determine when samples are inliers or not, used during robust
     * fine ranging position estimation.
     * If not defined, default threshold will be used.
     *
     * @return threshold for ranging estimation or null.
     */
    public Double getRangingThreshold() {
        return mRangingThreshold;
    }

    /**
     * Sets threshold to determine when samples are inliers or not, used during robust
     * fine ranging position estimation.
     * If not defined, default threshold will be used.
     *
     * @param rangingThreshold threshold for ranging estimation or null.
     * @throws LockedException if estimator is locked.
     */
    public void setRangingThreshold(Double rangingThreshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mRangingThreshold = rangingThreshold;
    }

    /**
     * Gets threshold to determine when samples are inliers or not, used during robust
     * coarse RSSI position estimation.
     * If not defined, default threshold will be used.
     *
     * @return threshold for RSSI estimation or null.
     */
    public Double getRssiThreshold() {
        return mRssiThreshold;
    }

    /**
     * Sets threshold to determine when samples are inliers or not, used during robust
     * coarse RSSI position estimation.
     * If not defined, default threshold will be used.
     *
     * @param rssiThreshold threshold for RSSI estimation or null.
     * @throws LockedException if estimator is locked.
     */
    public void setRssiThreshold(Double rssiThreshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mRssiThreshold = rssiThreshold;
    }

    /**
     * Gets located radio sources used for lateration.
     *
     * @return located radio sources used for lateration.
     */
    public List&lt;? extends RadioSourceLocated&lt;P&gt;&gt; getSources() {
        return mSources;
    }

    /**
     * Sets located radio sources used for lateration.
     *
     * @param sources   located radio sources used for lateration.
     * @throws LockedException          if estimator is locked.
     * @throws IllegalArgumentException if provided value is null or the number of
     *                                  provided sources is less than the required
     *                                  minimum.
     */
    public void setSources(List&lt;? extends RadioSourceLocated&lt;P&gt;&gt; sources)
            throws LockedException{
        if (isLocked()) {
            throw new LockedException();
        }

        internalSetSources(sources);
    }

    /**
     * Gets fingerprint containing readings at an unknown location for provided located
     * radio sources.
     *
     * @return fingerprint containing readings at an unknown location for provided
     * located radio sources.
     */
    public Fingerprint&lt;? extends RadioSource, ? extends Reading&lt;? extends RadioSource&gt;&gt; getFingerprint() {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/calibration/IMUBiasEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/IMUBiasEstimator.html#L3340">3340</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/calibration/IMUNoiseEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/IMUNoiseEstimator.html#L704">704</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                mBiasAngularRateX, mBiasAngularRateY, mBiasAngularRateZ);
    }

    /**
     * Gets estimated variance of x coordinate of accelerometer sensed specific
     * force expressed in (m^2/s^4).
     *
     * @return estimated variance of x coordinate of sensed specific force.
     */
    public double getVarianceFx() {
        return mVarianceFx;
    }

    /**
     * Gets estimated variance of y coordinate of accelerometer sensed specific
     * force expressed in (m^2/s^4).
     *
     * @return estimated variance of y coordinate of sensed specific force.
     */
    public double getVarianceFy() {
        return mVarianceFy;
    }

    /**
     * Gets estimated variance of z coordinate of accelerometer sensed specific
     * force expressed in (m^2/s^4).
     *
     * @return estimated variance of z coordinate of sensed specific force.
     */
    public double getVarianceFz() {
        return mVarianceFz;
    }

    /**
     * Gets estimated variance of x coordinate of gyroscope sensed angular rate
     * expressed in (rad^2/s^2).
     *
     * @return estimated variance of x coordinate of sensed angular rate.
     */
    public double getVarianceAngularRateX() {
        return mVarianceAngularRateX;
    }

    /**
     * Gets estimated variance of y coordinate of gyroscope sensed angular rate
     * expressed in (rad^2/s^2).
     *
     * @return estimated variance of y coordinate of sensed angular rate.
     */
    public double getVarianceAngularRateY() {
        return mVarianceAngularRateY;
    }

    /**
     * Gets estimated variance of z coordinate of gyroscope sensed angular rate
     * expressed in (rad^2/s^2).
     *
     * @return estimated variance of z coordinate of sensed angular rate.
     */
    public double getVarianceAngularRateZ() {
        return mVarianceAngularRateZ;
    }

    /**
     * Gets estimated standard deviation of x coordinate of accelerometer
     * sensed specific force expressed in (m/s^2).
     *
     * @return estimated standard deviation of x coordinate of sensed specific force.
     */
    public double getStandardDeviationFx() {
        return Math.sqrt(mVarianceFx);
    }

    /**
     * Gets estimated standard deviation of x coordinate of accelerometer
     * sensed specific force.
     *
     * @return estimated standard deviation of x coordinate of sensed specific force.
     */
    public Acceleration getStandardDeviationFxAsAcceleration() {
        return new Acceleration(getStandardDeviationFx(),
                AccelerationUnit.METERS_PER_SQUARED_SECOND);
    }

    /**
     * Gets estimated standard deviation of x coordinate of accelerometer
     * sensed specific force.
     *
     * @param result instance where estimated standard deviation of x coordinate
     *               of sensed specific force will be stored.
     */
    public void getStandardDeviationFxAsAcceleration(final Acceleration result) {
        result.setValue(getStandardDeviationFx());
        result.setUnit(AccelerationUnit.METERS_PER_SQUARED_SECOND);
    }

    /**
     * Gets estimated standard deviation of y coordinate of accelerometer
     * sensed specific force expressed in (m/s^2).
     *
     * @return estimated standard deviation of y coordinate of sensed specific
     * force.
     */
    public double getStandardDeviationFy() {
        return Math.sqrt(mVarianceFy);
    }

    /**
     * Gets estimated standard deviation of y coordinate of accelerometer
     * sensed specific force.
     *
     * @return estimated standard deviation of y coordinate of sensed specific
     * force.
     */
    public Acceleration getStandardDeviationFyAsAcceleration() {
        return new Acceleration(getStandardDeviationFy(),
                AccelerationUnit.METERS_PER_SQUARED_SECOND);
    }

    /**
     * Gets estimated standard deviation of y coordinate of accelerometer
     * sensed specific force.
     *
     * @param result instance where estimated standard deviation of y coordinate
     *               of sensed specific force will be stored.
     */
    public void getStandardDeviationFyAsAcceleration(final Acceleration result) {
        result.setValue(getStandardDeviationFy());
        result.setUnit(AccelerationUnit.METERS_PER_SQUARED_SECOND);
    }

    /**
     * Gets estimated standard deviation of z coordinate of accelerometer
     * sensed specific force expressed in (m/s^2).
     *
     * @return estimated standard deviation of z coordinate of sensed specific
     * force.
     */
    public double getStandardDeviationFz() {
        return Math.sqrt(mVarianceFz);
    }

    /**
     * Gets estimated standard deviation of z coordinate of accelerometer
     * sensed specific force.
     *
     * @return estimated standard deviation of z coordinate of sensed specific
     * force.
     */
    public Acceleration getStandardDeviationFzAsAcceleration() {
        return new Acceleration(getStandardDeviationFz(),
                AccelerationUnit.METERS_PER_SQUARED_SECOND);
    }

    /**
     * Gets estimated standard deviation of z coordinate of accelerometer
     * sensed specific force.
     *
     * @param result instance where estimated standard deviation of z coordinate
     *               of sensed specific force will be stored.
     */
    public void getStandardDeviationFzAsAcceleration(final Acceleration result) {
        result.setValue(getStandardDeviationFz());
        result.setUnit(AccelerationUnit.METERS_PER_SQUARED_SECOND);
    }

    /**
     * Gets average of estimated standard deviation of accelerometer sensed specific
     * force for all coordinates expressed in meters per squared second (m/s^2).
     *
     * @return average of estimated standard deviation of accelerometer.
     */
    public double getAverageAccelerometerStandardDeviation() {
        return (getStandardDeviationFx() + getStandardDeviationFy()
                + getStandardDeviationFz()) / 3.0;
    }

    /**
     * Gets average of estimated standard deviation of accelerometer sensed specific
     * force for all coordinates.
     *
     * @return average of estimated standard deviation of accelerometer.
     */
    public Acceleration getAverageAccelerometerStandardDeviationAsAcceleration() {
        return new Acceleration(getAverageAccelerometerStandardDeviation(),
                AccelerationUnit.METERS_PER_SQUARED_SECOND);
    }

    /**
     * Gets average of estimated standard deviation of accelerometer sensed specific
     * force for all coordinates.
     *
     * @param result instance where result data will be copied to.
     */
    public void getAverageAccelerometerStandardDeviationAsAcceleration(
            final Acceleration result) {
        result.setValue(getAverageAccelerometerStandardDeviation());
        result.setUnit(AccelerationUnit.METERS_PER_SQUARED_SECOND);
    }

    /**
     * Gets estimated standard deviation of x coordinate of gyroscope sensed angular
     * rate expressed in (rad/s).
     *
     * @return estimated standard deviaton of x coordinate of sensed angular rate.
     */
    public double getStandardDeviationAngularRateX() {
        return Math.sqrt(mVarianceAngularRateX);
    }

    /**
     * Gets estimated standard deviation of x coordinate of gyroscope sensed angular
     * rate.
     *
     * @return estimated standard deviation of x coordinate of sensed angular rate.
     */
    public AngularSpeed getStandardDeviationAngularRateXAsAngularSpeed() {
        return new AngularSpeed(getStandardDeviationAngularRateX(),
                AngularSpeedUnit.RADIANS_PER_SECOND);
    }

    /**
     * Gets estimated standard deviation of x coordinate of gyroscope sensed angular
     * rate.
     *
     * @param result instance where estimated standard deviation of x coordinate of
     *               sensed angular rate will be stored.
     */
    public void getStandardDeviationAngularRateXAsAngularSpeed(
            final AngularSpeed result) {
        result.setValue(getStandardDeviationAngularRateX());
        result.setUnit(AngularSpeedUnit.RADIANS_PER_SECOND);
    }

    /**
     * Gets estimated standard deviation of y coordinate of gyroscope sensed angular
     * rate expressed in (rad/s).
     *
     * @return estimated standard deviation of y coordinate of sensed angular rate.
     */
    public double getStandardDeviationAngularRateY() {
        return Math.sqrt(mVarianceAngularRateY);
    }

    /**
     * Gets estimated standard deviation of y coordinate of gyroscope sensed angular
     * rate.
     *
     * @return estimated standard deviation of y coordinate of sensed angular rate.
     */
    public AngularSpeed getStandardDeviationAngularRateYAsAngularSpeed() {
        return new AngularSpeed(getStandardDeviationAngularRateY(),
                AngularSpeedUnit.RADIANS_PER_SECOND);
    }

    /**
     * Gets estimated standard deviation of y coordinate of gyroscope sensed angular
     * rate.
     *
     * @param result instance where estimated standard deviation of y coordinate of
     *               sensed angular rate will be stored.
     */
    public void getStandardDeviationAngularRateYAsAngularSpeed(
            final AngularSpeed result) {
        result.setValue(getStandardDeviationAngularRateY());
        result.setUnit(AngularSpeedUnit.RADIANS_PER_SECOND);
    }

    /**
     * Gets estimated standard deviation of z coordinate of gyroscope sensed angular
     * rate expressed in (rad/s).
     *
     * @return estimated standard deviation of z coordinate of sensed angular rate.
     */
    public double getStandardDeviationAngularRateZ() {
        return Math.sqrt(mVarianceAngularRateZ);
    }

    /**
     * Gets estimated standard deviation of z coordinate of gyroscope sensed angular
     * rate.
     *
     * @return estimated standard deviation of z coordinate of sensed angular rate.
     */
    public AngularSpeed getStandardDeviationAngularRateZAsAngularSpeed() {
        return new AngularSpeed(getStandardDeviationAngularRateZ(),
                AngularSpeedUnit.RADIANS_PER_SECOND);
    }

    /**
     * Gets estimated standard deviation of z coordinate of gyroscope sensed angular
     * rate.
     *
     * @param result instance where estimated standard deviation of z coordinate of
     *               sensed angular rate will be stored.
     */
    public void getStandardDeviationAngularRateZAsAngularSpeed(
            final AngularSpeed result) {
        result.setValue(getStandardDeviationAngularRateZ());
        result.setUnit(AngularSpeedUnit.RADIANS_PER_SECOND);
    }

    /**
     * Gets average of estimated standard deviation of gyroscope sensed angular rate
     * for all coordinates expressed in radians per second (rad/s).
     *
     * @return average of estimated standard deviation of gyroscope.
     */
    public double getAverageGyroscopeStandardDeviation() {
        return (getStandardDeviationAngularRateX() + getStandardDeviationAngularRateY()
                + getStandardDeviationAngularRateZ()) / 3.0;
    }

    /**
     * Gets average of estimated standard deviation of gyroscope sensed angular rate
     * for all coordinates.
     *
     * @return average of estimated standard deviation of gyroscope.
     */
    public AngularSpeed getAverageGyroscopeStandardDeviationAsAngularSpeed() {
        return new AngularSpeed(getAverageGyroscopeStandardDeviation(),
                AngularSpeedUnit.RADIANS_PER_SECOND);
    }

    /**
     * Gets average of estimated standard deviation of gyroscope sensed angular rate
     * for all coordinates.
     *
     * @param result instance where result data will be copied to.
     */
    public void getAverageGyroscopeStandardDeviationAsAngularSpeed(final AngularSpeed result) {
        result.setValue(getAverageGyroscopeStandardDeviation());
        result.setUnit(AngularSpeedUnit.RADIANS_PER_SECOND);
    }

    /**
     * Gets estimated standard deviations of accelerometer and gyroscope components
     * as a body kinematics instance.
     *
     * @return a body kinematics instance containing standard deviation values.
     */
    public BodyKinematics getStandardDeviationsAsBodyKinematics() {
        return new BodyKinematics(getStandardDeviationFx(),
                getStandardDeviationFy(),
                getStandardDeviationFz(),
                getStandardDeviationAngularRateX(),
                getStandardDeviationAngularRateY(),
                getStandardDeviationAngularRateZ());
    }

    /**
     * Gets estimated standard deviations of accelerometer and gyroscope components
     * as a body kinematics instance.
     *
     * @param result instance where data will be stored.
     */
    public void getStandardDeviationsAsBodyKinematics(final BodyKinematics result) {
        result.setSpecificForceCoordinates(getStandardDeviationFx(),
                getStandardDeviationFy(), getStandardDeviationFz());
        result.setAngularRateCoordinates(getStandardDeviationAngularRateX(),
                getStandardDeviationAngularRateY(),
                getStandardDeviationAngularRateZ());
    }

    /**
     * Gets accelerometer noise PSD (Power Spectral Density) on x axis expressed
     * in (m^2 * s^-3).
     *
     * @return accelerometer noise PSD on x axis.
     */
    public double getPSDFx() {
        return mVarianceFx * mTimeInterval;
    }

    /**
     * Gets accelerometer noise PSD (Power Spectral Density) on y axis expressed
     * in (m^2 * s^-3).
     *
     * @return accelerometer noise PSD on y axis.
     */
    public double getPSDFy() {
        return mVarianceFy * mTimeInterval;
    }

    /**
     * Gets accelerometer noise PSD (Power Spectral Density) on z axis expressed
     * in (m^2 * s^-3).
     *
     * @return accelerometer noise PSD on z axis.
     */
    public double getPSDFz() {
        return mVarianceFz * mTimeInterval;
    }

    /**
     * Gets gyroscope noise PSD (Power Spectral Density) on x axis expressed
     * in (rad^2/s).
     *
     * @return gyroscope noise PSD on x axis.
     */
    public double getPSDAngularRateX() {
        return mVarianceAngularRateX * mTimeInterval;
    }

    /**
     * Gets gyroscope noise PSD (Power Spectral Density) on y axis expressed
     * in (rad^2/s).
     *
     * @return gyroscope noise PSD on y axis.
     */
    public double getPSDAngularRateY() {
        return mVarianceAngularRateY * mTimeInterval;
    }

    /**
     * Gets gyroscope noise PSD (Power Spectral Density) on z axis expressed
     * in (rad^2/s).
     *
     * @return gyroscope noise PSD on z axis.
     */
    public double getPSDAngularRateZ() {
        return mVarianceAngularRateZ * mTimeInterval;
    }

    /**
     * Gets accelerometer noise root PSD (Power Spectral Density) on x axis
     * expressed in (m * s^-1.5).
     *
     * @return accelerometer noise root PSD on x axis.
     */
    public double getRootPSDFx() {
        return Math.sqrt(getPSDFx());
    }

    /**
     * Gets accelerometer noise root PSD (Power Spectral Density) on y axis
     * expressed in (m * s^-1.5).
     *
     * @return accelerometer noise root PSD on y axis.
     */
    public double getRootPSDFy() {
        return Math.sqrt(getPSDFy());
    }

    /**
     * Gets accelerometer noise root PSD (Power Spectral Density) on z axis
     * expressed in (m * s^-1.5).
     *
     * @return accelerometer noise root PSD on z axis.
     */
    public double getRootPSDFz() {
        return Math.sqrt(getPSDFz());
    }

    /**
     * Gets gyroscope noise root PSD (Power Spectral Density) on x axis
     * expressed in (rad * s^-0.5).
     *
     * @return gyroscope noise root PSD on x axis.
     */
    public double getRootPSDAngularRateX() {
        return Math.sqrt(getPSDAngularRateX());
    }

    /**
     * Gets gyroscope noise root PSD (Power Spectral Density) on y axis
     * expressed in (rad * s^-0.5).
     *
     * @return gyroscope noise root PSD on y axis.
     */
    public double getRootPSDAngularRateY() {
        return Math.sqrt(getPSDAngularRateY());
    }

    /**
     * Gets gyroscope noise root PSD (Power Spectral Density) on z axis
     * expressed in (rad * s^-0.5).
     *
     * @return gyroscope noise root PSD on z axis.
     */
    public double getRootPSDAngularRateZ() {
        return Math.sqrt(getPSDAngularRateZ());
    }

    /**
     * Gets average accelerometer noise PSD (Power Spectral Density) among
     * x,y,z components expressed as (m^2/s^3).
     *
     * @return average accelerometer noise PSD.
     */
    public double getAccelerometerNoisePSD() {
        return (getPSDFx() + getPSDFy() + getPSDFz()) / 3.0;
    }

    /**
     * Gets average accelerometer noise root PSD (Power Spectral Density) among
     * x,y,z components expressed as (m * s^-1.5).
     *
     * @return average accelerometer noise root PSD.
     */
    public double getAccelerometerNoiseRootPSD() {
        return Math.sqrt(getAccelerometerNoisePSD());
    }

    /**
     * Gets average gyroscope noise PSD (Power Spectral Density) among
     * x,y,z components expressed in (rad^2/s).
     *
     * @return average gyroscope noise PSD.
     */
    public double getGyroNoisePSD() {
        return (getPSDAngularRateX() + getPSDAngularRateY() + getPSDAngularRateZ())
                / 3.0;
    }

    /**
     * Gets average gyroscope noise root PSD (Power Spectral Density) among
     * x,y,z components expressed in (rad * s^-0.5).
     *
     * @return average gyroscope noise root PSD.
     */
    public double getGyroNoiseRootPSD() {
        return Math.sqrt(getGyroNoisePSD());
    }

    /**
     * Gets estimated bias of accelerometer sensed specific force
     * expressed in meters per squared second (m/s^2) as a 3x1 matrix column vector.
     *
     * @return estimated bias of accelerometer sensed specific force.
     */
    public Matrix getAccelerometerBias() {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/calibration/KnownFrameAccelerometerLinearLeastSquaresCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/KnownFrameAccelerometerLinearLeastSquaresCalibrator.html#L426">426</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/calibration/KnownFrameAccelerometerNonLinearLeastSquaresCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/KnownFrameAccelerometerNonLinearLeastSquaresCalibrator.html#L2988">2988</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>        } catch (final AlgebraException e) {
            throw new CalibrationException(e);
        } finally {
            mRunning = false;
        }
    }

    /**
     * Gets array containing x,y,z components of estimated accelerometer biases
     * expressed in meters per squared second (m/s^2).
     *
     * @return array containing x,y,z components of estimated accelerometer biases.
     */
    @Override
    public double[] getEstimatedBiases() {
        return mEstimatedBiases;
    }

    /**
     * Gets array containing x,y,z components of estimated accelerometer biases
     * expressed in meters per squared second (m/s^2).
     *
     * @param result instance where estimated accelerometer biases will be stored.
     * @return true if result instance was updated, false otherwise (when estimation
     * is not yet available).
     */
    @Override
    public boolean getEstimatedBiases(final double[] result) {
        if (mEstimatedBiases != null) {
            System.arraycopy(mEstimatedBiases, 0, result,
                    0, mEstimatedBiases.length);
            return true;
        } else {
            return false;
        }
    }

    /**
     * Gets column matrix containing x,y,z components of estimated accelerometer biases
     * expressed in meters per squared second (m/s^2).
     *
     * @return column matrix containing x,y,z components of estimated accelerometer
     * biases
     */
    @Override
    public Matrix getEstimatedBiasesAsMatrix() {
        return mEstimatedBiases != null ? Matrix.newFromArray(mEstimatedBiases) : null;
    }

    /**
     * Gets column matrix containing x,y,z components of estimated accelerometer biases
     * expressed in meters per squared second (m/s^2).
     *
     * @param result instance where result data will be stored.
     * @return true if result was updated, false otherwise.
     * @throws WrongSizeException if provided result instance has invalid size.
     */
    @Override
    public boolean getEstimatedBiasesAsMatrix(final Matrix result)
            throws WrongSizeException {
        if (mEstimatedBiases != null) {
            result.fromArray(mEstimatedBiases);
            return true;
        } else {
            return false;
        }
    }

    /**
     * Gets x coordinate of estimated accelerometer bias expressed in meters per
     * squared second (m/s^2).
     *
     * @return x coordinate of estimated accelerometer bias or null if not available.
     */
    @Override
    public Double getEstimatedBiasFx() {
        return mEstimatedBiases != null ? mEstimatedBiases[0] : null;
    }

    /**
     * Gets y coordinate of estimated accelerometer bias expressed in meters per
     * squared second (m/s^2).
     *
     * @return y coordinate of estimated accelerometer bias or null if not available.
     */
    @Override
    public Double getEstimatedBiasFy() {
        return mEstimatedBiases != null ? mEstimatedBiases[1] : null;
    }

    /**
     * Gets z coordinate of estimated accelerometer bias expressed in meters per
     * squared second (m/s^2).
     *
     * @return z coordinate of estimated accelerometer bias or null if not available.
     */
    @Override
    public Double getEstimatedBiasFz() {
        return mEstimatedBiases != null ? mEstimatedBiases[2] : null;
    }

    /**
     * Gets x coordinate of estimated accelerometer bias.
     *
     * @return x coordinate of estimated accelerometer bias or null if not available.
     */
    @Override
    public Acceleration getEstimatedBiasFxAsAcceleration() {
        return mEstimatedBiases != null ?
                new Acceleration(mEstimatedBiases[0],
                        AccelerationUnit.METERS_PER_SQUARED_SECOND) : null;
    }

    /**
     * Gets x coordinate of estimated accelerometer bias.
     *
     * @param result instance where result will be stored.
     * @return true if result was updated, false if estimation is not available.
     */
    @Override
    public boolean getEstimatedBiasFxAsAcceleration(final Acceleration result) {
        if (mEstimatedBiases != null) {
            result.setValue(mEstimatedBiases[0]);
            result.setUnit(AccelerationUnit.METERS_PER_SQUARED_SECOND);
            return true;
        } else {
            return false;
        }
    }

    /**
     * Gets y coordinate of estimated accelerometer bias.
     *
     * @return y coordinate of estimated accelerometer bias or null if not available.
     */
    @Override
    public Acceleration getEstimatedBiasFyAsAcceleration() {
        return mEstimatedBiases != null ?
                new Acceleration(mEstimatedBiases[1],
                        AccelerationUnit.METERS_PER_SQUARED_SECOND) : null;
    }

    /**
     * Gets y coordinate of estimated accelerometer bias.
     *
     * @param result instance where result will be stored.
     * @return true if result was updated, false if estimation is not available.
     */
    @Override
    public boolean getEstimatedBiasFyAsAcceleration(final Acceleration result) {
        if (mEstimatedBiases != null) {
            result.setValue(mEstimatedBiases[1]);
            result.setUnit(AccelerationUnit.METERS_PER_SQUARED_SECOND);
            return true;
        } else {
            return false;
        }
    }

    /**
     * Gets z coordinate of estimated accelerometer bias.
     *
     * @return z coordinate of estimated accelerometer bias or null if not available.
     */
    @Override
    public Acceleration getEstimatedBiasFzAsAcceleration() {
        return mEstimatedBiases != null ?
                new Acceleration(mEstimatedBiases[2],
                        AccelerationUnit.METERS_PER_SQUARED_SECOND) : null;
    }

    /**
     * Gets z coordinate of estimated accelerometer bias.
     *
     * @param result instance where result will be stored.
     * @return true if result was updated, false if estimation is not available.
     */
    @Override
    public boolean getEstimatedBiasFzAsAcceleration(final Acceleration result) {
        if (mEstimatedBiases != null) {
            result.setValue(mEstimatedBiases[2]);
            result.setUnit(AccelerationUnit.METERS_PER_SQUARED_SECOND);
            return true;
        } else {
            return false;
        }
    }

    /**
     * Gets estimated accelerometer scale factors and ross coupling errors.
     * This is the product of matrix Ta containing cross coupling errors and Ka
     * containing scaling factors.
     * So tat:
     * &lt;pre&gt;
     *     Ma = [sx    mxy  mxz] = Ta*Ka
     *          [myx   sy   myz]
     *          [mzx   mzy  sz ]
     * &lt;/pre&gt;
     * Where:
     * &lt;pre&gt;
     *     Ka = [sx 0   0 ]
     *          [0  sy  0 ]
     *          [0  0   sz]
     * &lt;/pre&gt;
     * and
     * &lt;pre&gt;
     *     Ta = [1          -alphaXy    alphaXz ]
     *          [alphaYx    1           -alphaYz]
     *          [-alphaZx   alphaZy     1       ]
     * &lt;/pre&gt;
     * Hence:
     * &lt;pre&gt;
     *     Ma = [sx    mxy  mxz] = Ta*Ka =  [sx             -sy * alphaXy   sz * alphaXz ]
     *          [myx   sy   myz]            [sx * alphaYx   sy              -sz * alphaYz]
     *          [mzx   mzy  sz ]            [-sx * alphaZx  sy * alphaZy    sz           ]
     * &lt;/pre&gt;
     * This instance allows any 3x3 matrix however, typically alphaYx, alphaZx and alphaZy
     * are considered to be zero if the accelerometer z-axis is assumed to be the same
     * as the body z-axis. When this is assumed, myx = mzx = mzy = 0 and the Ma matrix
     * becomes upper diagonal:
     * &lt;pre&gt;
     *     Ma = [sx    mxy  mxz]
     *          [0     sy   myz]
     *          [0     0    sz ]
     * &lt;/pre&gt;
     * Values of this matrix are unitless.
     *
     * @return estimated accelerometer scale factors and cross coupling errors, or null
     * if not available.
     */
    @Override
    public Matrix getEstimatedMa() {
        return mEstimatedMa;
    }

    /**
     * Gets estimated x-axis scale factor.
     *
     * @return estimated x-axis scale factor or null if not available.
     */
    @Override
    public Double getEstimatedSx() {
        return mEstimatedMa != null ?
                mEstimatedMa.getElementAt(0, 0) : null;
    }

    /**
     * Gets estimated y-axis scale factor.
     *
     * @return estimated y-axis scale factor or null if not available.
     */
    @Override
    public Double getEstimatedSy() {
        return mEstimatedMa != null ?
                mEstimatedMa.getElementAt(1, 1) : null;
    }

    /**
     * Gets estimated z-axis scale factor.
     *
     * @return estimated z-axis scale factor or null if not available.
     */
    @Override
    public Double getEstimatedSz() {
        return mEstimatedMa != null ?
                mEstimatedMa.getElementAt(2, 2) : null;
    }

    /**
     * Gets estimated x-y cross-coupling error.
     *
     * @return estimated x-y cross-coupling error or null if not available.
     */
    @Override
    public Double getEstimatedMxy() {
        return mEstimatedMa != null ?
                mEstimatedMa.getElementAt(0, 1) : null;
    }

    /**
     * Gets estimated x-z cross-coupling error.
     *
     * @return estimated x-z cross-coupling error or null if not available.
     */
    @Override
    public Double getEstimatedMxz() {
        return mEstimatedMa != null ?
                mEstimatedMa.getElementAt(0, 2) : null;
    }

    /**
     * Gets estimated y-x cross-coupling error.
     *
     * @return estimated y-x cross-coupling error or null if not available.
     */
    @Override
    public Double getEstimatedMyx() {
        return mEstimatedMa != null ?
                mEstimatedMa.getElementAt(1, 0) : null;
    }

    /**
     * Gets estimated y-z cross-coupling error.
     *
     * @return estimated y-z cross-coupling error or null if not available.
     */
    @Override
    public Double getEstimatedMyz() {
        return mEstimatedMa != null ?
                mEstimatedMa.getElementAt(1, 2) : null;
    }

    /**
     * Gets estimated z-x cross-coupling error.
     *
     * @return estimated z-x cross-coupling error or null if not available.
     */
    @Override
    public Double getEstimatedMzx() {
        return mEstimatedMa != null ?
                mEstimatedMa.getElementAt(2, 0) : null;
    }

    /**
     * Gets estimated z-y cross-coupling error.
     *
     * @return estimated z-y cross-coupling error or null if not available.
     */
    @Override
    public Double getEstimatedMzy() {
        return mEstimatedMa != null ?
                mEstimatedMa.getElementAt(2, 1) : null;
    }</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustMixedRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustMixedRadioSourceEstimator.html#L1122">1122</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator.html#L1105">1105</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>            SequentialRobustMixedRadioSourceEstimatorListener&lt;S, P&gt; listener) {
        this(readings, initialPosition, initialTransmittedPowerdBm,
                initialPathLossExponent, listener);
        internalSetQualityScores(qualityScores);
    }

    /**
     * Indicates whether estimator is locked during estimation.
     *
     * @return true if estimator is locked, false otherwise.
     */
    public boolean isLocked() {
        return mLocked;
    }

    /**
     * Returns amount of progress variation before notifying a progress change during
     * estimation.
     *
     * @return amount of progress variation before notifying a progress change during
     * estimation.
     */
    public float getProgressDelta() {
        return mProgressDelta;
    }

    /**
     * Sets amount of progress variation before notifying a progress change during
     * estimation.
     *
     * @param progressDelta amount of progress variation before notifying a progress
     *                      change during estimation.
     * @throws IllegalArgumentException if progress delta is less than zero or greater than 1.
     * @throws LockedException if this estimator is locked.
     */
    public void setProgressDelta(float progressDelta) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (progressDelta &lt; MIN_PROGRESS_DELTA ||
                progressDelta &gt; MAX_PROGRESS_DELTA) {
            throw new IllegalArgumentException();
        }
        mProgressDelta = progressDelta;
    }

    /**
     * Gets robust method used for robust position estimation using ranging data.
     *
     * @return robust method used for robust position estimation.
     */
    public RobustEstimatorMethod getRangingRobustMethod() {
        return mRangingRobustMethod;
    }

    /**
     * Sets robust method used for robust position estimation using ranging data.
     *
     * @param rangingRobustMethod robust method used for robust position estimation.
     * @throws LockedException if estimator is locked.
     */
    public void setRangingRobustMethod(RobustEstimatorMethod rangingRobustMethod)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mRangingRobustMethod = rangingRobustMethod;
    }

    /**
     * Gets robust method used for pathloss exponent and transmitted power estimation
     * using RSSI data.
     *
     * @return robust method used for pathloss exponent and transmitted power
     * estimation.
     */
    public RobustEstimatorMethod getRssiRobustMethod() {
        return mRssiRobustMethod;
    }

    /**
     * Sets robust method used for pathloss exponent and transmitted power estimation
     * using RSSI data.
     *
     * @param rssiRobustMethod robust method used for pathloss exponent and transmitted
     *                         power estimation.
     * @throws LockedException if estimator is locked.
     */
    public void setRssiRobustMethod(RobustEstimatorMethod rssiRobustMethod)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mRssiRobustMethod = rssiRobustMethod;
    }

    /**
     * Gets size of subsets to be checked during ranging robust estimation.
     *
     * @return size of subsets to be checked during ranging robust estimation.
     */
    public int getRangingPreliminarySubsetSize() {
        return mRangingPreliminarySubsetSize;
    }

    /**
     * Sets size of subsets to be checked during ranging robust estimation.
     *
     * @param rangingPreliminarySubsetSize size of subsets to be checked during
     *                                     ranging robust estimation.
     * @throws LockedException if estimator is locked.
     * @throws IllegalArgumentException if provided value is less than {@link #getMinReadings()}.
     */
    public void setRangingPreliminarySubsetSize(int rangingPreliminarySubsetSize)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (rangingPreliminarySubsetSize &lt; getMinReadings()) {
            throw new IllegalArgumentException();
        }

        mRangingPreliminarySubsetSize = rangingPreliminarySubsetSize;
    }

    /**
     * Gets size of subsets to be checked during RSSI robust estimation.
     *
     * @return size of subsets to be checked during RSSI robust estimation.
     */
    public int getRssiPreliminarySubsetSize() {
        return mRssiPreliminarySubsetSize;
    }

    /**
     * Sets size of subsets to be checked during RSSI robust estimation.
     *
     * @param rssiPreliminarySubsetSize size of subsets to be checked during
     *                                  RSSI robust estimation.
     * @throws LockedException if estimator is locked.
     * @throws IllegalArgumentException if provided value is less than {@link #getMinReadings()}.
     */
    public void setRssiPreliminarySubsetSize(int rssiPreliminarySubsetSize)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (rssiPreliminarySubsetSize &lt; getMinReadings()) {
            throw new IllegalArgumentException();
        }

        mRssiPreliminarySubsetSize = rssiPreliminarySubsetSize;
    }

    /**
     * Gets threshold to determine when samples are inliers or not, used during robust
     * position estimation.
     * If not defined, default threshold will be used.
     *
     * @return threshold for ranging estimation or null.
     */
    public Double getRangingThreshold() {
        return mRangingThreshold;
    }

    /**
     * Sets threshold to determine when samples are inliers or not, used during robust
     * position estimation.
     * If not defined, default threshold will be used.
     *
     * @param rangingThreshold threshold for ranging estimation or null.
     * @throws LockedException if estimator is locked.
     */
    public void setRangingThreshold(Double rangingThreshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mRangingThreshold = rangingThreshold;
    }

    /**
     * Gets threshold to determine when samples are inliers or not, used during robust
     * pathloss exponent and transmitted power estimation.
     * If not defined, default threshold will be used.
     *
     * @return threshold for RSSI estimation or null.
     */
    public Double getRssiThreshold() {
        return mRssiThreshold;
    }

    /**
     * Sets threshold to determine when samples are inliers or not, used during robust
     * pathloss exponent and transmitted power estimation.
     * If not defined, default threshold will be used.
     *
     * @param rssiThreshold threshold for RSSI estimation or null.
     * @throws LockedException if estimator is locked.
     */
    public void setRssiThreshold(Double rssiThreshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mRssiThreshold = rssiThreshold;
    }

    /**
     * Returns amount of confidence expressed as a value between 0.0 and 1.0
     * (which is equivalent to 100%) for robust position estimation. The amount of
     * confidence indicates the probability that the estimated result is correct.
     * Usually this value will be close to 1.0, but not exactly 1.0.
     *
     * @return amount of confidence for robust position estimation as a value
     * between 0.0 and 1.0.
     */
    public double getRangingConfidence() {
        return mRangingConfidence;
    }

    /**
     * Sets amount of confidence expressed as a value between 0.0 and 1.0 (which is
     * equivalent to 100%) for robust position estimation. The amount of confidence
     * indicates the probability that the estimated result is correct. Usually this
     * value will be close to 1.0, but not exactly 1.0.
     *
     * @param rangingConfidence confidence to be set for robust position estimation
     *                          as a value between 0.0 and 1.0.
     * @throws IllegalArgumentException if provided value is not between 0.0 and 1.0.
     * @throws LockedException if estimator is locked.
     */
    public void setRangingConfidence(double rangingConfidence) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (rangingConfidence &lt; MIN_CONFIDENCE || rangingConfidence &gt; MAX_CONFIDENCE) {
            throw new IllegalArgumentException();
        }
        mRangingConfidence = rangingConfidence;
    }

    /**
     * Returns amount of confidence expressed as a value between 0.0 and 1.0
     * (which is equivalent to 100%) for pathloss exponent and transmitted power
     * estimation. The amount of confidence indicates the probability that the
     * estimated result is correct.
     * Usually this value will be close to 1.0, but not exactly 1.0.
     *
     * @return amount of confidence for robust pathloss exponent and transmitted power
     * estimation as a value between 0.0 and 1.0.
     */
    public double getRssiConfidence() {
        return mRssiConfidence;
    }

    /**
     * Sets amount of confidence expressed as a value between 0.0 and 1.0
     * (which is equivalent to 100%) for pathloss exponent and transmitted power
     * estimation. The amount of confidence indicates the probability that the
     * estimated result is correct. Usually this value will be close to 10.0, but
     * not exactly 1.0.
     *
     * @param rssiConfidence confidence to be set for robust pathloss exponent and
     *                       transmitted power estimation as a value between 0.0 and
     *                       1.0.
     * @throws IllegalArgumentException if provided value is not between 0.0 and 1.0.
     * @throws LockedException if estimator is locked.
     */
    public void setRssiConfidence(double rssiConfidence) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (rssiConfidence &lt; MIN_CONFIDENCE || rssiConfidence &gt; MAX_CONFIDENCE) {
            throw new IllegalArgumentException();
        }
        mRssiConfidence = rssiConfidence;
    }

    /**
     * Returns maximum allowed number of iterations for robust position estimation. If
     * maximum allowed number of iterations is achieved without converging to a result
     * when calling estimate(), a RobustEstimatorException will be raised.
     *
     * @return maximum allowed number of iterations for position estimation.
     */
    public int getRangingMaxIterations() {
        return mRangingMaxIterations;
    }

    /**
     * Sets maximum allowed number of iterations for robust position estimation. When
     * the maximum number of iterations is exceeded, an approximate result might be
     * available for retrieval.
     *
     * @param rangingMaxIterations maximum allowed number of iterations to be set
     *                             for position estimation.
     * @throws IllegalArgumentException if provided value is less than 1.
     * @throws LockedException if this estimator is locked.
     */
    public void setRangingMaxIterations(int rangingMaxIterations) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (rangingMaxIterations &lt; MIN_ITERATIONS) {
            throw new IllegalArgumentException();
        }
        mRangingMaxIterations = rangingMaxIterations;
    }

    /**
     * Returns maximum allowed number of iterations for robust pathloss exponent and
     * transmitted power estimation. If maximum allowed number of iterations is achieved
     * without converging to a result when calling estimate(), a RobustEstimatorException
     * will be raised.
     *
     * @return maximum allowed number of iterations for pathloss exponent and transmitted
     * power estimation.
     */
    public int getRssiMaxIterations() {
        return mRssiMaxIterations;
    }

    /**
     * Sets maximum allowed number of iterations for robust pathloss exponent and
     * transmitted power estimation. When the maximum number of iterations is exceeded,
     * an approximate result might be available for retrieval.
     *
     * @param rssiMaxIterations maximum allowed number of iterations to be set for
     *                          pathloss exponent and transmitted power estimation.
     * @throws IllegalArgumentException if provided value is less than 1.
     * @throws LockedException if this estimator is locked.
     */
    public void setRssiMaxIterations(int rssiMaxIterations) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (rssiMaxIterations &lt; MIN_ITERATIONS) {
            throw new IllegalArgumentException();
        }
        mRssiMaxIterations = rssiMaxIterations;
    }

    /**
     * Indicates whether result must be refined using a non-linear solver over found inliers.
     *
     * @return true to refine result, false to simply use result found by robust estimator
     * without further refining.
     */
    public boolean isResultRefined() {
        return mRefineResult;
    }

    /**
     * Specifies whether result must be refined using a non-linear solver over found inliers.
     *
     * @param refineResult true to refine result, false to simply use result found by robust
     *                     estimator without further refining.
     * @throws LockedException if estimator is locked.
     */
    public void setResultRefined(boolean refineResult) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mRefineResult = refineResult;
    }

    /**
     * Indicates whether covariance must be kept after refining result.
     * This setting is only taken into account if result is refined.
     *
     * @return true if covariance must be kept after refining result, false otherwise.
     */
    public boolean isCovarianceKept() {
        return mKeepCovariance;
    }

    /**
     * Specifies whether covariance must be kept after refining result.
     * This setting is only taken into account if result is refined.
     *
     * @param keepCovariance true if covariance must be kept after refining result,
     *                       false otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setCovarianceKept(boolean keepCovariance) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mKeepCovariance = keepCovariance;
    }

    /**
     * Gets signal readings belonging to the same radio source.
     *
     * @return signal readings belonging to the same radio source.
     */
    public List&lt;? extends ReadingLocated&lt;P&gt;&gt; getReadings() {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/calibration/KnownBiasAndFrameAccelerometerNonLinearLeastSquaresCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/KnownBiasAndFrameAccelerometerNonLinearLeastSquaresCalibrator.html#L2082">2082</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/calibration/KnownFrameAccelerometerNonLinearLeastSquaresCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/KnownFrameAccelerometerNonLinearLeastSquaresCalibrator.html#L2347">2347</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>        mBiasZ = convertAcceleration(biasZ);
    }

    /**
     * Gets initial x scaling factor.
     *
     * @return initial x scaling factor.
     */
    @Override
    public double getInitialSx() {
        return mInitialSx;
    }

    /**
     * Sets initial x scaling factor.
     *
     * @param initialSx initial x scaling factor.
     * @throws LockedException if calibrator is currently running.
     */
    @Override
    public void setInitialSx(final double initialSx) throws LockedException {
        if (mRunning) {
            throw new LockedException();
        }
        mInitialSx = initialSx;
    }

    /**
     * Gets initial y scaling factor.
     *
     * @return initial y scaling factor.
     */
    @Override
    public double getInitialSy() {
        return mInitialSy;
    }

    /**
     * Sets initial y scaling factor.
     *
     * @param initialSy initial y scaling factor.
     * @throws LockedException if calibrator is currently running.
     */
    @Override
    public void setInitialSy(final double initialSy) throws LockedException {
        if (mRunning) {
            throw new LockedException();
        }
        mInitialSy = initialSy;
    }

    /**
     * Gets initial z scaling factor.
     *
     * @return initial z scaling factor.
     */
    @Override
    public double getInitialSz() {
        return mInitialSz;
    }

    /**
     * Sets initial z scaling factor.
     *
     * @param initialSz initial z scaling factor.
     * @throws LockedException if calibrator is currently running.
     */
    @Override
    public void setInitialSz(final double initialSz) throws LockedException {
        if (mRunning) {
            throw new LockedException();
        }
        mInitialSz = initialSz;
    }

    /**
     * Gets initial x-y cross coupling error.
     *
     * @return initial x-y cross coupling error.
     */
    @Override
    public double getInitialMxy() {
        return mInitialMxy;
    }

    /**
     * Sets initial x-y cross coupling error.
     *
     * @param initialMxy initial x-y cross coupling error.
     * @throws LockedException if calibrator is currently running.
     */
    @Override
    public void setInitialMxy(final double initialMxy) throws LockedException {
        if (mRunning) {
            throw new LockedException();
        }
        mInitialMxy = initialMxy;
    }

    /**
     * Gets initial x-z cross coupling error.
     *
     * @return initial x-z cross coupling error.
     */
    @Override
    public double getInitialMxz() {
        return mInitialMxz;
    }

    /**
     * Sets initial x-z cross coupling error.
     *
     * @param initialMxz initial x-z cross coupling error.
     * @throws LockedException if calibrator is currently running.
     */
    @Override
    public void setInitialMxz(final double initialMxz) throws LockedException {
        if (mRunning) {
            throw new LockedException();
        }
        mInitialMxz = initialMxz;
    }

    /**
     * Gets initial y-x cross coupling error.
     *
     * @return initial y-x cross coupling error.
     */
    @Override
    public double getInitialMyx() {
        return mInitialMyx;
    }

    /**
     * Sets initial y-x cross coupling error.
     *
     * @param initialMyx initial y-x cross coupling error.
     * @throws LockedException if calibrator is currently running.
     */
    @Override
    public void setInitialMyx(final double initialMyx) throws LockedException {
        if (mRunning) {
            throw new LockedException();
        }
        mInitialMyx = initialMyx;
    }

    /**
     * Gets initial y-z cross coupling error.
     *
     * @return initial y-z cross coupling error.
     */
    @Override
    public double getInitialMyz() {
        return mInitialMyz;
    }

    /**
     * Sets initial y-z cross coupling error.
     *
     * @param initialMyz initial y-z cross coupling error.
     * @throws LockedException if calibrator is currently running.
     */
    @Override
    public void setInitialMyz(final double initialMyz) throws LockedException {
        if (mRunning) {
            throw new LockedException();
        }
        mInitialMyz = initialMyz;
    }

    /**
     * Gets initial z-x cross coupling error.
     *
     * @return initial z-x cross coupling error.
     */
    @Override
    public double getInitialMzx() {
        return mInitialMzx;
    }

    /**
     * Sets initial z-x cross coupling error.
     *
     * @param initialMzx initial z-x cross coupling error.
     * @throws LockedException if calibrator is currently running.
     */
    @Override
    public void setInitialMzx(final double initialMzx) throws LockedException {
        if (mRunning) {
            throw new LockedException();
        }
        mInitialMzx = initialMzx;
    }

    /**
     * Gets initial z-y cross coupling error.
     *
     * @return initial z-y cross coupling error.
     */
    @Override
    public double getInitialMzy() {
        return mInitialMzy;
    }

    /**
     * Sets initial z-y cross coupling error.
     *
     * @param initialMzy initial z-y cross coupling error.
     * @throws LockedException if calibrator is currently running.
     */
    @Override
    public void setInitialMzy(final double initialMzy) throws LockedException {
        if (mRunning) {
            throw new LockedException();
        }
        mInitialMzy = initialMzy;
    }

    /**
     * Sets initial scaling factors.
     *
     * @param initialSx initial x scaling factor.
     * @param initialSy initial y scaling factor.
     * @param initialSz initial z scaling factor.
     * @throws LockedException if calibrator is currently running.
     */
    @Override
    public void setInitialScalingFactors(
            final double initialSx, final double initialSy, final double initialSz)
            throws LockedException {
        if (mRunning) {
            throw new LockedException();
        }
        mInitialSx = initialSx;
        mInitialSy = initialSy;
        mInitialSz = initialSz;
    }

    /**
     * Sets initial cross coupling errors.
     *
     * @param initialMxy initial x-y cross coupling error.
     * @param initialMxz initial x-z cross coupling error.
     * @param initialMyx initial y-x cross coupling error.
     * @param initialMyz initial y-z cross coupling error.
     * @param initialMzx initial z-x cross coupling error.
     * @param initialMzy initial z-y cross coupling error.
     * @throws LockedException if calibrator is currently running.
     */
    @Override
    public void setInitialCrossCouplingErrors(
            final double initialMxy, final double initialMxz, final double initialMyx,
            final double initialMyz, final double initialMzx, final double initialMzy)
            throws LockedException {
        if (mRunning) {
            throw new LockedException();
        }
        mInitialMxy = initialMxy;
        mInitialMxz = initialMxz;
        mInitialMyx = initialMyx;
        mInitialMyz = initialMyz;
        mInitialMzx = initialMzx;
        mInitialMzy = initialMzy;
    }

    /**
     * Sets initial scaling factors and cross coupling errors.
     *
     * @param initialSx  initial x scaling factor.
     * @param initialSy  initial y scaling factor.
     * @param initialSz  initial z scaling factor.
     * @param initialMxy initial x-y cross coupling error.
     * @param initialMxz initial x-z cross coupling error.
     * @param initialMyx initial y-x cross coupling error.
     * @param initialMyz initial y-z cross coupling error.
     * @param initialMzx initial z-x cross coupling error.
     * @param initialMzy initial z-y cross coupling error.
     * @throws LockedException if calibrator is currently running.
     */
    @Override
    public void setInitialScalingFactorsAndCrossCouplingErrors(
            final double initialSx, final double initialSy, final double initialSz,
            final double initialMxy, final double initialMxz, final double initialMyx,
            final double initialMyz, final double initialMzx, final double initialMzy)
            throws LockedException {
        if (mRunning) {
            throw new LockedException();
        }
        setInitialScalingFactors(initialSx, initialSy, initialSz);
        setInitialCrossCouplingErrors(initialMxy, initialMxz, initialMyx,
                initialMyz, initialMzx, initialMzy);
    }

    /**
     * Gets known accelerometer bias as an array.
     * Array values are expressed in meters per squared second (m/s^2).
     *
     * @return array containint coordinates of known bias.
     */
    @Override
    public double[] getBias() {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/INSLooselyCoupledKalmanInitializerConfig.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/INSLooselyCoupledKalmanInitializerConfig.html#L112">112</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/INSTightlyCoupledKalmanInitializerConfig.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/INSTightlyCoupledKalmanInitializerConfig.html#L136">136</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public INSLooselyCoupledKalmanInitializerConfig(final INSLooselyCoupledKalmanInitializerConfig input) {
        copyFrom(input);
    }

    /**
     * Gets initial attitude uncertainty per axis expressed in radians (rad).
     *
     * @return initial attitude uncertainty per axis expressed in radians (rad).
     */
    public double getInitialAttitudeUncertainty() {
        return mInitialAttitudeUncertainty;
    }

    /**
     * Sets initial attitude uncertainty per axis expressed in radians (rad).
     *
     * @param initialAttitudeUncertainty initial attitude uncertainty per axis expressed
     *                                   in radians (rad).
     */
    public void setInitialAttitudeUncertainty(final double initialAttitudeUncertainty) {
        mInitialAttitudeUncertainty = initialAttitudeUncertainty;
    }

    /**
     * Gets initial attitude uncertainty per axis.
     *
     * @param result instance where initial attitude uncertainty per axis will be stored.
     */
    public void getInitialAttitudeUncertaintyAngle(final Angle result) {
        result.setValue(mInitialAttitudeUncertainty);
        result.setUnit(AngleUnit.RADIANS);
    }

    /**
     * Gets initial attitude uncertainty per axis.
     *
     * @return initial attitude uncertainty per axis.
     */
    public Angle getInitialAttitudeUncertaintyAngle() {
        return new Angle(mInitialAttitudeUncertainty, AngleUnit.RADIANS);
    }

    /**
     * Sets initial attitude uncertainty per axis.
     *
     * @param initialAttitudeUncertainty initial attitude uncertainty per axis.
     */
    public void setInitialAttitudeUncertainty(final Angle initialAttitudeUncertainty) {
        mInitialAttitudeUncertainty = AngleConverter.convert(
                initialAttitudeUncertainty.getValue().doubleValue(),
                initialAttitudeUncertainty.getUnit(), AngleUnit.RADIANS);
    }

    /**
     * Gets initial velocity uncertainty per axis expressed in meters per second (m/s).
     *
     * @return initial velocity uncertainty per axis expressed in meters per second (m/s).
     */
    public double getInitialVelocityUncertainty() {
        return mInitialVelocityUncertainty;
    }

    /**
     * Sets initial velocity uncertainty per axis expressed in meters per second (m/s).
     *
     * @param initialVelocityUncertainty initial velocity uncertainty per axis expressed
     *                                   in meters per second (m/s).
     */
    public void setInitialVelocityUncertainty(final double initialVelocityUncertainty) {
        mInitialVelocityUncertainty = initialVelocityUncertainty;
    }

    /**
     * Gets initial velocity uncertainty per axis.
     *
     * @param result instance where initial attitude uncertainty per axis will be stored.
     */
    public void getInitialVelocityUncertaintySpeed(final Speed result) {
        result.setValue(mInitialVelocityUncertainty);
        result.setUnit(SpeedUnit.METERS_PER_SECOND);
    }

    /**
     * Gets initial velocity uncertainty per axis.
     *
     * @return initial velocity uncertainty per axis.
     */
    public Speed getInitialVelocityUncertaintySpeed() {
        return new Speed(mInitialVelocityUncertainty, SpeedUnit.METERS_PER_SECOND);
    }

    /**
     * Sets initial velocity uncertainty per axis.
     *
     * @param initialVelocityUncertainty initial velocity uncertainty per axis.
     */
    public void setInitialVelocityUncertainty(final Speed initialVelocityUncertainty) {
        mInitialVelocityUncertainty = SpeedConverter.convert(
                initialVelocityUncertainty.getValue().doubleValue(),
                initialVelocityUncertainty.getUnit(), SpeedUnit.METERS_PER_SECOND);
    }

    /**
     * Gets initial position uncertainty per axis expressed in meters (m)
     *
     * @return initial position uncertainty per axis expressed in meters (m).
     */
    public double getInitialPositionUncertainty() {
        return mInitialPositionUncertainty;
    }

    /**
     * Sets initial position uncertainty per axis expressed in meters (m)
     *
     * @param initialPositionUncertainty initial position uncertainty per axis expressed
     *                                   in meters (m).
     */
    public void setInitialPositionUncertainty(final double initialPositionUncertainty) {
        mInitialPositionUncertainty = initialPositionUncertainty;
    }

    /**
     * Gets initial position uncertainty per axis.
     *
     * @param result instance where initial position uncertainty per axis will be stored.
     */
    public void getInitialPositionUncertaintyDistance(final Distance result) {
        result.setValue(mInitialPositionUncertainty);
        result.setUnit(DistanceUnit.METER);
    }

    /**
     * Gets initial position uncertainty per axis.
     *
     * @return initial position uncertainty per axis.
     */
    public Distance getInitialPositionUncertaintyDistance() {
        return new Distance(mInitialPositionUncertainty, DistanceUnit.METER);
    }

    /**
     * Sets initial position uncertainty per axis.
     *
     * @param initialPositionUncertainty initial position uncertainty per axis.
     */
    public void setInitialPositionUncertainty(final Distance initialPositionUncertainty) {
        mInitialPositionUncertainty = DistanceConverter.convert(
                initialPositionUncertainty.getValue().doubleValue(),
                initialPositionUncertainty.getUnit(), DistanceUnit.METER);
    }

    /**
     * Gets initial acceleration bias uncertainty expressed in meters per squared second (m/s^2).
     *
     * @return initial acceleration bias uncertainty expressed in meters per squared second (m/s^2).
     */
    public double getInitialAccelerationBiasUncertainty() {
        return mInitialAccelerationBiasUncertainty;
    }

    /**
     * Sets initial acceleration bias uncertainty expressed in meters per squared second (m/s^2).
     *
     * @param initialAccelerationBiasUncertainty initial acceleration bias uncertainty expressed in
     *                                           meters per squared second (m/s^2).
     */
    public void setInitialAccelerationBiasUncertainty(
            final double initialAccelerationBiasUncertainty) {
        mInitialAccelerationBiasUncertainty = initialAccelerationBiasUncertainty;
    }

    /**
     * Gets initial acceleration bias uncertainty.
     *
     * @param result instance where initial acceleration bias uncertainty will be stored.
     */
    public void getInitialAccelerationBiasUncertaintyAcceleration(final Acceleration result) {
        result.setValue(mInitialAccelerationBiasUncertainty);
        result.setUnit(AccelerationUnit.METERS_PER_SQUARED_SECOND);
    }

    /**
     * Gets initial acceleration bias uncertainty.
     *
     * @return initial acceleration bias uncertainty.
     */
    public Acceleration getInitialAccelerationBiasUncertaintyAcceleration() {
        return new Acceleration(mInitialAccelerationBiasUncertainty,
                AccelerationUnit.METERS_PER_SQUARED_SECOND);
    }

    /**
     * Sets initial acceleration bias uncertainty.
     *
     * @param initialAccelerationUncertainty initial acceleration bias uncertainty.
     */
    public void setInitialAccelerationBiasUncertainty(
            final Acceleration initialAccelerationUncertainty) {
        mInitialAccelerationBiasUncertainty = AccelerationConverter.convert(
                initialAccelerationUncertainty.getValue().doubleValue(),
                initialAccelerationUncertainty.getUnit(),
                AccelerationUnit.METERS_PER_SQUARED_SECOND);
    }

    /**
     * Gets initial gyroscope bias uncertainty expressed in radians per second (rad/s).
     *
     * @return initial gyroscope bias uncertainty expressed in radians per second (rad/s).
     */
    public double getInitialGyroscopeBiasUncertainty() {
        return mInitialGyroscopeBiasUncertainty;
    }

    /**
     * Sets initial gyroscope bias uncertainty expressed in radians per second (rad/s).
     *
     * @param initialGyroscopeBiasUncertainty initial gyroscope bias uncertainty expressed
     *                                        in radians per second (rad/s).
     */
    public void setInitialGyroscopeBiasUncertainty(
            final double initialGyroscopeBiasUncertainty) {
        mInitialGyroscopeBiasUncertainty = initialGyroscopeBiasUncertainty;
    }

    /**
     * Gets initial gyroscope bias uncertainty.
     *
     * @param result instance where initial gyroscope bias uncertainty will be stored.
     */
    public void getInitialGyroscopeBiasUncertaintyAngularSpeed(AngularSpeed result) {
        result.setValue(mInitialGyroscopeBiasUncertainty);
        result.setUnit(AngularSpeedUnit.RADIANS_PER_SECOND);
    }

    /**
     * Gets initial gyroscope bias uncertainty.
     *
     * @return initial gyroscope bias uncertainty.
     */
    public AngularSpeed getInitialGyroscopeBiasUncertaintyAngularSpeed() {
        return new AngularSpeed(mInitialGyroscopeBiasUncertainty,
                AngularSpeedUnit.RADIANS_PER_SECOND);
    }

    /**
     * Sets initial gyroscope bias uncertainty.
     *
     * @param initialGyroscopeBiasUncertainty initial gyroscope bias uncertainty.
     */
    public void setInitialGyroscopeBiasUncertainty(
            final AngularSpeed initialGyroscopeBiasUncertainty) {
        mInitialGyroscopeBiasUncertainty = AngularSpeedConverter.convert(
                initialGyroscopeBiasUncertainty.getValue().doubleValue(),
                initialGyroscopeBiasUncertainty.getUnit(),
                AngularSpeedUnit.RADIANS_PER_SECOND);
    }

    /**
     * Sets configuration parameters.
     *
     * @param initialAttitudeUncertainty         initial attitude uncertainty per axis
     *                                           expressed in radians (rad).
     * @param initialVelocityUncertainty         initial velocity uncertainty per axis
     *                                           expressed in meters per second (m/s).
     * @param initialPositionUncertainty         initial position uncertainty per axis
     *                                           expressed in meters (m).
     * @param initialAccelerationBiasUncertainty initial acceleration bias uncertainty
     *                                           expressed in meters per squared second (m/s^2).
     * @param initialGyroscopeBiasUncertainty    initial gyroscope bias uncertainty
     *                                           expressed in radians per second (rad/s).
     */
    public void setValues(final double initialAttitudeUncertainty,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/estimators/ECEFKinematicsEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/estimators/ECEFKinematicsEstimator.html#L2136">2136</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/estimators/ECIKinematicsEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/estimators/ECIKinematicsEstimator.html#L1162">1162</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                                          final ECEFFrame frame, final ECEFFrame oldFrame,
                                          final BodyKinematics result) {
        estimateKinematics(timeInterval, frame,
                oldFrame.getCoordinateTransformation(),
                oldFrame.getVx(), oldFrame.getVy(), oldFrame.getVz(), result);
    }

    /**
     * Estimates body kinematics (specific force applied to a body and its angular rates).
     *
     * @param timeInterval time interval between epochs expressed in seconds (s).
     * @param c            body-to-ECEF frame coordinate transformation matrix.
     * @param oldC         previous body-to-ECEF-frame coordinate transformation matrix.
     * @param vx           velocity of body frame x coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param vy           velocity of body frame y coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param vz           velocity of body frame z coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param oldVx        previous velocity of body frame x coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldVy        previous velocity of body frame y coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldVz        previous velocity of body frame z coordinate with respect ECEF
     *                     frame, resolved along EVEF-frame axes.
     * @param x            cartesian x coordinate of body position expressed in meters (m)
     *                     with respect ECEF frame, resolved along ECEF-frame axes.
     * @param y            cartesian y coordinate of body position expressed in meters (m)
     *                     with respect ECEF frame, resolved along ECEF-frame axes.
     * @param z            cartesian z coordinate of body position expressed in meters (m)
     *                     with respect ECEF frame, resolved along ECEF-frame axes.
     * @param result       instance where body kinematics estimation will be stored.
     * @throws IllegalArgumentException if provided time interval is negative or coordinated transformation matrices
     *                                  are not ECEF frame valid.
     */
    public static void estimateKinematics(final double timeInterval,
                                          final CoordinateTransformation c,
                                          final CoordinateTransformation oldC,
                                          final Speed vx, final Speed vy, final Speed vz,
                                          final Speed oldVx, final Speed oldVy, final Speed oldVz,
                                          final double x, final double y, final double z,
                                          final BodyKinematics result) {
        estimateKinematics(timeInterval, c, oldC,
                SpeedConverter.convert(vx.getValue().doubleValue(), vx.getUnit(), SpeedUnit.METERS_PER_SECOND),
                SpeedConverter.convert(vy.getValue().doubleValue(), vy.getUnit(), SpeedUnit.METERS_PER_SECOND),
                SpeedConverter.convert(vz.getValue().doubleValue(), vz.getUnit(), SpeedUnit.METERS_PER_SECOND),
                SpeedConverter.convert(oldVx.getValue().doubleValue(), oldVx.getUnit(), SpeedUnit.METERS_PER_SECOND),
                SpeedConverter.convert(oldVy.getValue().doubleValue(), oldVy.getUnit(), SpeedUnit.METERS_PER_SECOND),
                SpeedConverter.convert(oldVz.getValue().doubleValue(), oldVz.getUnit(), SpeedUnit.METERS_PER_SECOND),
                x, y, z, result);
    }

    /**
     * Estimates body kinematics (specific force applied to a body and its angular rates).
     *
     * @param timeInterval time interval between epochs.
     * @param c            body-to-ECEF frame coordinate transformation matrix.
     * @param oldC         previous body-to-ECEF-frame coordinate transformation matrix.
     * @param vx           velocity of body frame x coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param vy           velocity of body frame y coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param vz           velocity of body frame z coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param oldVx        previous velocity of body frame x coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldVy        previous velocity of body frame y coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldVz        previous velocity of body frame z coordinate with respect ECEF
     *                     frame, resolved along EVEF-frame axes.
     * @param x            cartesian x coordinate of body position expressed in meters (m)
     *                     with respect ECEF frame, resolved along ECEF-frame axes.
     * @param y            cartesian y coordinate of body position expressed in meters (m)
     *                     with respect ECEF frame, resolved along ECEF-frame axes.
     * @param z            cartesian z coordinate of body position expressed in meters (m)
     *                     with respect ECEF frame, resolved along ECEF-frame axes.
     * @param result       instance where body kinematics estimation will be stored.
     * @throws IllegalArgumentException if provided time interval is negative or coordinated transformation matrices
     *                                  are not ECEF frame valid.
     */
    public static void estimateKinematics(final Time timeInterval,
                                          final CoordinateTransformation c,
                                          final CoordinateTransformation oldC,
                                          final Speed vx, final Speed vy, final Speed vz,
                                          final Speed oldVx, final Speed oldVy, final Speed oldVz,
                                          final double x, final double y, final double z,
                                          final BodyKinematics result) {
        estimateKinematics(timeInterval, c, oldC,
                SpeedConverter.convert(vx.getValue().doubleValue(), vx.getUnit(), SpeedUnit.METERS_PER_SECOND),
                SpeedConverter.convert(vy.getValue().doubleValue(), vy.getUnit(), SpeedUnit.METERS_PER_SECOND),
                SpeedConverter.convert(vz.getValue().doubleValue(), vz.getUnit(), SpeedUnit.METERS_PER_SECOND),
                SpeedConverter.convert(oldVx.getValue().doubleValue(), oldVx.getUnit(), SpeedUnit.METERS_PER_SECOND),
                SpeedConverter.convert(oldVy.getValue().doubleValue(), oldVy.getUnit(), SpeedUnit.METERS_PER_SECOND),
                SpeedConverter.convert(oldVz.getValue().doubleValue(), oldVz.getUnit(), SpeedUnit.METERS_PER_SECOND),
                x, y, z, result);
    }

    /**
     * Estimates body kinematics (specific force applied to a body and its angular rates).
     *
     * @param timeInterval time interval between epochs expressed in seconds (s).
     * @param c            body-to-ECEF frame coordinate transformation matrix.
     * @param oldC         previous body-to-ECEF-frame coordinate transformation matrix.
     * @param vx           velocity of body frame x coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param vy           velocity of body frame y coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param vz           velocity of body frame z coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param oldVx        previous velocity of body frame x coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldVy        previous velocity of body frame y coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldVz        previous velocity of body frame z coordinate with respect ECEF
     *                     frame, resolved along EVEF-frame axes.
     * @param position     cartesian body position resolved along ECEF-frame axes.
     * @param result       instance where body kinematics estimation will be stored.
     * @throws IllegalArgumentException if provided time interval is negative or coordinated transformation matrices
     *                                  are not ECEF frame valid.
     */
    public static void estimateKinematics(final double timeInterval,
                                          final CoordinateTransformation c,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/calibration/RobustKnownBiasAndFrameAccelerometerCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/RobustKnownBiasAndFrameAccelerometerCalibrator.html#L1322">1322</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/calibration/RobustKnownFrameAccelerometerCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/RobustKnownFrameAccelerometerCalibrator.html#L692">692</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>        internalSetBias(bias);
    }

    /**
     * Gets initial x scaling factor.
     * This is only taken into account if non-linear preliminary solutions are used.
     *
     * @return initial x scaling factor.
     */
    public double getInitialSx() {
        return mInitialSx;
    }

    /**
     * Sets initial x scaling factor.
     * This is only taken into account if non-linear preliminary solutions are used.
     *
     * @param initialSx initial x scaling factor.
     * @throws LockedException if calibrator is currently running.
     */
    public void setInitialSx(final double initialSx) throws LockedException {
        if (mRunning) {
            throw new LockedException();
        }
        mInitialSx = initialSx;
    }

    /**
     * Gets initial y scaling factor.
     * This is only taken into account if non-linear preliminary solutions are used.
     *
     * @return initial y scaling factor.
     */
    public double getInitialSy() {
        return mInitialSy;
    }

    /**
     * Sets initial y scaling factor.
     * This is only taken into account if non-linear preliminary solutions are used.
     *
     * @param initialSy initial y scaling factor.
     * @throws LockedException if calibrator is currently running.
     */
    public void setInitialSy(final double initialSy) throws LockedException {
        if (mRunning) {
            throw new LockedException();
        }
        mInitialSy = initialSy;
    }

    /**
     * Gets initial z scaling factor.
     * This is only taken into account if non-linear preliminary solutions are used.
     *
     * @return initial z scaling factor.
     */
    public double getInitialSz() {
        return mInitialSz;
    }

    /**
     * Sets initial z scaling factor.
     * This is only taken into account if non-linear preliminary solutions are used.
     *
     * @param initialSz initial z scaling factor.
     * @throws LockedException if calibrator is currently running.
     */
    public void setInitialSz(final double initialSz) throws LockedException {
        if (mRunning) {
            throw new LockedException();
        }
        mInitialSz = initialSz;
    }

    /**
     * Gets initial x-y cross coupling error.
     * This is only taken into account if non-linear preliminary solutions are used.
     *
     * @return initial x-y cross coupling error.
     */
    public double getInitialMxy() {
        return mInitialMxy;
    }

    /**
     * Sets initial x-y cross coupling error.
     * This is only taken into account if non-linear preliminary solutions are used.
     *
     * @param initialMxy initial x-y cross coupling error.
     * @throws LockedException if calibrator is currently running.
     */
    public void setInitialMxy(final double initialMxy) throws LockedException {
        if (mRunning) {
            throw new LockedException();
        }
        mInitialMxy = initialMxy;
    }

    /**
     * Gets initial x-z cross coupling error.
     * This is only taken into account if non-linear preliminary solutions are used.
     *
     * @return initial x-z cross coupling error.
     */
    public double getInitialMxz() {
        return mInitialMxz;
    }

    /**
     * Sets initial x-z cross coupling error.
     * This is only taken into account if non-linear preliminary solutions are used.
     *
     * @param initialMxz initial x-z cross coupling error.
     * @throws LockedException if calibrator is currently running.
     */
    public void setInitialMxz(final double initialMxz) throws LockedException {
        if (mRunning) {
            throw new LockedException();
        }
        mInitialMxz = initialMxz;
    }

    /**
     * Gets initial y-x cross coupling error.
     * This is only taken into account if non-linear preliminary solutions are used.
     *
     * @return initial y-x cross coupling error.
     */
    public double getInitialMyx() {
        return mInitialMyx;
    }

    /**
     * Sets initial y-x cross coupling error.
     * This is only taken into account if non-linear preliminary solutions are used.
     *
     * @param initialMyx initial y-x cross coupling error.
     * @throws LockedException if calibrator is currently running.
     */
    public void setInitialMyx(final double initialMyx) throws LockedException {
        if (mRunning) {
            throw new LockedException();
        }
        mInitialMyx = initialMyx;
    }

    /**
     * Gets initial y-z cross coupling error.
     * This is only taken into account if non-linear preliminary solutions are used.
     *
     * @return initial y-z cross coupling error.
     */
    public double getInitialMyz() {
        return mInitialMyz;
    }

    /**
     * Sets initial y-z cross coupling error.
     * This is only taken into account if non-linear preliminary solutions are used.
     *
     * @param initialMyz initial y-z cross coupling error.
     * @throws LockedException if calibrator is currently running.
     */
    public void setInitialMyz(final double initialMyz) throws LockedException {
        if (mRunning) {
            throw new LockedException();
        }
        mInitialMyz = initialMyz;
    }

    /**
     * Gets initial z-x cross coupling error.
     * This is only taken into account if non-linear preliminary solutions are used.
     *
     * @return initial z-x cross coupling error.
     */
    public double getInitialMzx() {
        return mInitialMzx;
    }

    /**
     * Sets initial z-x cross coupling error.
     * This is only taken into account if non-linear preliminary solutions are used.
     *
     * @param initialMzx initial z-x cross coupling error.
     * @throws LockedException if calibrator is currently running.
     */
    public void setInitialMzx(final double initialMzx) throws LockedException {
        if (mRunning) {
            throw new LockedException();
        }
        mInitialMzx = initialMzx;
    }

    /**
     * Gets initial z-y cross coupling error.
     * This is only taken into account if non-linear preliminary solutions are used.
     *
     * @return initial z-y cross coupling error.
     */
    public double getInitialMzy() {
        return mInitialMzy;
    }

    /**
     * Sets initial z-y cross coupling error.
     * This is only taken into account if non-linear preliminary solutions are used.
     *
     * @param initialMzy initial z-y cross coupling error.
     * @throws LockedException if calibrator is currently running.
     */
    public void setInitialMzy(final double initialMzy) throws LockedException {
        if (mRunning) {
            throw new LockedException();
        }
        mInitialMzy = initialMzy;
    }

    /**
     * Sets initial scaling factors.
     * This is only taken into account if non-linear preliminary solutions are used.
     *
     * @param initialSx initial x scaling factor.
     * @param initialSy initial y scaling factor.
     * @param initialSz initial z scaling factor.
     * @throws LockedException if calibrator is currently running.
     */
    public void setInitialScalingFactors(
            final double initialSx, final double initialSy, final double initialSz)
            throws LockedException {
        if (mRunning) {
            throw new LockedException();
        }
        mInitialSx = initialSx;
        mInitialSy = initialSy;
        mInitialSz = initialSz;
    }

    /**
     * Sets initial cross coupling errors.
     * This is only taken into account if non-linear preliminary solutions are used.
     *
     * @param initialMxy initial x-y cross coupling error.
     * @param initialMxz initial x-z cross coupling error.
     * @param initialMyx initial y-x cross coupling error.
     * @param initialMyz initial y-z cross coupling error.
     * @param initialMzx initial z-x cross coupling error.
     * @param initialMzy initial z-y cross coupling error.
     * @throws LockedException if calibrator is currently running.
     */
    public void setInitialCrossCouplingErrors(
            final double initialMxy, final double initialMxz, final double initialMyx,
            final double initialMyz, final double initialMzx, final double initialMzy)
            throws LockedException {
        if (mRunning) {
            throw new LockedException();
        }
        mInitialMxy = initialMxy;
        mInitialMxz = initialMxz;
        mInitialMyx = initialMyx;
        mInitialMyz = initialMyz;
        mInitialMzx = initialMzx;
        mInitialMzy = initialMzy;
    }

    /**
     * Sets initial scaling factors and cross coupling errors.
     * This is only taken into account if non-linear preliminary solutions are used.
     *
     * @param initialSx  initial x scaling factor.
     * @param initialSy  initial y scaling factor.
     * @param initialSz  initial z scaling factor.
     * @param initialMxy initial x-y cross coupling error.
     * @param initialMxz initial x-z cross coupling error.
     * @param initialMyx initial y-x cross coupling error.
     * @param initialMyz initial y-z cross coupling error.
     * @param initialMzx initial z-x cross coupling error.
     * @param initialMzy initial z-y cross coupling error.
     * @throws LockedException if calibrator is currently running.
     */
    public void setInitialScalingFactorsAndCrossCouplingErrors(
            final double initialSx, final double initialSy, final double initialSz,
            final double initialMxy, final double initialMxz, final double initialMyx,
            final double initialMyz, final double initialMzx, final double initialMzy)
            throws LockedException {
        if (mRunning) {
            throw new LockedException();
        }
        setInitialScalingFactors(initialSx, initialSy, initialSz);
        setInitialCrossCouplingErrors(initialMxy, initialMxz, initialMyx,
                initialMyz, initialMzx, initialMzy);
    }

    /**
     * Gets initial scale factors and cross coupling errors matrix.
     * This is only taken into account if non-linear preliminary solutions are used.
     *
     * @return initial scale factors and cross coupling errors matrix.
     */
    public Matrix getInitialMa() {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/INSLooselyCoupledKalmanEpochEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/INSLooselyCoupledKalmanEpochEstimator.html#L688">688</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/INSTightlyCoupledKalmanEpochEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/INSTightlyCoupledKalmanEpochEstimator.html#L104">104</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                INSLooselyCoupledKalmanState.NUM_PARAMS);

        final Matrix tmp1 = omegaIe.multiplyByScalarAndReturnNew(
                propagationInterval);
        final Matrix tmp2 = phiMatrix.getSubmatrix(0, 0,
                2, 2);
        tmp2.subtract(tmp1);

        phiMatrix.setSubmatrix(0, 0,
                2, 2, tmp2);

        final Matrix estCbeOld = previousState
                .getBodyToEcefCoordinateTransformationMatrix();
        tmp1.copyFrom(estCbeOld);
        tmp1.multiplyByScalar(propagationInterval);

        phiMatrix.setSubmatrix(0, 12,
                2, 14, tmp1);
        phiMatrix.setSubmatrix(3, 9,
                5, 11, tmp1);

        final Matrix measFibb = new Matrix(BodyKinematics.COMPONENTS, 1);
        measFibb.setElementAtIndex(0, fx);
        measFibb.setElementAtIndex(1, fy);
        measFibb.setElementAtIndex(2, fz);

        estCbeOld.multiply(measFibb, tmp1);

        Utils.skewMatrix(tmp1, tmp2);
        tmp2.multiplyByScalar(-propagationInterval);

        phiMatrix.setSubmatrix(3, 0,
                5, 2, tmp2);

        phiMatrix.getSubmatrix(3, 3,
                5, 5, tmp1);
        tmp2.copyFrom(omegaIe);
        tmp2.multiplyByScalar(2.0 * propagationInterval);
        tmp1.subtract(tmp2);
        phiMatrix.setSubmatrix(3, 3,
                5, 5, tmp1);

        final double sinPrevLat = Math.sin(previousLatitude);
        final double cosPrevLat = Math.cos(previousLatitude);
        final double sinPrevLat2 = sinPrevLat * sinPrevLat;
        final double cosPrevLat2 = cosPrevLat * cosPrevLat;

        // From (2.137)
        final double geocentricRadius = EARTH_EQUATORIAL_RADIUS_WGS84
                / Math.sqrt(1.0 - Math.pow(EARTH_ECCENTRICITY * sinPrevLat, 2.0))
                * Math.sqrt(cosPrevLat2
                + Math.pow(1.0 - EARTH_ECCENTRICITY * EARTH_ECCENTRICITY, 2.0) * sinPrevLat2);

        final double prevX = previousState.getX();
        final double prevY = previousState.getY();
        final double prevZ = previousState.getZ();
        final ECEFGravity gravity = ECEFGravityEstimator.estimateGravityAndReturnNew(
                prevX, prevY, prevZ);

        final double previousPositionNorm = Math.sqrt(prevX * prevX +
                prevY * prevY + prevZ * prevZ);

        final Matrix estRebeOld = new Matrix(ECEFPosition.COMPONENTS, 1);
        estRebeOld.setElementAtIndex(0, prevX);
        estRebeOld.setElementAtIndex(1, prevY);
        estRebeOld.setElementAtIndex(2, prevZ);

        final Matrix g = gravity.asMatrix();
        g.multiplyByScalar(-2.0 * propagationInterval / geocentricRadius);

        final Matrix estRebeOldTrans = estRebeOld.transposeAndReturnNew();
        estRebeOldTrans.multiplyByScalar(1.0 / previousPositionNorm);

        g.multiply(estRebeOldTrans, tmp1);

        phiMatrix.setSubmatrix(3, 6,
                5, 8, tmp1);

        for (int i = 0; i &lt; ECEFPosition.COMPONENTS; i++) {
            phiMatrix.setElementAt(6 + i, 3 + i, propagationInterval);
        }</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/calibration/KnownBiasAndFrameAccelerometerLinearLeastSquaresCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/KnownBiasAndFrameAccelerometerLinearLeastSquaresCalibrator.html#L686">686</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/calibration/KnownBiasAndFrameAccelerometerNonLinearLeastSquaresCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/KnownBiasAndFrameAccelerometerNonLinearLeastSquaresCalibrator.html#L1858">1858</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>        mListener = listener;
    }

    /**
     * Gets known x coordinate of accelerometer bias expressed in meters per squared
     * second (m/s^2).
     *
     * @return x coordinate of accelerometer bias.
     */
    @Override
    public double getBiasX() {
        return mBiasX;
    }

    /**
     * Sets known x coordinate of accelerometer bias expressed in meters per squared
     * second (m/s^2).
     *
     * @param biasX x coordinate of accelerometer bias.
     * @throws LockedException if estimator is currently running.
     */
    @Override
    public void setBiasX(final double biasX) throws LockedException {
        if (mRunning) {
            throw new LockedException();
        }
        mBiasX = biasX;
    }

    /**
     * Gets known y coordinate of accelerometer bias expressed in meters per squared
     * second (m/s^2).
     *
     * @return y coordinate of accelerometer bias.
     */
    @Override
    public double getBiasY() {
        return mBiasY;
    }

    /**
     * Sets known y coordinate of accelerometer bias expressed in meters per squared
     * second (m/s^2).
     *
     * @param biasY y coordinate of accelerometer bias.
     * @throws LockedException if estimator is currently running.
     */
    @Override
    public void setBiasY(final double biasY) throws LockedException {
        if (mRunning) {
            throw new LockedException();
        }

        mBiasY = biasY;
    }

    /**
     * Gets known z coordinate of accelerometer bias expressed in meters per squared
     * second (m/s^2).
     *
     * @return z coordinate of accelerometer bias.
     */
    @Override
    public double getBiasZ() {
        return mBiasZ;
    }

    /**
     * Sets known z coordinate of accelerometer bias expressed in meters per squared
     * second (m/s^2).
     *
     * @param biasZ z coordinate of accelerometer bias.
     * @throws LockedException if estimator is currently running.
     */
    @Override
    public void setBiasZ(final double biasZ) throws LockedException {
        if (mRunning) {
            throw new LockedException();
        }

        mBiasZ = biasZ;
    }

    /**
     * Gets known x coordinate of accelerometer bias.
     *
     * @return x coordinate of accelerometer bias.
     */
    @Override
    public Acceleration getBiasXAsAcceleration() {
        return new Acceleration(mBiasX, AccelerationUnit.METERS_PER_SQUARED_SECOND);
    }

    /**
     * Gets known x coordinate of accelerometer bias.
     *
     * @param result instance where result data will be stored.
     */
    @Override
    public void getBiasXAsAcceleration(final Acceleration result) {
        result.setValue(mBiasX);
        result.setUnit(AccelerationUnit.METERS_PER_SQUARED_SECOND);
    }

    /**
     * Sets known x coordinate of accelerometer bias.
     *
     * @param biasX x coordinate of accelerometer bias.
     * @throws LockedException if estimator is currently running.
     */
    @Override
    public void setBiasX(final Acceleration biasX) throws LockedException {
        if (mRunning) {
            throw new LockedException();
        }

        mBiasX = convertAcceleration(biasX);
    }

    /**
     * Gets known y coordinate of accelerometer bias.
     *
     * @return y coordinate of accelerometer bias.
     */
    @Override
    public Acceleration getBiasYAsAcceleration() {
        return new Acceleration(mBiasY, AccelerationUnit.METERS_PER_SQUARED_SECOND);
    }

    /**
     * Gets known y coordinate of accelerometer bias.
     *
     * @param result instance where result data will be stored.
     */
    @Override
    public void getBiasYAsAcceleration(final Acceleration result) {
        result.setValue(mBiasY);
        result.setUnit(AccelerationUnit.METERS_PER_SQUARED_SECOND);
    }

    /**
     * Sets known y coordinate of accelerometer bias.
     *
     * @param biasY y coordinate of accelerometer bias.
     * @throws LockedException if estimator is currently running.
     */
    @Override
    public void setBiasY(final Acceleration biasY) throws LockedException {
        if (mRunning) {
            throw new LockedException();
        }

        mBiasY = convertAcceleration(biasY);
    }

    /**
     * Gets known z coordinate of accelerometer bias.
     *
     * @return z coordinate of accelerometer bias.
     */
    @Override
    public Acceleration getBiasZAsAcceleration() {
        return new Acceleration(mBiasZ, AccelerationUnit.METERS_PER_SQUARED_SECOND);
    }

    /**
     * Gets known z coordinate of accelerometer bias.
     *
     * @param result instance where result data will be stored.
     */
    @Override
    public void getBiasZAsAcceleration(final Acceleration result) {
        result.setValue(mBiasZ);
        result.setUnit(AccelerationUnit.METERS_PER_SQUARED_SECOND);
    }

    /**
     * Sets known z coordinate of accelerometer bias.
     *
     * @param biasZ z coordinate of accelerometer bias.
     * @throws LockedException if estimator is currently running.
     */
    @Override
    public void setBiasZ(final Acceleration biasZ) throws LockedException {
        if (mRunning) {
            throw new LockedException();
        }

        mBiasZ = convertAcceleration(biasZ);
    }

    /**
     * Sets known accelerometer bias coordinates expressed in meters per squared
     * second (m/s^2).
     *
     * @param biasX x coordinate of accelerometer bias.
     * @param biasY y coordinate of accelerometer bias.
     * @param biasZ z coordinate of accelerometer bias.
     * @throws LockedException if estimator is currently running.
     */
    @Override
    public void setBiasCoordinates(
            final double biasX, final double biasY, final double biasZ)
            throws LockedException {
        if (mRunning) {
            throw new LockedException();
        }

        mBiasX = biasX;
        mBiasY = biasY;
        mBiasZ = biasZ;
    }

    /**
     * Sets known accelerometer bias coordinates.
     *
     * @param biasX z coordinate of accelerometer bias.
     * @param biasY y coordinate of accelerometer bias.
     * @param biasZ z coordinate of accelerometer bias.
     * @throws LockedException if estimator is curently running.
     */
    @Override
    public void setBiasCoordinates(final Acceleration biasX, final Acceleration biasY,
                                   final Acceleration biasZ) throws LockedException {
        if (mRunning) {
            throw new LockedException();
        }

        mBiasX = convertAcceleration(biasX);
        mBiasY = convertAcceleration(biasY);
        mBiasZ = convertAcceleration(biasZ);
    }

    /**
     * Gets known accelerometer bias as an array.
     * Array values are expressed in meters per squared second (m/s^2).
     *
     * @return array containint coordinates of known bias.
     */
    @Override
    public double[] getBias() {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustMixedRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustMixedRadioSourceEstimator.html#L1556">1556</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator.html#L1539">1539</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>            SequentialRobustMixedRadioSourceEstimatorListener&lt;S, P&gt; listener)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }

        mListener = listener;
    }

    /**
     * Returns quality scores corresponding to each pair of
     * positions and distances (i.e. sample).
     * The larger the score value the better the quality of the sample.
     * This implementation always returns null.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @return quality scores corresponding to each sample.
     */
    public double[] getQualityScores() {
        return mQualityScores;
    }

    /**
     * Sets quality scores corresponding to each pair of positions and
     * distances (i.e. sample).
     * The larger the score value the better the quality of the sample.
     * This implementation makes no action.
     * Subclasses using quality scores must implement proper behaviour.
     *
     * @param qualityScores quality scores corresponding to each pair of
     *                      matched points.
     * @throws IllegalArgumentException if provided quality scores length
     * is smaller than minimum required samples.
     * @throws LockedException if robust solver is locked because an
     * estimation is already in progress.
     */
    public void setQualityScores(double[] qualityScores) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetQualityScores(qualityScores);
    }

    /**
     * Gets initial transmitted power to start the estimation of radio source
     * transmitted power (expressed in dBm's).
     * If not defined, average value of received power readings will be used.
     *
     * @return initial transmitted power to start the estimation of radio source
     * transmitted power.
     */
    public Double getInitialTransmittedPowerdBm() {
        return mInitialTransmittedPowerdBm;
    }

    /**
     * Sets initial transmitted power to start the estimation of radio source
     * transmitted power (expressed in dBm's).
     * If not defined, average value of received power readings will be used.
     *
     * @param initialTransmittedPowerdBm initial transmitted power to start the
     *                                   estimation of radio source transmitted
     *                                   power.
     * @throws LockedException if estimator is locked.
     */
    public void setInitialTransmittedPowerdBm(Double initialTransmittedPowerdBm)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mInitialTransmittedPowerdBm = initialTransmittedPowerdBm;
    }

    /**
     * Gets initial transmitted power to start the estimation of radio source
     * transmitted power (expressed in mW).
     * If not defined, average value of received power readings will be used.
     *
     * @return initial transmitted power to start the estimation of radio source
     * transmitted power.
     */
    public Double getInitialTransmittedPower() {
        return mInitialTransmittedPowerdBm != null ?
                Utils.dBmToPower(mInitialTransmittedPowerdBm) : null;
    }

    /**
     * Sets initial transmitted power to start the estimation of radio source
     * transmitted power (expressed in mW).
     * If not defined, average value of received power readings will be used.
     *
     * @param initialTransmittedPower initial transmitted power to start the
     *                                estimation of radio source transmitted power.
     * @throws LockedException if estimator is locked.
     * @throws IllegalArgumentException if provided value is negative.
     */
    public void setInitialTransmittedPower(Double initialTransmittedPower)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (initialTransmittedPower != null) {
            if (initialTransmittedPower &lt; 0.0) {
                throw new IllegalArgumentException();
            }
            mInitialTransmittedPowerdBm = Utils.powerTodBm(
                    initialTransmittedPower);
        } else {
            mInitialTransmittedPowerdBm = null;
        }
    }

    /**
     * Gets initial position to start the estimation of radio source position.
     * If not defined, centroid of provided fingerprints will be used.
     *
     * @return initial position to start the estimation of radio source position.
     */
    public P getInitialPosition() {
        return mInitialPosition;
    }

    /**
     * Sets initial position to start the estimation of radio source position.
     * If not defined, centroid of provided fingerprints will be used.
     *
     * @param initialPosition initial position to start the estimation of radio
     *                        source position.
     * @throws LockedException if estimator is locked.
     */
    public void setInitialPosition(P initialPosition) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mInitialPosition = initialPosition;
    }

    /**
     * Gets initial exponent typically used on free space for path loss propagation
     * in terms of distance.
     * On different environments path loss exponent might have different value:
     * - Free space: 2.0
     * - Urban Area: 2.7 to 3.5
     * - Suburban Area: 3 to 5
     * - Indoor (line-of-sight): 1.6 to 1.8
     *
     * If path loss exponent estimation is enabled, estimation will start at this
     * value and will converge to the most appropriate value.
     * If path loss exponent estimation is disabled, this value will be assumed
     * to be exact and the estimated path loss exponent will be equal to this
     * value.
     *
     * @return initial path loss exponent.
     */
    public double getInitialPathLossExponent() {
        return mInitialPathLossExponent;
    }

    /**
     * Sets initial exponent typically used on free space for path loss propagation
     * in terms of distance.
     * On different environments path loss exponent might have different value:
     * - Free space: 2.0
     * - Urban Area: 2.7 to 3.5
     * - Suburban Area: 3 to 5
     * - Indoor (line-of-sight): 1.6 to 1.8
     *
     * If path loss exponent estimation is enabled, estimation will start at this
     * value and will converge to the most appropriate value.
     * If path loss exponent estimation is disabled, this value will be assumed
     * to be exact and the estimated path loss exponent will be equal to this
     * value.
     *
     * @param initialPathLossExponent initial path loss exponent.
     * @throws LockedException if estimator is locked.
     */
    public void setInitialPathLossExponent(double initialPathLossExponent)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mInitialPathLossExponent = initialPathLossExponent;
    }

    /**
     * Indicates whether transmitted power estimation is enabled or not.
     *
     * @return true if transmitted power estimation is enabled, false otherwise.
     */
    public boolean isTransmittedPowerEstimationEnabled() {
        return mTransmittedPowerEstimationEnabled;
    }

    /**
     * Specifies whether transmitted power estimation is enabled or not.
     *
     * @param transmittedPowerEstimationEnabled true if transmitted power estimation is enabled,
     *                                          false otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setTransmittedPowerEstimationEnabled(boolean transmittedPowerEstimationEnabled)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mTransmittedPowerEstimationEnabled = transmittedPowerEstimationEnabled;
    }

    /**
     * Indicates whether path loss estimation is enabled or not.
     *
     * @return true if path loss estimation is enabled, false otherwise.
     */
    public boolean isPathLossEstimationEnabled() {
        return mPathLossEstimationEnabled;
    }

    /**
     * Specifies whether path loss estimation is enabled or not.
     *
     * @param pathLossEstimationEnabled true if path loss estimation is enabled,
     *                                  false otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setPathLossEstimationEnabled(boolean pathLossEstimationEnabled)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mPathLossEstimationEnabled = pathLossEstimationEnabled;
    }

    /**
     * Indicates whether position covariances of readings must be taken into account to increase
     * the amount of standard deviation of each ranging measure by the amount of position standard
     * deviation assuming that both measures are statistically independent.
     *
     * @return true to take into account reading position covariances, false otherwise.
     */
    public boolean getUseReadingPositionCovariance() {
        return mUseReadingPositionCovariances;
    }

    /**
     * Specifies whether position covariances of readings must be taken into account to increase
     * the amount of standard deviation of each ranging measure by the amount of position standard
     * deviation assuming that both measures are statistically independent.
     *
     * @param useReadingPositionCovariances true to take into account reading position covariances, false
     *                                      otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setUseReadingPositionCovariances(boolean useReadingPositionCovariances)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mUseReadingPositionCovariances = useReadingPositionCovariances;
    }

    /**
     * Indicates whether an homogeneous ranging linear solver is used to estimate preliminary
     * positions.
     *
     * @return true if homogeneous ranging linear solver is used, false if an inhomogeneous ranging linear
     * one is used instead.
     */
    public boolean isHomogeneousRangingLinearSolverUsed() {
        return mUseHomogeneousRangingLinearSolver;
    }

    /**
     * Specifies whether an homogeneous ranging linear solver is used to estimate preliminary
     * positions.
     *
     * @param useHomogeneousRangingLinearSolver true if homogeneous ranging linear solver is used, false
     *                                          if an inhomogeneous ranging linear one is used instead.
     * @throws LockedException if estimator is locked.
     */
    public void setHomogeneousRangingLinearSolverUsed(
            boolean useHomogeneousRangingLinearSolver) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }

        mUseHomogeneousRangingLinearSolver = useHomogeneousRangingLinearSolver;
    }


    /**
     * Gets covariance for estimated position and power.
     * Matrix contains information in the following order:
     * Top-left submatrix contains covariance of position,
     * then follows transmitted power variance, and finally
     * the last element contains pathloss exponent variance.
     * This is only available when result has been refined and covariance is kept.
     *
     * @return covariance for estimated position and power.
     */
    public Matrix getCovariance() {
        return mCovariance;
    }

    /**
     * Gets estimated position covariance.
     * Size of this matrix will depend on the number of dimensions
     * of estimated position (either 2 or 3).
     * This is only available when result has been refined and covariance is kept.
     *
     * @return estimated position covariance.
     */
    public Matrix getEstimatedPositionCovariance() {
        return mEstimatedPositionCovariance;
    }

    /**
     * Gets estimated position.
     *
     * @return estimated position.
     */
    public P getEstimatedPosition() {
        return mEstimatedPosition;
    }

    /**
     * Indicates whether readings are valid or not.
     * Readings are considered valid when there are enough readings.
     *
     * @param readings readings to be validated.
     * @return true if readings are valid, false otherwise.
     */
    public boolean areValidReadings(
            List&lt;? extends ReadingLocated&lt;P&gt;&gt; readings) {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/calibration/KnownBiasAndFrameAccelerometerNonLinearLeastSquaresCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/KnownBiasAndFrameAccelerometerNonLinearLeastSquaresCalibrator.html#L3268">3268</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/calibration/KnownFrameAccelerometerNonLinearLeastSquaresCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/KnownFrameAccelerometerNonLinearLeastSquaresCalibrator.html#L3796">3796</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>        if (mEstimatedMa == null) {
            mEstimatedMa = new Matrix(BodyKinematics.COMPONENTS,
                    BodyKinematics.COMPONENTS);
        } else {
            mEstimatedMa.initialize(0.0);
        }

        mEstimatedMa.setElementAt(0, 0, sx);
        mEstimatedMa.setElementAt(1, 0, myx);
        mEstimatedMa.setElementAt(2, 0, mzx);

        mEstimatedMa.setElementAt(0, 1, mxy);
        mEstimatedMa.setElementAt(1, 1, sy);
        mEstimatedMa.setElementAt(2, 1, mzy);

        mEstimatedMa.setElementAt(0, 2, mxz);
        mEstimatedMa.setElementAt(1, 2, myz);
        mEstimatedMa.setElementAt(2, 2, sz);

        mEstimatedCovariance = mFitter.getCovar();
        mEstimatedChiSq = mFitter.getChisq();
    }

    /**
     * Sets input data into Levenberg-Marquardt fitter.
     *
     * @throws WrongSizeException never happens.
     */
    private void setInputData() throws WrongSizeException {
        // set input data using:
        //  fmeasx = bx + ftruex + sx * ftruex + mxy * ftruey + mxz * ftruez
        //  fmeasy = by + myx * ftruex + ftruey + sy * ftruey + myz * ftruez
        //  fmeasz = bz + mzx * ftruex + mzy * ftruey + ftruez + sz * ftruez

        final BodyKinematics expectedKinematics = new BodyKinematics();

        final int numMeasurements = mMeasurements.size();
        final Matrix x = new Matrix(numMeasurements, BodyKinematics.COMPONENTS);
        final Matrix y = new Matrix(numMeasurements, BodyKinematics.COMPONENTS);
        final double[] specificForceStandardDeviations = new double[numMeasurements];
        int i = 0;
        for (final StandardDeviationFrameBodyKinematics measurement : mMeasurements) {
            final BodyKinematics measuredKinematics = measurement.getKinematics();
            final ECEFFrame ecefFrame = measurement.getFrame();
            final ECEFFrame previousEcefFrame = measurement.getPreviousFrame();
            final double timeInterval = measurement.getTimeInterval();

            ECEFKinematicsEstimator.estimateKinematics(timeInterval, ecefFrame,
                    previousEcefFrame, expectedKinematics);

            final double fMeasX = measuredKinematics.getFx();
            final double fMeasY = measuredKinematics.getFy();
            final double fMeasZ = measuredKinematics.getFz();

            final double fTrueX = expectedKinematics.getFx();
            final double fTrueY = expectedKinematics.getFy();
            final double fTrueZ = expectedKinematics.getFz();

            x.setElementAt(i, 0, fTrueX);
            x.setElementAt(i, 1, fTrueY);
            x.setElementAt(i, 2, fTrueZ);

            y.setElementAt(i, 0, fMeasX);
            y.setElementAt(i, 1, fMeasY);
            y.setElementAt(i, 2, fMeasZ);

            specificForceStandardDeviations[i] =
                    measurement.getSpecificForceStandardDeviation();
            i++;
        }

        mFitter.setInputData(x, y, specificForceStandardDeviations);
    }

    /**
     * Converts acceleration instance to meters per squared second.
     *
     * @param acceleration acceleration instance to be converted.
     * @return converted value.
     */
    private static double convertAcceleration(final Acceleration acceleration) {
        return AccelerationConverter.convert(acceleration.getValue().doubleValue(),
                acceleration.getUnit(), AccelerationUnit.METERS_PER_SQUARED_SECOND);
    }
}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/INSLooselyCoupledKalmanState.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/INSLooselyCoupledKalmanState.html#L861">861</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/INSTightlyCoupledKalmanState.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/INSTightlyCoupledKalmanState.html#L996">996</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public INSLooselyCoupledKalmanState(final INSLooselyCoupledKalmanState input) {
        copyFrom(input);
    }

    /**
     * Gets estimated body to ECEF coordinate transformation matrix.
     *
     * @return estimated body to ECEF coordinate transformation matrix.
     */
    public Matrix getBodyToEcefCoordinateTransformationMatrix() {
        return mBodyToEcefCoordinateTransformationMatrix;
    }

    /**
     * Sets estimated body to ECEF coordinate transformation matrix.
     *
     * @param bodyToEcefCoordinateTransformationMatrix estimated body to ECEF coordinate
     *                                                 transformation matrix.
     * @throws IllegalArgumentException if provided matrix is not 3x3.
     */
    public void setBodyToEcefCoordinateTransformationMatrix(
            final Matrix bodyToEcefCoordinateTransformationMatrix) {
        if (bodyToEcefCoordinateTransformationMatrix.getRows() != CoordinateTransformation.ROWS ||
                bodyToEcefCoordinateTransformationMatrix.getColumns() != CoordinateTransformation.COLS) {
            throw new IllegalArgumentException();
        }
        mBodyToEcefCoordinateTransformationMatrix =
                bodyToEcefCoordinateTransformationMatrix;
    }

    /**
     * Gets estimated ECEF user velocity resolved around x axis and expressed in meters per second (m/s).
     *
     * @return estimated ECEF user velocity resolved around x axis and expressed in meters per second (m/s).
     */
    public double getVx() {
        return mVx;
    }

    /**
     * Sets estimated ECEF user velocity resolved around x axis and expressed in meters per second (m/s).
     *
     * @param vx estimated ECEF user velocity resolved around x axis and expressed in meters per second (m/s).
     */
    public void setVx(final double vx) {
        mVx = vx;
    }

    /**
     * Gets estimated ECEF user velocity resolved around y axis and expressed in meters per second (m/s).
     *
     * @return estimated ECEF user velocity resolved around y axis and expressed in meters per second (m/s).
     */
    public double getVy() {
        return mVy;
    }

    /**
     * Sets estimated ECEF user velocity resolved around y axis and expressed in meters per second (m/s).
     *
     * @param vy estimated ECEF user velocity resolved around y axis and expressed in meters per scond (m/s).
     */
    public void setVy(final double vy) {
        mVy = vy;
    }

    /**
     * Gets estimated ECEF user velocity resolved around z axis and expressed in meters per second (m/s).
     *
     * @return estimated ECEF user velocity resolved around z axis and expressed in meters per second (m/s).
     */
    public double getVz() {
        return mVz;
    }

    /**
     * Sets estimated ECEF user velocity resolved around z axis and expressed in meters per second (m/s).
     *
     * @param vz estimated ECEF user velocity resolved around z axis and expressed in meters per second (m/s).
     */
    public void setVz(final double vz) {
        mVz = vz;
    }

    /**
     * Sets estimated ECEF user velocity coordinates.
     *
     * @param vx estimated ECEF user velocity resolved around x axis and expressed in meters per second (m/s).
     * @param vy estimated ECEF user velocity resolved around y axis and expressed in meters per second (m/s).
     * @param vz estimated ECEF user velocity resolved around z axis and expressed in meters per second (m/s).
     */
    public void setVelocityCoordinates(
            final double vx, final double vy, final double vz) {
        mVx = vx;
        mVy = vy;
        mVz = vz;
    }

    /**
     * Gets x coordinate of estimated ECEF user position expressed in meters (m).
     *
     * @return x coordinate of estimated ECEF user position expressed in meters (m).
     */
    public double getX() {
        return mX;
    }

    /**
     * Sets x coordinate of estimated ECEF user position expressed in meters (m).
     *
     * @param x x coordinate of estimated ECEF user position expressed in meters (m).
     */
    public void setX(final double x) {
        mX = x;
    }

    /**
     * Gets y coordinate of estimated ECEF user position expressed in meters (m).
     *
     * @return y coordinate of estimated ECEF user position expressed in meters (m).
     */
    public double getY() {
        return mY;
    }

    /**
     * Sets y coordinate of estimated ECEF user position expressed in meters (m).
     *
     * @param y y coordinate of estimated ECEF user position expressed in meters (m).
     */
    public void setY(final double y) {
        mY = y;
    }

    /**
     * Gets z coordinate of estimated ECEF user position expressed in meters (m).
     *
     * @return z coordinate of estimated ECEF user position expressed in meters (m).
     */
    public double getZ() {
        return mZ;
    }

    /**
     * Sets z coordinate of estimated ECEF user position expressed in meters (m).
     *
     * @param z z coordinate of estimated ECEF user position expressed in meters (m).
     */
    public void setZ(final double z) {
        mZ = z;
    }

    /**
     * Sets estimated ECEF user position coordinates.
     *
     * @param x x coordinate of estimated ECEF user position expressed in meters (m).
     * @param y y coordinate of estimated ECEF user position expressed in meters (m).
     * @param z z coordinate of estimated ECEF user position expressed in meters (m).
     */
    public void setPositionCoordinates(
            final double x, final double y, final double z) {
        mX = x;
        mY = y;
        mZ = z;
    }

    /**
     * Gets estimated accelerometer bias resolved around x axis and expressed in
     * meters per squared second (m/s^2).
     *
     * @return estimated accelerometer bias resolved around x axis and expressed in
     * meters per squared second (m/s^2).
     */
    public double getAccelerationBiasX() {
        return mAccelerationBiasX;
    }

    /**
     * Sets estimated accelerometer bias resolved around x axis and expressed in
     * meters per squared second (m/s^2).
     *
     * @param accelerationBiasX estimated accelerometer bias resolved around x axis and
     *                          expressed in meters per squared second (m/s^2).
     */
    public void setAccelerationBiasX(final double accelerationBiasX) {
        mAccelerationBiasX = accelerationBiasX;
    }

    /**
     * Gets estimated accelerometer bias resolved around y axis and expressed in
     * meters per squared second (m/s^2).
     *
     * @return estimated accelerometer bias resolved around y axis and expressed in
     * meters per squared second (m/s^2).
     */
    public double getAccelerationBiasY() {
        return mAccelerationBiasY;
    }

    /**
     * Sets estimated accelerometer bias resolved around y axis and expressed in
     * meters per squared second (m/s^2).
     *
     * @param accelerationBiasY estimated accelerometer bias resolved around y axis
     *                          and expressed in meters per squared second (m/s^2).
     */
    public void setAccelerationBiasY(final double accelerationBiasY) {
        mAccelerationBiasY = accelerationBiasY;
    }

    /**
     * Gets estimated accelerometer bias resolved around z axis and expressed in
     * meters per squared second (m/s^2).
     *
     * @return estimated accelerometer bias resolved around z axis and
     * expressed in meters per squared second (m/s^2).
     */
    public double getAccelerationBiasZ() {
        return mAccelerationBiasZ;
    }

    /**
     * Sets estimated accelerometer bias resolved around z axis and expressed in
     * meters per squared second (m/s^2).
     *
     * @param accelerationBiasZ estimated accelerometer bias resolved around z axis
     *                          and expressed in meters per squared second (m/s^2).
     */
    public void setAccelerationBiasZ(final double accelerationBiasZ) {
        mAccelerationBiasZ = accelerationBiasZ;
    }

    /**
     * Sets estimated accelerometer bias expressed in meters per squared second (m/s^2).
     *
     * @param accelerationBiasX estimated accelerometer bias resolved around x axis and
     *                          expressed in meters per squared second (m/s^2).
     * @param accelerationBiasY estimated accelerometer bias resolved around y axis and
     *                          expressed in meters per squared second (m/s^2).
     * @param accelerationBiasZ estimated accelerometer bias resolved around z axis and
     *                          expressed in meters per squared second (m/s^2).
     */
    public void setAccelerationBiasCoordinates(
            final double accelerationBiasX, final double accelerationBiasY,
            final double accelerationBiasZ) {
        mAccelerationBiasX = accelerationBiasX;
        mAccelerationBiasY = accelerationBiasY;
        mAccelerationBiasZ = accelerationBiasZ;
    }

    /**
     * Gets estimated gyroscope bias resolved around x axis and expressed in
     * radians per second (rad/s).
     *
     * @return estimated gyroscope bias resolved around x axis and expressed in
     * radians per second (rad/s).
     */
    public double getGyroBiasX() {
        return mGyroBiasX;
    }

    /**
     * Sets estimated gyroscope bias resolved around x axis and expressed in
     * radians per second (rad/s).
     *
     * @param gyroBiasX estimated gyroscope bias resolved around x axis and
     *                  expressed in radians per second (rad/s).
     */
    public void setGyroBiasX(final double gyroBiasX) {
        mGyroBiasX = gyroBiasX;
    }

    /**
     * Gets estimated gyroscope bias resolved around y axis and expressed in
     * radians per second (rad/s).
     *
     * @return estimated gyroscope bias resolved around y axis and expressed
     * in radians per second (rad/s).
     */
    public double getGyroBiasY() {
        return mGyroBiasY;
    }

    /**
     * Sets estimated gyroscope bias resolved around y axis and expressed in
     * radians per second (rad/s).
     *
     * @param gyroBiasY estimated gyroscope bias resolved around y axis and
     *                  expressed in radians per second (rad/s).
     */
    public void setGyroBiasY(final double gyroBiasY) {
        mGyroBiasY = gyroBiasY;
    }

    /**
     * Gets estimated gyroscope bias resolved around z axis and expressed in
     * radians per second (rad/s).
     *
     * @return estimated gyroscope bias resolved around z axis and expressed
     * in radians per second (rad/s).
     */
    public double getGyroBiasZ() {
        return mGyroBiasZ;
    }

    /**
     * Sets estimated gyroscope bias resolved around z axis and expressed in
     * radians per second (rad/s).
     *
     * @param gyroBiasZ estimated gyroscope bias resolved around z axis and
     *                  expressed in radians per second (rad/s).
     */
    public void setGyroBiasZ(final double gyroBiasZ) {
        mGyroBiasZ = gyroBiasZ;
    }

    /**
     * Sets estimated gyroscope bias coordinates expressed in radians
     * per second (rad/s).
     *
     * @param gyroBiasX estimated gyroscope bias resolved around x axis and
     *                  expressed in radians per second (rad/s).
     * @param gyroBiasY estimated gyroscope bias resolved around y axis and
     *                  expressed in radians per second (rad/s).
     * @param gyroBiasZ estimated gyroscope bias resolved around z axis and
     *                  expressed in radians per second (rad/s).
     */
    public void setGyroBiasCoordinates(
            final double gyroBiasX, final double gyroBiasY, final double gyroBiasZ) {
        mGyroBiasX = gyroBiasX;
        mGyroBiasY = gyroBiasY;
        mGyroBiasZ = gyroBiasZ;
    }

    /**
     * Gets Kalman filter error covariance matrix.
     * Notice that covariance is expressed in terms of ECEF coordinates.
     * If accuracy of position, attitude or velocity needs to be expressed in terms
     * of NED coordinates, their respective submatrices of this covariance matrix
     * must be rotated, taking into account the Jacobian of the matrix transformation
     * relating both coordinates, the covariance can be expressed following the law
     * of propagation of uncertainties (https://en.wikipedia.org/wiki/Propagation_of_uncertainty)
     * as: cov(f(x)) = J*cov(x)*J'.
     *
     * @param result instance where result data will be copied to.
     * @return true if result data has been copied, false otherwise.
     */
    public boolean getCovariance(final Matrix result) {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/Utils.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/Utils.html#L492">492</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/Utils.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/Utils.html#L1188">1188</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public static MultivariateNormalDist propagateVariancesToRssiVarianceFirstOrderNonLinear3D(
            final double fingerprintRssi, final double pathLossExponent,
            Point3D fingerprintPosition, Point3D radioSourcePosition,
            Point3D estimatedPosition,
            Double fingerprintRssiVariance,
            Double pathLossExponentVariance,
            Matrix fingerprintPositionCovariance,
            Matrix radioSourcePositionCovariance,
            Matrix estimatedPositionCovariance) throws IndoorException {

        if (fingerprintPosition == null || radioSourcePosition == null ||
                estimatedPosition == null) {
            return null;
        }

        //1st order Taylor expression of received power in 3D:
        //Pr(pi) = Pr(p1)
        //  - 10*n*(x1 - xa)/(ln(10)*d1a^2)*(xi - x1)
        //  - 10*n*(y1 - ya)/(ln(10)*d1a^2)*(yi - y1)
        //  - 10*n*(z1 - za)/(ln(10)*d1a^2)*(zi - z1)
        //where d1a^2 = (x1 - xa)^2 + (y1 - ya)^2 + (z1 - za)^2

        final double x1 = fingerprintPosition.getInhomX();
        final double y1 = fingerprintPosition.getInhomY();
        final double z1 = fingerprintPosition.getInhomZ();

        final double xa = radioSourcePosition.getInhomX();
        final double ya = radioSourcePosition.getInhomY();
        final double za = radioSourcePosition.getInhomZ();

        final double xi = estimatedPosition.getInhomX();
        final double yi = estimatedPosition.getInhomY();
        final double zi = estimatedPosition.getInhomZ();

        double[] mean = new double[] {
                fingerprintRssi, pathLossExponent, x1, y1, z1, xa, ya, za, xi, yi, zi
        };
        Matrix covariance = Matrix.diagonal(new double[]{
                fingerprintRssiVariance != null ? fingerprintRssiVariance : 0.0,
                pathLossExponentVariance != null ? pathLossExponentVariance : 0.0,
                0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0
        });

        if (fingerprintPositionCovariance != null &amp;&amp;
                fingerprintPositionCovariance.getRows() == Point3D.POINT3D_INHOMOGENEOUS_COORDINATES_LENGTH &amp;&amp;
                fingerprintPositionCovariance.getColumns() == Point3D.POINT3D_INHOMOGENEOUS_COORDINATES_LENGTH) {

            covariance.setSubmatrix(2, 2,
                    4, 4,
                    fingerprintPositionCovariance);
        }

        if (radioSourcePositionCovariance != null &amp;&amp;
                radioSourcePositionCovariance.getRows() == Point3D.POINT3D_INHOMOGENEOUS_COORDINATES_LENGTH &amp;&amp;
                radioSourcePositionCovariance.getColumns() == Point3D.POINT3D_INHOMOGENEOUS_COORDINATES_LENGTH) {
            covariance.setSubmatrix(5, 5,
                    7, 7,
                    radioSourcePositionCovariance);
        }

        if (estimatedPositionCovariance != null &amp;&amp;
                estimatedPositionCovariance.getRows() == Point3D.POINT3D_INHOMOGENEOUS_COORDINATES_LENGTH &amp;&amp;
                estimatedPositionCovariance.getColumns() == Point3D.POINT3D_INHOMOGENEOUS_COORDINATES_LENGTH) {
            covariance.setSubmatrix(8, 8,
                    10, 10,
                    estimatedPositionCovariance);
        }

        try {
            return MultivariateNormalDist.propagate(new MultivariateNormalDist.JacobianEvaluator() {
                @Override
                public void evaluate(double[] x, double[] y, Matrix jacobian) {

                    //Pr(pi) = Pr(p1)
                    //  - 10*n*(x1 - xa)/(ln(10)*d1a^2)*(xi - x1)
                    //  - 10*n*(y1 - ya)/(ln(10)*d1a^2)*(yi - y1)
                    //  - 10*n*(z1 - za)/(ln(10)*d1a^2)*(zi - z1)
                    //where d1a^2 = (x1 - xa)^2 + (y1 - ya)^2 + (z1 - za)^2

                    //Hence:
                    //Pr(pi) = Pr(p1) -10*n*((x1 - xa)*(xi - x1) + (y1 - ya)*(yi - y1) + (z1 - za)*(zi - z1))/
                    //      (ln(10)*((x1 - xa)^2 + (y1 - ya)^2 + (z1 - za)^2))

                    double diffX1a = x1 - xa;
                    double diffY1a = y1 - ya;
                    double diffZ1a = z1 - za;

                    double diffXi1 = xi - x1;
                    double diffYi1 = yi - y1;
                    double diffZi1 = zi - z1;

                    double diffX1a2 = diffX1a * diffX1a;
                    double diffY1a2 = diffY1a * diffY1a;
                    double diffZ1a2 = diffZ1a * diffZ1a;

                    double d1a2 = diffX1a2 + diffY1a2 + diffZ1a2;</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator2D.html#L833">833</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator2D.html#L838">838</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>            RobustRangingAndRssiRadioSourceEstimatorListener&lt;S, Point2D&gt; listener) {
        super(readings, initialPosition, initialTransmittedPowerdBm,
                initialPathLossExponent, listener);
        internalSetQualityScores(qualityScores);
    }

    /**
     * Gets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on distance between estimated position and distances
     * provided for each sample.
     *
     * @return threshold to determine whether samples are inliers or not.
     */
    public double getThreshold() {
        return mThreshold;
    }

    /**
     * Sets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on distance between estimated position and distances
     * provided for each sample.
     *
     * @param threshold threshold to determine whether samples are inliers or not.
     * @throws IllegalArgumentException if provided value is equal or less than zero.
     * @throws LockedException if this solver is locked.
     */
    public void setThreshold(double threshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (threshold &lt;= MIN_THRESHOLD) {
            throw new IllegalArgumentException();
        }
        mThreshold = threshold;
    }

    /**
     * Returns quality scores corresponding to each pair of
     * positions and distances (i.e. sample).
     * The larger the score value the better the quality of the sample.
     * This implementation always returns null.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @return quality scores corresponding to each sample.
     */
    @Override
    public double[] getQualityScores() {
        return mQualityScores;
    }

    /**
     * Sets quality scores corresponding to each pair of positions and
     * distances (i.e. sample).
     * The larger the score value the better the quality of the sample.
     * This implementation makes no action.
     * Subclasses using quality scores must implement proper behaviour.
     *
     * @param qualityScores quality scores corresponding to each pair of
     *                      matched points.
     * @throws IllegalArgumentException if provided quality scores length
     * is smaller than minimum required samples.
     * @throws LockedException if robust solver is locked because an
     * estimation is already in progress.
     */
    public void setQualityScores(double[] qualityScores) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetQualityScores(qualityScores);
    }

    /**
     * Indicates whether solver is ready to find a solution.
     *
     * @return true if solver is ready, false otherwise.
     */
    @Override
    public boolean isReady() {
        return super.isReady() &amp;&amp; mQualityScores != null &amp;&amp;
                mQualityScores.length == mReadings.size();
    }

    /**
     * Indicates whether inliers must be computed and kept.
     *
     * @return true if inliers must be computed and kept, false if inliers
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepInliersEnabled() {
        return mComputeAndKeepInliers;
    }

    /**
     * Specifies whether inliers must be computed and kept.
     *
     * @param computeAndKeepInliers true if inliers must be computed and kept,
     *                              false if inliers only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepInliersEnabled(boolean computeAndKeepInliers)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mComputeAndKeepInliers = computeAndKeepInliers;
    }

    /**
     * Indicates whether residuals must be computed and kept.
     *
     * @return true if residuals must be computed and kept, false if residuals
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepResidualsEnabled() {
        return mComputeAndKeepResiduals;
    }

    /**
     * Specifies whether residuals must be computed and kept.
     *
     * @param computeAndKeepResiduals true if residuals must be computed and kept,
     *                                false if residuals only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepResidualsEnabled(boolean computeAndKeepResiduals)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mComputeAndKeepResiduals = computeAndKeepResiduals;
    }

    /**
     * Robustly estimates position, transmitted power and pathloss exponent for a
     * radio source.
     *
     * @throws LockedException if instance is busy during estimation.
     * @throws NotReadyException if estimator is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     * (i.e. numerical instability, no solution available, etc).
     */
    @Override
    public void estimate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        PROSACRobustEstimator&lt;Solution&lt;Point2D&gt;&gt; innerEstimator =
                new PROSACRobustEstimator&lt;&gt;(
                        new PROSACRobustEstimatorListener&lt;Solution&lt;Point2D&gt;&gt;() {

                    @Override
                    public double[] getQualityScores() {
                        return mQualityScores;
                    }

                    @Override
                    public double getThreshold() {
                        return mThreshold;
                    }

                    @Override
                    public int getTotalSamples() {
                        return mReadings.size();
                    }

                    @Override
                    public int getSubsetSize() {
                        return Math.max(mPreliminarySubsetSize, getMinReadings());
                    }

                    @Override
                    public void estimatePreliminarSolutions(int[] samplesIndices,
                            List&lt;Solution&lt;Point2D&gt;&gt; solutions) {
                        solvePreliminarSolutions(samplesIndices, solutions);
                    }

                    @Override
                    public double computeResidual(Solution&lt;Point2D&gt; currentEstimation, int i) {
                        return residual(currentEstimation, i);
                    }

                    @Override
                    public boolean isReady() {
                        return PROSACRobustRangingAndRssiRadioSourceEstimator2D.this.isReady();</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator3D.html#L832">832</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator3D.html#L837">837</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>            RobustRangingAndRssiRadioSourceEstimatorListener&lt;S, Point3D&gt; listener) {
        super(readings, initialPosition, initialTransmittedPowerdBm,
                initialPathLossExponent, listener);
        internalSetQualityScores(qualityScores);
    }

    /**
     * Gets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on distance between estimated position and distances
     * provided for each sample.
     *
     * @return threshold to determine whether samples are inliers or not.
     */
    public double getThreshold() {
        return mThreshold;
    }

    /**
     * Sets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on distance between estimated position and distances
     * provided for each sample.
     *
     * @param threshold threshold to determine whether samples are inliers or not.
     * @throws IllegalArgumentException if provided value is equal or less than zero.
     * @throws LockedException if this solver is locked.
     */
    public void setThreshold(double threshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (threshold &lt;= MIN_THRESHOLD) {
            throw new IllegalArgumentException();
        }
        mThreshold = threshold;
    }

    /**
     * Returns quality scores corresponding to each pair of
     * positions and distances (i.e. sample).
     * The larger the score value the better the quality of the sample.
     * This implementation always returns null.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @return quality scores corresponding to each sample.
     */
    @Override
    public double[] getQualityScores() {
        return mQualityScores;
    }

    /**
     * Sets quality scores corresponding to each pair of positions and
     * distances (i.e. sample).
     * The larger the score value the better the quality of the sample.
     * This implementation makes no action.
     * Subclasses using quality scores must implement proper behaviour.
     *
     * @param qualityScores quality scores corresponding to each pair of
     *                      matched points.
     * @throws IllegalArgumentException if provided quality scores length
     * is smaller than minimum required samples.
     * @throws LockedException if robust solver is locked because an
     * estimation is already in progress.
     */
    public void setQualityScores(double[] qualityScores)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetQualityScores(qualityScores);
    }

    /**
     * Indicates whether solver is ready to find a solution.
     *
     * @return true if solver is ready, false otherwise.
     */
    @Override
    public boolean isReady() {
        return super.isReady() &amp;&amp; mQualityScores != null &amp;&amp;
                mQualityScores.length == mReadings.size();
    }

    /**
     * Indicates whether inliers must be computed and kept.
     *
     * @return true if inliers must be computed and kept, false if inliers
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepInliersEnabled() {
        return mComputeAndKeepInliers;
    }

    /**
     * Specifies whether inliers must be computed and kept.
     *
     * @param computeAndKeepInliers true if inliers must be computed and kept,
     *                              false if inliers only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepInliersEnabled(boolean computeAndKeepInliers)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mComputeAndKeepInliers = computeAndKeepInliers;
    }

    /**
     * Indicates whether residuals must be computed and kept.
     *
     * @return true if residuals must be computed and kept, false if residuals
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepResidualsEnabled() {
        return mComputeAndKeepResiduals;
    }

    /**
     * Specifies whether residuals must be computed and kept.
     *
     * @param computeAndKeepResiduals true if residuals must be computed and kept,
     *                                false if residuals only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepResidualsEnabled(boolean computeAndKeepResiduals)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mComputeAndKeepResiduals = computeAndKeepResiduals;
    }

    /**
     * Robustly estimates position, transmitted power and pathloss exponent for a
     * radio source.
     *
     * @throws LockedException if instance is busy during estimation.
     * @throws NotReadyException if estimator is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     * (i.e. numerical instability, no solution available, etc).
     */
    @Override
    public void estimate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        PROSACRobustEstimator&lt;Solution&lt;Point3D&gt;&gt; innerEstimator =
                new PROSACRobustEstimator&lt;&gt;(
                        new PROSACRobustEstimatorListener&lt;Solution&lt;Point3D&gt;&gt;() {

                            @Override
                            public double[] getQualityScores() {
                                return mQualityScores;
                            }

                            @Override
                            public double getThreshold() {
                                return mThreshold;
                            }

                            @Override
                            public int getTotalSamples() {
                                return mReadings.size();
                            }

                            @Override
                            public int getSubsetSize() {
                                return Math.max(mPreliminarySubsetSize, getMinReadings());
                            }

                            @Override
                            public void estimatePreliminarSolutions(int[] samplesIndices,
                                                                    List&lt;Solution&lt;Point3D&gt;&gt; solutions) {
                                solvePreliminarSolutions(samplesIndices, solutions);
                            }

                            @Override
                            public double computeResidual(Solution&lt;Point3D&gt; currentEstimation, int i) {
                                return residual(currentEstimation, i);
                            }

                            @Override
                            public boolean isReady() {
                                return PROSACRobustRangingAndRssiRadioSourceEstimator3D.this.isReady();</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/calibration/KnownBiasAndFrameAccelerometerLinearLeastSquaresCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/KnownBiasAndFrameAccelerometerLinearLeastSquaresCalibrator.html#L1087">1087</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/calibration/KnownFrameAccelerometerLinearLeastSquaresCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/KnownFrameAccelerometerLinearLeastSquaresCalibrator.html#L610">610</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>            mRunning = false;
        }
    }

    /**
     * Gets estimated accelerometer scale factors and ross coupling errors.
     * This is the product of matrix Ta containing cross coupling errors and Ka
     * containing scaling factors.
     * So tat:
     * &lt;pre&gt;
     *     Ma = [sx    mxy  mxz] = Ta*Ka
     *          [myx   sy   myz]
     *          [mzx   mzy  sz ]
     * &lt;/pre&gt;
     * Where:
     * &lt;pre&gt;
     *     Ka = [sx 0   0 ]
     *          [0  sy  0 ]
     *          [0  0   sz]
     * &lt;/pre&gt;
     * and
     * &lt;pre&gt;
     *     Ta = [1          -alphaXy    alphaXz ]
     *          [alphaYx    1           -alphaYz]
     *          [-alphaZx   alphaZy     1       ]
     * &lt;/pre&gt;
     * Hence:
     * &lt;pre&gt;
     *     Ma = [sx    mxy  mxz] = Ta*Ka =  [sx             -sy * alphaXy   sz * alphaXz ]
     *          [myx   sy   myz]            [sx * alphaYx   sy              -sz * alphaYz]
     *          [mzx   mzy  sz ]            [-sx * alphaZx  sy * alphaZy    sz           ]
     * &lt;/pre&gt;
     * This instance allows any 3x3 matrix however, typically alphaYx, alphaZx and alphaZy
     * are considered to be zero if the accelerometer z-axis is assumed to be the same
     * as the body z-axis. When this is assumed, myx = mzx = mzy = 0 and the Ma matrix
     * becomes upper diagonal:
     * &lt;pre&gt;
     *     Ma = [sx    mxy  mxz]
     *          [0     sy   myz]
     *          [0     0    sz ]
     * &lt;/pre&gt;
     * Values of this matrix are unitless.
     *
     * @return estimated accelerometer scale factors and cross coupling errors, or null
     * if not available.
     */
    @Override
    public Matrix getEstimatedMa() {
        return mEstimatedMa;
    }

    /**
     * Gets estimated x-axis scale factor.
     *
     * @return estimated x-axis scale factor or null if not available.
     */
    @Override
    public Double getEstimatedSx() {
        return mEstimatedMa != null ?
                mEstimatedMa.getElementAt(0, 0) : null;
    }

    /**
     * Gets estimated y-axis scale factor.
     *
     * @return estimated y-axis scale factor or null if not available.
     */
    @Override
    public Double getEstimatedSy() {
        return mEstimatedMa != null ?
                mEstimatedMa.getElementAt(1, 1) : null;
    }

    /**
     * Gets estimated z-axis scale factor.
     *
     * @return estimated z-axis scale factor or null if not available.
     */
    @Override
    public Double getEstimatedSz() {
        return mEstimatedMa != null ?
                mEstimatedMa.getElementAt(2, 2) : null;
    }

    /**
     * Gets estimated x-y cross-coupling error.
     *
     * @return estimated x-y cross-coupling error or null if not available.
     */
    @Override
    public Double getEstimatedMxy() {
        return mEstimatedMa != null ?
                mEstimatedMa.getElementAt(0, 1) : null;
    }

    /**
     * Gets estimated x-z cross-coupling error.
     *
     * @return estimated x-z cross-coupling error or null if not available.
     */
    @Override
    public Double getEstimatedMxz() {
        return mEstimatedMa != null ?
                mEstimatedMa.getElementAt(0, 2) : null;
    }

    /**
     * Gets estimated y-x cross-coupling error.
     *
     * @return estimated y-x cross-coupling error or null if not available.
     */
    @Override
    public Double getEstimatedMyx() {
        return mEstimatedMa != null ?
                mEstimatedMa.getElementAt(1, 0) : null;
    }

    /**
     * Gets estimated y-z cross-coupling error.
     *
     * @return estimated y-z cross-coupling error or null if not available.
     */
    @Override
    public Double getEstimatedMyz() {
        return mEstimatedMa != null ?
                mEstimatedMa.getElementAt(1, 2) : null;
    }

    /**
     * Gets estimated z-x cross-coupling error.
     *
     * @return estimated z-x cross-coupling error or null if not available.
     */
    @Override
    public Double getEstimatedMzx() {
        return mEstimatedMa != null ?
                mEstimatedMa.getElementAt(2, 0) : null;
    }

    /**
     * Gets estimated z-y cross-coupling error.
     *
     * @return estimated z-y cross-coupling error or null if not available.
     */
    @Override
    public Double getEstimatedMzy() {
        return mEstimatedMa != null ?
                mEstimatedMa.getElementAt(2, 1) : null;
    }

    /**
     * Internal method to perform calibration when common z-axis is assumed for both
     * the accelerometer and gyroscope.
     *
     * @throws AlgebraException if there are numerical errors.
     */
    private void calibrateCommonAxis() throws AlgebraException {
        // The accelerometer model is:
        // fmeas = ba + (I + Ma) * ftrue + w

        // Ideally a least squares solution tries to minimize noise component, so:
        // fmeas = ba + (I + Ma) * ftrue

        // Hence:
        //  [fmeasx] = [bx] + ( [1  0   0] + [sx    mxy mxz])   [ftruex]
        //  [fmeasy] = [by]     [0  1   0]   [myx   sy  myz]    [ftruey]
        //  [fmeasz] = [bz]     [0  0   1]   [mzx   mzy sz ]    [ftruez]

        // where myx = mzx = mzy = 0

        // Hence:
        //  [fmeasx] = [bx] + ( [1  0   0] + [sx    mxy mxz])   [ftruex]
        //  [fmeasy] = [by]     [0  1   0]   [0     sy  myz]    [ftruey]
        //  [fmeasz] = [bz]     [0  0   1]   [0     0   sz ]    [ftruez]

        //  [fmeasx] = [bx] +   [1+sx   mxy     mxz ][ftruex]
        //  [fmeasy]   [by]     [0      1+sy    myz ][ftruey]
        //  [fmeasz]   [bz]     [0      0       1+sz][ftruez]

        //  fmeasx = bx + (1+sx) * ftruex + mxy * ftruey + mxz * ftruez
        //  fmeasy = by + (1+sy) * ftruey + myz * ftruez
        //  fmeasz = bz + (1+sz) * ftruez

        // Where the unknowns are: sx, sy, sz, mxy mxz, myz
        // Reordering:
        //  fmeasx = bx + ftruex + sx * ftruex + mxy * ftruey + mxz * ftruez
        //  fmeasy = by + ftruey + sy * ftruey + myz * ftruez
        //  fmeasz = bz + ftruez + sz * ftruez

        //  fmeasx - ftruex - bx = sx * ftruex + mxy * ftruey + mxz * ftruez
        //  fmeasy - ftruey - by = sy * ftruey + myz * ftruez
        //  fmeasz - ftruez - bz = sz * ftruez

        // [ftruex  0       0       ftruey  ftruez  0     ][sx ] = [fmeasx - ftruex - bx]
        // [0       ftruey  0       0       0       ftruez][sy ]   [fmeasy - ftruey - by]
        // [0       0       ftruez  0       0       0     ][sz ]   [fmeasz - ftruez - bz]
        //                                                 [mxy]
        //                                                 [mxz]
        //                                                 [myz]

        final BodyKinematics expectedKinematics = new BodyKinematics();

        final int rows = EQUATIONS_PER_MEASUREMENT * mMeasurements.size();
        final Matrix a = new Matrix(rows, COMMON_Z_AXIS_UNKNOWNS);
        final Matrix b = new Matrix(rows, 1);
        int i = 0;
        for (final FrameBodyKinematics measurement : mMeasurements) {
            final BodyKinematics measuredKinematics = measurement.getKinematics();
            final ECEFFrame ecefFrame = measurement.getFrame();
            final ECEFFrame previousEcefFrame = measurement.getPreviousFrame();
            final double timeInterval = measurement.getTimeInterval();

            ECEFKinematicsEstimator.estimateKinematics(timeInterval, ecefFrame,
                    previousEcefFrame, expectedKinematics);

            final double fMeasX = measuredKinematics.getFx();
            final double fMeasY = measuredKinematics.getFy();
            final double fMeasZ = measuredKinematics.getFz();

            final double fTrueX = expectedKinematics.getFx();
            final double fTrueY = expectedKinematics.getFy();
            final double fTrueZ = expectedKinematics.getFz();

            a.setElementAt(i, 0, fTrueX);</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/estimators/ECEFKinematicsEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/estimators/ECEFKinematicsEstimator.html#L2483">2483</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/estimators/ECIKinematicsEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/estimators/ECIKinematicsEstimator.html#L1381">1381</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>        estimateKinematics(timeInterval, c, oldC, velocity, oldVelocity,
                position.getInhomX(), position.getInhomY(), position.getInhomZ(), result);
    }

    /**
     * Estimates body kinematics (specific force applied to a body and its angular rates).
     *
     * @param timeInterval time interval between epochs expressed in seconds (s).
     * @param c            boy-to-ECEF frame coordinate transformation matrix.
     * @param oldC         previous body-to-ECEF-frame coordinate transformation matrix.
     * @param vx           velocity of body frame x coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param vy           velocity of body frame y coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param vz           velocity of body frame z coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param oldVx        previous velocity of body frame x coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldVy        previous velocity of body frame y coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldVz        previous velocity of body frame z coordinate with respect ECEF
     *                     frame, resolved along EVEF-frame axes.
     * @param position     body position expressed in meters (m) with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param result       instance where body kinematics estimation will be stored.
     * @throws IllegalArgumentException if provided time interval is negative or coordinated transformation matrices
     *                                  are not ECEF frame valid.
     */
    public static void estimateKinematics(final double timeInterval,
                                          final CoordinateTransformation c,
                                          final CoordinateTransformation oldC,
                                          final Speed vx, final Speed vy, final Speed vz,
                                          final Speed oldVx, final Speed oldVy, final Speed oldVz,
                                          final Point3D position, final BodyKinematics result) {
        estimateKinematics(timeInterval, c, oldC, vx, vy, vz, oldVx, oldVy, oldVz,
                position.getInhomX(), position.getInhomY(), position.getInhomZ(), result);
    }

    /**
     * Estimates body kinematics (specific force applied to a body and its angular rates).
     *
     * @param timeInterval time interval between epochs.
     * @param c            boy-to-ECEF frame coordinate transformation matrix.
     * @param oldC         previous body-to-ECEF-frame coordinate transformation matrix.
     * @param vx           velocity of body frame x coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param vy           velocity of body frame y coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param vz           velocity of body frame z coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param oldVx        previous velocity of body frame x coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldVy        previous velocity of body frame y coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldVz        previous velocity of body frame z coordinate with respect ECEF
     *                     frame, resolved along EVEF-frame axes.
     * @param position     body position expressed in meters (m) with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param result       instance where body kinematics estimation will be stored.
     * @throws IllegalArgumentException if provided time interval is negative or coordinated transformation matrices
     *                                  are not ECEF frame valid.
     */
    public static void estimateKinematics(final Time timeInterval,
                                          final CoordinateTransformation c,
                                          final CoordinateTransformation oldC,
                                          final Speed vx, final Speed vy, final Speed vz,
                                          final Speed oldVx, final Speed oldVy, final Speed oldVz,
                                          final Point3D position, final BodyKinematics result) {
        estimateKinematics(timeInterval, c, oldC, vx, vy, vz, oldVx, oldVy, oldVz,
                position.getInhomX(), position.getInhomY(), position.getInhomZ(), result);
    }

    /**
     * Estimates body kinematics (specific force applied to a body and its angular rates).
     *
     * @param timeInterval time interval between epochs expressed in seconds (s).
     * @param c            body-to-ECEF frame coordinate transformation matrix.
     * @param oldC         previous body-to-ECEF-frame coordinate transformation matrix.
     * @param vx           velocity of body frame x coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per
     *                     second (m/s).
     * @param vy           velocity of body frame y coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per
     *                     second (m/s).
     * @param vz           velocity of body frame z coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per
     *                     second (m/s).
     * @param oldVx        previous velocity of body frame x coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters
     *                     per second (m/s).
     * @param oldVy        previous velocity of body frame y coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters
     *                     per second (m/s).
     * @param oldVz        previous velocity of body frame z coordinate with respect ECEF
     *                     frame, resolved along EVEF-frame axes and expressed in meters
     *                     per second (m/s).
     * @param x            cartesian x coordinate of body position expressed in meters (m)
     *                     with respect ECEF frame, resolved along ECEF-frame axes.
     * @param y            cartesian y coordinate of body position expressed in meters (m)
     *                     with respect ECEF frame, resolved along ECEF-frame axes.
     * @param z            cartesian z coordinate of body position expressed in meters (m)
     *                     with respect ECEF frame, resolved along ECEF-frame axes.
     * @return a new body kinematics instance.
     * @throws IllegalArgumentException if provided time interval is negative or coordinated transformation matrices
     *                                  are not ECEF frame valid.
     */
    public static BodyKinematics estimateKinematicsAndReturnNew(final double timeInterval,
                                                                final CoordinateTransformation c,
                                                                final CoordinateTransformation oldC,
                                                                final double vx, final double vy, final double vz,
                                                                final double oldVx, final double oldVy, final double oldVz,
                                                                final double x, final double y, final double z) {
        final BodyKinematics result = new BodyKinematics();
        estimateKinematics(timeInterval, c, oldC, vx, vy, vz, oldVx, oldVy, oldVz,
                x, y, z, result);
        return result;
    }

    /**
     * Estimates body kinematics (specific force applied to a body and its angular rates).
     *
     * @param timeInterval time interval between.
     * @param c            body-to-ECEF frame coordinate transformation matrix.
     * @param oldC         previous body-to-ECEF-frame coordinate transformation matrix.
     * @param vx           velocity of body frame x coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per
     *                     second (m/s).
     * @param vy           velocity of body frame y coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per
     *                     second (m/s).
     * @param vz           velocity of body frame z coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per
     *                     second (m/s).
     * @param oldVx        previous velocity of body frame x coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters
     *                     per second (m/s).
     * @param oldVy        previous velocity of body frame y coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters
     *                     per second (m/s).
     * @param oldVz        previous velocity of body frame z coordinate with respect ECEF
     *                     frame, resolved along EVEF-frame axes and expressed in meters
     *                     per second (m/s).
     * @param x            cartesian x coordinate of body position expressed in meters (m)
     *                     with respect ECEF frame, resolved along ECEF-frame axes.
     * @param y            cartesian y coordinate of body position expressed in meters (m)
     *                     with respect ECEF frame, resolved along ECEF-frame axes.
     * @param z            cartesian z coordinate of body position expressed in meters (m)
     *                     with respect ECEF frame, resolved along ECEF-frame axes.
     * @return a new body kinematics instance.
     * @throws IllegalArgumentException if provided time interval is negative or coordinated transformation matrices
     *                                  are not ECEF frame valid.
     */
    public static BodyKinematics estimateKinematicsAndReturnNew(final Time timeInterval,
                                                                final CoordinateTransformation c,
                                                                final CoordinateTransformation oldC,
                                                                final double vx, final double vy, final double vz,
                                                                final double oldVx, final double oldVy, final double oldVz,
                                                                final double x, final double y, final double z) {
        final BodyKinematics result = new BodyKinematics();
        estimateKinematics(timeInterval, c, oldC, vx, vy, vz, oldVx, oldVy, oldVz,
                x, y, z, result);
        return result;
    }

    /**
     * Estimates body kinematics (specific force applied to a body and its angular rates).
     *
     * @param timeInterval time interval between epochs expressed in seconds (s).
     * @param c            boy-to-ECEF frame coordinate transformation matrix.
     * @param oldC         previous body-to-ECEF-frame coordinate transformation matrix.
     * @param velocity     velocity of body frame with respect ECEF frame.
     * @param oldVelocity  previous velocity of body frame with respect ECEF frame.
     * @param x            cartesian x coordinate of body position expressed in meters (m)
     *                     with respect ECEF frame, resolved along ECEF-frame axes.
     * @param y            cartesian y coordinate of body position expressed in meters (m)
     *                     with respect ECEF frame, resolved along ECEF-frame axes.
     * @param z            cartesian z coordinate of body position expressed in meters (m)
     *                     with respect ECEF frame, resolved along ECEF-frame axes.
     * @return a new body kinematics instance.
     * @throws IllegalArgumentException if provided time interval is negative or coordinated transformation matrices
     *                                  are not ECEF frame valid.
     */
    public static BodyKinematics estimateKinematicsAndReturnNew(final double timeInterval,
                                                                final CoordinateTransformation c,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator2D.html#L835">835</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator2D.html#L325">325</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator2D.html#L840">840</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>                initialPathLossExponent, listener);
        internalSetQualityScores(qualityScores);
    }

    /**
     * Gets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on distance between estimated position and distances
     * provided for each sample.
     *
     * @return threshold to determine whether samples are inliers or not.
     */
    public double getThreshold() {
        return mThreshold;
    }

    /**
     * Sets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on distance between estimated position and distances
     * provided for each sample.
     *
     * @param threshold threshold to determine whether samples are inliers or not.
     * @throws IllegalArgumentException if provided value is equal or less than zero.
     * @throws LockedException if this solver is locked.
     */
    public void setThreshold(double threshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (threshold &lt;= MIN_THRESHOLD) {
            throw new IllegalArgumentException();
        }
        mThreshold = threshold;
    }

    /**
     * Returns quality scores corresponding to each pair of
     * positions and distances (i.e. sample).
     * The larger the score value the better the quality of the sample.
     * This implementation always returns null.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @return quality scores corresponding to each sample.
     */
    @Override
    public double[] getQualityScores() {
        return mQualityScores;
    }

    /**
     * Sets quality scores corresponding to each pair of positions and
     * distances (i.e. sample).
     * The larger the score value the better the quality of the sample.
     * This implementation makes no action.
     * Subclasses using quality scores must implement proper behaviour.
     *
     * @param qualityScores quality scores corresponding to each pair of
     *                      matched points.
     * @throws IllegalArgumentException if provided quality scores length
     * is smaller than minimum required samples.
     * @throws LockedException if robust solver is locked because an
     * estimation is already in progress.
     */
    public void setQualityScores(double[] qualityScores) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetQualityScores(qualityScores);
    }

    /**
     * Indicates whether solver is ready to find a solution.
     *
     * @return true if solver is ready, false otherwise.
     */
    @Override
    public boolean isReady() {
        return super.isReady() &amp;&amp; mQualityScores != null &amp;&amp;
                mQualityScores.length == mReadings.size();
    }

    /**
     * Indicates whether inliers must be computed and kept.
     *
     * @return true if inliers must be computed and kept, false if inliers
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepInliersEnabled() {
        return mComputeAndKeepInliers;
    }

    /**
     * Specifies whether inliers must be computed and kept.
     *
     * @param computeAndKeepInliers true if inliers must be computed and kept,
     *                              false if inliers only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepInliersEnabled(boolean computeAndKeepInliers)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mComputeAndKeepInliers = computeAndKeepInliers;
    }

    /**
     * Indicates whether residuals must be computed and kept.
     *
     * @return true if residuals must be computed and kept, false if residuals
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepResidualsEnabled() {
        return mComputeAndKeepResiduals;
    }

    /**
     * Specifies whether residuals must be computed and kept.
     *
     * @param computeAndKeepResiduals true if residuals must be computed and kept,
     *                                false if residuals only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepResidualsEnabled(boolean computeAndKeepResiduals)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mComputeAndKeepResiduals = computeAndKeepResiduals;
    }

    /**
     * Robustly estimates position, transmitted power and pathloss exponent for a
     * radio source.
     *
     * @throws LockedException if instance is busy during estimation.
     * @throws NotReadyException if estimator is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     * (i.e. numerical instability, no solution available, etc).
     */
    @Override
    public void estimate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        PROSACRobustEstimator&lt;Solution&lt;Point2D&gt;&gt; innerEstimator =
                new PROSACRobustEstimator&lt;&gt;(
                        new PROSACRobustEstimatorListener&lt;Solution&lt;Point2D&gt;&gt;() {

                    @Override
                    public double[] getQualityScores() {
                        return mQualityScores;
                    }

                    @Override
                    public double getThreshold() {
                        return mThreshold;
                    }

                    @Override
                    public int getTotalSamples() {
                        return mReadings.size();
                    }

                    @Override
                    public int getSubsetSize() {
                        return Math.max(mPreliminarySubsetSize, getMinReadings());
                    }

                    @Override
                    public void estimatePreliminarSolutions(int[] samplesIndices,
                            List&lt;Solution&lt;Point2D&gt;&gt; solutions) {
                        solvePreliminarSolutions(samplesIndices, solutions);
                    }

                    @Override
                    public double computeResidual(Solution&lt;Point2D&gt; currentEstimation, int i) {
                        return residual(currentEstimation, i);
                    }

                    @Override
                    public boolean isReady() {
                        return PROSACRobustRangingAndRssiRadioSourceEstimator2D.this.isReady();</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator3D.html#L834">834</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator3D.html#L325">325</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator3D.html#L839">839</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                initialPathLossExponent, listener);
        internalSetQualityScores(qualityScores);
    }

    /**
     * Gets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on distance between estimated position and distances
     * provided for each sample.
     *
     * @return threshold to determine whether samples are inliers or not.
     */
    public double getThreshold() {
        return mThreshold;
    }

    /**
     * Sets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on distance between estimated position and distances
     * provided for each sample.
     *
     * @param threshold threshold to determine whether samples are inliers or not.
     * @throws IllegalArgumentException if provided value is equal or less than zero.
     * @throws LockedException if this solver is locked.
     */
    public void setThreshold(double threshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (threshold &lt;= MIN_THRESHOLD) {
            throw new IllegalArgumentException();
        }
        mThreshold = threshold;
    }

    /**
     * Returns quality scores corresponding to each pair of
     * positions and distances (i.e. sample).
     * The larger the score value the better the quality of the sample.
     * This implementation always returns null.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @return quality scores corresponding to each sample.
     */
    @Override
    public double[] getQualityScores() {
        return mQualityScores;
    }

    /**
     * Sets quality scores corresponding to each pair of positions and
     * distances (i.e. sample).
     * The larger the score value the better the quality of the sample.
     * This implementation makes no action.
     * Subclasses using quality scores must implement proper behaviour.
     *
     * @param qualityScores quality scores corresponding to each pair of
     *                      matched points.
     * @throws IllegalArgumentException if provided quality scores length
     * is smaller than minimum required samples.
     * @throws LockedException if robust solver is locked because an
     * estimation is already in progress.
     */
    public void setQualityScores(double[] qualityScores)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetQualityScores(qualityScores);
    }

    /**
     * Indicates whether solver is ready to find a solution.
     *
     * @return true if solver is ready, false otherwise.
     */
    @Override
    public boolean isReady() {
        return super.isReady() &amp;&amp; mQualityScores != null &amp;&amp;
                mQualityScores.length == mReadings.size();
    }

    /**
     * Indicates whether inliers must be computed and kept.
     *
     * @return true if inliers must be computed and kept, false if inliers
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepInliersEnabled() {
        return mComputeAndKeepInliers;
    }

    /**
     * Specifies whether inliers must be computed and kept.
     *
     * @param computeAndKeepInliers true if inliers must be computed and kept,
     *                              false if inliers only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepInliersEnabled(boolean computeAndKeepInliers)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mComputeAndKeepInliers = computeAndKeepInliers;
    }

    /**
     * Indicates whether residuals must be computed and kept.
     *
     * @return true if residuals must be computed and kept, false if residuals
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepResidualsEnabled() {
        return mComputeAndKeepResiduals;
    }

    /**
     * Specifies whether residuals must be computed and kept.
     *
     * @param computeAndKeepResiduals true if residuals must be computed and kept,
     *                                false if residuals only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepResidualsEnabled(boolean computeAndKeepResiduals)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mComputeAndKeepResiduals = computeAndKeepResiduals;
    }

    /**
     * Robustly estimates position, transmitted power and pathloss exponent for a
     * radio source.
     *
     * @throws LockedException if instance is busy during estimation.
     * @throws NotReadyException if estimator is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     * (i.e. numerical instability, no solution available, etc).
     */
    @Override
    public void estimate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        PROSACRobustEstimator&lt;Solution&lt;Point3D&gt;&gt; innerEstimator =
                new PROSACRobustEstimator&lt;&gt;(
                        new PROSACRobustEstimatorListener&lt;Solution&lt;Point3D&gt;&gt;() {

                            @Override
                            public double[] getQualityScores() {
                                return mQualityScores;
                            }

                            @Override
                            public double getThreshold() {
                                return mThreshold;
                            }

                            @Override
                            public int getTotalSamples() {
                                return mReadings.size();
                            }

                            @Override
                            public int getSubsetSize() {
                                return Math.max(mPreliminarySubsetSize, getMinReadings());
                            }

                            @Override
                            public void estimatePreliminarSolutions(int[] samplesIndices,
                                                                    List&lt;Solution&lt;Point3D&gt;&gt; solutions) {
                                solvePreliminarSolutions(samplesIndices, solutions);
                            }

                            @Override
                            public double computeResidual(Solution&lt;Point3D&gt; currentEstimation, int i) {
                                return residual(currentEstimation, i);
                            }

                            @Override
                            public boolean isReady() {
                                return PROSACRobustRangingAndRssiRadioSourceEstimator3D.this.isReady();</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/fingerprint/BaseFingerprintPositionAndRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/fingerprint/BaseFingerprintPositionAndRadioSourceEstimator.html#L158">158</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/fingerprint/BaseFingerprintPositionEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/fingerprint/BaseFingerprintPositionEstimator.html#L165">165</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public BaseFingerprintPositionAndRadioSourceEstimator(
            List&lt;? extends RssiFingerprintLocated&lt;? extends RadioSource,
            ? extends RssiReading&lt;? extends RadioSource&gt;, P&gt;&gt; locatedFingerprints,
            RssiFingerprint&lt;? extends RadioSource,
            ? extends RssiReading&lt;? extends RadioSource&gt;&gt; fingerprint,
            L listener) {
        this(listener);
        internalSetLocatedFingerprints(locatedFingerprints);
        internalSetFingerprint(fingerprint);
    }

    /**
     * Gets located fingerprints containing RSSI readings.
     * @return located fingerprints containing RSSI readings.
     */
    public List&lt;? extends RssiFingerprintLocated&lt;? extends RadioSource,
            ? extends RssiReading&lt;? extends RadioSource&gt;, P&gt;&gt; getLocatedFingerprints() {
        return mLocatedFingerprints;
    }

    /**
     * Sets located fingerprints containing RSSI readings.
     * @param locatedFingerprints located fingerprints containing RSSI readings.
     * @throws LockedException if estimator is locked.
     * @throws IllegalArgumentException if provided value is null or there are not enough
     * fingerprints or readings within provided fingerprints (for 2D position estimation at
     * least 2 readings are required in a single fingerprint, or at least 2 fingerprints
     * at different locations containing a single reading are required. For 3D position
     * estimation 3 reading in a single fingerprint, or 3 fingerprints containing a single
     * reading or any combination resulting in at least 3 readings at different locations
     * are required).
     */
    public void setLocatedFingerprints(List&lt;? extends RssiFingerprintLocated&lt;? extends RadioSource,
            ? extends RssiReading&lt;? extends RadioSource&gt;, P&gt;&gt; locatedFingerprints)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }

        internalSetLocatedFingerprints(locatedFingerprints);
    }

    /**
     * Gets fingerprint containing readings at an unknown location for provided located
     * fingerprints.
     * @return fingerprint containing readings at an unknown location for provided located
     * fingerprints.
     */
    public RssiFingerprint&lt;? extends RadioSource, ? extends RssiReading&lt;? extends RadioSource&gt;&gt;
            getFingerprint() {
        return mFingerprint;
    }

    /**
     * Sets fingerprint containing readings at an unknown location for provided located fingerprints.
     * @param fingerprint fingerprint containing readings at an unknown location for provided located fingerprints.
     * @throws LockedException if estimator is locked.
     * @throws IllegalArgumentException if provided value is null.
     */
    public void setFingerprint(RssiFingerprint&lt;? extends RadioSource,
            ? extends RssiReading&lt;? extends RadioSource&gt;&gt; fingerprint)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }

        internalSetFingerprint(fingerprint);
    }

    /**
     * Get minimum number of nearest fingerprints to search.
     * @return minimum number of nearest fingerprints, -1 indicates to initially use
     * all fingerprints needed to estimate available radio sources.
     */
    public int getMinNearestFingerprints() {
        return mMinNearestFingerprints;
    }

    /**
     * Gets maximum number of nearest fingerprints to search.
     * @return maximum number of nearest fingerprints, -1 indicates to use all available
     * fingerprints.
     */
    public int getMaxNearestFingerprints() {
        return mMaxNearestFingerprints;
    }

    /**
     * Sets minimum and maximum number of nearest fingerprints to search.
     * If minimum value is -1, then the minimum required number of fingerprints needed
     * to estimate available radio sources is used.
     * If maximum value is -1, then the problem is attempted to be solved until all
     * available fingerprints are used.
     * @param minNearestFingerprints minimum number of nearest fingerprints or -1.
     * @param maxNearestFingerprints maximum number of nearest fingerprints or -1.
     * @throws LockedException if estimator is locked.
     * @throws IllegalArgumentException if minimum value is larger than maximum value (as
     * long as it has a limit defined), or if maximum value is not negative when
     * minimum one is less than 1, or if minimum value is zero.
     */
    public void setMinMaxNearestFingerprints(int minNearestFingerprints,
            int maxNearestFingerprints) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }

        internalSetMinMaxNearestFingerprints(minNearestFingerprints,
                maxNearestFingerprints);
    }

    /**
     * Gets path loss exponent to be used by default.
     * This is typically used on free space for path loss propagation in
     * terms of distance.
     * On different environments path loss exponent might have different values:
     * - Free space: 2.0
     * - Urban Area: 2.7 to 3.5
     * - Suburban Area: 3 to 5
     * - Indoor (line-of-sight): 1.6 to 1.8
     * @return path loss exponent to be used by default.
     */
    public double getPathLossExponent() {
        return mPathLossExponent;
    }

    /**
     * Sets path loss exponent to be used by default.
     * This is typically used on free space for path loss propagation in
     * terms of distance.
     * On different environments path loss exponent might have different values:
     * - Free space: 2.0
     * - Urban Area: 2.7 to 3.5
     * - Suburban Area: 3 to 5
     * - Indoor (line-of-sight): 1.6 to 1.8
     * @param pathLossExponent path loss exponent to be used by default.
     * @throws LockedException if estimator is locked.
     */
    public void setPathLossExponent(double pathLossExponent) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mPathLossExponent = pathLossExponent;
    }

    /**
     * Gets listener to be notified of events raised by this instance.
     * @return listener to be notified of events raised by this instance.
     */
    public L getListener() {
        return mListener;
    }

    /**
     * Sets listener to be notified of events raised by this instance.
     * @param listener listener to be notified of events raised by this instance.
     * @throws LockedException if estimator is locked.
     */
    public void setListener(L listener) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mListener = listener;
    }

    /**
     * Gets estimated inhomogeneous position coordinates.
     * @return estimated inhomogeneous position coordinates.
     */
    public double[] getEstimatedPositionCoordinates() {
        return mEstimatedPositionCoordinates;
    }

    /**
     * Gets estimated estimated position and stores result into provided instance.
     * @param estimatedPosition instance where estimated estimated position will be stored.
     */
    public void getEstimatedPosition(P estimatedPosition) {
        if (mEstimatedPositionCoordinates != null) {
            for (int i = 0; i &lt; mEstimatedPositionCoordinates.length; i++) {
                estimatedPosition.setInhomogeneousCoordinate(i,
                        mEstimatedPositionCoordinates[i]);
            }
        }
    }

    /**
     * Gets estimated position or null if not available yet.
     * @return estimated position or null.
     */
    public P getEstimatedPosition() {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/calibration/KnownBiasAndFrameAccelerometerNonLinearLeastSquaresCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/KnownBiasAndFrameAccelerometerNonLinearLeastSquaresCalibrator.html#L2482">2482</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/calibration/KnownFrameAccelerometerNonLinearLeastSquaresCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/KnownFrameAccelerometerNonLinearLeastSquaresCalibrator.html#L2747">2747</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>        mBiasZ = bias.getElementAtIndex(2);
    }

    /**
     * Gets initial scale factors and cross coupling errors matrix.
     *
     * @return initial scale factors and cross coupling errors matrix.
     */
    @Override
    public Matrix getInitialMa() {
        Matrix result;
        try {
            result = new Matrix(BodyKinematics.COMPONENTS,
                    BodyKinematics.COMPONENTS);
            getInitialMa(result);
        } catch (final WrongSizeException ignore) {
            // never happens
            result = null;
        }
        return result;
    }

    /**
     * Gets initial scale factors and cross coupling errors matrix.
     *
     * @param result instance where data will be stored.
     * @throws IllegalArgumentException if provided matrix is not 3x3.
     */
    @Override
    public void getInitialMa(final Matrix result) {
        if (result.getRows() != BodyKinematics.COMPONENTS ||
                result.getColumns() != BodyKinematics.COMPONENTS) {
            throw new IllegalArgumentException();
        }
        result.setElementAtIndex(0, mInitialSx);
        result.setElementAtIndex(1, mInitialMyx);
        result.setElementAtIndex(2, mInitialMzx);

        result.setElementAtIndex(3, mInitialMxy);
        result.setElementAtIndex(4, mInitialSy);
        result.setElementAtIndex(5, mInitialMzy);

        result.setElementAtIndex(6, mInitialMxz);
        result.setElementAtIndex(7, mInitialMyz);
        result.setElementAtIndex(8, mInitialSz);
    }

    /**
     * Sets initial scale factors and cross coupling errors matrix.
     *
     * @param initialMa initial scale factors and cross coupling errors matrix.
     * @throws IllegalArgumentException if provided matrix is not 3x3.
     * @throws LockedException          if calibrator is currently running.
     */
    @Override
    public void setInitialMa(final Matrix initialMa) throws LockedException {
        if (mRunning) {
            throw new LockedException();
        }
        if (initialMa.getRows() != BodyKinematics.COMPONENTS ||
                initialMa.getColumns() != BodyKinematics.COMPONENTS) {
            throw new IllegalArgumentException();
        }

        mInitialSx = initialMa.getElementAtIndex(0);
        mInitialMyx = initialMa.getElementAtIndex(1);
        mInitialMzx = initialMa.getElementAtIndex(2);

        mInitialMxy = initialMa.getElementAtIndex(3);
        mInitialSy = initialMa.getElementAtIndex(4);
        mInitialMzy = initialMa.getElementAtIndex(5);

        mInitialMxz = initialMa.getElementAtIndex(6);
        mInitialMyz = initialMa.getElementAtIndex(7);
        mInitialSz = initialMa.getElementAtIndex(8);
    }

    /**
     * Gets a collection of body kinematics measurements taken at different
     * frames (positions, orientations and velocities) and containing the standard
     * deviations of accelerometer and gyroscope measurements.
     * If a single device IMU needs to be calibrated, typically all measurements are
     * taken at the same position, with zero velocity and multiple orientations.
     * However, if we just want to calibrate the a given IMU model (e.g. obtain
     * an average and less precise calibration for the IMU of a given phone model),
     * we could take measurements collected throughout the planet at multiple positions
     * while the phone remains static (e.g. while charging), hence each measurement
     * position will change, velocity will remain zero and orientation will be
     * typically constant at horizontal orientation while the phone remains on a
     * flat surface.
     *
     * @return a collection of body kinematics measurements taken at different
     * frames (positions, orientations and velocities).
     */
    @Override
    public Collection&lt;? extends StandardDeviationFrameBodyKinematics&gt; getMeasurements() {
        return mMeasurements;
    }

    /**
     * Sets a collection of body kinematics measurements taken at different
     * frames (positions, orientations and velocities) and containing the standard
     * deviations of accelerometer and gyroscope measurements.
     * If a single device IMU needs to be calibrated, typically all measurements are
     * taken at the same position, with zero velocity and multiple orientations.
     * However, if we just want to calibrate the a given IMU model (e.g. obtain
     * an average and less precise calibration for the IMU of a given phone model),
     * we could take measurements collected throughout the planet at multiple positions
     * while the phone remains static (e.g. while charging), hence each measurement
     * position will change, velocity will remain zero and orientation will be
     * typically constant at horizontal orientation while the phone remains on a
     * flat surface.
     *
     * @param measurements collection of body kinematics measurements taken at different
     *                     frames (positions, orientations and velocities).
     * @throws LockedException if calibrator is currently running.
     */
    @Override
    public void setMeasurements(
            final Collection&lt;? extends StandardDeviationFrameBodyKinematics&gt; measurements)
            throws LockedException {
        if (mRunning) {
            throw new LockedException();
        }
        mMeasurements = measurements;
    }

    /**
     * Indicates whether z-axis is assumed to be common for accelerometer and
     * gyroscope.
     * When enabled, this eliminates 3 variables from Ma matrix.
     *
     * @return true if z-axis is assumed to be common for accelerometer and gyroscope,
     * false otherwise.
     */
    @Override
    public boolean isCommonAxisUsed() {
        return mCommonAxisUsed;
    }

    /**
     * Specifies whether z-axis is assumed to be common for accelerometer and
     * gyroscope.
     * When enabled, this eliminates 3 variables from Ma matrix.
     *
     * @param commonAxisUsed true if z-axis is assumed to be common for accelerometer
     *                       and gyroscope, false otherwise.
     * @throws LockedException if calibrator is currently running.
     */
    @Override
    public void setCommonAxisUsed(final boolean commonAxisUsed) throws LockedException {
        if (mRunning) {
            throw new LockedException();
        }

        mCommonAxisUsed = commonAxisUsed;
    }

    /**
     * Gets listener to handle events raised by this estimator.
     *
     * @return listener to handle events raised by this estimator.
     */
    @Override
    public KnownBiasAndFrameAccelerometerNonLinearLeastSquaresCalibratorListener getListener() {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/Utils.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/Utils.html#L251">251</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/Utils.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/Utils.html#L786">786</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public static MultivariateNormalDist propagateVariancesToRssiVarianceFirstOrderNonLinear2D(
            final double fingerprintRssi, final double pathLossExponent,
            Point2D fingerprintPosition, Point2D radioSourcePosition,
            Point2D estimatedPosition,
            Double fingerprintRssiVariance,
            Double pathLossExponentVariance,
            Matrix fingerprintPositionCovariance,
            Matrix radioSourcePositionCovariance,
            Matrix estimatedPositionCovariance) throws IndoorException {

        if (fingerprintPosition == null || radioSourcePosition == null ||
                estimatedPosition == null) {
            return null;
        }

        //1st order Taylor expression of received power in 2D:
        //Pr(pi) = Pr(p1)
        //  - 10*n*(x1 - xa)/(ln(10)*d1a^2)*(xi - x1)
        //  - 10*n*(y1 - ya)/(ln(10)*d1a^2)*(yi - y1)
        //where d1a^2 = (x1 - xa)^2 + (y1 - ya)^2

        final double x1 = fingerprintPosition.getInhomX();
        final double y1 = fingerprintPosition.getInhomY();

        final double xa = radioSourcePosition.getInhomX();
        final double ya = radioSourcePosition.getInhomY();

        final double xi = estimatedPosition.getInhomX();
        final double yi = estimatedPosition.getInhomY();

        double[] mean = new double[] {
                fingerprintRssi, pathLossExponent, x1, y1, xa, ya, xi, yi
        };
        Matrix covariance = Matrix.diagonal(new double[]{
                fingerprintRssiVariance != null ? fingerprintRssiVariance : 0.0,
                pathLossExponentVariance != null ? pathLossExponentVariance : 0.0,
                0.0, 0.0, 0.0, 0.0, 0.0, 0.0
        });

        if (fingerprintPositionCovariance != null &amp;&amp;
                fingerprintPositionCovariance.getRows() == Point2D.POINT2D_INHOMOGENEOUS_COORDINATES_LENGTH &amp;&amp;
                fingerprintPositionCovariance.getColumns() == Point2D.POINT2D_INHOMOGENEOUS_COORDINATES_LENGTH) {

            covariance.setSubmatrix(2, 2,
                    3, 3,
                    fingerprintPositionCovariance);
        }

        if (radioSourcePositionCovariance != null &amp;&amp;
                radioSourcePositionCovariance.getRows() == Point2D.POINT2D_INHOMOGENEOUS_COORDINATES_LENGTH &amp;&amp;
                radioSourcePositionCovariance.getColumns() == Point2D.POINT2D_INHOMOGENEOUS_COORDINATES_LENGTH) {
            covariance.setSubmatrix(4, 4,
                    5, 5,
                    radioSourcePositionCovariance);
        }

        if (estimatedPositionCovariance != null &amp;&amp;
                estimatedPositionCovariance.getRows() == Point2D.POINT2D_INHOMOGENEOUS_COORDINATES_LENGTH &amp;&amp;
                estimatedPositionCovariance.getColumns() == Point2D.POINT2D_INHOMOGENEOUS_COORDINATES_LENGTH) {
            covariance.setSubmatrix(6, 6,
                    7, 7,
                    estimatedPositionCovariance);
        }

        try {
            return MultivariateNormalDist.propagate(new MultivariateNormalDist.JacobianEvaluator() {
                @Override
                public void evaluate(double[] x, double[] y, Matrix jacobian) {

                    //Pr(pi) = Pr(p1)
                    //  - 10*n*(x1 - xa)/(ln(10)*d1a^2)*(xi - x1)
                    //  - 10*n*(y1 - ya)/(ln(10)*d1a^2)*(yi - y1)
                    //where d1a^2 = (x1 - xa)^2 + (y1 - ya)^2

                    //Hence:
                    //Pr(pi) = Pr(p1) -10*n*((x1 - xa)*(xi - x1) + (y1 - ya)*(yi - y1))/
                    //      (ln(10)*((x1 - xa)^2 + (y1 - ya)^2))

                    double diffX1a = x1 - xa;
                    double diffY1a = y1 - ya;

                    double diffXi1 = xi - x1;
                    double diffYi1 = yi - y1;

                    double diffX1a2 = diffX1a * diffX1a;
                    double diffY1a2 = diffY1a * diffY1a;

                    double d1a2 = diffX1a2 + diffY1a2;</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/calibration/RobustKnownBiasAndFrameAccelerometerCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/RobustKnownBiasAndFrameAccelerometerCalibrator.html#L1782">1782</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/calibration/RobustKnownFrameAccelerometerCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/RobustKnownFrameAccelerometerCalibrator.html#L1261">1261</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public void setListener(final RobustKnownBiasAndFrameAccelerometerCalibratorListener listener)
            throws LockedException {
        if (mRunning) {
            throw new LockedException();
        }

        mListener = listener;
    }

    /**
     * Indicates whether calibrator is ready to start.
     *
     * @return true if calibrator is ready, false otherwise.
     */
    public boolean isReady() {
        return mMeasurements != null &amp;&amp; mMeasurements.size() &gt;= MINIMUM_MEASUREMENTS;
    }

    /**
     * Indicates whether calibrator is currently running or not.
     *
     * @return true if calibrator is running, false otherwise.
     */
    public boolean isRunning() {
        return mRunning;
    }

    /**
     * Indicates whether a linear calibrator is used or not for preliminary
     * solutions.
     *
     * @return indicates whether a linear calibrator is used or not for
     * preliminary solutions.
     */
    public boolean isLinearCalibratorUsed() {
        return mUseLinearCalibrator;
    }

    /**
     * Sepecifies whether a linear calibrator is used or not for preliminary
     * solutions.
     *
     * @param linearCalibratorUsed indicates whether a linear calibrator is used
     *                             or not for preliminary solutions.
     * @throws LockedException if calibrator is currently running.
     */
    public void setLinearCalibratorUsed(final boolean linearCalibratorUsed)
            throws LockedException {
        if (mRunning) {
            throw new LockedException();
        }
        mUseLinearCalibrator = linearCalibratorUsed;
    }

    /**
     * Indicates whether preliminary solutions must be refined after an initial linear solution is found.
     * If no initial solution is found using a linear solver, a non linear solver will be
     * used regardless of this value using an average solution as the initial value to be
     * refined.
     *
     * @return true if preliminary solutions must be refined after an initial linear solution, false
     * otherwise.
     */
    public boolean isPreliminarySolutionRefined() {
        return mRefinePreliminarySolutions;
    }

    /**
     * Specifies whether preliminary solutions must be refined after an initial linear solution is found.
     * If no initial solution is found using a linear solver, a non linear solver will be
     * used regardless of this value using an average solution as the initial value to be
     * refined.
     *
     * @param preliminarySolutionRefined true if preliminary solutions must be refined after an
     *                                   initial linear solution, false otherwise.
     * @throws LockedException if calibrator is currently running.
     */
    public void setPreliminarySolutionRefined(boolean preliminarySolutionRefined)
            throws LockedException {
        if (mRunning) {
            throw new LockedException();
        }

        mRefinePreliminarySolutions = preliminarySolutionRefined;
    }

    /**
     * Returns amount of progress variation before notifying a progress change during
     * calibration.
     *
     * @return amount of progress variation before notifying a progress change during
     * calibration.
     */
    public float getProgressDelta() {
        return mProgressDelta;
    }

    /**
     * Sets amount of progress variation before notifying a progress change during
     * calibration.
     *
     * @param progressDelta amount of progress variation before notifying a progress
     *                      change during calibration.
     * @throws IllegalArgumentException if progress delta is less than zero or greater than 1.
     * @throws LockedException          if calibrator is currently running.
     */
    public void setProgressDelta(float progressDelta) throws LockedException {
        if (mRunning) {
            throw new LockedException();
        }
        if (progressDelta &lt; MIN_PROGRESS_DELTA ||
                progressDelta &gt; MAX_PROGRESS_DELTA) {
            throw new IllegalArgumentException();
        }
        mProgressDelta = progressDelta;
    }

    /**
     * Returns amount of confidence expressed as a value between 0.0 and 1.0
     * (which is equivalent to 100%). The amount of confidence indicates the probability
     * that the estimated result is correct. Usually this value will be close to 1.0, but
     * not exactly 1.0.
     *
     * @return amount of confidence as a value between 0.0 and 1.0.
     */
    public double getConfidence() {
        return mConfidence;
    }

    /**
     * Sets amount of confidence expressed as a value between 0.0 and 1.0 (which is
     * equivalent to 100%). The amount of confidence indicates the probability that
     * the estimated result is correct. Usually this value will be close to 1.0, but
     * not exactly 1.0.
     *
     * @param confidence confidence to be set as a value between 0.0 and 1.0.
     * @throws IllegalArgumentException if provided value is not between 0.0 and 1.0.
     * @throws LockedException          if calibrator is currently running.
     */
    public void setConfidence(double confidence) throws LockedException {
        if (mRunning) {
            throw new LockedException();
        }
        if (confidence &lt; MIN_CONFIDENCE || confidence &gt; MAX_CONFIDENCE) {
            throw new IllegalArgumentException();
        }
        mConfidence = confidence;
    }

    /**
     * Returns maximum allowed number of iterations. If maximum allowed number of
     * iterations is achieved without converging to a result when calling calibrate(),
     * a RobustEstimatorException will be raised.
     *
     * @return maximum allowed number of iterations.
     */
    public int getMaxIterations() {
        return mMaxIterations;
    }

    /**
     * Sets maximum allowed number of iterations. When the maximum number of iterations
     * is exceeded, result will not be available, however an approximate result will be
     * available for retrieval.
     *
     * @param maxIterations maximum allowed number of iterations to be set.
     * @throws IllegalArgumentException if provided value is less than 1.
     * @throws LockedException          if calibrator is currently running.
     */
    public void setMaxIterations(int maxIterations) throws LockedException {
        if (mRunning) {
            throw new LockedException();
        }
        if (maxIterations &lt; MIN_ITERATIONS) {
            throw new IllegalArgumentException();
        }
        mMaxIterations = maxIterations;
    }

    /**
     * Gets data related to inliers found after estimation.
     *
     * @return data related to inliers found after estimation.
     */
    public InliersData getInliersData() {
        return mInliersData;
    }

    /**
     * Indicates whether result must be refined using a non-linear solver over found inliers.
     *
     * @return true to refine result, false to simply use result found by robust estimator
     * without further refining.
     */
    public boolean isResultRefined() {
        return mRefineResult;
    }

    /**
     * Specifies whether result must be refined using a non-linear solver over found inliers.
     *
     * @param refineResult true to refine result, false to simply use result found by robust
     *                     estimator without further refining.
     * @throws LockedException if calibrator is currently running.
     */
    public void setResultRefined(boolean refineResult) throws LockedException {
        if (mRunning) {
            throw new LockedException();
        }
        mRefineResult = refineResult;
    }

    /**
     * Indicates whether covariance must be kept after refining result.
     * This setting is only taken into account if result is refined.
     *
     * @return true if covariance must be kept after refining result, false otherwise.
     */
    public boolean isCovarianceKept() {
        return mKeepCovariance;
    }

    /**
     * Specifies whether covariance must be kept after refining result.
     * This setting is only taken into account if result is refined.
     *
     * @param keepCovariance true if covariance must be kept after refining result,
     *                       false otherwise.
     * @throws LockedException if calibrator is currently running.
     */
    public void setCovarianceKept(boolean keepCovariance) throws LockedException {
        if (mRunning) {
            throw new LockedException();
        }
        mKeepCovariance = keepCovariance;
    }

    /**
     * Returns quality scores corresponding to each pair of
     * positions and distances (i.e. sample).
     * The larger the score value the better the quality of the sample.
     * This implementation always returns null.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @return quality scores corresponding to each sample.
     */
    public double[] getQualityScores() {
        return null;
    }

    /**
     * Sets quality scores corresponding to each pair of positions and
     * distances (i.e. sample).
     * The larger the score value the better the quality of the sample.
     * This implementation makes no action.
     * Subclasses using quality scores must implement proper behaviour.
     *
     * @param qualityScores quality scores corresponding to each pair of
     *                      matched points.
     * @throws IllegalArgumentException if provided quality scores length
     *                                  is smaller than minimum required samples.
     * @throws LockedException          if calibrator is currently running.
     */
    public void setQualityScores(double[] qualityScores)
            throws LockedException {
    }

    /**
     * Gets estimated accelerometer scale factors and ross coupling errors.
     * This is the product of matrix Ta containing cross coupling errors and Ka
     * containing scaling factors.
     * So tat:
     * &lt;pre&gt;
     *     Ma = [sx    mxy  mxz] = Ta*Ka
     *          [myx   sy   myz]
     *          [mzx   mzy  sz ]
     * &lt;/pre&gt;
     * Where:
     * &lt;pre&gt;
     *     Ka = [sx 0   0 ]
     *          [0  sy  0 ]
     *          [0  0   sz]
     * &lt;/pre&gt;
     * and
     * &lt;pre&gt;
     *     Ta = [1          -alphaXy    alphaXz ]
     *          [alphaYx    1           -alphaYz]
     *          [-alphaZx   alphaZy     1       ]
     * &lt;/pre&gt;
     * Hence:
     * &lt;pre&gt;
     *     Ma = [sx    mxy  mxz] = Ta*Ka =  [sx             -sy * alphaXy   sz * alphaXz ]
     *          [myx   sy   myz]            [sx * alphaYx   sy              -sz * alphaYz]
     *          [mzx   mzy  sz ]            [-sx * alphaZx  sy * alphaZy    sz           ]
     * &lt;/pre&gt;
     * This instance allows any 3x3 matrix however, typically alphaYx, alphaZx and alphaZy
     * are considered to be zero if the accelerometer z-axis is assumed to be the same
     * as the body z-axis. When this is assumed, myx = mzx = mzy = 0 and the Ma matrix
     * becomes upper diagonal:
     * &lt;pre&gt;
     *     Ma = [sx    mxy  mxz]
     *          [0     sy   myz]
     *          [0     0    sz ]
     * &lt;/pre&gt;
     * Values of this matrix are unitless.
     *
     * @return estimated accelerometer scale factors and cross coupling errors, or null
     * if not available.
     */
    public Matrix getEstimatedMa() {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator2D.html#L2891">2891</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator3D.html#L2891">2891</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>        Point2D initialPosition = result.getEstimatedPosition();
        double initialTransmittedPowerdBm =
                result.getEstimatedTransmittedPowerdBm();
        double initialPathLossExponent = result.getEstimatedPathLossExponent();

        if (mRefineResult &amp;&amp; mInliersData != null) {
            BitSet inliers = mInliersData.getInliers();
            int nSamples = mReadings.size();

            mInnerReadings.clear();

            for (int i = 0; i &lt; nSamples; i++) {
                if (inliers.get(i)) {
                    //sample is inlier
                    mInnerReadings.add(mReadings.get(i));
                }
            }

            try {
                mInnerEstimator.setInitialPosition(initialPosition);
                mInnerEstimator.setInitialTransmittedPowerdBm(initialTransmittedPowerdBm);
                mInnerEstimator.setInitialPathLossExponent(initialPathLossExponent);
                mInnerEstimator.setTransmittedPowerEstimationEnabled(mTransmittedPowerEstimationEnabled);
                mInnerEstimator.setPositionEstimationEnabled(mPositionEstimationEnabled);
                mInnerEstimator.setPathLossEstimationEnabled(mPathLossEstimationEnabled);
                mInnerEstimator.setReadings(mInnerReadings);

                mInnerEstimator.estimate();

                Matrix cov = mInnerEstimator.getEstimatedCovariance();
                if (mKeepCovariance &amp;&amp; cov != null) {
                    //keep covariance
                    mCovariance = cov;

                    int dims = getNumberOfDimensions();
                    int pos = 0;
                    if (mPositionEstimationEnabled) {
                        //position estimation enabled
                        int d = dims -1;
                        if (mEstimatedPositionCovariance == null) {
                            mEstimatedPositionCovariance = mCovariance.
                                    getSubmatrix(0, 0, d, d);
                        } else {
                            mCovariance.getSubmatrix(0, 0, d, d,
                                    mEstimatedPositionCovariance);
                        }
                        pos += dims;
                    } else {
                        //position estimation disabled
                        mEstimatedPositionCovariance = null;
                    }

                    if (mTransmittedPowerEstimationEnabled) {
                        //transmitted power estimation enabled
                        mEstimatedTransmittedPowerVariance = mCovariance.
                                getElementAt(pos, pos);
                        pos++;
                    } else {
                        //transmitted power estimation disabled
                        mEstimatedTransmittedPowerVariance = null;
                    }

                    if (mPathLossEstimationEnabled) {
                        //pathloss exponent estimation enabled
                        mEstimatedPathLossExponentVariance = mCovariance.
                                getElementAt(pos, pos);
                    } else {
                        //pathloss exponent estimation disabled
                        mEstimatedPathLossExponentVariance = null;
                    }
                } else {
                    mCovariance = null;
                    mEstimatedPositionCovariance = null;
                    mEstimatedTransmittedPowerVariance = null;
                    mEstimatedPathLossExponentVariance = null;
                }

                mEstimatedPosition = mInnerEstimator.getEstimatedPosition();
                mEstimatedTransmittedPowerdBm =
                        mInnerEstimator.getEstimatedTransmittedPowerdBm();
                mEstimatedPathLossExponent =
                        mInnerEstimator.getEstimatedPathLossExponent();
            } catch (Exception e) {
                //refinement failed, so we return input value, and covariance
                //becomes unavailable
                mCovariance = null;
                mEstimatedPositionCovariance = null;
                mEstimatedTransmittedPowerVariance = null;
                mEstimatedPathLossExponentVariance = null;

                mEstimatedPosition = initialPosition;
                mEstimatedTransmittedPowerdBm = initialTransmittedPowerdBm;
                mEstimatedPathLossExponent = initialPathLossExponent;
            }
        } else {
            mCovariance = null;
            mEstimatedPositionCovariance = null;
            mEstimatedTransmittedPowerVariance = null;
            mEstimatedPathLossExponentVariance = null;

            mEstimatedPosition = initialPosition;
            mEstimatedTransmittedPowerdBm = initialTransmittedPowerdBm;
            mEstimatedPathLossExponent = initialPathLossExponent;
        }
    }
}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/calibration/RobustKnownBiasAndFrameAccelerometerCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/RobustKnownBiasAndFrameAccelerometerCalibrator.html#L1613">1613</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/calibration/RobustKnownFrameAccelerometerCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/RobustKnownFrameAccelerometerCalibrator.html#L1092">1092</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                initialMyz, initialMzx, initialMzy);
    }

    /**
     * Gets initial scale factors and cross coupling errors matrix.
     * This is only taken into account if non-linear preliminary solutions are used.
     *
     * @return initial scale factors and cross coupling errors matrix.
     */
    public Matrix getInitialMa() {
        Matrix result;
        try {
            result = new Matrix(BodyKinematics.COMPONENTS,
                    BodyKinematics.COMPONENTS);
            getInitialMa(result);
        } catch (final WrongSizeException ignore) {
            // never happens
            result = null;
        }
        return result;
    }

    /**
     * Gets initial scale factors and cross coupling errors matrix.
     * This is only taken into account if non-linear preliminary solutions are used.
     *
     * @param result instance where data will be stored.
     * @throws IllegalArgumentException if provided matrix is not 3x3.
     */
    public void getInitialMa(final Matrix result) {
        if (result.getRows() != BodyKinematics.COMPONENTS ||
                result.getColumns() != BodyKinematics.COMPONENTS) {
            throw new IllegalArgumentException();
        }
        result.setElementAtIndex(0, mInitialSx);
        result.setElementAtIndex(1, mInitialMyx);
        result.setElementAtIndex(2, mInitialMzx);

        result.setElementAtIndex(3, mInitialMxy);
        result.setElementAtIndex(4, mInitialSy);
        result.setElementAtIndex(5, mInitialMzy);

        result.setElementAtIndex(6, mInitialMxz);
        result.setElementAtIndex(7, mInitialMyz);
        result.setElementAtIndex(8, mInitialSz);
    }

    /**
     * Sets initial scale factors and cross coupling errors matrix.
     * This is only taken into account if non-linear preliminary solutions are used.
     *
     * @param initialMa initial scale factors and cross coupling errors matrix.
     * @throws IllegalArgumentException if provided matrix is not 3x3.
     * @throws LockedException          if calibrator is currently running.
     */
    public void setInitialMa(final Matrix initialMa) throws LockedException {
        if (mRunning) {
            throw new LockedException();
        }
        if (initialMa.getRows() != BodyKinematics.COMPONENTS ||
                initialMa.getColumns() != BodyKinematics.COMPONENTS) {
            throw new IllegalArgumentException();
        }

        mInitialSx = initialMa.getElementAtIndex(0);
        mInitialMyx = initialMa.getElementAtIndex(1);
        mInitialMzx = initialMa.getElementAtIndex(2);

        mInitialMxy = initialMa.getElementAtIndex(3);
        mInitialSy = initialMa.getElementAtIndex(4);
        mInitialMzy = initialMa.getElementAtIndex(5);

        mInitialMxz = initialMa.getElementAtIndex(6);
        mInitialMyz = initialMa.getElementAtIndex(7);
        mInitialSz = initialMa.getElementAtIndex(8);
    }

    /**
     * Gets a list of body kinematics measurements taken at different
     * frames (positions, orientations and velocities) and containing the standard
     * deviations of accelerometer and gyroscope measurements.
     * If a single device IMU needs to be calibrated, typically all measurements are
     * taken at the same position, with zero velocity and multiple orientations.
     * However, if we just want to calibrate the a given IMU model (e.g. obtain
     * an average and less precise calibration for the IMU of a given phone model),
     * we could take measurements collected throughout the planet at multiple positions
     * while the phone remains static (e.g. while charging), hence each measurement
     * position will change, velocity will remain zero and orientation will be
     * typically constant at horizontal orientation while the phone remains on a
     * flat surface.
     *
     * @return a collection of body kinematics measurements taken at different
     * frames (positions, orientations and velocities).
     */
    public List&lt;StandardDeviationFrameBodyKinematics&gt; getMeasurements() {
        return mMeasurements;
    }

    /**
     * Sets a list of body kinematics measurements taken at different
     * frames (positions, orientations and velocities) and containing the standard
     * deviations of accelerometer and gyroscope measurements.
     * If a single device IMU needs to be calibrated, typically all measurements are
     * taken at the same position, with zero velocity and multiple orientations.
     * However, if we just want to calibrate the a given IMU model (e.g. obtain
     * an average and less precise calibration for the IMU of a given phone model),
     * we could take measurements collected throughout the planet at multiple positions
     * while the phone remains static (e.g. while charging), hence each measurement
     * position will change, velocity will remain zero and orientation will be
     * typically constant at horizontal orientation while the phone remains on a
     * flat surface.
     *
     * @param measurements collection of body kinematics measurements taken at different
     *                     frames (positions, orientations and velocities).
     * @throws LockedException if calibrator is currently running.
     */
    public void setMeasurements(
            final List&lt;StandardDeviationFrameBodyKinematics&gt; measurements)
            throws LockedException {
        if (mRunning) {
            throw new LockedException();
        }
        mMeasurements = measurements;
    }

    /**
     * Indicates whether z-axis is assumed to be common for accelerometer and
     * gyroscope.
     * When enabled, this eliminates 3 variables from Ma matrix.
     *
     * @return true if z-axis is assumed to be common for accelerometer and gyroscope,
     * false otherwise.
     */
    public boolean isCommonAxisUsed() {
        return mCommonAxisUsed;
    }

    /**
     * Specifies whether z-axis is assumed to be common for accelerometer and
     * gyroscope.
     * When enabled, this eliminates 3 variables from Ma matrix.
     *
     * @param commonAxisUsed true if z-axis is assumed to be common for accelerometer
     *                       and gyroscope, false otherwise.
     * @throws LockedException if calibrator is currently running.
     */
    public void setCommonAxisUsed(final boolean commonAxisUsed) throws LockedException {
        if (mRunning) {
            throw new LockedException();
        }

        mCommonAxisUsed = commonAxisUsed;
    }

    /**
     * Gets listener to handle events raised by this estimator.
     *
     * @return listener to handle events raised by this estimator.
     */
    public RobustKnownBiasAndFrameAccelerometerCalibratorListener getListener() {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator2D.html#L2917">2917</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator3D.html#L2919">2919</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>        Point2D initialPosition = result.getEstimatedPosition();
        double initialTransmittedPowerdBm =
                result.getEstimatedTransmittedPowerdBm();
        double initialPathLossExponent = result.getEstimatedPathLossExponent();

        if (mRefineResult &amp;&amp; mInliersData != null) {
            BitSet inliers = mInliersData.getInliers();
            int nSamples = mReadings.size();

            mInnerReadings.clear();

            for (int i = 0; i &lt; nSamples; i++) {
                if (inliers.get(i)) {
                    //sample is inlier
                    mInnerReadings.add(mReadings.get(i));
                }
            }

            try {
                mInnerEstimator.setInitialPosition(initialPosition);
                mInnerEstimator.setInitialTransmittedPowerdBm(initialTransmittedPowerdBm);
                mInnerEstimator.setInitialPathLossExponent(initialPathLossExponent);
                mInnerEstimator.setTransmittedPowerEstimationEnabled(
                        mTransmittedPowerEstimationEnabled);
                mInnerEstimator.setPathLossEstimationEnabled(
                        mPathLossEstimationEnabled);
                mInnerEstimator.setReadings(mInnerReadings);
                mInnerEstimator.setUseReadingPositionCovariances(
                        mUseReadingPositionCovariances);

                mInnerEstimator.estimate();

                Matrix cov = mInnerEstimator.getEstimatedCovariance();
                if (mKeepCovariance &amp;&amp; cov != null) {
                    //keep covariance
                    mCovariance = cov;

                    int dims = getNumberOfDimensions();
                    int pos = 0;

                    int d = dims -1;
                    if (mEstimatedPositionCovariance == null) {
                        mEstimatedPositionCovariance = mCovariance.
                                getSubmatrix(0, 0, d, d);
                    } else {
                        mCovariance.getSubmatrix(0, 0, d, d,
                                mEstimatedPositionCovariance);
                    }
                    pos += dims;

                    if (mTransmittedPowerEstimationEnabled) {
                        //transmitted power estimation enabled
                        mEstimatedTransmittedPowerVariance = mCovariance.
                                getElementAt(pos, pos);
                        pos++;
                    } else {
                        //transmitted power estimation disabled
                        mEstimatedTransmittedPowerVariance = null;
                    }

                    if (mPathLossEstimationEnabled) {
                        //pathloss exponent estimation enabled
                        mEstimatedPathLossExponentVariance = mCovariance.
                                getElementAt(pos, pos);
                    } else {
                        //pathloss exponent estimation disabled
                        mEstimatedPathLossExponentVariance = null;
                    }
                } else {
                    mCovariance = null;
                    mEstimatedPositionCovariance = null;
                    mEstimatedTransmittedPowerVariance = null;
                    mEstimatedPathLossExponentVariance = null;
                }

                mEstimatedPosition = mInnerEstimator.getEstimatedPosition();
                mEstimatedTransmittedPowerdBm =
                        mInnerEstimator.getEstimatedTransmittedPowerdBm();
                mEstimatedPathLossExponent =
                        mInnerEstimator.getEstimatedPathLossExponent();
            } catch (Exception e) {
                //refinement failed, so we return input value, and covariance
                //becomes unavailable
                mCovariance = null;
                mEstimatedPositionCovariance = null;
                mEstimatedTransmittedPowerVariance = null;
                mEstimatedPathLossExponentVariance = null;

                mEstimatedPosition = initialPosition;
                mEstimatedTransmittedPowerdBm = initialTransmittedPowerdBm;
                mEstimatedPathLossExponent = initialPathLossExponent;
            }
        } else {
            mCovariance = null;
            mEstimatedPositionCovariance = null;
            mEstimatedTransmittedPowerVariance = null;
            mEstimatedPathLossExponentVariance = null;

            mEstimatedPosition = initialPosition;
            mEstimatedTransmittedPowerdBm = initialTransmittedPowerdBm;
            mEstimatedPathLossExponent = initialPathLossExponent;
        }
    }
}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/MixedRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MixedRadioSourceEstimator.html#L494">494</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RangingAndRssiRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RangingAndRssiRadioSourceEstimator.html#L484">484</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>            MixedRadioSourceEstimatorListener&lt;S, P&gt; listener) {
        this(readings, initialPosition, initialTransmittedPowerdBm, listener);
        mInitialPathLossExponent = initialPathLossExponent;
    }

    /**
     * Gets initial transmitted power to start the estimation of radio source
     * transmitted power (expressed in dBm's).
     * If not defined, average value of received power readings will be used.
     *
     * If transmitted power estimation is enabled, estimation will start at this
     * value and will converte the most appropriate value.
     * If transmitted power estimation is disabled, this value will be assumed to be
     * exact and the estimated transmitted power will be equal to this value
     * (converted to dBm's).
     * @return initial transmitted power to start the estimation of radio source
     * transmitted power.
     */
    public Double getInitialTransmittedPowerdBm() {
        return mInitialTransmittedPowerdBm;
    }

    /**
     * Sets initial transmitted power to start the estimation of radio source
     * transmitted power (expressed in dBm's).
     * If not defined, average value of received power readings will be used.
     *
     * If transmitted power estimation is enabled, estimation will start at this
     * value and will converte the most appropriate value.
     * If transmitted power estimation is disabled, this value will be assumed to be
     * exact and the estimated transmitted power will be equal to this value
     * (converted to dBm's).
     * @param initialTransmittedPowerdBm initial transmitted power to start the
     *                                   estimation of radio source transmitted
     *                                   power.
     * @throws LockedException if estimator is locked.
     */
    public void setInitialTransmittedPowerdBm(Double initialTransmittedPowerdBm)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mInitialTransmittedPowerdBm = initialTransmittedPowerdBm;
    }

    /**
     * Gets initial transmitted power to start the estimation of radio source
     * transmitted power (expressed in mW).
     * If not defined, average value of received power readings will be used.
     *
     * If transmitted power estimation is enabled, estimation will start at this
     * value and will converte the most appropriate value.
     * If transmitted power estimation is disabled, this value will be assumed to be
     * exact and the estimated transmitted power will be equal to this value
     * (converted to dBm's).
     * @return initial transmitted power to start the estimation of radio source
     * transmitted power.
     */
    public Double getInitialTransmittedPower() {
        return mInitialTransmittedPowerdBm != null ?
                Utils.dBmToPower(mInitialTransmittedPowerdBm) : null;
    }

    /**
     * Sets initial transmitted power to start the estimation of radio source
     * transmitted power (expressed in mW).
     * If not defined, average value of received power readings will be used.
     *
     * If transmitted power estimation is enabled, estimation will start at this
     * value and will converte the most appropriate value.
     * If transmitted power estimation is disabled, this value will be assumed to be
     * exact and the estimated transmitted power will be equal to this value
     * (converted to dBm's).
     * @param initialTransmittedPower initial transmitted power to start the
     *                                estimation of radio source transmitted power.
     * @throws LockedException if estimator is locked.
     * @throws IllegalArgumentException if provided value is negative.
     */
    public void setInitialTransmittedPower(Double initialTransmittedPower)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (initialTransmittedPower != null) {
            if (initialTransmittedPower &lt; 0.0) {
                throw new IllegalArgumentException();
            }
            mInitialTransmittedPowerdBm = Utils.powerTodBm(
                    initialTransmittedPower);
        } else {
            mInitialTransmittedPowerdBm = null;
        }
    }

    /**
     * Indicates whether transmitted power estimation is enabled or not.
     * @return true if transmitted power estimation is enabled, false otherwise.
     */
    public boolean isTransmittedPowerEstimationEnabled() {
        return mTransmittedPowerEstimationEnabled;
    }

    /**
     * Specifies whether transmitted power estimation is enabled or not.
     * @param transmittedPowerEstimationEnabled true if transmitted power estimation is enabled,
     *                                          false otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setTransmittedPowerEstimationEnabled(boolean transmittedPowerEstimationEnabled)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mTransmittedPowerEstimationEnabled = transmittedPowerEstimationEnabled;
    }

    /**
     * Gets initial position to start the estimation of radio source position.
     * If not defined, centroid of provided readings will be used.
     *
     * If position estimation is enabled, estimation will start at this value
     * and will converge to the most appropriate value.
     * If position estimation is disabled, this value will be assumed to
     * be exact and the estimated position will be equal to this value.
     * @return initial position to start the estimation of radio source position.
     */
    public P getInitialPosition() {
        return mInitialPosition;
    }

    /**
     * Sets initial position to start the estimation of radio source position.
     * If not defined, centroid of provided fingerprints will be used.
     *
     * If position estimation is enabled, estimation will start at this value
     * and will converge to the most appropriate value.
     * If position estimation is disabled, this value will be assumed to
     * be exact and the estimated position will be equal to this value.
     * @param initialPosition initial position to start the estimation of radio
     *                        source position.
     * @throws LockedException if estimator is locked.
     */
    public void setInitialPosition(P initialPosition) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mInitialPosition = initialPosition;
    }

    /**
     * Gets initial exponent typically used on free space for path loss propagation
     * in terms of distance.
     * On different environments path loss exponent might have different value:
     * - Free space: 2.0
     * - Urban Area: 2.7 to 3.5
     * - Suburban Area: 3 to 5
     * - Indoor (line-of-sight): 1.6 to 1.8
     *
     * If path loss exponent estimation is enabled, estimation will start at this
     * value and will converge to the most appropriate value.
     * If path loss exponent estimation is disabled, this value will be assumed
     * to be exact and the estimated path loss exponent will be equal to this
     * value.
     * @return initial path loss exponent.
     */
    public double getInitialPathLossExponent() {
        return mInitialPathLossExponent;
    }

    /**
     * Sets initial exponent typically used on free space for path loss propagation
     * in terms of distance.
     * On different environments path loss exponent might have different value:
     * - Free space: 2.0
     * - Urban Area: 2.7 to 3.5
     * - Suburban Area: 3 to 5
     * - Indoor (line-of-sight): 1.6 to 1.8
     *
     * If path loss exponent estimation is enabled, estimation will start at this
     * value and will converge to the most appropriate value.
     * If path loss exponent estimation is disabled, this value will be assumed
     * to be exact and the estimated path loss exponent will be equal to this
     * value.
     * @param initialPathLossExponent initial path loss exponent.
     * @throws LockedException if estimator is locked.
     */
    public void setInitialPathLossExponent(double initialPathLossExponent)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mInitialPathLossExponent = initialPathLossExponent;
    }

    /**
     * Indicates whether path loss estimation is enabled or not.
     * @return true if path loss estimation is enabled, false otherwise.
     */
    public boolean isPathLossEstimationEnabled() {
        return mPathLossEstimationEnabled;
    }

    /**
     * Specifies whether path loss estimation is enabled or not.
     * @param pathLossEstimationEnabled true if path loss estimation is enabled,
     *                                  false otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setPathLossEstimationEnabled(boolean pathLossEstimationEnabled)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mPathLossEstimationEnabled = pathLossEstimationEnabled;
    }

    /**
     * Indicates whether position covariances of readings must be taken into account to increase
     * the amount of standard deviation of each ranging measure by the amount of position standard
     * deviation assuming that both measures are statistically independent.
     * @return true to take into account reading position covariances, false otherwise.
     */
    public boolean getUseReadingPositionCovariance() {
        return mUseReadingPositionCovariances;
    }

    /**
     * Specifies whether position covariances of readings must be taken into account to increase
     * the amount of standard deviation of each ranging measure by the amount of position standard
     * deviation assuming that both measures are statistically independent.
     * @param useReadingPositionCovariances true to take into account reading position covariances, false
     *                                      otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setUseReadingPositionCovariances(boolean useReadingPositionCovariances)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mUseReadingPositionCovariances = useReadingPositionCovariances;
    }

    /**
     * Indicates whether an homogeneous linear solver is used to estimate an initial
     * position for the internal ranging radio source estimator.
     * @return true if homogeneous linear solver is used, false if an inhomogeneous linear
     * one is used instead.
     */
    public boolean isHomogeneousRangingLinearSolverUsed() {
        return mUseHomogeneousRangingLinearSolver;
    }

    /**
     * Specifies whether an homogeneous linear solver is used to estimate an initial
     * position for the internal ranging radio source estimator.
     * @param useHomogeneousLinearSolver true if homogeneous linear solver is used, false
     *                                   if an inhomogeneous linear one is used instead.
     * @throws LockedException if estimator is locked.
     */
    public void setHomogeneousRangingLinearSolverUsed(boolean useHomogeneousLinearSolver)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }

        mUseHomogeneousRangingLinearSolver = useHomogeneousLinearSolver;
    }</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/Utils.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/Utils.html#L492">492</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/Utils.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/Utils.html#L1188">1188</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/Utils.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/Utils.html#L2142">2142</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    public static MultivariateNormalDist propagateVariancesToRssiVarianceFirstOrderNonLinear3D(
            final double fingerprintRssi, final double pathLossExponent,
            Point3D fingerprintPosition, Point3D radioSourcePosition,
            Point3D estimatedPosition,
            Double fingerprintRssiVariance,
            Double pathLossExponentVariance,
            Matrix fingerprintPositionCovariance,
            Matrix radioSourcePositionCovariance,
            Matrix estimatedPositionCovariance) throws IndoorException {

        if (fingerprintPosition == null || radioSourcePosition == null ||
                estimatedPosition == null) {
            return null;
        }

        //1st order Taylor expression of received power in 3D:
        //Pr(pi) = Pr(p1)
        //  - 10*n*(x1 - xa)/(ln(10)*d1a^2)*(xi - x1)
        //  - 10*n*(y1 - ya)/(ln(10)*d1a^2)*(yi - y1)
        //  - 10*n*(z1 - za)/(ln(10)*d1a^2)*(zi - z1)
        //where d1a^2 = (x1 - xa)^2 + (y1 - ya)^2 + (z1 - za)^2

        final double x1 = fingerprintPosition.getInhomX();
        final double y1 = fingerprintPosition.getInhomY();
        final double z1 = fingerprintPosition.getInhomZ();

        final double xa = radioSourcePosition.getInhomX();
        final double ya = radioSourcePosition.getInhomY();
        final double za = radioSourcePosition.getInhomZ();

        final double xi = estimatedPosition.getInhomX();
        final double yi = estimatedPosition.getInhomY();
        final double zi = estimatedPosition.getInhomZ();

        double[] mean = new double[] {
                fingerprintRssi, pathLossExponent, x1, y1, z1, xa, ya, za, xi, yi, zi
        };
        Matrix covariance = Matrix.diagonal(new double[]{
                fingerprintRssiVariance != null ? fingerprintRssiVariance : 0.0,
                pathLossExponentVariance != null ? pathLossExponentVariance : 0.0,
                0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0
        });

        if (fingerprintPositionCovariance != null &amp;&amp;
                fingerprintPositionCovariance.getRows() == Point3D.POINT3D_INHOMOGENEOUS_COORDINATES_LENGTH &amp;&amp;
                fingerprintPositionCovariance.getColumns() == Point3D.POINT3D_INHOMOGENEOUS_COORDINATES_LENGTH) {

            covariance.setSubmatrix(2, 2,
                    4, 4,
                    fingerprintPositionCovariance);
        }

        if (radioSourcePositionCovariance != null &amp;&amp;
                radioSourcePositionCovariance.getRows() == Point3D.POINT3D_INHOMOGENEOUS_COORDINATES_LENGTH &amp;&amp;
                radioSourcePositionCovariance.getColumns() == Point3D.POINT3D_INHOMOGENEOUS_COORDINATES_LENGTH) {
            covariance.setSubmatrix(5, 5,
                    7, 7,
                    radioSourcePositionCovariance);
        }

        if (estimatedPositionCovariance != null &amp;&amp;
                estimatedPositionCovariance.getRows() == Point3D.POINT3D_INHOMOGENEOUS_COORDINATES_LENGTH &amp;&amp;
                estimatedPositionCovariance.getColumns() == Point3D.POINT3D_INHOMOGENEOUS_COORDINATES_LENGTH) {
            covariance.setSubmatrix(8, 8,
                    10, 10,
                    estimatedPositionCovariance);
        }

        try {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator2D.html#L831">831</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator2D.html#L842">842</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>            RobustRangingAndRssiRadioSourceEstimatorListener&lt;S, Point2D&gt; listener) {
        super(readings, initialPosition, initialTransmittedPowerdBm,
                initialPathLossExponent, listener);
        internalSetQualityScores(qualityScores);
    }

    /**
     * Returns threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value, the
     * algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algorithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @return stop threshold to stop the algorithm prematurely when a certain
     * accuracy has been reached.
     */
    public double getStopThreshold() {
        return mStopThreshold;
    }

    /**
     * Sets threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value,
     * the algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algorithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @param stopThreshold stop threshold to stop the algorithm prematurely
     *                      when a certain accuracy has been reached.
     * @throws IllegalArgumentException if provided value is zero or negative.
     * @throws LockedException if this solver is locked.
     */
    public void setStopThreshold(double stopThreshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (stopThreshold &lt;= MIN_STOP_THRESHOLD) {
            throw new IllegalArgumentException();
        }

        mStopThreshold = stopThreshold;
    }

    /**
     * Returns quality scores corresponding to each pair of
     * positions and distances (i.e. sample).
     * The larger the score value the better the quality of the sample.
     * This implementation always returns null.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @return quality scores corresponding to each sample.
     */
    @Override
    public double[] getQualityScores() {
        return mQualityScores;
    }

    /**
     * Sets quality scores corresponding to each pair of positions and
     * distances (i.e. sample).
     * The larger the score value the better the quality of the sample.
     * This implementation makes no action.
     * Subclasses using quality scores must implement proper behaviour.
     *
     * @param qualityScores quality scores corresponding to each pair of
     *                      matched points.
     * @throws IllegalArgumentException if provided quality scores length
     * is smaller than minimum required samples.
     * @throws LockedException if robust solver is locked because an
     * estimation is already in progress.
     */
    public void setQualityScores(double[] qualityScores) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetQualityScores(qualityScores);
    }

    /**
     * Indicates whether solver is ready to find a solution.
     *
     * @return true if solver is ready, false otherwise.
     */
    @Override
    public boolean isReady() {
        return super.isReady() &amp;&amp; mQualityScores != null &amp;&amp;
                mQualityScores.length == mReadings.size();
    }

    /**
     * Robustly estimates position, transmitted power and pathloss exponent for a
     * radio source.
     *
     * @throws LockedException if instance is busy during estimation.
     * @throws NotReadyException if estimator is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     * (i.e. numerical instability, no solution available, etc).
     */
    @Override
    public void estimate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        PROMedSRobustEstimator&lt;Solution&lt;Point2D&gt;&gt; innerEstimator =
                new PROMedSRobustEstimator&lt;&gt;(
                        new PROMedSRobustEstimatorListener&lt;Solution&lt;Point2D&gt;&gt;() {

                    @Override
                    public double[] getQualityScores() {
                        return mQualityScores;
                    }

                    @Override
                    public double getThreshold() {
                        return mStopThreshold;
                    }

                    @Override
                    public int getTotalSamples() {
                        return mReadings.size();
                    }

                    @Override
                    public int getSubsetSize() {
                        return Math.max(mPreliminarySubsetSize, getMinReadings());
                    }

                    @Override
                    public void estimatePreliminarSolutions(int[] samplesIndices,
                            List&lt;Solution&lt;Point2D&gt;&gt; solutions) {
                        solvePreliminarSolutions(samplesIndices, solutions);
                    }

                    @Override
                    public double computeResidual(Solution&lt;Point2D&gt; currentEstimation, int i) {
                        return residual(currentEstimation, i);
                    }

                    @Override
                    public boolean isReady() {
                        return PROMedSRobustRangingAndRssiRadioSourceEstimator2D.this.isReady();</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator3D.html#L831">831</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator3D.html#L841">841</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>            RobustRangingAndRssiRadioSourceEstimatorListener&lt;S, Point3D&gt; listener) {
        super(readings, initialPosition, initialTransmittedPowerdBm,
                initialPathLossExponent, listener);
        internalSetQualityScores(qualityScores);
    }

    /**
     * Returns threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value, the
     * algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algorithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @return stop threshold to stop the algorithm prematurely when a certain
     * accuracy has been reached.
     */
    public double getStopThreshold() {
        return mStopThreshold;
    }

    /**
     * Sets threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value,
     * the algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algorithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @param stopThreshold stop threshold to stop the algorithm prematurely
     *                      when a certain accuracy has been reached.
     * @throws IllegalArgumentException if provided value is zero or negative.
     * @throws LockedException if this solver is locked.
     */
    public void setStopThreshold(double stopThreshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (stopThreshold &lt;= MIN_STOP_THRESHOLD) {
            throw new IllegalArgumentException();
        }

        mStopThreshold = stopThreshold;
    }

    /**
     * Returns quality scores corresponding to each pair of
     * positions and distances (i.e. sample).
     * The larger the score value the better the quality of the sample.
     * This implementation always returns null.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @return quality scores corresponding to each sample.
     */
    @Override
    public double[] getQualityScores() {
        return mQualityScores;
    }

    /**
     * Sets quality scores corresponding to each pair of positions and
     * distances (i.e. sample).
     * The larger the score value the better the quality of the sample.
     * This implementation makes no action.
     * Subclasses using quality scores must implement proper behaviour.
     *
     * @param qualityScores quality scores corresponding to each pair of
     *                      matched points.
     * @throws IllegalArgumentException if provided quality scores length
     * is smaller than minimum required samples.
     * @throws LockedException if robust solver is locked because an
     * estimation is already in progress.
     */
    public void setQualityScores(double[] qualityScores) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetQualityScores(qualityScores);
    }

    /**
     * Indicates whether solver is ready to find a solution.
     *
     * @return true if solver is ready, false otherwise.
     */
    @Override
    public boolean isReady() {
        return super.isReady() &amp;&amp; mQualityScores != null &amp;&amp;
                mQualityScores.length == mReadings.size();
    }

    /**
     * Robustly estimates position, transmitted power and pathloss exponent for a
     * radio source.
     *
     * @throws LockedException if instance is busy during estimation.
     * @throws NotReadyException if estimator is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     * (i.e. numerical instability, no solution available, etc).
     */
    @Override
    public void estimate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        PROMedSRobustEstimator&lt;Solution&lt;Point3D&gt;&gt; innerEstimator =
                new PROMedSRobustEstimator&lt;&gt;(
                        new PROMedSRobustEstimatorListener&lt;Solution&lt;Point3D&gt;&gt;() {

                            @Override
                            public double[] getQualityScores() {
                                return mQualityScores;
                            }

                            @Override
                            public double getThreshold() {
                                return mStopThreshold;
                            }

                            @Override
                            public int getTotalSamples() {
                                return mReadings.size();
                            }

                            @Override
                            public int getSubsetSize() {
                                return Math.max(mPreliminarySubsetSize, getMinReadings());
                            }

                            @Override
                            public void estimatePreliminarSolutions(int[] samplesIndices,
                                                                    List&lt;Solution&lt;Point3D&gt;&gt; solutions) {
                                solvePreliminarSolutions(samplesIndices, solutions);
                            }

                            @Override
                            public double computeResidual(Solution&lt;Point3D&gt; currentEstimation, int i) {
                                return residual(currentEstimation, i);
                            }

                            @Override
                            public boolean isReady() {
                                return PROMedSRobustRangingAndRssiRadioSourceEstimator3D.this.isReady();</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/calibration/KnownBiasAndFrameAccelerometerNonLinearLeastSquaresCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/KnownBiasAndFrameAccelerometerNonLinearLeastSquaresCalibrator.html#L2726">2726</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/calibration/KnownFrameAccelerometerNonLinearLeastSquaresCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/KnownFrameAccelerometerNonLinearLeastSquaresCalibrator.html#L3172">3172</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>            mRunning = false;
        }
    }

    /**
     * Gets estimated accelerometer scale factors and ross coupling errors.
     * This is the product of matrix Ta containing cross coupling errors and Ka
     * containing scaling factors.
     * So tat:
     * &lt;pre&gt;
     *     Ma = [sx    mxy  mxz] = Ta*Ka
     *          [myx   sy   myz]
     *          [mzx   mzy  sz ]
     * &lt;/pre&gt;
     * Where:
     * &lt;pre&gt;
     *     Ka = [sx 0   0 ]
     *          [0  sy  0 ]
     *          [0  0   sz]
     * &lt;/pre&gt;
     * and
     * &lt;pre&gt;
     *     Ta = [1          -alphaXy    alphaXz ]
     *          [alphaYx    1           -alphaYz]
     *          [-alphaZx   alphaZy     1       ]
     * &lt;/pre&gt;
     * Hence:
     * &lt;pre&gt;
     *     Ma = [sx    mxy  mxz] = Ta*Ka =  [sx             -sy * alphaXy   sz * alphaXz ]
     *          [myx   sy   myz]            [sx * alphaYx   sy              -sz * alphaYz]
     *          [mzx   mzy  sz ]            [-sx * alphaZx  sy * alphaZy    sz           ]
     * &lt;/pre&gt;
     * This instance allows any 3x3 matrix however, typically alphaYx, alphaZx and alphaZy
     * are considered to be zero if the accelerometer z-axis is assumed to be the same
     * as the body z-axis. When this is assumed, myx = mzx = mzy = 0 and the Ma matrix
     * becomes upper diagonal:
     * &lt;pre&gt;
     *     Ma = [sx    mxy  mxz]
     *          [0     sy   myz]
     *          [0     0    sz ]
     * &lt;/pre&gt;
     * Values of this matrix are unitless.
     *
     * @return estimated accelerometer scale factors and cross coupling errors, or null
     * if not available.
     */
    @Override
    public Matrix getEstimatedMa() {
        return mEstimatedMa;
    }

    /**
     * Gets estimated x-axis scale factor.
     *
     * @return estimated x-axis scale factor or null if not available.
     */
    @Override
    public Double getEstimatedSx() {
        return mEstimatedMa != null ?
                mEstimatedMa.getElementAt(0, 0) : null;
    }

    /**
     * Gets estimated y-axis scale factor.
     *
     * @return estimated y-axis scale factor or null if not available.
     */
    @Override
    public Double getEstimatedSy() {
        return mEstimatedMa != null ?
                mEstimatedMa.getElementAt(1, 1) : null;
    }

    /**
     * Gets estimated z-axis scale factor.
     *
     * @return estimated z-axis scale factor or null if not available.
     */
    @Override
    public Double getEstimatedSz() {
        return mEstimatedMa != null ?
                mEstimatedMa.getElementAt(2, 2) : null;
    }

    /**
     * Gets estimated x-y cross-coupling error.
     *
     * @return estimated x-y cross-coupling error or null if not available.
     */
    @Override
    public Double getEstimatedMxy() {
        return mEstimatedMa != null ?
                mEstimatedMa.getElementAt(0, 1) : null;
    }

    /**
     * Gets estimated x-z cross-coupling error.
     *
     * @return estimated x-z cross-coupling error or null if not available.
     */
    @Override
    public Double getEstimatedMxz() {
        return mEstimatedMa != null ?
                mEstimatedMa.getElementAt(0, 2) : null;
    }

    /**
     * Gets estimated y-x cross-coupling error.
     *
     * @return estimated y-x cross-coupling error or null if not available.
     */
    @Override
    public Double getEstimatedMyx() {
        return mEstimatedMa != null ?
                mEstimatedMa.getElementAt(1, 0) : null;
    }

    /**
     * Gets estimated y-z cross-coupling error.
     *
     * @return estimated y-z cross-coupling error or null if not available.
     */
    @Override
    public Double getEstimatedMyz() {
        return mEstimatedMa != null ?
                mEstimatedMa.getElementAt(1, 2) : null;
    }

    /**
     * Gets estimated z-x cross-coupling error.
     *
     * @return estimated z-x cross-coupling error or null if not available.
     */
    @Override
    public Double getEstimatedMzx() {
        return mEstimatedMa != null ?
                mEstimatedMa.getElementAt(2, 0) : null;
    }

    /**
     * Gets estimated z-y cross-coupling error.
     *
     * @return estimated z-y cross-coupling error or null if not available.
     */
    @Override
    public Double getEstimatedMzy() {
        return mEstimatedMa != null ?
                mEstimatedMa.getElementAt(2, 1) : null;
    }

    /**
     * Gets estimated covariance matrix for estimated position.
     *
     * @return estimated covariance matrix for estimated position.
     */
    @Override
    public Matrix getEstimatedCovariance() {
        return mEstimatedCovariance;
    }

    /**
     * Gets estimated chi square value.
     *
     * @return estimated chi square value.
     */
    @Override
    public double getEstimatedChiSq() {
        return mEstimatedChiSq;
    }

    /**
     * Internal method to perform calibration when common z-axis is assumed for both
     * the accelerometer and gyroscope.
     *
     * @throws AlgebraException                         if there are numerical errors.
     * @throws FittingException                         if no convergence to solution is found.
     * @throws com.irurueta.numerical.NotReadyException if fitter is not ready.
     */
    private void calibrateCommonAxis() throws AlgebraException, FittingException,
            com.irurueta.numerical.NotReadyException {
        // The accelerometer model is:
        // fmeas = ba + (I + Ma) * ftrue + w

        // Ideally a least squares solution tries to minimize noise component, so:
        // fmeas = ba + (I + Ma) * ftrue

        // Hence:
        //  [fmeasx] = [bx] + ( [1  0   0] + [sx    mxy mxz])   [ftruex]
        //  [fmeasy] = [by]     [0  1   0]   [myx   sy  myz]    [ftruey]
        //  [fmeasz] = [bz]     [0  0   1]   [mzx   mzy sz ]    [ftruez]

        // where myx = mzx = mzy = 0

        // Hence:
        //  [fmeasx] = [bx] + ( [1  0   0] + [sx    mxy mxz])   [ftruex]
        //  [fmeasy] = [by]     [0  1   0]   [0     sy  myz]    [ftruey]
        //  [fmeasz] = [bz]     [0  0   1]   [0     0   sz ]    [ftruez]

        //  [fmeasx] = [bx] +   [1+sx   mxy     mxz ][ftruex]
        //  [fmeasy]   [by]     [0      1+sy    myz ][ftruey]
        //  [fmeasz]   [bz]     [0      0       1+sz][ftruez]

        //  fmeasx = bx + (1+sx) * ftruex + mxy * ftruey + mxz * ftruez
        //  fmeasy = by + (1+sy) * ftruey + myz * ftruez
        //  fmeasz = bz + (1+sz) * ftruez

        // Where the unknowns are: sx, sy, sz, mxy mxz, myz
        // Reordering:
        //  fmeasx = bx + ftruex + sx * ftruex + mxy * ftruey + mxz * ftruez
        //  fmeasy = by + ftruey + sy * ftruey + myz * ftruez
        //  fmeasz = bz + ftruez + sz * ftruez

        //  fmeasx - ftruex - bx = sx * ftruex + mxy * ftruey + mxz * ftruez
        //  fmeasy - ftruey - by = sy * ftruey + myz * ftruez
        //  fmeasz - ftruez - bz = sz * ftruez

        // [ftruex  0       0       ftruey  ftruez  0     ][sx ] = [fmeasx - ftruex - bx]
        // [0       ftruey  0       0       0       ftruez][sy ]   [fmeasy - ftruey - by]
        // [0       0       ftruez  0       0       0     ][sz ]   [fmeasz - ftruez - bz]
        //                                                 [mxy]
        //                                                 [mxz]
        //                                                 [myz]

        mFitter.setFunctionEvaluator(new LevenbergMarquardtMultiVariateFunctionEvaluator() {
            @Override
            public int getNumberOfDimensions() {
                // Input points are true specific force coordinates
                return BodyKinematics.COMPONENTS;
            }

            @Override
            public int getNumberOfVariables() {
                // The multivariate function returns the components of measured specific force
                return BodyKinematics.COMPONENTS;
            }

            @Override
            public double[] createInitialParametersArray() {
                final double[] initial = new double[COMMON_Z_AXIS_UNKNOWNS];

                initial[0] = mInitialSx;</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/PROSACRobustMixedPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROSACRobustMixedPositionEstimator2D.html#L357">357</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/PROSACRobustRangingAndRssiPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROSACRobustRangingAndRssiPositionEstimator2D.html#L361">361</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/PROSACRobustRangingPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROSACRobustRangingPositionEstimator2D.html#L357">357</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/PROSACRobustRssiPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROSACRobustRssiPositionEstimator2D.html#L359">359</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>            RobustMixedPositionEstimatorListener&lt;Point2D&gt; listener) {
        this(sources, fingerprint, listener);
        internalSetSourceQualityScores(sourceQualityScores);
        internalSetFingerprintReadingsQualityScores(fingerprintReadingQualityScores);
    }

    /**
     * Returns quality scores corresponding to each radio source.
     * The larger the score value the better the quality of the sample.
     *
     * @return quality scores corresponding to each radio source.
     */
    public double[] getSourceQualityScores() {
        return mSourceQualityScores;
    }

    /**
     * Sets quality scores corresponding to each radio source.
     * The larger the score value the better the quality of the radio source.
     *
     * @param sourceQualityScores quality scores corresponding to each radio source.
     * @throws LockedException          if this instance is locked.
     * @throws IllegalArgumentException if provided quality scores length is smaller
     *                                  than minimum required samples.
     */
    public void setSourceQualityScores(double[] sourceQualityScores)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetSourceQualityScores(sourceQualityScores);
    }

    /**
     * Gets quality scores corresponding to each reading within provided fingerprint.
     * The larger the score value the better the quality of the reading.
     * This implementation always returns null.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @return quality scores corresponding to each reading within provided
     * fingerprint.
     */
    public double[] getFingerprintReadingsQualityScores() {
        return mFingerprintReadingsQualityScores;
    }

    /**
     * Sets quality scores corresponding to each reading within provided fingerprint.
     * The larger the score value the better the quality of the reading.
     * This implementation makes no action.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @param fingerprintReadingsQualityScores quality scores corresponding to each
     *                                         reading within provided fingerprint.
     * @throws LockedException          if this instance is locked.
     * @throws IllegalArgumentException if provided quality scores length is smaller
     *                                  than minimum required samples.
     */
    public void setFingerprintReadingsQualityScores(
            double[] fingerprintReadingsQualityScores) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetFingerprintReadingsQualityScores(fingerprintReadingsQualityScores);
    }

    /**
     * Gets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on distance between estimated position and distances
     * provided for each sample.
     * @return threshold to determine whether samples are inliers or not.
     */
    public double getThreshold() {
        return ((PROSACRobustLateration2DSolver) mLaterationSolver).
                getThreshold();
    }

    /**
     * Sets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on distance between estimated position and distances
     * provided for each sample.
     * @param threshold threshold to determine whether samples are inliers or not.
     * @throws IllegalArgumentException if provided value is equal or less than zero.
     * @throws LockedException if this solver is locked.
     */
    public void setThreshold(double threshold) throws LockedException {
        ((PROSACRobustLateration2DSolver) mLaterationSolver).
                setThreshold(threshold);
    }

    /**
     * Indicates whether inliers must be computed and kept.
     * @return true if inliers must be computed and kept, false if inliers
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepInliersEnabled() {
        return ((PROSACRobustLateration2DSolver) mLaterationSolver).
                isComputeAndKeepInliersEnabled();
    }

    /**
     * Specifies whether inliers must be computed and kept.
     * @param computeAndKeepInliers true if inliers must be computed and kept,
     *                              false if inliers only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepInliersEnabled(boolean computeAndKeepInliers)
            throws LockedException {
        ((PROSACRobustLateration2DSolver) mLaterationSolver).
                setComputeAndKeepInliersEnabled(computeAndKeepInliers);
    }

    /**
     * Indicates whether residuals must be computed and kept.
     * @return true if residuals must be computed and kept, false if residuals
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepResiduals() {
        return ((PROSACRobustLateration2DSolver) mLaterationSolver).
                isComputeAndKeepResiduals();
    }

    /**
     * Specifies whether residuals must be computed and kept.
     * @param computeAndKeepResiduals true if residuals must be computed and kept,
     *                                false if residuals only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepResidualsEnabled(boolean computeAndKeepResiduals)
            throws LockedException {
        ((PROSACRobustLateration2DSolver) mLaterationSolver).
                setComputeAndKeepResidualsEnabled(computeAndKeepResiduals);
    }

    /**
     * Returns method being used for robust estimation.
     * @return method being used for robust estimation.
     */
    @Override
    public RobustEstimatorMethod getMethod() {
        return RobustEstimatorMethod.PROSAC;
    }

    /**
     * Initializes robust lateration solver.
     */
    private void init() {
        mLaterationSolver = new PROSACRobustLateration2DSolver(
                mTrilaterationSolverListener);
    }

    /**
     * Sets quality scores corresponding to each provided located radio source.
     * This method is used internally and does not check whether instance is
     * locked or not.
     * @param sourceQualityScores quality scores to be set.
     * @throws IllegalArgumentException if provided quality scores length
     * is smaller than 3 samples.
     */
    private void internalSetSourceQualityScores(double[] sourceQualityScores) {
        if (sourceQualityScores == null ||
                sourceQualityScores.length &lt; getMinRequiredSources()) {
            throw new IllegalArgumentException();
        }

        mSourceQualityScores = sourceQualityScores;

        buildPositionsDistancesDistanceStandardDeviationsAndQualityScores();
    }

    /**
     * Sets quality scores corresponding to each provided reading within provided
     * fingerprint.
     * This method is used internally and does not check whether instance is locked
     * or not.
     * @param fingerprintReadingsQualityScores quality scores to be set.
     * @throws IllegalArgumentException if provided quality scores lengt is
     * smaller than 3 samples.
     */
    private void internalSetFingerprintReadingsQualityScores(
            double[] fingerprintReadingsQualityScores) {
        if (fingerprintReadingsQualityScores == null ||
                fingerprintReadingsQualityScores.length &lt; getMinRequiredSources()) {
            throw new IllegalArgumentException();
        }

        mFingerprintReadingsQualityScores = fingerprintReadingsQualityScores;

        buildPositionsDistancesDistanceStandardDeviationsAndQualityScores();
    }
}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/PROSACRobustMixedPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROSACRobustMixedPositionEstimator3D.html#L357">357</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/PROSACRobustRangingAndRssiPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROSACRobustRangingAndRssiPositionEstimator3D.html#L361">361</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/PROSACRobustRangingPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROSACRobustRangingPositionEstimator3D.html#L357">357</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/PROSACRobustRssiPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROSACRobustRssiPositionEstimator3D.html#L359">359</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>                                                RobustMixedPositionEstimatorListener&lt;Point3D&gt; listener) {
        this(sources, fingerprint, listener);
        internalSetSourceQualityScores(sourceQualityScores);
        internalSetFingerprintReadingsQualityScores(fingerprintReadingQualityScores);
    }

    /**
     * Returns quality scores corresponding to each radio source.
     * The larger the score value the better the quality of the sample.
     *
     * @return quality scores corresponding to each radio source.
     */
    public double[] getSourceQualityScores() {
        return mSourceQualityScores;
    }

    /**
     * Sets quality scores corresponding to each radio source.
     * The larger the score value the better the quality of the radio source.
     *
     * @param sourceQualityScores quality scores corresponding to each radio source.
     * @throws LockedException          if this instance is locked.
     * @throws IllegalArgumentException if provided quality scores length is smaller
     *                                  than minimum required samples.
     */
    public void setSourceQualityScores(double[] sourceQualityScores)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetSourceQualityScores(sourceQualityScores);
    }

    /**
     * Gets quality scores corresponding to each reading within provided fingerprint.
     * The larger the score value the better the quality of the reading.
     * This implementation always returns null.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @return quality scores corresponding to each reading within provided
     * fingerprint.
     */
    public double[] getFingerprintReadingsQualityScores() {
        return mFingerprintReadingsQualityScores;
    }

    /**
     * Sets quality scores corresponding to each reading within provided fingerprint.
     * The larger the score value the better the quality of the reading.
     * This implementation makes no action.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @param fingerprintReadingsQualityScores quality scores corresponding to each
     *                                         reading within provided fingerprint.
     * @throws LockedException          if this instance is locked.
     * @throws IllegalArgumentException if provided quality scores length is smaller
     *                                  than minimum required samples.
     */
    public void setFingerprintReadingsQualityScores(
            double[] fingerprintReadingsQualityScores) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetFingerprintReadingsQualityScores(fingerprintReadingsQualityScores);
    }

    /**
     * Gets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on distance between estimated position and distances
     * provided for each sample.
     * @return threshold to determine whether samples are inliers or not.
     */
    public double getThreshold() {
        return ((PROSACRobustLateration3DSolver) mLaterationSolver).
                getThreshold();
    }

    /**
     * Sets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on distance between estimated position and distances
     * provided for each sample.
     * @param threshold threshold to determine whether samples are inliers or not.
     * @throws IllegalArgumentException if provided value is equal or less than zero.
     * @throws LockedException if this solver is locked.
     */
    public void setThreshold(double threshold) throws LockedException {
        ((PROSACRobustLateration3DSolver) mLaterationSolver).
                setThreshold(threshold);
    }

    /**
     * Indicates whether inliers must be computed and kept.
     * @return true if inliers must be computed and kept, false if inliers
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepInliersEnabled() {
        return ((PROSACRobustLateration3DSolver) mLaterationSolver).
                isComputeAndKeepInliersEnabled();
    }

    /**
     * Specifies whether inliers must be computed and kept.
     * @param computeAndKeepInliers true if inliers must be computed and kept,
     *                              false if inliers only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepInliersEnabled(boolean computeAndKeepInliers)
            throws LockedException {
        ((PROSACRobustLateration3DSolver) mLaterationSolver).
                setComputeAndKeepInliersEnabled(computeAndKeepInliers);
    }

    /**
     * Indicates whether residuals must be computed and kept.
     * @return true if residuals must be computed and kept, false if residuals
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepResiduals() {
        return ((PROSACRobustLateration3DSolver) mLaterationSolver).
                isComputeAndKeepResiduals();
    }

    /**
     * Specifies whether residuals must be computed and kept.
     * @param computeAndKeepResiduals true if residuals must be computed and kept,
     *                                false if residuals only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepResidualsEnabled(boolean computeAndKeepResiduals)
            throws LockedException {
        ((PROSACRobustLateration3DSolver) mLaterationSolver).
                setComputeAndKeepResidualsEnabled(computeAndKeepResiduals);
    }

    /**
     * Returns method being used for robust estimation.
     * @return method being used for robust estimation.
     */
    @Override
    public RobustEstimatorMethod getMethod() {
        return RobustEstimatorMethod.PROSAC;
    }

    /**
     * Initializes robust lateration solver.
     */
    private void init() {
        mLaterationSolver = new PROSACRobustLateration3DSolver(
                mTrilaterationSolverListener);
    }

    /**
     * Sets quality scores corresponding to each provided located radio source.
     * This method is used internally and does not check whether instance is
     * locked or not.
     * @param sourceQualityScores quality scores to be set.
     * @throws IllegalArgumentException if provided quality scores length
     * is smaller than 3 samples.
     */
    private void internalSetSourceQualityScores(double[] sourceQualityScores) {
        if (sourceQualityScores == null ||
                sourceQualityScores.length &lt; getMinRequiredSources()) {
            throw new IllegalArgumentException();
        }

        mSourceQualityScores = sourceQualityScores;

        buildPositionsDistancesDistanceStandardDeviationsAndQualityScores();
    }

    /**
     * Sets quality scores corresponding to each provided reading within provided
     * fingerprint.
     * This method is used internally and does not check whether instance is locked
     * or not.
     * @param fingerprintReadingsQualityScores quality scores to be set.
     * @throws IllegalArgumentException if provided quality scores lengt is
     * smaller than 3 samples.
     */
    private void internalSetFingerprintReadingsQualityScores(
            double[] fingerprintReadingsQualityScores) {
        if (fingerprintReadingsQualityScores == null ||
                fingerprintReadingsQualityScores.length &lt; getMinRequiredSources()) {
            throw new IllegalArgumentException();
        }

        mFingerprintReadingsQualityScores = fingerprintReadingsQualityScores;

        buildPositionsDistancesDistanceStandardDeviationsAndQualityScores();
    }
}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/calibration/KnownBiasAndFrameAccelerometerLinearLeastSquaresCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/KnownBiasAndFrameAccelerometerLinearLeastSquaresCalibrator.html#L916">916</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/calibration/KnownBiasAndFrameAccelerometerNonLinearLeastSquaresCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/KnownBiasAndFrameAccelerometerNonLinearLeastSquaresCalibrator.html#L2373">2373</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>        mBiasZ = convertAcceleration(biasZ);
    }

    /**
     * Gets known accelerometer bias as an array.
     * Array values are expressed in meters per squared second (m/s^2).
     *
     * @return array containint coordinates of known bias.
     */
    @Override
    public double[] getBias() {
        final double[] result = new double[BodyKinematics.COMPONENTS];
        getBias(result);
        return result;
    }

    /**
     * Gets known accelerometer bias as an array.
     * Array values are expressed in meters per squared second (m/s^2).
     *
     * @param result instance where result data will be copied to.
     * @throws IllegalArgumentException if provided array does not have length 3.
     */
    @Override
    public void getBias(final double[] result) {
        if (result.length != BodyKinematics.COMPONENTS) {
            throw new IllegalArgumentException();
        }
        result[0] = mBiasX;
        result[1] = mBiasY;
        result[2] = mBiasZ;
    }

    /**
     * Sets known accelerometer bias as an array.
     * Array values are expressed in meters per squared second (m/s^2).
     *
     * @param bias known accelerometer bias.
     * @throws LockedException          if calibrator is currently running.
     * @throws IllegalArgumentException if provided array does not have length 3.
     */
    @Override
    public void setBias(final double[] bias) throws LockedException {
        if (mRunning) {
            throw new LockedException();
        }

        if (bias.length != BodyKinematics.COMPONENTS) {
            throw new IllegalArgumentException();
        }
        mBiasX = bias[0];
        mBiasY = bias[1];
        mBiasZ = bias[2];
    }

    /**
     * Gets known accelerometer bias as a column matrix.
     *
     * @return known accelerometer bias as a column matrix.
     */
    @Override
    public Matrix getBiasAsMatrix() {
        Matrix result;
        try {
            result = new Matrix(BodyKinematics.COMPONENTS, 1);
            getBiasAsMatrix(result);
        } catch (final WrongSizeException ignore) {
            // never happens
            result = null;
        }
        return result;
    }

    /**
     * Gets known accelerometer bias as a column matrix.
     *
     * @param result instance where result data will be copied to.
     * @throws IllegalArgumentException if provided matrix is not 3x1.
     */
    @Override
    public void getBiasAsMatrix(final Matrix result) {
        if (result.getRows() != BodyKinematics.COMPONENTS
                || result.getColumns() != 1) {
            throw new IllegalArgumentException();
        }
        result.setElementAtIndex(0, mBiasX);
        result.setElementAtIndex(1, mBiasY);
        result.setElementAtIndex(2, mBiasZ);
    }

    /**
     * Sets known accelerometer bias as a column matrix.
     *
     * @param bias accelerometer bias to be set.
     * @throws LockedException          if calibrator is currently running
     * @throws IllegalArgumentException if provided matrix is not 3x1.
     */
    @Override
    public void setBias(final Matrix bias) throws LockedException {
        if (mRunning) {
            throw new LockedException();
        }
        if (bias.getRows() != BodyKinematics.COMPONENTS
                || bias.getColumns() != 1) {
            throw new IllegalArgumentException();
        }

        mBiasX = bias.getElementAtIndex(0);
        mBiasY = bias.getElementAtIndex(1);
        mBiasZ = bias.getElementAtIndex(2);
    }

    /**
     * Indicates whether estimator is ready to start the estimator.
     *
     * @return true if estimator is ready, false otherwise.
     */
    @Override
    public boolean isReady() {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/estimators/ECEFKinematicsEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/estimators/ECEFKinematicsEstimator.html#L778">778</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/estimators/ECIKinematicsEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/estimators/ECIKinematicsEstimator.html#L408">408</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>        estimateKinematics(timeInterval, c, oldC, velocity, oldVelocity, position, result);
    }

    /**
     * Estimates body kinematics (specific force applied to a body and its angular rates).
     *
     * @param timeInterval time interval between epochs expressed in seconds (s).
     * @param c            boy-to-ECEF frame coordinate transformation matrix.
     * @param oldC         previous body-to-ECEF-frame coordinate transformation matrix.
     * @param vx           velocity of body frame x coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param vy           velocity of body frame y coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param vz           velocity of body frame z coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param oldVx        previous velocity of body frame x coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldVy        previous velocity of body frame y coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldVz        previous velocity of body frame z coordinate with respect ECEF
     *                     frame, resolved along EVEF-frame axes.
     * @param position     body position expressed in meters (m) with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param result       instance where body kinematics estimation will be stored.
     * @throws IllegalArgumentException if provided time interval is negative or coordinated transformation matrices
     *                                  are not ECEF frame valid.
     */
    public void estimate(final double timeInterval,
                         final CoordinateTransformation c,
                         final CoordinateTransformation oldC,
                         final Speed vx, final Speed vy, final Speed vz,
                         final Speed oldVx, final Speed oldVy, final Speed oldVz,
                         final Point3D position, final BodyKinematics result) {
        estimateKinematics(timeInterval, c, oldC, vx, vy, vz, oldVx, oldVy, oldVz,
                position, result);
    }

    /**
     * Estimates body kinematics (specific force applied to a body and its angular rates).
     *
     * @param timeInterval time interval between epochs.
     * @param c            boy-to-ECEF frame coordinate transformation matrix.
     * @param oldC         previous body-to-ECEF-frame coordinate transformation matrix.
     * @param vx           velocity of body frame x coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param vy           velocity of body frame y coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param vz           velocity of body frame z coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param oldVx        previous velocity of body frame x coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldVy        previous velocity of body frame y coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldVz        previous velocity of body frame z coordinate with respect ECEF
     *                     frame, resolved along EVEF-frame axes.
     * @param position     body position expressed in meters (m) with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param result       instance where body kinematics estimation will be stored.
     * @throws IllegalArgumentException if provided time interval is negative or coordinated transformation matrices
     *                                  are not ECEF frame valid.
     */
    public void estimate(final Time timeInterval,
                         final CoordinateTransformation c,
                         final CoordinateTransformation oldC,
                         final Speed vx, final Speed vy, final Speed vz,
                         final Speed oldVx, final Speed oldVy, final Speed oldVz,
                         final Point3D position, final BodyKinematics result) {
        estimateKinematics(timeInterval, c, oldC, vx, vy, vz, oldVx, oldVy, oldVz,
                position, result);
    }

    /**
     * Estimates body kinematics (specific force applied to a body and its angular rates).
     *
     * @param timeInterval time interval between epochs expressed in seconds (s).
     * @param c            body-to-ECEF frame coordinate transformation matrix.
     * @param oldC         previous body-to-ECEF-frame coordinate transformation matrix.
     * @param vx           velocity of body frame x coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per
     *                     second (m/s).
     * @param vy           velocity of body frame y coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per
     *                     second (m/s).
     * @param vz           velocity of body frame z coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per
     *                     second (m/s).
     * @param oldVx        previous velocity of body frame x coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters
     *                     per second (m/s).
     * @param oldVy        previous velocity of body frame y coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters
     *                     per second (m/s).
     * @param oldVz        previous velocity of body frame z coordinate with respect ECEF
     *                     frame, resolved along EVEF-frame axes and expressed in meters
     *                     per second (m/s).
     * @param x            cartesian x coordinate of body position expressed in meters (m)
     *                     with respect ECEF frame, resolved along ECEF-frame axes.
     * @param y            cartesian y coordinate of body position expressed in meters (m)
     *                     with respect ECEF frame, resolved along ECEF-frame axes.
     * @param z            cartesian z coordinate of body position expressed in meters (m)
     *                     with respect ECEF frame, resolved along ECEF-frame axes.
     * @return a new body kinematics instance.
     * @throws IllegalArgumentException if provided time interval is negative or coordinated transformation matrices
     *                                  are not ECEF frame valid.
     */
    public BodyKinematics estimateAndReturnNew(final double timeInterval,
                                               final CoordinateTransformation c,
                                               final CoordinateTransformation oldC,
                                               final double vx, final double vy, final double vz,
                                               final double oldVx, final double oldVy, final double oldVz,
                                               final double x, final double y, final double z) {
        return estimateKinematicsAndReturnNew(timeInterval, c, oldC, vx, vy, vz, oldVx, oldVy, oldVz,
                x, y, z);
    }

    /**
     * Estimates body kinematics (specific force applied to a body and its angular rates).
     *
     * @param timeInterval time interval between.
     * @param c            body-to-ECEF frame coordinate transformation matrix.
     * @param oldC         previous body-to-ECEF-frame coordinate transformation matrix.
     * @param vx           velocity of body frame x coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per
     *                     second (m/s).
     * @param vy           velocity of body frame y coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per
     *                     second (m/s).
     * @param vz           velocity of body frame z coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per
     *                     second (m/s).
     * @param oldVx        previous velocity of body frame x coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters
     *                     per second (m/s).
     * @param oldVy        previous velocity of body frame y coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters
     *                     per second (m/s).
     * @param oldVz        previous velocity of body frame z coordinate with respect ECEF
     *                     frame, resolved along EVEF-frame axes and expressed in meters
     *                     per second (m/s).
     * @param x            cartesian x coordinate of body position expressed in meters (m)
     *                     with respect ECEF frame, resolved along ECEF-frame axes.
     * @param y            cartesian y coordinate of body position expressed in meters (m)
     *                     with respect ECEF frame, resolved along ECEF-frame axes.
     * @param z            cartesian z coordinate of body position expressed in meters (m)
     *                     with respect ECEF frame, resolved along ECEF-frame axes.
     * @return a new body kinematics instance.
     * @throws IllegalArgumentException if provided time interval is negative or coordinated transformation matrices
     *                                  are not ECEF frame valid.
     */
    public BodyKinematics estimateAndReturnNew(final Time timeInterval,
                                               final CoordinateTransformation c,
                                               final CoordinateTransformation oldC,
                                               final double vx, final double vy, final double vz,
                                               final double oldVx, final double oldVy, final double oldVz,
                                               final double x, final double y, final double z) {
        return estimateKinematicsAndReturnNew(timeInterval, c, oldC, vx, vy, vz,
                oldVx, oldVy, oldVz, x, y, z);
    }

    /**
     * Estimates body kinematics (specific force applied to a body and its angular rates).
     *
     * @param timeInterval time interval between epochs expressed in seconds (s).
     * @param c            boy-to-ECEF frame coordinate transformation matrix.
     * @param oldC         previous body-to-ECEF-frame coordinate transformation matrix.
     * @param velocity     velocity of body frame with respect ECEF frame.
     * @param oldVelocity  previous velocity of body frame with respect ECEF frame.
     * @param x            cartesian x coordinate of body position expressed in meters (m)
     *                     with respect ECEF frame, resolved along ECEF-frame axes.
     * @param y            cartesian y coordinate of body position expressed in meters (m)
     *                     with respect ECEF frame, resolved along ECEF-frame axes.
     * @param z            cartesian z coordinate of body position expressed in meters (m)
     *                     with respect ECEF frame, resolved along ECEF-frame axes.
     * @return a new body kinematics instance.
     * @throws IllegalArgumentException if provided time interval is negative or coordinated transformation matrices
     *                                  are not ECEF frame valid.
     */
    public BodyKinematics estimateAndReturnNew(final double timeInterval,
                                               final CoordinateTransformation c,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator2D.html#L2807">2807</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator2D.html#L2785">2785</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>        List&lt;? extends RangingAndRssiReadingLocated&lt;S, Point2D&gt;&gt; readings = getReadings();
        if (readings == null || readings.isEmpty()) {
            return null;
        }
        S source = readings.get(0).getSource();

        Point2D estimatedPosition = getEstimatedPosition();
        if (estimatedPosition == null) {
            return null;
        }

        Matrix estimatedPositionCovariance = getEstimatedPositionCovariance();

        Double transmittedPowerVariance =
                getEstimatedTransmittedPowerVariance();
        Double transmittedPowerStandardDeviation = transmittedPowerVariance != null ?
                Math.sqrt(transmittedPowerVariance) : null;

        Double pathlossExponentVariance =
                getEstimatedPathLossExponentVariance();
        Double pathlossExponentStandardDeviation = pathlossExponentVariance != null ?
                Math.sqrt(pathlossExponentVariance) : null;

        if (source instanceof WifiAccessPoint) {
            WifiAccessPoint accessPoint = (WifiAccessPoint) source;
            return new WifiAccessPointWithPowerAndLocated2D(accessPoint.getBssid(),
                    source.getFrequency(), accessPoint.getSsid(),
                    getEstimatedTransmittedPowerdBm(),
                    transmittedPowerStandardDeviation,
                    getEstimatedPathLossExponent(),
                    pathlossExponentStandardDeviation,
                    estimatedPosition,
                    estimatedPositionCovariance);
        } else if(source instanceof Beacon) {
            Beacon beacon = (Beacon) source;
            return new BeaconWithPowerAndLocated2D(beacon.getIdentifiers(),
                    getEstimatedTransmittedPowerdBm(), beacon.getFrequency(),
                    beacon.getBluetoothAddress(), beacon.getBeaconTypeCode(),
                    beacon.getManufacturer(), beacon.getServiceUuid(),
                    beacon.getBluetoothName(),
                    getEstimatedPathLossExponent(),
                    transmittedPowerStandardDeviation,
                    pathlossExponentStandardDeviation,
                    estimatedPosition, estimatedPositionCovariance);
        }else {
            return null;
        }
    }

    /**
     * Solves preliminar solution for a subset of samples.
     *
     * @param samplesIndices    indices of subset samples.
     * @param solutions         instance where solution will be stored.
     */
    @Override
    protected void solvePreliminarSolutions(int[] samplesIndices,
            List&lt;Solution&lt;Point2D&gt;&gt; solutions) {

        try {
            int index;

            mInnerReadings.clear();
            for (int samplesIndice : samplesIndices) {
                index = samplesIndice;
                mInnerReadings.add(mReadings.get(index));
            }

            //initial transmitted power and position might or might not be available
            mInnerEstimator.setInitialTransmittedPowerdBm(
                    mInitialTransmittedPowerdBm);
            mInnerEstimator.setInitialPosition(mInitialPosition);
            mInnerEstimator.setInitialPathLossExponent(mInitialPathLossExponent);

            mInnerEstimator.setTransmittedPowerEstimationEnabled(
                    mTransmittedPowerEstimationEnabled);
            mInnerEstimator.setPathLossEstimationEnabled(mPathLossEstimationEnabled);</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/NonLinearMixedPositionEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/NonLinearMixedPositionEstimator.html#L116">116</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/NonLinearRangingAndRssiPositionEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/NonLinearRangingAndRssiPositionEstimator.html#L116">116</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/NonLinearRangingPositionEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/NonLinearRangingPositionEstimator.html#L116">116</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/NonLinearRssiPositionEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/NonLinearRssiPositionEstimator.html#L115">115</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>            MixedPositionEstimatorListener&lt;P&gt; listener) {
        this(listener);
        mInitialPosition = initialPosition;
    }

    /**
     * Gets initial position to start position estimation.
     * If not defined, centroid of located sources position will be used to start
     * the estimation.
     *
     * @return initial position to start position estimation.
     */
    public P getInitialPosition() {
        return mInitialPosition;
    }

    /**
     * Sets initial position to start position estimation.
     * If not defined, centroid of located sources position will be used to start
     * the estimation.
     *
     * @param initialPosition initial position to start position estimation.
     * @throws LockedException if estimator is locked.
     */
    public void setInitialPosition(P initialPosition) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mInitialPosition = initialPosition;
    }

    /**
     * Indicates whether located radio source position covariance must be taken into
     * account (if available) to determine distance standard deviation.
     *
     * @return true to take radio source position covariance into account, false
     * otherwise.
     */
    public boolean isRadioSourcePositionCovarianceUsed() {
        return mUseRadioSourcePositionCovariance;
    }

    /**
     * Specifies whether located radio source position covariance must be taken into
     * account (if available) to determine distance standard deviation.
     *
     * @param useRadioSourcePositionCovariance true to take radio source position
     *                                         covariance into account, false otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setRadioSourcePositionCovarianceUsed(
            boolean useRadioSourcePositionCovariance) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mUseRadioSourcePositionCovariance = useRadioSourcePositionCovariance;
    }

    /**
     * Gets distance standard deviation fallback value to use when none can be
     * determined from provided radio sources and fingerprint readings.
     *
     * @return distance standard deviation to use as fallback.
     */
    public double getFallbackDistanceStandardDeviation() {
        return mFallbackDistanceStandardDeviation;
    }

    /**
     * Sets distance standard deviation fallback value to use when none can be
     * determined from provided radio sources and fingerprint readings.
     *
     * @param fallbackDistanceStandardDeviation distance standard deviation to use
     *                                          as fallback.
     * @throws LockedException if estimator is locked.
     */
    public void setFallbackDistanceStandardDeviation(
            double fallbackDistanceStandardDeviation) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mFallbackDistanceStandardDeviation = fallbackDistanceStandardDeviation;
    }

    /**
     * Gets minimum required number of located radio sources to perform lateration.
     *
     * @return minimum required number of located radio sources to perform lateration.
     */
    @Override
    public int getMinRequiredSources() {
        return mTrilaterationSolver.getMinRequiredPositionsAndDistances();
    }

    /**
     * Indicates whether estimator is ready to find a solution.
     *
     * @return true if estimator is ready, false otherwise.
     */
    @Override
    public boolean isReady() {
        return mTrilaterationSolver.isReady();
    }

    /**
     * Returns boolean indicating whether this estimator is locked because an estimation
     * is already in progress.
     *
     * @return true if estimator is locked, false otherwise.
     */
    @Override
    public boolean isLocked() {
        return mTrilaterationSolver.isLocked();
    }

    /**
     * Gets standard deviations of distances from known located radio sources to the
     * location of provided readings in a fingerprint.
     * Distance standard deviations are used internally to solve lateration.
     *
     * @return standard deviations used internally.
     */
    public double[] getDistanceStandardDeviations() {
        return mTrilaterationSolver.getDistanceStandardDeviations();
    }

    /**
     * Estimates position based on provided located radio sources and readings of such
     * radio sources at an unknown location.
     *
     * @throws LockedException              if estimator is locked.
     * @throws NotReadyException            if estimator is not ready.
     * @throws PositionEstimationException  if estimation fails for some other reason.
     */
    @Override
    public void estimate() throws LockedException, NotReadyException,
            PositionEstimationException {
        try {
            mTrilaterationSolver.setInitialPosition(mInitialPosition);

            mTrilaterationSolver.solve();
            mEstimatedPositionCoordinates =
                    mTrilaterationSolver.getEstimatedPositionCoordinates();
        } catch (LaterationException e) {
            throw new PositionEstimationException(e);
        }
    }

    /**
     * Gets known positions of radio sources used internally to solve lateration.
     *
     * @return known positions used internally.
     */
    @Override
    public P[] getPositions() {
        return mTrilaterationSolver.getPositions();
    }

    /**
     * Gets euclidean distances from known located radio sources to the location of
     * provided readings in a fingerprint.
     * Distance values are used internally to solve lateration.
     *
     * @return euclidean distances used internally.
     */
    @Override
    public double[] getDistances() {
        return mTrilaterationSolver.getDistances();
    }

    /**
     * Gets estimated covariance matrix for estimated position.
     *
     * @return estimated covariance matrix for estimated position.
     */
    public Matrix getCovariance() {
        return mTrilaterationSolver.getCovariance();
    }

    /**
     * Internally sets located radio sources used for lateration.
     * @param sources located radio sources used for lateration.
     * @throws IllegalArgumentException if provided value is null or the number of
     * provided sources is less than the required minimum.
     */
    protected void internalSetSources(List&lt;? extends RadioSourceLocated&lt;P&gt;&gt; sources) {
        super.internalSetSources(sources);
        buildPositionsDistancesAndDistanceStandardDeviations();
    }

    /**
     * Internally sets fingerprint containing readings at an unknown location for provided
     * located radio sources.
     *
     * @param fingerprint fingerprint containing readings at an unknown location for
     *                    provided located radio sources.
     * @throws IllegalArgumentException if provided value is null.
     */
    protected void internalSetFingerprint(
            Fingerprint&lt;? extends RadioSource, ? extends Reading&lt;? extends RadioSource&gt;&gt; fingerprint) {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator2D.html#L833">833</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator2D.html#L329">329</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator2D.html#L844">844</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                initialPathLossExponent, listener);
        internalSetQualityScores(qualityScores);
    }

    /**
     * Returns threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value, the
     * algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algorithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @return stop threshold to stop the algorithm prematurely when a certain
     * accuracy has been reached.
     */
    public double getStopThreshold() {
        return mStopThreshold;
    }

    /**
     * Sets threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value,
     * the algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algorithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @param stopThreshold stop threshold to stop the algorithm prematurely
     *                      when a certain accuracy has been reached.
     * @throws IllegalArgumentException if provided value is zero or negative.
     * @throws LockedException if this solver is locked.
     */
    public void setStopThreshold(double stopThreshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (stopThreshold &lt;= MIN_STOP_THRESHOLD) {
            throw new IllegalArgumentException();
        }

        mStopThreshold = stopThreshold;
    }

    /**
     * Returns quality scores corresponding to each pair of
     * positions and distances (i.e. sample).
     * The larger the score value the better the quality of the sample.
     * This implementation always returns null.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @return quality scores corresponding to each sample.
     */
    @Override
    public double[] getQualityScores() {
        return mQualityScores;
    }

    /**
     * Sets quality scores corresponding to each pair of positions and
     * distances (i.e. sample).
     * The larger the score value the better the quality of the sample.
     * This implementation makes no action.
     * Subclasses using quality scores must implement proper behaviour.
     *
     * @param qualityScores quality scores corresponding to each pair of
     *                      matched points.
     * @throws IllegalArgumentException if provided quality scores length
     * is smaller than minimum required samples.
     * @throws LockedException if robust solver is locked because an
     * estimation is already in progress.
     */
    public void setQualityScores(double[] qualityScores) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetQualityScores(qualityScores);
    }

    /**
     * Indicates whether solver is ready to find a solution.
     *
     * @return true if solver is ready, false otherwise.
     */
    @Override
    public boolean isReady() {
        return super.isReady() &amp;&amp; mQualityScores != null &amp;&amp;
                mQualityScores.length == mReadings.size();
    }

    /**
     * Robustly estimates position, transmitted power and pathloss exponent for a
     * radio source.
     *
     * @throws LockedException if instance is busy during estimation.
     * @throws NotReadyException if estimator is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     * (i.e. numerical instability, no solution available, etc).
     */
    @Override
    public void estimate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        PROMedSRobustEstimator&lt;Solution&lt;Point2D&gt;&gt; innerEstimator =
                new PROMedSRobustEstimator&lt;&gt;(
                        new PROMedSRobustEstimatorListener&lt;Solution&lt;Point2D&gt;&gt;() {

                    @Override
                    public double[] getQualityScores() {
                        return mQualityScores;
                    }

                    @Override
                    public double getThreshold() {
                        return mStopThreshold;
                    }

                    @Override
                    public int getTotalSamples() {
                        return mReadings.size();
                    }

                    @Override
                    public int getSubsetSize() {
                        return Math.max(mPreliminarySubsetSize, getMinReadings());
                    }

                    @Override
                    public void estimatePreliminarSolutions(int[] samplesIndices,
                            List&lt;Solution&lt;Point2D&gt;&gt; solutions) {
                        solvePreliminarSolutions(samplesIndices, solutions);
                    }

                    @Override
                    public double computeResidual(Solution&lt;Point2D&gt; currentEstimation, int i) {
                        return residual(currentEstimation, i);
                    }

                    @Override
                    public boolean isReady() {
                        return PROMedSRobustRangingAndRssiRadioSourceEstimator2D.this.isReady();</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator3D.html#L833">833</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator3D.html#L329">329</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator3D.html#L843">843</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>                initialPathLossExponent, listener);
        internalSetQualityScores(qualityScores);
    }

    /**
     * Returns threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value, the
     * algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algorithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @return stop threshold to stop the algorithm prematurely when a certain
     * accuracy has been reached.
     */
    public double getStopThreshold() {
        return mStopThreshold;
    }

    /**
     * Sets threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value,
     * the algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algorithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @param stopThreshold stop threshold to stop the algorithm prematurely
     *                      when a certain accuracy has been reached.
     * @throws IllegalArgumentException if provided value is zero or negative.
     * @throws LockedException if this solver is locked.
     */
    public void setStopThreshold(double stopThreshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (stopThreshold &lt;= MIN_STOP_THRESHOLD) {
            throw new IllegalArgumentException();
        }

        mStopThreshold = stopThreshold;
    }

    /**
     * Returns quality scores corresponding to each pair of
     * positions and distances (i.e. sample).
     * The larger the score value the better the quality of the sample.
     * This implementation always returns null.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @return quality scores corresponding to each sample.
     */
    @Override
    public double[] getQualityScores() {
        return mQualityScores;
    }

    /**
     * Sets quality scores corresponding to each pair of positions and
     * distances (i.e. sample).
     * The larger the score value the better the quality of the sample.
     * This implementation makes no action.
     * Subclasses using quality scores must implement proper behaviour.
     *
     * @param qualityScores quality scores corresponding to each pair of
     *                      matched points.
     * @throws IllegalArgumentException if provided quality scores length
     * is smaller than minimum required samples.
     * @throws LockedException if robust solver is locked because an
     * estimation is already in progress.
     */
    public void setQualityScores(double[] qualityScores) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetQualityScores(qualityScores);
    }

    /**
     * Indicates whether solver is ready to find a solution.
     *
     * @return true if solver is ready, false otherwise.
     */
    @Override
    public boolean isReady() {
        return super.isReady() &amp;&amp; mQualityScores != null &amp;&amp;
                mQualityScores.length == mReadings.size();
    }

    /**
     * Robustly estimates position, transmitted power and pathloss exponent for a
     * radio source.
     *
     * @throws LockedException if instance is busy during estimation.
     * @throws NotReadyException if estimator is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     * (i.e. numerical instability, no solution available, etc).
     */
    @Override
    public void estimate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        PROMedSRobustEstimator&lt;Solution&lt;Point3D&gt;&gt; innerEstimator =
                new PROMedSRobustEstimator&lt;&gt;(
                        new PROMedSRobustEstimatorListener&lt;Solution&lt;Point3D&gt;&gt;() {

                            @Override
                            public double[] getQualityScores() {
                                return mQualityScores;
                            }

                            @Override
                            public double getThreshold() {
                                return mStopThreshold;
                            }

                            @Override
                            public int getTotalSamples() {
                                return mReadings.size();
                            }

                            @Override
                            public int getSubsetSize() {
                                return Math.max(mPreliminarySubsetSize, getMinReadings());
                            }

                            @Override
                            public void estimatePreliminarSolutions(int[] samplesIndices,
                                                                    List&lt;Solution&lt;Point3D&gt;&gt; solutions) {
                                solvePreliminarSolutions(samplesIndices, solutions);
                            }

                            @Override
                            public double computeResidual(Solution&lt;Point3D&gt; currentEstimation, int i) {
                                return residual(currentEstimation, i);
                            }

                            @Override
                            public boolean isReady() {
                                return PROMedSRobustRangingAndRssiRadioSourceEstimator3D.this.isReady();</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator2D.html#L394">394</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator2D.html#L405">405</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>            RobustRangingAndRssiRadioSourceEstimatorListener&lt;S, Point2D&gt; listener) {
        super(readings, initialPosition, initialTransmittedPowerdBm,
                initialPathLossExponent, listener);
    }

    /**
     * Gets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on received power (RSSI) expressed
     * in dBm's between received value that should have been received on estimated
     * isotropical model and actual measured value.
     *
     * @return threshold to determine whether samples are inliers or not.
     */
    public double getThreshold() {
        return mThreshold;
    }

    /**
     * Sets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on received power (RSSI) expressed
     * in dBm's between received value that should have been received on estimated
     * isotropical model and actual measured value.
     *
     * @param threshold threshold to determine whether samples are inliers or not.
     * @throws IllegalArgumentException if provided value is equal or less than zero.
     * @throws LockedException if this estimator is locked.
     */
    public void setThreshold(double threshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (threshold &lt;= MIN_THRESHOLD) {
            throw new IllegalArgumentException();
        }
        mThreshold = threshold;
    }


    /**
     * Indicates whether inliers must be computed and kept.
     *
     * @return true if inliers must be computed and kept, false if inliers
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepInliersEnabled() {
        return mComputeAndKeepInliers;
    }

    /**
     * Specifies whether inliers must be computed and kept.
     *
     * @param computeAndKeepInliers true if inliers must be computed and kept,
     *                              false if inliers only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepInliersEnabled(boolean computeAndKeepInliers)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mComputeAndKeepInliers = computeAndKeepInliers;
    }

    /**
     * Indicates whether residuals must be computed and kept.
     *
     * @return true if residuals must be computed and kept, false if residuals
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepResidualsEnabled() {
        return mComputeAndKeepResiduals;
    }

    /**
     * Specifies whether residuals must be computed and kept.
     *
     * @param computeAndKeepResiduals true if residuals must be computed and kept,
     *                                false if residuals only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepResidualsEnabled(boolean computeAndKeepResiduals)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mComputeAndKeepResiduals = computeAndKeepResiduals;
    }

    /**
     * Robustly estimates position, transmitted power and pathloss exponent for a
     * radio source.
     *
     * @throws LockedException if instance is busy during estimation.
     * @throws NotReadyException if estimator is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     * (i.e. numerical instability, no solution available, etc).
     */
    @Override
    public void estimate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        RANSACRobustEstimator&lt;Solution&lt;Point2D&gt;&gt; innerEstimator =
                new RANSACRobustEstimator&lt;&gt;(
                        new RANSACRobustEstimatorListener&lt;Solution&lt;Point2D&gt;&gt;() {
                    @Override
                    public double getThreshold() {
                        return mThreshold;
                    }

                    @Override
                    public int getTotalSamples() {
                        return mReadings.size();
                    }

                    @Override
                    public int getSubsetSize() {
                        return Math.max(mPreliminarySubsetSize, getMinReadings());
                    }

                    @Override
                    public void estimatePreliminarSolutions(int[] samplesIndices,
                            List&lt;Solution&lt;Point2D&gt;&gt; solutions) {
                        solvePreliminarSolutions(samplesIndices, solutions);
                    }

                    @Override
                    public double computeResidual(Solution&lt;Point2D&gt; currentEstimation, int i) {
                        return residual(currentEstimation, i);
                    }

                    @Override
                    public boolean isReady() {
                        return RANSACRobustRangingAndRssiRadioSourceEstimator2D.this.isReady();</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator3D.html#L394">394</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator3D.html#L405">405</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>            RobustRangingAndRssiRadioSourceEstimatorListener&lt;S, Point3D&gt; listener) {
        super(readings, initialPosition, initialTransmittedPowerdBm,
                initialPathLossExponent, listener);
    }

    /**
     * Gets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on received power (RSSI) expressed
     * in dBm's between received value that should have been received on estimated
     * isotropical model and actual measured value.
     *
     * @return threshold to determine whether samples are inliers or not.
     */
    public double getThreshold() {
        return mThreshold;
    }

    /**
     * Sets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on received power (RSSI) expressed
     * in dBm's between received value that should have been received on estimated
     * isotropical model and actual measured value.
     *
     * @param threshold threshold to determine whether samples are inliers or not.
     * @throws IllegalArgumentException if provided value is equal or less than zero.
     * @throws LockedException if this estimator is locked.
     */
    public void setThreshold(double threshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (threshold &lt;= MIN_THRESHOLD) {
            throw new IllegalArgumentException();
        }
        mThreshold = threshold;
    }


    /**
     * Indicates whether inliers must be computed and kept.
     *
     * @return true if inliers must be computed and kept, false if inliers
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepInliersEnabled() {
        return mComputeAndKeepInliers;
    }

    /**
     * Specifies whether inliers must be computed and kept.
     *
     * @param computeAndKeepInliers true if inliers must be computed and kept,
     *                              false if inliers only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepInliersEnabled(boolean computeAndKeepInliers)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mComputeAndKeepInliers = computeAndKeepInliers;
    }

    /**
     * Indicates whether residuals must be computed and kept.
     *
     * @return true if residuals must be computed and kept, false if residuals
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepResidualsEnabled() {
        return mComputeAndKeepResiduals;
    }

    /**
     * Specifies whether residuals must be computed and kept.
     *
     * @param computeAndKeepResiduals true if residuals must be computed and kept,
     *                                false if residuals only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepResidualsEnabled(boolean computeAndKeepResiduals)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mComputeAndKeepResiduals = computeAndKeepResiduals;
    }

    /**
     * Robustly estimates position, transmitted power and pathloss exponent for a
     * radio source.
     *
     * @throws LockedException if instance is busy during estimation.
     * @throws NotReadyException if estimator is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     * (i.e. numerical instability, no solution available, etc).
     */
    @Override
    public void estimate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        RANSACRobustEstimator&lt;Solution&lt;Point3D&gt;&gt; innerEstimator =
                new RANSACRobustEstimator&lt;&gt;(
                        new RANSACRobustEstimatorListener&lt;Solution&lt;Point3D&gt;&gt;() {
                            @Override
                            public double getThreshold() {
                                return mThreshold;
                            }

                            @Override
                            public int getTotalSamples() {
                                return mReadings.size();
                            }

                            @Override
                            public int getSubsetSize() {
                                return Math.max(mPreliminarySubsetSize, getMinReadings());
                            }

                            @Override
                            public void estimatePreliminarSolutions(int[] samplesIndices,
                                                                    List&lt;Solution&lt;Point3D&gt;&gt; solutions) {
                                solvePreliminarSolutions(samplesIndices, solutions);
                            }

                            @Override
                            public double computeResidual(Solution&lt;Point3D&gt; currentEstimation, int i) {
                                return residual(currentEstimation, i);
                            }

                            @Override
                            public boolean isReady() {
                                return RANSACRobustRangingAndRssiRadioSourceEstimator3D.this.isReady();</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/RadioSourceKNearestFinder.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/RadioSourceKNearestFinder.html#L41">41</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/RadioSourceNoMeanKNearestFinder.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/RadioSourceNoMeanKNearestFinder.html#L45">45</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    public RadioSourceKNearestFinder(Collection&lt;? extends RssiFingerprintLocated&lt;S, RssiReading&lt;S&gt;, P&gt;&gt; fingerprints) {
        if (fingerprints == null) {
            throw new IllegalArgumentException();
        }
        mFingerprints = fingerprints;
    }

    /**
     * Finds nearest fingerprint to provided one, in terms of signal euclidean distances, within the collection of
     * provided fingerprints.
     * @param fingerprint fingerprint to find the nearest to.
     * @return nearest fingerprint or null if none could be found.
     */
    public RssiFingerprintLocated&lt;S, RssiReading&lt;S&gt;, P&gt; findNearestTo(RssiFingerprint&lt;S, RssiReading&lt;S&gt;&gt; fingerprint) {
        return findNearestTo(fingerprint, mFingerprints);
    }

    /**
     * Finds k-nearest fingerprints to provided one, in terms of signal euclidean distances, within the collection
     * of provided fingerprints.
     * @param fingerprint fingerprint to find the k-nearest ones to.
     * @param k number of nearest fingerprints to find.
     * @return nearest fingerprints ordered from closest to farthest or an empty list if none could be found.
     * @throws IllegalArgumentException if either fingerprint is null or k is les than 1.
     */
    public List&lt;RssiFingerprintLocated&lt;S, RssiReading&lt;S&gt;, P&gt;&gt; findKNearestTo(
            RssiFingerprint&lt;S, RssiReading&lt;S&gt;&gt; fingerprint, int k) {
        return findKNearestTo(fingerprint, mFingerprints, k);
    }

    /**
     * Finds k-nearest fingerprints to provided one, in terms of signal euclidean distances, within the collection
     * of provided fingerprints.
     * @param fingerprint fingerprint to find the k-nearest ones to.
     * @param k number of nearest fingerprints to find.
     * @param nearestFingerprints list where found nearest fingerprints will be stored ordered from closest to farthest
     *                            or an empty list if none could be found.
     * @param nearestSqrDistances list where squared signal euclidean distances corresponding to found fingerprints will
     *                            be stored or an empty list if no fingerprint is found.
     * @throws IllegalArgumentException if any parameter is null or k is less than 1.
     */
    public void findKNearestTo(RssiFingerprint&lt;S, RssiReading&lt;S&gt;&gt; fingerprint, int k,
            List&lt;RssiFingerprintLocated&lt;S, RssiReading&lt;S&gt;, P&gt;&gt; nearestFingerprints,
            List&lt;Double&gt; nearestSqrDistances) {
        findKNearestTo(fingerprint, mFingerprints, k, nearestFingerprints, nearestSqrDistances);
    }

    /**
     * Gets collection of fingerprints to match against.
     * @return collection of fingerprints to match against.
     */
    public Collection&lt;? extends RssiFingerprintLocated&lt;S, RssiReading&lt;S&gt;, P&gt;&gt; getFingerprints() {
        return mFingerprints;
    }

    /**
     * Finds nearest fingerprint to provided one, in terms of signal euclidean distances, within the collection of
     * provided fingerprints.
     * @param fingerprint fingerprint to find the nearest to.
     * @param fingerprints collection of fingerprints to make the search for the nearest one.
     * @return nearest fingerprint or null if none could be found.
     * @throws IllegalArgumentException if either fingerprint or collection of fingerprints is null.
     * @param &lt;P&gt; a {@link Point} type.
     * @param &lt;S&gt; a {@link RadioSource} type.
     */
    @SuppressWarnings(&quot;Duplicates&quot;)
    public static &lt;P extends Point&lt;?&gt;, S extends RadioSource&gt; RssiFingerprintLocated&lt;S, RssiReading&lt;S&gt;, P&gt;
            findNearestTo(RssiFingerprint&lt;S, RssiReading&lt;S&gt;&gt; fingerprint,
            Collection&lt;? extends RssiFingerprintLocated&lt;S, RssiReading&lt;S&gt;, P&gt;&gt; fingerprints) {
        if (fingerprint == null || fingerprints == null) {
            throw new IllegalArgumentException();
        }

        double bestSqrDist = Double.MAX_VALUE;
        RssiFingerprintLocated&lt;S, RssiReading&lt;S&gt;, P&gt; result = null;
        for(RssiFingerprintLocated&lt;S, RssiReading&lt;S&gt;, P&gt; f : fingerprints) {
            double sqrDist = f.sqrDistanceTo(fingerprint);</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/estimators/ECEFKinematicsEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/estimators/ECEFKinematicsEstimator.html#L2348">2348</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/estimators/ECIKinematicsEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/estimators/ECIKinematicsEstimator.html#L1306">1306</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>                                          final ECEFFrame frame,
                                          final CoordinateTransformation oldC,
                                          final Speed oldVx, final Speed oldVy, final Speed oldVz,
                                          final BodyKinematics result) {
        estimateKinematics(timeInterval, frame, oldC,
                SpeedConverter.convert(oldVx.getValue().doubleValue(), oldVx.getUnit(), SpeedUnit.METERS_PER_SECOND),
                SpeedConverter.convert(oldVy.getValue().doubleValue(), oldVy.getUnit(), SpeedUnit.METERS_PER_SECOND),
                SpeedConverter.convert(oldVz.getValue().doubleValue(), oldVz.getUnit(), SpeedUnit.METERS_PER_SECOND),
                result);
    }

    /**
     * Estimates body kinematics (specific force applied to a body and its angular rates).
     *
     * @param timeInterval time interval between epochs expressed in seconds (s).
     * @param c            body-to-ECEF frame coordinate transformation matrix.
     * @param oldC         previous body-to-ECEF-frame coordinate transformation matrix.
     * @param vx           velocity of body frame x coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per
     *                     second (m/s).
     * @param vy           velocity of body frame y coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per
     *                     second (m/s).
     * @param vz           velocity of body frame z coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per
     *                     second (m/s).
     * @param oldVx        previous velocity of body frame x coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters
     *                     per second (m/s).
     * @param oldVy        previous velocity of body frame y coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters
     *                     per second (m/s).
     * @param oldVz        previous velocity of body frame z coordinate with respect ECEF
     *                     frame, resolved along EVEF-frame axes and expressed in meters
     *                     per second (m/s).
     * @param position     body position expressed in meters (m) with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param result       instance where body kinematics estimation will be stored.
     * @throws IllegalArgumentException if provided time interval is negative or coordinated transformation matrices
     *                                  are not ECEF frame valid.
     */
    public static void estimateKinematics(final double timeInterval,
                                          final CoordinateTransformation c,
                                          final CoordinateTransformation oldC,
                                          final double vx, final double vy, final double vz,
                                          final double oldVx, final double oldVy, final double oldVz,
                                          final Point3D position, final BodyKinematics result) {
        estimateKinematics(timeInterval, c, oldC, vx, vy, vz, oldVx, oldVy, oldVz,
                position.getInhomX(), position.getInhomY(), position.getInhomZ(), result);
    }

    /**
     * Estimates body kinematics (specific force applied to a body and its angular rates).
     *
     * @param timeInterval time interval between epochs.
     * @param c            body-to-ECEF frame coordinate transformation matrix.
     * @param oldC         previous body-to-ECEF-frame coordinate transformation matrix.
     * @param vx           velocity of body frame x coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per
     *                     second (m/s).
     * @param vy           velocity of body frame y coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per
     *                     second (m/s).
     * @param vz           velocity of body frame z coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per
     *                     second (m/s).
     * @param oldVx        previous velocity of body frame x coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters
     *                     per second (m/s).
     * @param oldVy        previous velocity of body frame y coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters
     *                     per second (m/s).
     * @param oldVz        previous velocity of body frame z coordinate with respect ECEF
     *                     frame, resolved along EVEF-frame axes and expressed in meters
     *                     per second (m/s).
     * @param position     body position expressed in meters (m) with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param result       instance where body kinematics estimation will be stored.
     * @throws IllegalArgumentException if provided time interval is negative or coordinated transformation matrices
     *                                  are not ECEF frame valid.
     */
    public static void estimateKinematics(final Time timeInterval,
                                          final CoordinateTransformation c,
                                          final CoordinateTransformation oldC,
                                          final double vx, final double vy, final double vz,
                                          final double oldVx, final double oldVy, final double oldVz,
                                          final Point3D position, final BodyKinematics result) {
        estimateKinematics(timeInterval, c, oldC, vx, vy, vz, oldVx, oldVy, oldVz,
                position.getInhomX(), position.getInhomY(), position.getInhomZ(), result);
    }

    /**
     * Estimates body kinematics (specific force applied to a body and its angular rates).
     *
     * @param timeInterval time interval between epochs expressed in seconds (s).
     * @param c            body-to-ECEF frame coordinate transformation matrix.
     * @param oldC         previous body-to-ECEF-frame coordinate transformation matrix.
     * @param velocity     velocity of body frame with respect ECEF frame.
     * @param oldVelocity  previous velocity of body frame with respect ECEF frame.
     * @param position     body position expressed in meters (m) with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param result       instance where body kinematics estimation will be stored.
     * @throws IllegalArgumentException if provided time interval is negative or coordinated transformation matrices
     *                                  are not ECEF frame valid.
     */
    public static void estimateKinematics(final double timeInterval,
                                          final CoordinateTransformation c,
                                          final CoordinateTransformation oldC,
                                          final ECEFVelocity velocity,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/Utils.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/Utils.html#L251">251</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/Utils.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/Utils.html#L786">786</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/Utils.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/Utils.html#L1949">1949</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public static MultivariateNormalDist propagateVariancesToRssiVarianceFirstOrderNonLinear2D(
            final double fingerprintRssi, final double pathLossExponent,
            Point2D fingerprintPosition, Point2D radioSourcePosition,
            Point2D estimatedPosition,
            Double fingerprintRssiVariance,
            Double pathLossExponentVariance,
            Matrix fingerprintPositionCovariance,
            Matrix radioSourcePositionCovariance,
            Matrix estimatedPositionCovariance) throws IndoorException {

        if (fingerprintPosition == null || radioSourcePosition == null ||
                estimatedPosition == null) {
            return null;
        }

        //1st order Taylor expression of received power in 2D:
        //Pr(pi) = Pr(p1)
        //  - 10*n*(x1 - xa)/(ln(10)*d1a^2)*(xi - x1)
        //  - 10*n*(y1 - ya)/(ln(10)*d1a^2)*(yi - y1)
        //where d1a^2 = (x1 - xa)^2 + (y1 - ya)^2

        final double x1 = fingerprintPosition.getInhomX();
        final double y1 = fingerprintPosition.getInhomY();

        final double xa = radioSourcePosition.getInhomX();
        final double ya = radioSourcePosition.getInhomY();

        final double xi = estimatedPosition.getInhomX();
        final double yi = estimatedPosition.getInhomY();

        double[] mean = new double[] {
                fingerprintRssi, pathLossExponent, x1, y1, xa, ya, xi, yi
        };
        Matrix covariance = Matrix.diagonal(new double[]{
                fingerprintRssiVariance != null ? fingerprintRssiVariance : 0.0,
                pathLossExponentVariance != null ? pathLossExponentVariance : 0.0,
                0.0, 0.0, 0.0, 0.0, 0.0, 0.0
        });

        if (fingerprintPositionCovariance != null &amp;&amp;
                fingerprintPositionCovariance.getRows() == Point2D.POINT2D_INHOMOGENEOUS_COORDINATES_LENGTH &amp;&amp;
                fingerprintPositionCovariance.getColumns() == Point2D.POINT2D_INHOMOGENEOUS_COORDINATES_LENGTH) {

            covariance.setSubmatrix(2, 2,
                    3, 3,
                    fingerprintPositionCovariance);
        }

        if (radioSourcePositionCovariance != null &amp;&amp;
                radioSourcePositionCovariance.getRows() == Point2D.POINT2D_INHOMOGENEOUS_COORDINATES_LENGTH &amp;&amp;
                radioSourcePositionCovariance.getColumns() == Point2D.POINT2D_INHOMOGENEOUS_COORDINATES_LENGTH) {
            covariance.setSubmatrix(4, 4,
                    5, 5,
                    radioSourcePositionCovariance);
        }

        if (estimatedPositionCovariance != null &amp;&amp;
                estimatedPositionCovariance.getRows() == Point2D.POINT2D_INHOMOGENEOUS_COORDINATES_LENGTH &amp;&amp;
                estimatedPositionCovariance.getColumns() == Point2D.POINT2D_INHOMOGENEOUS_COORDINATES_LENGTH) {
            covariance.setSubmatrix(6, 6,
                    7, 7,
                    estimatedPositionCovariance);
        }

        try {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator2D.html#L396">396</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator2D.html#L173">173</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator2D.html#L407">407</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>                initialPathLossExponent, listener);
    }

    /**
     * Gets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on received power (RSSI) expressed
     * in dBm's between received value that should have been received on estimated
     * isotropical model and actual measured value.
     *
     * @return threshold to determine whether samples are inliers or not.
     */
    public double getThreshold() {
        return mThreshold;
    }

    /**
     * Sets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on received power (RSSI) expressed
     * in dBm's between received value that should have been received on estimated
     * isotropical model and actual measured value.
     *
     * @param threshold threshold to determine whether samples are inliers or not.
     * @throws IllegalArgumentException if provided value is equal or less than zero.
     * @throws LockedException if this estimator is locked.
     */
    public void setThreshold(double threshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (threshold &lt;= MIN_THRESHOLD) {
            throw new IllegalArgumentException();
        }
        mThreshold = threshold;
    }


    /**
     * Indicates whether inliers must be computed and kept.
     *
     * @return true if inliers must be computed and kept, false if inliers
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepInliersEnabled() {
        return mComputeAndKeepInliers;
    }

    /**
     * Specifies whether inliers must be computed and kept.
     *
     * @param computeAndKeepInliers true if inliers must be computed and kept,
     *                              false if inliers only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepInliersEnabled(boolean computeAndKeepInliers)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mComputeAndKeepInliers = computeAndKeepInliers;
    }

    /**
     * Indicates whether residuals must be computed and kept.
     *
     * @return true if residuals must be computed and kept, false if residuals
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepResidualsEnabled() {
        return mComputeAndKeepResiduals;
    }

    /**
     * Specifies whether residuals must be computed and kept.
     *
     * @param computeAndKeepResiduals true if residuals must be computed and kept,
     *                                false if residuals only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepResidualsEnabled(boolean computeAndKeepResiduals)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mComputeAndKeepResiduals = computeAndKeepResiduals;
    }

    /**
     * Robustly estimates position, transmitted power and pathloss exponent for a
     * radio source.
     *
     * @throws LockedException if instance is busy during estimation.
     * @throws NotReadyException if estimator is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     * (i.e. numerical instability, no solution available, etc).
     */
    @Override
    public void estimate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        RANSACRobustEstimator&lt;Solution&lt;Point2D&gt;&gt; innerEstimator =
                new RANSACRobustEstimator&lt;&gt;(
                        new RANSACRobustEstimatorListener&lt;Solution&lt;Point2D&gt;&gt;() {
                    @Override
                    public double getThreshold() {
                        return mThreshold;
                    }

                    @Override
                    public int getTotalSamples() {
                        return mReadings.size();
                    }

                    @Override
                    public int getSubsetSize() {
                        return Math.max(mPreliminarySubsetSize, getMinReadings());
                    }

                    @Override
                    public void estimatePreliminarSolutions(int[] samplesIndices,
                            List&lt;Solution&lt;Point2D&gt;&gt; solutions) {
                        solvePreliminarSolutions(samplesIndices, solutions);
                    }

                    @Override
                    public double computeResidual(Solution&lt;Point2D&gt; currentEstimation, int i) {
                        return residual(currentEstimation, i);
                    }

                    @Override
                    public boolean isReady() {
                        return RANSACRobustRangingAndRssiRadioSourceEstimator2D.this.isReady();</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator3D.html#L396">396</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator3D.html#L173">173</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator3D.html#L407">407</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                initialPathLossExponent, listener);
    }

    /**
     * Gets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on received power (RSSI) expressed
     * in dBm's between received value that should have been received on estimated
     * isotropical model and actual measured value.
     *
     * @return threshold to determine whether samples are inliers or not.
     */
    public double getThreshold() {
        return mThreshold;
    }

    /**
     * Sets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on received power (RSSI) expressed
     * in dBm's between received value that should have been received on estimated
     * isotropical model and actual measured value.
     *
     * @param threshold threshold to determine whether samples are inliers or not.
     * @throws IllegalArgumentException if provided value is equal or less than zero.
     * @throws LockedException if this estimator is locked.
     */
    public void setThreshold(double threshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (threshold &lt;= MIN_THRESHOLD) {
            throw new IllegalArgumentException();
        }
        mThreshold = threshold;
    }


    /**
     * Indicates whether inliers must be computed and kept.
     *
     * @return true if inliers must be computed and kept, false if inliers
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepInliersEnabled() {
        return mComputeAndKeepInliers;
    }

    /**
     * Specifies whether inliers must be computed and kept.
     *
     * @param computeAndKeepInliers true if inliers must be computed and kept,
     *                              false if inliers only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepInliersEnabled(boolean computeAndKeepInliers)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mComputeAndKeepInliers = computeAndKeepInliers;
    }

    /**
     * Indicates whether residuals must be computed and kept.
     *
     * @return true if residuals must be computed and kept, false if residuals
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepResidualsEnabled() {
        return mComputeAndKeepResiduals;
    }

    /**
     * Specifies whether residuals must be computed and kept.
     *
     * @param computeAndKeepResiduals true if residuals must be computed and kept,
     *                                false if residuals only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepResidualsEnabled(boolean computeAndKeepResiduals)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mComputeAndKeepResiduals = computeAndKeepResiduals;
    }

    /**
     * Robustly estimates position, transmitted power and pathloss exponent for a
     * radio source.
     *
     * @throws LockedException if instance is busy during estimation.
     * @throws NotReadyException if estimator is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     * (i.e. numerical instability, no solution available, etc).
     */
    @Override
    public void estimate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        RANSACRobustEstimator&lt;Solution&lt;Point3D&gt;&gt; innerEstimator =
                new RANSACRobustEstimator&lt;&gt;(
                        new RANSACRobustEstimatorListener&lt;Solution&lt;Point3D&gt;&gt;() {
                            @Override
                            public double getThreshold() {
                                return mThreshold;
                            }

                            @Override
                            public int getTotalSamples() {
                                return mReadings.size();
                            }

                            @Override
                            public int getSubsetSize() {
                                return Math.max(mPreliminarySubsetSize, getMinReadings());
                            }

                            @Override
                            public void estimatePreliminarSolutions(int[] samplesIndices,
                                                                    List&lt;Solution&lt;Point3D&gt;&gt; solutions) {
                                solvePreliminarSolutions(samplesIndices, solutions);
                            }

                            @Override
                            public double computeResidual(Solution&lt;Point3D&gt; currentEstimation, int i) {
                                return residual(currentEstimation, i);
                            }

                            @Override
                            public boolean isReady() {
                                return RANSACRobustRangingAndRssiRadioSourceEstimator3D.this.isReady();</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator.html#L446">446</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustMixedRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustMixedRadioSourceEstimator.html#L1597">1597</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator.html#L1580">1580</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    }

    /**
     * Gets initial transmitted power to start the estimation of radio source
     * transmitted power (expressed in dBm's).
     * If not defined, average value of received power readings will be used.
     * @return initial transmitted power to start the estimation of radio source
     * transmitted power.
     */
    public Double getInitialTransmittedPowerdBm() {
        return mInitialTransmittedPowerdBm;
    }

    /**
     * Sets initial transmitted power to start the estimation of radio source
     * transmitted power (expressed in dBm's).
     * If not defined, average value of received power readings will be used.
     * @param initialTransmittedPowerdBm initial transmitted power to start the
     *                                   estimation of radio source transmitted
     *                                   power.
     * @throws LockedException if estimator is locked.
     */
    public void setInitialTransmittedPowerdBm(Double initialTransmittedPowerdBm)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mInitialTransmittedPowerdBm = initialTransmittedPowerdBm;
    }

    /**
     * Gets initial transmitted power to start the estimation of radio source
     * transmitted power (expressed in mW).
     * If not defined, average value of received power readings will be used.
     * @return initial transmitted power to start the estimation of radio source
     * transmitted power.
     */
    public Double getInitialTransmittedPower() {
        return mInitialTransmittedPowerdBm != null ?
                Utils.dBmToPower(mInitialTransmittedPowerdBm) : null;
    }

    /**
     * Sets initial transmitted power to start the estimation of radio source
     * transmitted power (expressed in mW).
     * If not defined, average value of received power readings will be used.
     * @param initialTransmittedPower initial transmitted power to start the
     *                                estimation of radio source transmitted power.
     * @throws LockedException if estimator is locked.
     * @throws IllegalArgumentException if provided value is negative.
     */
    public void setInitialTransmittedPower(Double initialTransmittedPower)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (initialTransmittedPower != null) {
            if (initialTransmittedPower &lt; 0.0) {
                throw new IllegalArgumentException();
            }
            mInitialTransmittedPowerdBm = Utils.powerTodBm(
                    initialTransmittedPower);
        } else {
            mInitialTransmittedPowerdBm = null;
        }
    }

    /**
     * Gets initial position to start the estimation of radio source position.
     * If not defined, centroid of provided fingerprints will be used.
     * @return initial position to start the estimation of radio source position.
     */
    public P getInitialPosition() {
        return mInitialPosition;
    }

    /**
     * Sets initial position to start the estimation of radio source position.
     * If not defined, centroid of provided fingerprints will be used.
     * @param initialPosition initial position to start the estimation of radio
     *                        source position.
     * @throws LockedException if estimator is locked.
     */
    public void setInitialPosition(P initialPosition) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mInitialPosition = initialPosition;
    }

    /**
     * Gets initial exponent typically used on free space for path loss propagation
     * in terms of distance.
     * On different environments path loss exponent might have different value:
     * - Free space: 2.0
     * - Urban Area: 2.7 to 3.5
     * - Suburban Area: 3 to 5
     * - Indoor (line-of-sight): 1.6 to 1.8
     *
     * If path loss exponent estimation is enabled, estimation will start at this
     * value and will converge to the most appropriate value.
     * If path loss exponent estimation is disabled, this value will be assumed
     * to be exact and the estimated path loss exponent will be equal to this
     * value.
     * @return initial path loss exponent.
     */
    public double getInitialPathLossExponent() {
        return mInitialPathLossExponent;
    }

    /**
     * Sets initial exponent typically used on free space for path loss propagation
     * in terms of distance.
     * On different environments path loss exponent might have different value:
     * - Free space: 2.0
     * - Urban Area: 2.7 to 3.5
     * - Suburban Area: 3 to 5
     * - Indoor (line-of-sight): 1.6 to 1.8
     *
     * If path loss exponent estimation is enabled, estimation will start at this
     * value and will converge to the most appropriate value.
     * If path loss exponent estimation is disabled, this value will be assumed
     * to be exact and the estimated path loss exponent will be equal to this
     * value.
     * @param initialPathLossExponent initial path loss exponent.
     * @throws LockedException if estimator is locked.
     */
    public void setInitialPathLossExponent(double initialPathLossExponent)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mInitialPathLossExponent = initialPathLossExponent;
    }

    /**
     * Indicates whether transmitted power estimation is enabled or not.
     * @return true if transmitted power estimation is enabled, false otherwise.
     */
    public boolean isTransmittedPowerEstimationEnabled() {
        return mTransmittedPowerEstimationEnabled;
    }

    /**
     * Specifies whether transmitted power estimation is enabled or not.
     * @param transmittedPowerEstimationEnabled true if transmitted power estimation is enabled,
     *                                          false otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setTransmittedPowerEstimationEnabled(boolean transmittedPowerEstimationEnabled)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mTransmittedPowerEstimationEnabled = transmittedPowerEstimationEnabled;
    }

    /**
     * Indicates whether path loss estimation is enabled or not.
     * @return true if path loss estimation is enabled, false otherwise.
     */
    public boolean isPathLossEstimationEnabled() {
        return mPathLossEstimationEnabled;
    }

    /**
     * Specifies whether path loss estimation is enabled or not.
     * @param pathLossEstimationEnabled true if path loss estimation is enabled,
     *                                  false otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setPathLossEstimationEnabled(boolean pathLossEstimationEnabled)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mPathLossEstimationEnabled = pathLossEstimationEnabled;
    }

    /**
     * Indicates whether position covariances of readings must be taken into account to increase
     * the amount of standard deviation of each ranging measure by the amount of position standard
     * deviation assuming that both measures are statistically independent.
     * @return true to take into account reading position covariances, false otherwise.
     */
    public boolean getUseReadingPositionCovariance() {
        return mUseReadingPositionCovariances;
    }

    /**
     * Specifies whether position covariances of readings must be taken into account to increase
     * the amount of standard deviation of each ranging measure by the amount of position standard
     * deviation assuming that both measures are statistically independent.
     * @param useReadingPositionCovariances true to take into account reading position covariances, false
     *                                      otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setUseReadingPositionCovariances(boolean useReadingPositionCovariances)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mUseReadingPositionCovariances = useReadingPositionCovariances;
    }

    /**
     * Indicates whether an homogeneous linear solver is used to estimate an initial
     * position for the internal ranging radio source estimator.
     * @return true if homogeneous linear solver is used, false if an inhomogeneous linear
     * one is used instead.
     */
    public abstract boolean isHomogeneousRangingLinearSolverUsed();</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/lateration/HomogeneousLinearLeastSquaresLateration2DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/HomogeneousLinearLeastSquaresLateration2DSolver.html#L85">85</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/lateration/InhomogeneousLinearLeastSquaresLateration2DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/InhomogeneousLinearLeastSquaresLateration2DSolver.html#L85">85</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    public HomogeneousLinearLeastSquaresLateration2DSolver(Circle[] circles,
                                                           LaterationSolverListener&lt;Point2D&gt; listener) {
        super(listener);
        internalSetCircles(circles);
    }

    /**
     * Gets circles defined by provided positions and distances.
     * @return circles defined by provided positions and distances.
     */
    public Circle[] getCircles() {
        if (mPositions == null) {
            return null;
        }

        Circle[] result = new Circle[mPositions.length];

        for (int i = 0; i &lt; mPositions.length; i++) {
            result[i] = new Circle(mPositions[i], mDistances[i]);
        }
        return result;
    }

    /**
     * Sets circles defining positions and euclidean distances.
     * @param circles circles defining positions and distances.
     * @throws IllegalArgumentException if circles is null or length of array of circles
     * is less than 2.
     * @throws LockedException if instance is busy solving the lateration problem.
     */
    public void setCircles(Circle[] circles) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetCircles(circles);
    }

    /**
     * Gets number of dimensions of provided points.
     * @return always returns 2 dimensions.
     */
    @Override
    public int getNumberOfDimensions() {
        return Point2D.POINT2D_INHOMOGENEOUS_COORDINATES_LENGTH;
    }

    /**
     * Minimum required number of positions and distances.
     * At least 3 positions and distances will be required to linearly solve a 2D problem.
     * @return minimum required number of positions and distances.
     */
    @Override
    public int getMinRequiredPositionsAndDistances() {
        return Point2D.POINT2D_INHOMOGENEOUS_COORDINATES_LENGTH + 1;
    }

    /**
     * Gets estimated position.
     * @return estimated position.
     */
    @Override
    public Point2D getEstimatedPosition() {
        if (mEstimatedPositionCoordinates == null) {
            return null;
        }

        InhomogeneousPoint2D position = new InhomogeneousPoint2D();
        getEstimatedPosition(position);
        return position;
    }

    /**
     * Internally sets circles defining positions and euclidean distances.
     * @param circles circles defining positions and distances.
     * @throws IllegalArgumentException if circles is null or length of array of circles
     * is less than 3.
     */
    private void internalSetCircles(Circle[] circles) {
        if (circles == null || circles.length &lt; getMinRequiredPositionsAndDistances()) {
            throw new IllegalArgumentException();
        }

        Point2D[] positions = new Point2D[circles.length];
        double[] distances = new double[circles.length];
        for (int i = 0; i &lt; circles.length; i++) {
            Circle circle = circles[i];
            positions[i] = circle.getCenter();
            distances[i] = circle.getRadius();
        }

        internalSetPositionsAndDistances(positions, distances);
    }
}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/lateration/HomogeneousLinearLeastSquaresLateration3DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/HomogeneousLinearLeastSquaresLateration3DSolver.html#L85">85</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/lateration/InhomogeneousLinearLeastSquaresLateration3DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/InhomogeneousLinearLeastSquaresLateration3DSolver.html#L85">85</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    public HomogeneousLinearLeastSquaresLateration3DSolver(Sphere[] spheres,
                                                           LaterationSolverListener&lt;Point3D&gt; listener) {
        super(listener);
        internalSetSpheres(spheres);
    }

    /**
     * Gets spheres defined by provided positions and distances.
     * @return spheres defined by provided positions and distances.
     */
    public Sphere[] getSpheres() {
        if (mPositions == null) {
            return null;
        }

        Sphere[] result = new Sphere[mPositions.length];

        for (int i = 0; i &lt; mPositions.length; i++) {
            result[i] = new Sphere(mPositions[i], mDistances[i]);
        }
        return result;
    }

    /**
     * Sets spheres defining positions and euclidean distances.
     * @param spheres spheres defining positions and distances.
     * @throws IllegalArgumentException if spheres is null or length of array of spheres
     * is less than 2.
     * @throws LockedException if instance is busy solving the lateration problem.
     */
    public void setSpheres(Sphere[] spheres) throws LockedException {
        if(isLocked()) {
            throw new LockedException();
        }
        internalSetSpheres(spheres);
    }

    /**
     * Gets number of dimensions of provided points.
     * @return always returns 2 dimensions.
     */
    @Override
    public int getNumberOfDimensions() {
        return Point3D.POINT3D_INHOMOGENEOUS_COORDINATES_LENGTH;
    }

    /**
     * Minimum required number of positions and distances.
     * At least 4 positions and distances will be required to linearly solve a 3D problem.
     * @return minimum required number of positions and distances.
     */
    @Override
    public int getMinRequiredPositionsAndDistances() {
        return Point3D.POINT3D_INHOMOGENEOUS_COORDINATES_LENGTH + 1;
    }

    /**
     * Gets estimated position.
     * @return estimated position.
     */
    @Override
    public Point3D getEstimatedPosition() {
        if (mEstimatedPositionCoordinates == null) {
            return null;
        }

        InhomogeneousPoint3D position = new InhomogeneousPoint3D();
        getEstimatedPosition(position);
        return position;
    }

    /**
     * Internally sets spheres defining positions and euclidean distances.
     * @param spheres spheres defining positions and distances.
     * @throws IllegalArgumentException if spheres is null or length of array of spheres
     * is less than 4.
     */
    private void internalSetSpheres(Sphere[] spheres) {
        if (spheres == null || spheres.length &lt; getMinRequiredPositionsAndDistances()) {
            throw new IllegalArgumentException();
        }

        Point3D[] positions = new Point3D[spheres.length];
        double[] distances = new double[spheres.length];
        for (int i = 0; i &lt; spheres.length; i++) {
            Sphere sphere = spheres[i];
            positions[i] = sphere.getCenter();
            distances[i] = sphere.getRadius();
        }

        internalSetPositionsAndDistances(positions, distances);
    }
}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/calibration/RobustKnownBiasAndFrameAccelerometerCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/RobustKnownBiasAndFrameAccelerometerCalibrator.html#L2047">2047</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/calibration/RobustKnownFrameAccelerometerCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/RobustKnownFrameAccelerometerCalibrator.html#L1694">1694</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    }

    /**
     * Gets estimated accelerometer scale factors and ross coupling errors.
     * This is the product of matrix Ta containing cross coupling errors and Ka
     * containing scaling factors.
     * So tat:
     * &lt;pre&gt;
     *     Ma = [sx    mxy  mxz] = Ta*Ka
     *          [myx   sy   myz]
     *          [mzx   mzy  sz ]
     * &lt;/pre&gt;
     * Where:
     * &lt;pre&gt;
     *     Ka = [sx 0   0 ]
     *          [0  sy  0 ]
     *          [0  0   sz]
     * &lt;/pre&gt;
     * and
     * &lt;pre&gt;
     *     Ta = [1          -alphaXy    alphaXz ]
     *          [alphaYx    1           -alphaYz]
     *          [-alphaZx   alphaZy     1       ]
     * &lt;/pre&gt;
     * Hence:
     * &lt;pre&gt;
     *     Ma = [sx    mxy  mxz] = Ta*Ka =  [sx             -sy * alphaXy   sz * alphaXz ]
     *          [myx   sy   myz]            [sx * alphaYx   sy              -sz * alphaYz]
     *          [mzx   mzy  sz ]            [-sx * alphaZx  sy * alphaZy    sz           ]
     * &lt;/pre&gt;
     * This instance allows any 3x3 matrix however, typically alphaYx, alphaZx and alphaZy
     * are considered to be zero if the accelerometer z-axis is assumed to be the same
     * as the body z-axis. When this is assumed, myx = mzx = mzy = 0 and the Ma matrix
     * becomes upper diagonal:
     * &lt;pre&gt;
     *     Ma = [sx    mxy  mxz]
     *          [0     sy   myz]
     *          [0     0    sz ]
     * &lt;/pre&gt;
     * Values of this matrix are unitless.
     *
     * @return estimated accelerometer scale factors and cross coupling errors, or null
     * if not available.
     */
    public Matrix getEstimatedMa() {
        return mEstimatedMa;
    }

    /**
     * Gets estimated x-axis scale factor.
     *
     * @return estimated x-axis scale factor or null if not available.
     */
    public Double getEstimatedSx() {
        return mEstimatedMa != null ?
                mEstimatedMa.getElementAt(0, 0) : null;
    }

    /**
     * Gets estimated y-axis scale factor.
     *
     * @return estimated y-axis scale factor or null if not available.
     */
    public Double getEstimatedSy() {
        return mEstimatedMa != null ?
                mEstimatedMa.getElementAt(1, 1) : null;
    }

    /**
     * Gets estimated z-axis scale factor.
     *
     * @return estimated z-axis scale factor or null if not available.
     */
    public Double getEstimatedSz() {
        return mEstimatedMa != null ?
                mEstimatedMa.getElementAt(2, 2) : null;
    }

    /**
     * Gets estimated x-y cross-coupling error.
     *
     * @return estimated x-y cross-coupling error or null if not available.
     */
    public Double getEstimatedMxy() {
        return mEstimatedMa != null ?
                mEstimatedMa.getElementAt(0, 1) : null;
    }

    /**
     * Gets estimated x-z cross-coupling error.
     *
     * @return estimated x-z cross-coupling error or null if not available.
     */
    public Double getEstimatedMxz() {
        return mEstimatedMa != null ?
                mEstimatedMa.getElementAt(0, 2) : null;
    }

    /**
     * Gets estimated y-x cross-coupling error.
     *
     * @return estimated y-x cross-coupling error or null if not available.
     */
    public Double getEstimatedMyx() {
        return mEstimatedMa != null ?
                mEstimatedMa.getElementAt(1, 0) : null;
    }

    /**
     * Gets estimated y-z cross-coupling error.
     *
     * @return estimated y-z cross-coupling error or null if not available.
     */
    public Double getEstimatedMyz() {
        return mEstimatedMa != null ?
                mEstimatedMa.getElementAt(1, 2) : null;
    }

    /**
     * Gets estimated z-x cross-coupling error.
     *
     * @return estimated z-x cross-coupling error or null if not available.
     */
    public Double getEstimatedMzx() {
        return mEstimatedMa != null ?
                mEstimatedMa.getElementAt(2, 0) : null;
    }

    /**
     * Gets estimated z-y cross-coupling error.
     *
     * @return estimated z-y cross-coupling error or null if not available.
     */
    public Double getEstimatedMzy() {
        return mEstimatedMa != null ?
                mEstimatedMa.getElementAt(2, 1) : null;
    }

    /**
     * Gets estimated covariance matrix for estimated position.
     * This is only available when result has been refined and covariance
     * is kept.
     *
     * @return estimated covariance matrix for estimated position.
     */
    public Matrix getEstimatedCovariance() {
        return mEstimatedCovariance;
    }

    /**
     * Gets size of subsets to be checked during robust estimation.
     * This has to be at least {@link #MINIMUM_MEASUREMENTS}.
     *
     * @return size of subsets to be checked during robust estimation.
     */
    public int getPreliminarySubsetSize() {
        return mPreliminarySubsetSize;
    }

    /**
     * Sets size of subsets to be checked during robust estimation.
     * This has to be at least {@link #MINIMUM_MEASUREMENTS}.
     *
     * @param preliminarySubsetSize size of subsets to be checked during robust estimation.
     * @throws LockedException          if calibrator is currently running.
     * @throws IllegalArgumentException if provided value is less than {@link #MINIMUM_MEASUREMENTS}.
     */
    public void setPreliminarySubsetSize(int preliminarySubsetSize) throws LockedException {
        if (mRunning) {
            throw new LockedException();
        }
        if (preliminarySubsetSize &lt; MINIMUM_MEASUREMENTS) {
            throw new IllegalArgumentException();
        }

        mPreliminarySubsetSize = preliminarySubsetSize;
    }

    /**
     * Estimates accelerometer calibration parameters containing scale factors
     * and cross-coupling errors.
     *
     * @throws LockedException      if calibrator is currently running.
     * @throws NotReadyException    if calibrator is not ready.
     * @throws CalibrationException if estimation fails for numerical reasons.
     */
    public abstract void calibrate() throws LockedException, NotReadyException, CalibrationException;

    /**
     * Returns method being used for robust estimation.
     *
     * @return method being used for robust estimation.
     */
    public abstract RobustEstimatorMethod getMethod();

    /**
     * Creates a robust accelerometer calibrator.
     *
     * @param method robust estimator method.
     * @return a robust accelerometer calibrator.
     */
    public static RobustKnownBiasAndFrameAccelerometerCalibrator create(</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/LinearMixedPositionEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/LinearMixedPositionEstimator.html#L79">79</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/LinearRangingAndRssiPositionEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/LinearRangingAndRssiPositionEstimator.html#L80">80</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/LinearRangingPositionEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/LinearRangingPositionEstimator.html#L79">79</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/LinearRssiPositionEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/LinearRssiPositionEstimator.html#L82">82</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    public LinearMixedPositionEstimator(MixedPositionEstimatorListener&lt;P&gt; listener) {
        super(listener);
        init();
    }

    /**
     * Indicates whether an homogeneous linear solver is used to estimate position.
     *
     * @return  true if homogeneous linear solver is used, false if an inhomogeneous
     *          linear one is used instead.
     */
    public boolean isHomogeneousLinearSolverUsed() {
        return mUseHomogeneousLinearSolver;
    }

    /**
     * Specifies whether an homogeneous linear solver is used to estimate position.
     *
     * @param useHomogeneousLinearSolver true if homogeneous linear solver is used, false
     *                                   if an inhomogeneous linear one is used instead.
     * @throws LockedException if estimator is locked.
     */
    public void setHomogeneousLinearSolverUsed(boolean useHomogeneousLinearSolver)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }

        mUseHomogeneousLinearSolver = useHomogeneousLinearSolver;
    }

    /**
     * Gets minimum required number of located radio sources to perform lateration.
     *
     * @return minimum required number of located radio sources to perform lateration.
     */
    @Override
    public int getMinRequiredSources() {
        return mUseHomogeneousLinearSolver?
                mHomogeneousTrilaterationSolver.getMinRequiredPositionsAndDistances() :
                mInhomogeneousTrilaterationSolver.getMinRequiredPositionsAndDistances();
    }

    /**
     * Indicates whether estimator is ready to find a solution.
     * @return true if estimator is ready, false otherwise.
     */
    @Override
    public boolean isReady() {
        return (!mUseHomogeneousLinearSolver &amp;&amp; mInhomogeneousTrilaterationSolver.isReady()) ||
                (mUseHomogeneousLinearSolver &amp;&amp; mHomogeneousTrilaterationSolver.isReady());
    }

    /**
     * Returns boolean indicating whether this estimator is locked because an estimation is already in progress.
     * @return true if estimator is locked, false otherwise.
     */
    @Override
    public boolean isLocked() {
        return mInhomogeneousTrilaterationSolver.isLocked() ||
                mHomogeneousTrilaterationSolver.isLocked();
    }

    /**
     * Estimates position based on provided located radio sources and RSSI readings of
     * such radio sources at an unknown location.
     * @throws LockedException if estimator is locked.
     * @throws NotReadyException if estimator is not ready.
     * @throws PositionEstimationException if estimation fails for some other reason.
     */
    @SuppressWarnings(&quot;Duplicates&quot;)
    @Override
    public void estimate() throws LockedException, NotReadyException,
            PositionEstimationException {
        try {
            if (mUseHomogeneousLinearSolver) {
                mHomogeneousTrilaterationSolver.solve();
                mEstimatedPositionCoordinates =
                        mHomogeneousTrilaterationSolver.getEstimatedPositionCoordinates();
            } else {
                mInhomogeneousTrilaterationSolver.solve();
                mEstimatedPositionCoordinates =
                        mInhomogeneousTrilaterationSolver.getEstimatedPositionCoordinates();
            }
        } catch (LaterationException e) {
            throw new PositionEstimationException(e);
        }
    }

    /**
     * Gets known positions of radio sources used internally to solve lateration.
     *
     * @return known positions used internally.
     */
    @Override
    public P[] getPositions() {
        return mUseHomogeneousLinearSolver ?
                mHomogeneousTrilaterationSolver.getPositions() :
                mInhomogeneousTrilaterationSolver.getPositions();
    }

    /**
     * Gets euclidean distances from known located radio sources to
     * the location of provided readings in a fingerprint.
     * Distance values are used internally to solve lateration.
     *
     * @return euclidean distances used internally.
     */
    @Override
    public double[] getDistances() {
        return mUseHomogeneousLinearSolver ?
                mHomogeneousTrilaterationSolver.getDistances() :
                mInhomogeneousTrilaterationSolver.getDistances();
    }

    /**
     * Internally sets located radio sources used for lateration.
     *
     * @param sources located radio sources used for lateration.
     * @throws IllegalArgumentException if provided value is null or the number of
     *                                  provided sources is less than the required
     *                                  minimum.
     */
    protected void internalSetSources(List&lt;? extends RadioSourceLocated&lt;P&gt;&gt; sources) {
        super.internalSetSources(sources);
        buildPositionsAndDistances();
    }

    /**
     * Internally sets fingerprint containing readings at an unknown location for provided
     * located radio sources.
     *
     * @param fingerprint fingerprint containing readings at an unknown location for
     *                    provided located radio sources.
     * @throws IllegalArgumentException if provided value is null.
     */
    protected void internalSetFingerprint(
            Fingerprint&lt;? extends RadioSource, ? extends Reading&lt;? extends RadioSource&gt;&gt; fingerprint) {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/RadioSourceKNearestFinder.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/RadioSourceKNearestFinder.html#L117">117</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/RadioSourceNoMeanKNearestFinder.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/RadioSourceNoMeanKNearestFinder.html#L122">122</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>            double sqrDist = f.sqrDistanceTo(fingerprint);
            if (sqrDist &lt; bestSqrDist) {
                bestSqrDist = sqrDist;
                result = f;
            }
        }

        return result;
    }

    /**
     * Finds k-nearest fingerprints to provided one, in terms of signal euclidean distances, within the collection
     * of provided fingerprints.
     * @param fingerprint fingerprint to find the k-nearest ones to.
     * @param fingerprints collection of fingerprints to make the search for the nearest ones.
     * @param k number of nearest fingerprints to find.
     * @return nearest fingerprints ordered from closest to farthest or an empty list if none could be found.
     * @throws IllegalArgumentException if either fingerprint or collection of fingerprints is null, or k is less than
     * 1.
     * @param &lt;P&gt; a {@link Point} type.
     * @param &lt;S&gt; a {@link RadioSource} type.
     */
    public static &lt;P extends Point&lt;?&gt;, S extends RadioSource&gt; List&lt;RssiFingerprintLocated&lt;S, RssiReading&lt;S&gt;, P&gt;&gt;
            findKNearestTo(RssiFingerprint&lt;S, RssiReading&lt;S&gt;&gt; fingerprint,
            Collection&lt;? extends RssiFingerprintLocated&lt;S, RssiReading&lt;S&gt;, P&gt;&gt; fingerprints,
            int k) {

        List&lt;RssiFingerprintLocated&lt;S, RssiReading&lt;S&gt;, P&gt;&gt; result =
                new ArrayList&lt;&gt;();
        List&lt;Double&gt; nearestSqrDistances = new ArrayList&lt;&gt;();
        findKNearestTo(fingerprint, fingerprints, k, result, nearestSqrDistances);

        return result;
    }

    /**
     * Finds k-nearest fingerprints to provided one, in terms of signal euclidean distances, within the collection
     * of provided fingerprints.
     * @param fingerprint fingerprint to find the k-nearest ones to.
     * @param fingerprints collection of fingerprints ot make the search for the nearest ones.
     * @param k number of nearest fingerprints to find.
     * @param nearestFingerprints list where found nearest fingerprints will be stored ordered from closest to farthest
     *                            or an empty list if none could be found.
     * @param nearestSqrDistances list where squared signal euclidean distances corresponding to found fingerprints will
     *                            be stored or an empty list if no fingerprint is found.
     * @throws IllegalArgumentException if any parameter is null or k is less than 1.
     * @param &lt;P&gt; a {@link Point} type.
     * @param &lt;S&gt; a {@link RadioSource} type.
     */
    @SuppressWarnings(&quot;Duplicates&quot;)
    public static &lt;P extends Point&lt;?&gt;, S extends RadioSource&gt; void findKNearestTo(
            RssiFingerprint&lt;S, RssiReading&lt;S&gt;&gt; fingerprint,
            Collection&lt;? extends RssiFingerprintLocated&lt;S, RssiReading&lt;S&gt;, P&gt;&gt; fingerprints,
            int k, List&lt;RssiFingerprintLocated&lt;S, RssiReading&lt;S&gt;, P&gt;&gt; nearestFingerprints,
            List&lt;Double&gt; nearestSqrDistances) {

        if (fingerprint == null || fingerprints == null || k &lt; 1 || nearestFingerprints == null ||
                nearestSqrDistances == null) {
            throw new IllegalArgumentException();
        }

        nearestSqrDistances.clear();
        nearestFingerprints.clear();

        double maxSqrDist = Double.MAX_VALUE;
        for (RssiFingerprintLocated&lt;S, RssiReading&lt;S&gt;, P&gt; f : fingerprints) {
            double sqrDist = f.sqrDistanceTo(fingerprint);</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/SequentialRobustMixedPositionEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/SequentialRobustMixedPositionEstimator.html#L974">974</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/SequentialRobustRangingAndRssiPositionEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/SequentialRobustRangingAndRssiPositionEstimator.html#L947">947</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustMixedRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustMixedRadioSourceEstimator.html#L1326">1326</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator.html#L1309">1309</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    }

    /**
     * Returns amount of confidence expressed as a value between 0.0 and 1.0 (which
     * is equivalent to 100%) for robust position estimation on ranging data. The
     * amount of confidence indicates the probability that the estimated result is
     * correct. Usually this value will be close to 1.0, but not exactly 1.0.
     *
     * @return amount of confidence for robust position estimation as a value between
     * 0.0 and 1.0.
     */
    public double getRangingConfidence() {
        return mRangingConfidence;
    }

    /**
     * Sets amount of confidence expressed as a value between 0.0 and 1.0 (which is
     * equivalent to 100%) for robust position estimation on ranging data. The amount
     * of confidence indicates the probability that the estimated result is correct.
     * Usually this value will be close to 1.0, but not exactly 1.0.
     *
     * @param rangingConfidence confidence to be set for robust position estimation as
     *                          a value between 0.0 and 1.0.
     * @throws IllegalArgumentException if provided value is not between 0.0 and 1.0.
     * @throws LockedException          if estimator is locked.
     */
    public void setRangingConfidence(double rangingConfidence) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (rangingConfidence &lt; MIN_CONFIDENCE || rangingConfidence &gt; MAX_CONFIDENCE) {
            throw new IllegalArgumentException();
        }
        mRangingConfidence = rangingConfidence;
    }

    /**
     * Returns amount of confidence expressed as a value between 0.0 and 1.0 (which is
     * equivalent to 100%) for robust position estimation on RSSI data. The amount of
     * confidence indicates the probability that the estimated result is correct.
     * Usually this value will be close to 1.0, but not exactly 1.0.
     *
     * @return amount of confidence for robust position estimation as a value between
     * 0.0 and 1.0.
     */
    public double getRssiConfidence() {
        return mRssiConfidence;
    }

    /**
     * Sets amount of confidence expressed as a value between 0.0 and 1.0 (which is
     * equivalent to 100%) for robust position estimation on RSSI data. The amount
     * of confidence indicates the probability that the estimated result is correct.
     * Usually this value will be close to 1.0, but not exactly 1.0.
     *
     * @param rssiConfidence    amount of confidence for robust position estimation as
     *                          a value between 0.0 and 1.0.
     * @throws IllegalArgumentException if provided value is not between 0.0 and 1.0.
     * @throws LockedException          if estimator is locked.
     */
    public void setRssiConfidence(double rssiConfidence) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (rssiConfidence &lt; MIN_CONFIDENCE || rssiConfidence &gt; MAX_CONFIDENCE) {
            throw new IllegalArgumentException();
        }
        mRssiConfidence = rssiConfidence;
    }

    /**
     * Gets maximum allowed number of iterations for robust ranging position estimation.
     * When the maximum number of iterations is exceeded, an approximate result might
     * be available for retrieval.
     *
     * @return maximum allowed number of iterations for position estimation.
     */
    public int getRangingMaxIterations() {
        return mRangingMaxIterations;
    }

    /**
     * Sets maximum allowed number of iterations for robust ranging position
     * estimation.
     * When the maximum number of iterations is exceeded, an approximate result might
     * be available for retrieval.
     *
     * @param rangingMaxIterations  maximum allowed number of iterations to be set for
     *                              position estimation.
     * @throws IllegalArgumentException if provided value is less than 1.
     * @throws LockedException          if estimator is locked.
     */
    public void setRangingMaxIterations(int rangingMaxIterations)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (rangingMaxIterations &lt; MIN_ITERATIONS) {
            throw new IllegalArgumentException();
        }
        mRangingMaxIterations = rangingMaxIterations;
    }

    /**
     * Gets maximum allowed number of iterations for robust RSSI position estimation.
     * When the maximum number of iterations is exceeded, an approximate result might
     * be available for retrieval.
     *
     * @return maximum allowed number of iterations for position estimation.
     */
    public int getRssiMaxIterations() {
        return mRssiMaxIterations;
    }

    /**
     * Sets maximum allowed number of iterations for robust RSSI position estimation.
     * When the maximum number of iterations is exceeded, an approximate result might
     * be available for retrieval.
     *
     * @param rssiMaxIterations maximum allowed number of iterations to be set for
     *                          position estimation.
     * @throws IllegalArgumentException if provided value is less than 1.
     * @throws LockedException          if estimator is locked.
     */
    public void setRssiMaxIterations(int rssiMaxIterations) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (rssiMaxIterations &lt; MIN_ITERATIONS) {
            throw new IllegalArgumentException();
        }
        mRssiMaxIterations = rssiMaxIterations;
    }

    /**
     * Indicates whether result is refined using all found inliers.
     *
     * @return true if result is refined, false otherwise.
     */
    public boolean isResultRefined() {
        return mRefineResult;
    }

    /**
     * Specifies whether result is refined using all found inliers.
     *
     * @param refineResult true if result is refined, false otherwise.
     * @throws LockedException if this instance is locked.
     */
    public void setResultRefined(boolean refineResult) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }

        mRefineResult = refineResult;
    }

    /**
     * Indicates whether covariance must be kept after refining result.
     * This setting is only taken into account if result is refined.
     *
     * @return true if covariance must be kept after refining result, false otherwise.
     */
    public boolean isCovarianceKept() {
        return mKeepCovariance;
    }

    /**
     * Specifies whether covariance must be kept after refining result.
     * This setting is only taken into account if result is refined.
     *
     * @param keepCovariance true if covariance must be kept after refining result,
     *                       false otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setCovarianceKept(boolean keepCovariance) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mKeepCovariance = keepCovariance;
    }

    /**
     * Indicates whether a linear solver is used for preliminary solution estimation
     * using ranging measurements.
     * The result obtained on each preliminary solution might be later refined.
     *
     * @return true if a linear solver is used for preliminary solution estimation on
     * ranging readings.
     */
    public boolean isRangingLinearSolverUsed() {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator2D.html#L2797">2797</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator2D.html#L840">840</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    }

    /**
     * Gets estimated located radio source with estimated transmitted power.
     *
     * @return estimated located radio source with estimated transmitted power or null.
     */
    @Override
    @SuppressWarnings(&quot;unchecked&quot;)
    public RadioSourceWithPowerAndLocated&lt;Point2D&gt; getEstimatedRadioSource() {
        List&lt;? extends RangingAndRssiReadingLocated&lt;S, Point2D&gt;&gt; readings = getReadings();
        if (readings == null || readings.isEmpty()) {
            return null;
        }
        S source = readings.get(0).getSource();

        Point2D estimatedPosition = getEstimatedPosition();
        if (estimatedPosition == null) {
            return null;
        }

        Matrix estimatedPositionCovariance = getEstimatedPositionCovariance();

        Double transmittedPowerVariance =
                getEstimatedTransmittedPowerVariance();
        Double transmittedPowerStandardDeviation = transmittedPowerVariance != null ?
                Math.sqrt(transmittedPowerVariance) : null;

        Double pathlossExponentVariance =
                getEstimatedPathLossExponentVariance();
        Double pathlossExponentStandardDeviation = pathlossExponentVariance != null ?
                Math.sqrt(pathlossExponentVariance) : null;

        if (source instanceof WifiAccessPoint) {
            WifiAccessPoint accessPoint = (WifiAccessPoint) source;
            return new WifiAccessPointWithPowerAndLocated2D(accessPoint.getBssid(),
                    source.getFrequency(), accessPoint.getSsid(),
                    getEstimatedTransmittedPowerdBm(),
                    transmittedPowerStandardDeviation,
                    getEstimatedPathLossExponent(),
                    pathlossExponentStandardDeviation,
                    estimatedPosition,
                    estimatedPositionCovariance);
        } else if(source instanceof Beacon) {
            Beacon beacon = (Beacon) source;
            return new BeaconWithPowerAndLocated2D(beacon.getIdentifiers(),
                    getEstimatedTransmittedPowerdBm(), beacon.getFrequency(),
                    beacon.getBluetoothAddress(), beacon.getBeaconTypeCode(),
                    beacon.getManufacturer(), beacon.getServiceUuid(),
                    beacon.getBluetoothName(),
                    getEstimatedPathLossExponent(),
                    transmittedPowerStandardDeviation,
                    pathlossExponentStandardDeviation,
                    estimatedPosition, estimatedPositionCovariance);
        }else {
            return null;
        }
    }

    /**
     * Solves preliminar solution for a subset of samples.
     *
     * @param samplesIndices    indices of subset samples.
     * @param solutions         instance where solution will be stored.
     */
    @Override
    protected void solvePreliminarSolutions(int[] samplesIndices,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator3D.html#L2799">2799</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator3D.html#L839">839</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    }

    /**
     * Gets estimated located radio source with estimated transmitted power.
     *
     * @return estimated located radio source with estimated transmitted power or null.
     */
    @Override
    @SuppressWarnings(&quot;unchecked&quot;)
    public RadioSourceWithPowerAndLocated&lt;Point3D&gt; getEstimatedRadioSource() {
        List&lt;? extends RangingAndRssiReadingLocated&lt;S, Point3D&gt;&gt; readings = getReadings();
        if (readings == null || readings.isEmpty()) {
            return null;
        }
        S source = readings.get(0).getSource();

        Point3D estimatedPosition = getEstimatedPosition();
        if (estimatedPosition == null) {
            return null;
        }

        Matrix estimatedPositionCovariance = getEstimatedPositionCovariance();

        Double transmittedPowerVariance =
                getEstimatedTransmittedPowerVariance();
        Double transmittedPowerStandardDeviation = transmittedPowerVariance != null ?
                Math.sqrt(transmittedPowerVariance) : null;

        Double pathlossExponentVariance =
                getEstimatedPathLossExponentVariance();
        Double pathlossExponentStandardDeviation = pathlossExponentVariance != null ?
                Math.sqrt(pathlossExponentVariance) : null;

        if (source instanceof WifiAccessPoint) {
            WifiAccessPoint accessPoint = (WifiAccessPoint) source;
            return new WifiAccessPointWithPowerAndLocated3D(accessPoint.getBssid(),
                    source.getFrequency(), accessPoint.getSsid(),
                    getEstimatedTransmittedPowerdBm(),
                    transmittedPowerStandardDeviation,
                    getEstimatedPathLossExponent(),
                    pathlossExponentStandardDeviation,
                    estimatedPosition,
                    estimatedPositionCovariance);
        } else if(source instanceof Beacon) {
            Beacon beacon = (Beacon) source;
            return new BeaconWithPowerAndLocated3D(beacon.getIdentifiers(),
                    getEstimatedTransmittedPowerdBm(), beacon.getFrequency(),
                    beacon.getBluetoothAddress(), beacon.getBeaconTypeCode(),
                    beacon.getManufacturer(), beacon.getServiceUuid(),
                    beacon.getBluetoothName(),
                    getEstimatedPathLossExponent(),
                    transmittedPowerStandardDeviation,
                    pathlossExponentStandardDeviation,
                    estimatedPosition, estimatedPositionCovariance);
        }else {
            return null;
        }
    }

    /**
     * Solves preliminar solution for a subset of samples.
     *
     * @param samplesIndices    indices of subset samples.
     * @param solutions         instance where solution will be stored.
     */
    @Override
    protected void solvePreliminarSolutions(int[] samplesIndices,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/gnss/GNSSEstimation.java</td>
<td><a href="./xref/com/irurueta/navigation/gnss/GNSSEstimation.html#L435">435</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/INSLooselyCoupledKalmanState.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/INSLooselyCoupledKalmanState.html#L1471">1471</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/INSTightlyCoupledKalmanState.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/INSTightlyCoupledKalmanState.html#L1644">1644</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    }

    /**
     * Gets x coordinate of estimated ECEF user position.
     *
     * @param result instance where x coordinate of estimated ECEF user position will be stored.
     */
    public void getDistanceX(final Distance result) {
        result.setValue(mX);
        result.setUnit(DistanceUnit.METER);
    }

    /**
     * Gets x coordinate of estimated ECEF user position.
     *
     * @return x coordinate of estimated ECEF user position.
     */
    public Distance getDistanceX() {
        return new Distance(mX, DistanceUnit.METER);
    }

    /**
     * Sets x coordinate of estimated ECEF user position.
     *
     * @param x x coordinate of estimated ECEF user position.
     */
    public void setDistanceX(final Distance x) {
        mX = DistanceConverter.convert(x.getValue().doubleValue(), x.getUnit(),
                DistanceUnit.METER);
    }

    /**
     * Gets y coordinate of estimated ECEF user position.
     *
     * @param result instance where y coordinate of estimated ECEF user position will be stored.
     */
    public void getDistanceY(final Distance result) {
        result.setValue(mY);
        result.setUnit(DistanceUnit.METER);
    }

    /**
     * Gets y coordinate of estimated ECEF user position.
     *
     * @return y coordinate of estimated ECEF user position.
     */
    public Distance getDistanceY() {
        return new Distance(mY, DistanceUnit.METER);
    }

    /**
     * Sets y coordinate of estimated ECEF user position.
     *
     * @param y y coordinate of estimated ECEF user position.
     */
    public void setDistanceY(final Distance y) {
        mY = DistanceConverter.convert(y.getValue().doubleValue(), y.getUnit(),
                DistanceUnit.METER);
    }

    /**
     * Gets z coordinate of estimated ECEF user position.
     *
     * @param result instance where z coordinate of estimated ECEF user position will be stored.
     */
    public void getDistanceZ(final Distance result) {
        result.setValue(mZ);
        result.setUnit(DistanceUnit.METER);
    }

    /**
     * Gets z coordinate of estimated ECEF user position.
     *
     * @return z coordinate of estimated ECEF user position.
     */
    public Distance getDistanceZ() {
        return new Distance(mZ, DistanceUnit.METER);
    }

    /**
     * Sets z coordinate of estimated ECEF user position.
     *
     * @param z z coordinate of estimated ECEF user position.
     */
    public void setDistanceZ(final Distance z) {
        mZ = DistanceConverter.convert(z.getValue().doubleValue(), z.getUnit(),
                DistanceUnit.METER);
    }

    /**
     * Sets coordinates of estimated ECEF user position.
     *
     * @param x x coordinate.
     * @param y y coordinate.
     * @param z z coordinate.
     */
    public void setPositionCoordinates(final Distance x, final Distance y, final Distance z) {
        setDistanceX(x);
        setDistanceY(y);
        setDistanceZ(z);
    }

    /**
     * Gets x coordinate of estimated ECEF user velocity.
     *
     * @param result instance where x coordinate of estimated ECEF user velocity will
     *               be stored.
     */
    public void getSpeedX(final Speed result) {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator2D.html#L2775">2775</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RssiRadioSourceEstimator2D.html#L402">402</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    }

    /**
     * Gets estimated located radio source with estimated transmitted power.
     *
     * @return estimated located radio source with estimated transmitted power or null.
     */
    @Override
    @SuppressWarnings(&quot;unchecked&quot;)
    public RadioSourceWithPowerAndLocated&lt;Point2D&gt; getEstimatedRadioSource() {
        List&lt;? extends RssiReadingLocated&lt;S, Point2D&gt;&gt; readings = getReadings();
        if (readings == null || readings.isEmpty()) {
            return null;
        }
        S source = readings.get(0).getSource();

        Point2D estimatedPosition = getEstimatedPosition();
        if (estimatedPosition == null) {
            return null;
        }

        Matrix estimatedPositionCovariance = getEstimatedPositionCovariance();

        Double transmittedPowerVariance =
                getEstimatedTransmittedPowerVariance();
        Double transmittedPowerStandardDeviation = transmittedPowerVariance != null ?
                Math.sqrt(transmittedPowerVariance) : null;

        Double pathlossExponentVariance =
                getEstimatedPathLossExponentVariance();
        Double pathlossExponentStandardDeviation = pathlossExponentVariance != null ?
                Math.sqrt(pathlossExponentVariance) : null;

        if (source instanceof WifiAccessPoint) {
            WifiAccessPoint accessPoint = (WifiAccessPoint) source;
            return new WifiAccessPointWithPowerAndLocated2D(accessPoint.getBssid(),
                    source.getFrequency(), accessPoint.getSsid(),
                    getEstimatedTransmittedPowerdBm(),
                    transmittedPowerStandardDeviation,
                    getEstimatedPathLossExponent(),
                    pathlossExponentStandardDeviation,
                    estimatedPosition,
                    estimatedPositionCovariance);
        } else if(source instanceof Beacon) {
            Beacon beacon = (Beacon) source;
            return new BeaconWithPowerAndLocated2D(beacon.getIdentifiers(),
                    getEstimatedTransmittedPowerdBm(), beacon.getFrequency(),
                    beacon.getBluetoothAddress(), beacon.getBeaconTypeCode(),
                    beacon.getManufacturer(), beacon.getServiceUuid(),
                    beacon.getBluetoothName(),
                    getEstimatedPathLossExponent(),
                    transmittedPowerStandardDeviation,
                    pathlossExponentStandardDeviation,
                    estimatedPosition, estimatedPositionCovariance);
        }else {
            return null;
        }
    }</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator2D.html#L833">833</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator3D.html#L832">832</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator2D.html#L838">838</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator3D.html#L837">837</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>            RobustRangingAndRssiRadioSourceEstimatorListener&lt;S, Point2D&gt; listener) {
        super(readings, initialPosition, initialTransmittedPowerdBm,
                initialPathLossExponent, listener);
        internalSetQualityScores(qualityScores);
    }

    /**
     * Gets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on distance between estimated position and distances
     * provided for each sample.
     *
     * @return threshold to determine whether samples are inliers or not.
     */
    public double getThreshold() {
        return mThreshold;
    }

    /**
     * Sets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on distance between estimated position and distances
     * provided for each sample.
     *
     * @param threshold threshold to determine whether samples are inliers or not.
     * @throws IllegalArgumentException if provided value is equal or less than zero.
     * @throws LockedException if this solver is locked.
     */
    public void setThreshold(double threshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (threshold &lt;= MIN_THRESHOLD) {
            throw new IllegalArgumentException();
        }
        mThreshold = threshold;
    }

    /**
     * Returns quality scores corresponding to each pair of
     * positions and distances (i.e. sample).
     * The larger the score value the better the quality of the sample.
     * This implementation always returns null.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @return quality scores corresponding to each sample.
     */
    @Override
    public double[] getQualityScores() {
        return mQualityScores;
    }

    /**
     * Sets quality scores corresponding to each pair of positions and
     * distances (i.e. sample).
     * The larger the score value the better the quality of the sample.
     * This implementation makes no action.
     * Subclasses using quality scores must implement proper behaviour.
     *
     * @param qualityScores quality scores corresponding to each pair of
     *                      matched points.
     * @throws IllegalArgumentException if provided quality scores length
     * is smaller than minimum required samples.
     * @throws LockedException if robust solver is locked because an
     * estimation is already in progress.
     */
    public void setQualityScores(double[] qualityScores) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetQualityScores(qualityScores);
    }

    /**
     * Indicates whether solver is ready to find a solution.
     *
     * @return true if solver is ready, false otherwise.
     */
    @Override
    public boolean isReady() {
        return super.isReady() &amp;&amp; mQualityScores != null &amp;&amp;
                mQualityScores.length == mReadings.size();
    }

    /**
     * Indicates whether inliers must be computed and kept.
     *
     * @return true if inliers must be computed and kept, false if inliers
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepInliersEnabled() {
        return mComputeAndKeepInliers;
    }

    /**
     * Specifies whether inliers must be computed and kept.
     *
     * @param computeAndKeepInliers true if inliers must be computed and kept,
     *                              false if inliers only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepInliersEnabled(boolean computeAndKeepInliers)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mComputeAndKeepInliers = computeAndKeepInliers;
    }

    /**
     * Indicates whether residuals must be computed and kept.
     *
     * @return true if residuals must be computed and kept, false if residuals
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepResidualsEnabled() {
        return mComputeAndKeepResiduals;
    }

    /**
     * Specifies whether residuals must be computed and kept.
     *
     * @param computeAndKeepResiduals true if residuals must be computed and kept,
     *                                false if residuals only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepResidualsEnabled(boolean computeAndKeepResiduals)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mComputeAndKeepResiduals = computeAndKeepResiduals;
    }

    /**
     * Robustly estimates position, transmitted power and pathloss exponent for a
     * radio source.
     *
     * @throws LockedException if instance is busy during estimation.
     * @throws NotReadyException if estimator is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     * (i.e. numerical instability, no solution available, etc).
     */
    @Override
    public void estimate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        PROSACRobustEstimator&lt;Solution&lt;Point2D&gt;&gt; innerEstimator =</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/INSGNSSLooselyCoupledKalmanFilteredEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/INSGNSSLooselyCoupledKalmanFilteredEstimator.html#L1918">1918</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/INSLooselyCoupledKalmanFilteredEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/INSLooselyCoupledKalmanFilteredEstimator.html#L1640">1640</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>            mState = new INSLooselyCoupledKalmanState();
        }
    }

    /**
     * Corrects provided kinematics by taking into account currently estimated
     * specific force and angular rate biases.
     * This method stores the result into the variable member containing corrected
     * kinematics values.
     *
     * @param kinematics kinematics instance to be corrected.
     */
    private void correctKinematics(final BodyKinematics kinematics) {
        if (mCorrectedKinematics == null) {
            mCorrectedKinematics = new BodyKinematics();
        }

        final double accelBiasX;
        final double accelBiasY;
        final double accelBiasZ;
        final double gyroBiasX;
        final double gyroBiasY;
        final double gyroBiasZ;
        if (mState != null) {
            accelBiasX = getValueOrZero(mState.getAccelerationBiasX());
            accelBiasY = getValueOrZero(mState.getAccelerationBiasY());
            accelBiasZ = getValueOrZero(mState.getAccelerationBiasZ());
            gyroBiasX = getValueOrZero(mState.getGyroBiasX());
            gyroBiasY = getValueOrZero(mState.getGyroBiasY());
            gyroBiasZ = getValueOrZero(mState.getGyroBiasZ());
        } else {
            accelBiasX = 0.0;
            accelBiasY = 0.0;
            accelBiasZ = 0.0;
            gyroBiasX = 0.0;
            gyroBiasY = 0.0;
            gyroBiasZ = 0.0;
        }

        final double fx = kinematics.getFx();
        final double fy = kinematics.getFy();
        final double fz = kinematics.getFz();
        final double angularRateX = kinematics.getAngularRateX();
        final double angularRateY = kinematics.getAngularRateY();
        final double angularRateZ = kinematics.getAngularRateZ();

        mCorrectedKinematics.setSpecificForceCoordinates(
                fx - accelBiasX, fy - accelBiasY, fz - accelBiasZ);
        mCorrectedKinematics.setAngularRateCoordinates(
                angularRateX - gyroBiasX,
                angularRateY - gyroBiasY,
                angularRateZ - gyroBiasZ);
    }

    /**
     * Returns provided value if not infinity and not NaN.
     *
     * @param value value to be returned.
     * @return value or 0.0.
     */
    private double getValueOrZero(final double value) {
        if (Double.isNaN(value) || Double.isInfinite(value)) {
            return 0.0;
        } else {
            return value;
        }
    }
}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator2D.html#L324">324</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator3D.html#L324">324</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>            RobustRangingRadioSourceEstimatorListener&lt;S, Point2D&gt; listener) {
        super(readings, initialPosition, listener);
        internalSetQualityScores(qualityScores);
    }

    /**
     * Gets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on distance between estimated position and distances
     * provided for each sample.
     *
     * @return threshold to determine whether samples are inliers or not.
     */
    public double getThreshold() {
        return mThreshold;
    }

    /**
     * Sets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on distance between estimated position and distances
     * provided for each sample.
     *
     * @param threshold threshold to determine whether samples are inliers or not.
     * @throws IllegalArgumentException if provided value is equal or less than zero.
     * @throws LockedException if this solver is locked.
     */
    public void setThreshold(double threshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (threshold &lt;= MIN_THRESHOLD) {
            throw new IllegalArgumentException();
        }
        mThreshold = threshold;
    }

    /**
     * Returns quality scores corresponding to each pair of
     * positions and distances (i.e. sample).
     * The larger the score value the better the quality of the sample.
     * This implementation always returns null.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @return quality scores corresponding to each sample.
     */
    @Override
    public double[] getQualityScores() {
        return mQualityScores;
    }

    /**
     * Sets quality scores corresponding to each pair of positions and
     * distances (i.e. sample).
     * The larger the score value the better the quality of the sample.
     * This implementation makes no action.
     * Subclasses using quality scores must implement proper behaviour.
     *
     * @param qualityScores quality scores corresponding to each pair of
     *                      matched points.
     * @throws IllegalArgumentException if provided quality scores length
     * is smaller than minimum required samples.
     * @throws LockedException if robust solver is locked because an
     * estimation is already in progress.
     */
    public void setQualityScores(double[] qualityScores)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetQualityScores(qualityScores);
    }

    /**
     * Indicates whether solver is ready to find a solution.
     *
     * @return true if solver is ready, false otherwise.
     */
    @Override
    public boolean isReady() {
        return super.isReady() &amp;&amp; mQualityScores != null &amp;&amp;
                mQualityScores.length == mReadings.size();
    }

    /**
     * Indicates whether inliers must be computed and kept.
     *
     * @return true if inliers must be computed and kept, false if inliers
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepInliersEnabled() {
        return mComputeAndKeepInliers;
    }

    /**
     * Specifies whether inliers must be computed and kept.
     *
     * @param computeAndKeepInliers true if inliers must be computed and kept,
     *                              false if inliers only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepInliersEnabled(boolean computeAndKeepInliers)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mComputeAndKeepInliers = computeAndKeepInliers;
    }

    /**
     * Indicates whether residuals must be computed and kept.
     *
     * @return true if residuals must be computed and kept, false if residuals
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepResidualsEnabled() {
        return mComputeAndKeepResiduals;
    }

    /**
     * Specifies whether residuals must be computed and kept.
     *
     * @param computeAndKeepResiduals true if residuals must be computed and kept,
     *                                false if residuals only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepResidualsEnabled(boolean computeAndKeepResiduals)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mComputeAndKeepResiduals = computeAndKeepResiduals;
    }

    /**
     * Robustly estimates position for a radio source.
     *
     * @throws LockedException if instance is busy during estimation.
     * @throws NotReadyException if estimator is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     * (i.e. numerical instability, no solution available, etc).
     */
    @Override
    public void estimate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        PROSACRobustEstimator&lt;Solution&lt;Point2D&gt;&gt; innerEstimator =</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/PROMedSRobustMixedPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROMedSRobustMixedPositionEstimator2D.html#L358">358</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/PROMedSRobustRangingAndRssiPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROMedSRobustRangingAndRssiPositionEstimator2D.html#L358">358</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/PROMedSRobustRangingPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROMedSRobustRangingPositionEstimator2D.html#L357">357</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/PROMedSRobustRssiPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROMedSRobustRssiPositionEstimator2D.html#L356">356</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>            RobustMixedPositionEstimatorListener&lt;Point2D&gt; listener) {
        this(sources, fingerprint, listener);
        internalSetSourceQualityScores(sourceQualityScores);
        internalSetFingerprintReadingsQualityScores(fingerprintReadingsQualityScores);
    }

    /**
     * Returns quality scores corresponding to each radio source.
     * The larger the score value the better the quality of the sample.
     *
     * @return quality scores corresponding to each radio source.
     */
    public double[] getSourceQualityScores() {
        return mSourceQualityScores;
    }

    /**
     * Sets quality scores corresponding to each radio source.
     * The larger the score value the better the quality of the radio source.
     *
     * @param sourceQualityScores quality scores corresponding to each radio source.
     * @throws LockedException          if this instance is locked.
     * @throws IllegalArgumentException if provided quality scores length is smaller
     *                                  than minimum required samples.
     */
    public void setSourceQualityScores(double[] sourceQualityScores)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetSourceQualityScores(sourceQualityScores);
    }

    /**
     * Gets quality scores corresponding to each reading within provided fingerprint.
     * The larger the score value the better the quality of the reading.
     * This implementation always returns null.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @return quality scores corresponding to each reading within provided
     * fingerprint.
     */
    public double[] getFingerprintReadingsQualityScores() {
        return mFingerprintReadingsQualityScores;
    }

    /**
     * Sets quality scores corresponding to each reading within provided fingerprint.
     * The larger the score value the better the quality of the reading.
     * This implementation makes no action.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @param fingerprintReadingsQualityScores quality scores corresponding to each
     *                                         reading within provided fingerprint.
     * @throws LockedException          if this instance is locked.
     * @throws IllegalArgumentException if provided quality scores length is smaller
     *                                  than minimum required samples.
     */
    public void setFingerprintReadingsQualityScores(
            double[] fingerprintReadingsQualityScores) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetFingerprintReadingsQualityScores(fingerprintReadingsQualityScores);
    }

    /**
     * Returns threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value, the
     * algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algrithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @return stop threshold to stop the algorithm prematurely when a certain
     * accuracy has been reached.
     */
    public double getStopThreshold() {
        return ((PROMedSRobustLateration2DSolver) mLaterationSolver).
                getStopThreshold();
    }

    /**
     * Sets threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value,
     * the algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algorithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @param stopThreshold stop threshold to stop the algorithm prematurely
     *                      when a certain accuracy has been reached.
     * @throws IllegalArgumentException if provided value is zero or negative.
     * @throws LockedException if this solver is locked.
     */
    public void setStopThreshold(double stopThreshold) throws LockedException {
        ((PROMedSRobustLateration2DSolver) mLaterationSolver).
                setStopThreshold(stopThreshold);
    }

    /**
     * Returns method being used for robust estimation.
     * @return method being used for robust estimation.
     */
    @Override
    public RobustEstimatorMethod getMethod() {
        return RobustEstimatorMethod.PROMedS;
    }

    /**
     * Initializes robust lateration solver.
     */
    private void init() {
        mLaterationSolver = new PROMedSRobustLateration2DSolver(
                mTrilaterationSolverListener);
    }

    /**
     * Sets quality scores corresponding to each provided located radio source.
     * This method is used internally and does not check whether instance is
     * locked or not.
     * @param sourceQualityScores quality scores to be set.
     * @throws IllegalArgumentException if provided quality scores length
     * is smaller than 3 samples.
     */
    private void internalSetSourceQualityScores(double[] sourceQualityScores) {
        if (sourceQualityScores == null ||
                sourceQualityScores.length &lt; getMinRequiredSources()) {
            throw new IllegalArgumentException();
        }

        mSourceQualityScores = sourceQualityScores;

        buildPositionsDistancesDistanceStandardDeviationsAndQualityScores();
    }

    /**
     * Sets quality scores corresponding to each provided reading within provided
     * fingerprint.
     * This method is used internally and does not check whether instance is locked
     * or not.
     * @param fingerprintReadingsQualityScores quality scores to be set.
     * @throws IllegalArgumentException if provided quality scores lengt is
     * smaller than 3 samples.
     */
    private void internalSetFingerprintReadingsQualityScores(
            double[] fingerprintReadingsQualityScores) {
        if (fingerprintReadingsQualityScores == null ||
                fingerprintReadingsQualityScores.length &lt; getMinRequiredSources()) {
            throw new IllegalArgumentException();
        }

        mFingerprintReadingsQualityScores = fingerprintReadingsQualityScores;

        buildPositionsDistancesDistanceStandardDeviationsAndQualityScores();
    }
}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/PROMedSRobustMixedPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROMedSRobustMixedPositionEstimator3D.html#L358">358</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/PROMedSRobustRangingAndRssiPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROMedSRobustRangingAndRssiPositionEstimator3D.html#L358">358</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/PROMedSRobustRangingPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROMedSRobustRangingPositionEstimator3D.html#L357">357</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>                                                 RobustMixedPositionEstimatorListener&lt;Point3D&gt; listener) {
        this(sources, fingerprint, listener);
        internalSetSourceQualityScores(sourceQualityScores);
        internalSetFingerprintReadingsQualityScores(fingerprintReadingsQualityScores);
    }

    /**
     * Returns quality scores corresponding to each radio source.
     * The larger the score value the better the quality of the sample.
     *
     * @return quality scores corresponding to each radio source.
     */
    public double[] getSourceQualityScores() {
        return mSourceQualityScores;
    }

    /**
     * Sets quality scores corresponding to each radio source.
     * The larger the score value the better the quality of the radio source.
     *
     * @param sourceQualityScores quality scores corresponding to each radio source.
     * @throws LockedException          if this instance is locked.
     * @throws IllegalArgumentException if provided quality scores length is smaller
     *                                  than minimum required samples.
     */
    public void setSourceQualityScores(double[] sourceQualityScores)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetSourceQualityScores(sourceQualityScores);
    }

    /**
     * Gets quality scores corresponding to each reading within provided fingerprint.
     * The larger the score value the better the quality of the reading.
     * This implementation always returns null.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @return quality scores corresponding to each reading within provided
     * fingerprint.
     */
    public double[] getFingerprintReadingsQualityScores() {
        return mFingerprintReadingsQualityScores;
    }

    /**
     * Sets quality scores corresponding to each reading within provided fingerprint.
     * The larger the score value the better the quality of the reading.
     * This implementation makes no action.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @param fingerprintReadingsQualityScores quality scores corresponding to each
     *                                         reading within provided fingerprint.
     * @throws LockedException          if this instance is locked.
     * @throws IllegalArgumentException if provided quality scores length is smaller
     *                                  than minimum required samples.
     */
    public void setFingerprintReadingsQualityScores(
            double[] fingerprintReadingsQualityScores) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetFingerprintReadingsQualityScores(fingerprintReadingsQualityScores);
    }

    /**
     * Returns threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value, the
     * algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algrithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @return stop threshold to stop the algorithm prematurely when a certain
     * accuracy has been reached.
     */
    public double getStopThreshold() {
        return ((PROMedSRobustLateration3DSolver) mLaterationSolver).
                getStopThreshold();
    }

    /**
     * Sets threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value,
     * the algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algorithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @param stopThreshold stop threshold to stop the algorithm prematurely
     *                      when a certain accuracy has been reached.
     * @throws IllegalArgumentException if provided value is zero or negative.
     * @throws LockedException if this solver is locked.
     */
    public void setStopThreshold(double stopThreshold) throws LockedException {
        ((PROMedSRobustLateration3DSolver) mLaterationSolver).
                setStopThreshold(stopThreshold);
    }

    /**
     * Returns method being used for robust estimation.
     * @return method being used for robust estimation.
     */
    @Override
    public RobustEstimatorMethod getMethod() {
        return RobustEstimatorMethod.PROMedS;
    }

    /**
     * Initializes robust lateration solver.
     */
    private void init() {
        mLaterationSolver = new PROMedSRobustLateration3DSolver(
                mTrilaterationSolverListener);
    }

    /**
     * Sets quality scores corresponding to each provided located radio source.
     * This method is used internally and does not check whether instance is
     * locked or not.
     * @param sourceQualityScores quality scores to be set.
     * @throws IllegalArgumentException if provided quality scores length
     * is smaller than 3 samples.
     */
    private void internalSetSourceQualityScores(double[] sourceQualityScores) {
        if (sourceQualityScores == null ||
                sourceQualityScores.length &lt; getMinRequiredSources()) {
            throw new IllegalArgumentException();
        }

        mSourceQualityScores = sourceQualityScores;

        buildPositionsDistancesDistanceStandardDeviationsAndQualityScores();
    }

    /**
     * Sets quality scores corresponding to each provided reading within provided
     * fingerprint.
     * This method is used internally and does not check whether instance is locked
     * or not.
     * @param fingerprintReadingsQualityScores quality scores to be set.
     * @throws IllegalArgumentException if provided quality scores lengt is
     * smaller than 3 samples.
     */
    private void internalSetFingerprintReadingsQualityScores(
            double[] fingerprintReadingsQualityScores) {
        if (fingerprintReadingsQualityScores == null ||
                fingerprintReadingsQualityScores.length &lt; getMinRequiredSources()) {
            throw new IllegalArgumentException();
        }

        mFingerprintReadingsQualityScores = fingerprintReadingsQualityScores;

        buildPositionsDistancesDistanceStandardDeviationsAndQualityScores();
    }
}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/lateration/NonLinearLeastSquaresLateration2DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/NonLinearLeastSquaresLateration2DSolver.html#L351">351</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/lateration/RobustLateration2DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/RobustLateration2DSolver.html#L1346">1346</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    }

    /**
     * Internally sets circles defining positions and euclidean distances.
     * @param circles circles defining positions and distances.
     * @throws IllegalArgumentException if circles is null or length of array of circles
     * is less than 2.
     */
    private void internalSetCircles(Circle[] circles) {
        if (circles == null || circles.length &lt; getMinRequiredPositionsAndDistances()) {
            throw new IllegalArgumentException();
        }

        Point2D[] positions = new Point2D[circles.length];
        double[] distances = new double[circles.length];
        for (int i = 0; i &lt; circles.length; i++) {
            Circle circle = circles[i];
            positions[i] = circle.getCenter();
            distances[i] = circle.getRadius();
        }

        internalSetPositionsAndDistances(positions, distances);
    }

    /**
     * Internally sets circles defining positions and euclidean distances along with the standard
     * deviations of provided circles radii.
     * @param circles circles defining positions and distances.
     * @param radiusStandardDeviations standard deviations of circles radii.
     * @throws IllegalArgumentException if circles is null, length of arrays is less than
     * 2 or don't have the same length.
     */
    private void internalSetCirclesAndStandardDeviations(Circle[] circles,
            double[] radiusStandardDeviations) {
        if (circles == null || circles.length &lt; getMinRequiredPositionsAndDistances()) {
            throw new IllegalArgumentException();
        }

        if (radiusStandardDeviations == null) {
            throw new IllegalArgumentException();
        }

        if (radiusStandardDeviations.length != circles.length) {
            throw new IllegalArgumentException();
        }

        Point2D[] positions = new Point2D[circles.length];
        double[] distances = new double[circles.length];
        for (int i = 0; i &lt; circles.length; i++) {
            Circle circle = circles[i];
            positions[i] = circle.getCenter();
            distances[i] = circle.getRadius();
        }

        internalSetPositionsDistancesAndStandardDeviations(positions, distances,
                radiusStandardDeviations);
    }</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RobustRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRadioSourceEstimator.html#L217">217</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/lateration/RobustLaterationSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/RobustLaterationSolver.html#L412">412</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    }

    /**
     * Indicates whether estimator is locked during estimation.
     *
     * @return true if estimator is locked, false otherwise.
     */
    public boolean isLocked() {
        return mLocked;
    }

    /**
     * Returns amount of progress variation before notifying a progress change during
     * estimation.
     *
     * @return amount of progress variation before notifying a progress change during
     * estimation.
     */
    public float getProgressDelta() {
        return mProgressDelta;
    }

    /**
     * Sets amount of progress variation before notifying a progress change during
     * estimation.
     *
     * @param progressDelta amount of progress variation before notifying a progress
     *                      change during estimation.
     * @throws IllegalArgumentException if progress delta is less than zero or greater than 1.
     * @throws LockedException if this estimator is locked.
     */
    public void setProgressDelta(float progressDelta) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (progressDelta &lt; MIN_PROGRESS_DELTA ||
                progressDelta &gt; MAX_PROGRESS_DELTA) {
            throw new IllegalArgumentException();
        }
        mProgressDelta = progressDelta;
    }

    /**
     * Returns amount of confidence expressed as a value between 0.0 and 1.0
     * (which is equivalent to 100%). The amount of confidence indicates the probability
     * that the estimated result is correct. Usually this value will be close to 1.0, but
     * not exactly 1.0.
     *
     * @return amount of confidence as a value between 0.0 and 1.0.
     */
    public double getConfidence() {
        return mConfidence;
    }

    /**
     * Sets amount of confidence expressed as a value between 0.0 and 1.0 (which is
     * equivalent to 100%). The amount of confidence indicates the probability that
     * the estimated result is correct. Usually this value will be close to 1.0, but
     * not exactly 1.0.
     *
     * @param confidence confidence to be set as a value between 0.0 and 1.0.
     * @throws IllegalArgumentException if provided value is not between 0.0 and 1.0.
     * @throws LockedException if estimator is locked.
     */
    public void setConfidence(double confidence) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (confidence &lt; MIN_CONFIDENCE || confidence &gt; MAX_CONFIDENCE) {
            throw new IllegalArgumentException();
        }
        mConfidence = confidence;
    }

    /**
     * Returns maximum allowed number of iterations. If maximum allowed number of
     * iterations is achieved without converging to a result when calling estimate(),
     * a RobustEstimatorException will be raised.
     *
     * @return maximum allowed number of iterations.
     */
    public int getMaxIterations() {
        return mMaxIterations;
    }

    /**
     * Sets maximum allowed number of iterations. When the maximum number of iterations
     * is exceeded, result will not be available, however an approximate result will be
     * available for retrieval.
     *
     * @param maxIterations maximum allowed number of iterations to be set.
     * @throws IllegalArgumentException if provided value is less than 1.
     * @throws LockedException if this estimator is locked.
     */
    public void setMaxIterations(int maxIterations) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (maxIterations &lt; MIN_ITERATIONS) {
            throw new IllegalArgumentException();
        }
        mMaxIterations = maxIterations;
    }

    /**
     * Gets data related to inliers found after estimation.
     *
     * @return data related to inliers found after estimation.
     */
    public InliersData getInliersData() {
        return mInliersData;
    }

    /**
     * Indicates whether result must be refined using a non-linear solver over found inliers.
     *
     * @return true to refine result, false to simply use result found by robust estimator
     * without further refining.
     */
    public boolean isResultRefined() {
        return mRefineResult;
    }

    /**
     * Specifies whether result must be refined using a non-linear solver over found inliers.
     *
     * @param refineResult true to refine result, false to simply use result found by robust
     *                     estimator without further refining.
     * @throws LockedException if estimator is locked.
     */
    public void setResultRefined(boolean refineResult) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mRefineResult = refineResult;
    }

    /**
     * Indicates whether covariance must be kept after refining result.
     * This setting is only taken into account if result is refined.
     *
     * @return true if covariance must be kept after refining result, false otherwise.
     */
    public boolean isCovarianceKept() {
        return mKeepCovariance;
    }

    /**
     * Specifies whether covariance must be kept after refining result.
     * This setting is only taken into account if result is refined.
     *
     * @param keepCovariance true if covariance must be kept after refining result,
     *                       false otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setCovarianceKept(boolean keepCovariance) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mKeepCovariance = keepCovariance;
    }

    /**
     * Gets signal readings belonging to the same radio source.
     *
     * @return signal readings belonging to the same radio source.
     */
    public List&lt;? extends R&gt; getReadings() {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator.html#L442">442</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator.html#L439">439</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>            RobustRangingAndRssiRadioSourceEstimatorListener&lt;S, P&gt; listener) {
        this(readings, initialPosition, initialTransmittedPowerdBm,
                listener);
        mInitialPathLossExponent = initialPathLossExponent;
    }

    /**
     * Gets initial transmitted power to start the estimation of radio source
     * transmitted power (expressed in dBm's).
     * If not defined, average value of received power readings will be used.
     * @return initial transmitted power to start the estimation of radio source
     * transmitted power.
     */
    public Double getInitialTransmittedPowerdBm() {
        return mInitialTransmittedPowerdBm;
    }

    /**
     * Sets initial transmitted power to start the estimation of radio source
     * transmitted power (expressed in dBm's).
     * If not defined, average value of received power readings will be used.
     * @param initialTransmittedPowerdBm initial transmitted power to start the
     *                                   estimation of radio source transmitted
     *                                   power.
     * @throws LockedException if estimator is locked.
     */
    public void setInitialTransmittedPowerdBm(Double initialTransmittedPowerdBm)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mInitialTransmittedPowerdBm = initialTransmittedPowerdBm;
    }

    /**
     * Gets initial transmitted power to start the estimation of radio source
     * transmitted power (expressed in mW).
     * If not defined, average value of received power readings will be used.
     * @return initial transmitted power to start the estimation of radio source
     * transmitted power.
     */
    public Double getInitialTransmittedPower() {
        return mInitialTransmittedPowerdBm != null ?
                Utils.dBmToPower(mInitialTransmittedPowerdBm) : null;
    }

    /**
     * Sets initial transmitted power to start the estimation of radio source
     * transmitted power (expressed in mW).
     * If not defined, average value of received power readings will be used.
     * @param initialTransmittedPower initial transmitted power to start the
     *                                estimation of radio source transmitted power.
     * @throws LockedException if estimator is locked.
     * @throws IllegalArgumentException if provided value is negative.
     */
    public void setInitialTransmittedPower(Double initialTransmittedPower)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (initialTransmittedPower != null) {
            if (initialTransmittedPower &lt; 0.0) {
                throw new IllegalArgumentException();
            }
            mInitialTransmittedPowerdBm = Utils.powerTodBm(
                    initialTransmittedPower);
        } else {
            mInitialTransmittedPowerdBm = null;
        }
    }

    /**
     * Gets initial position to start the estimation of radio source position.
     * If not defined, centroid of provided fingerprints will be used.
     * @return initial position to start the estimation of radio source position.
     */
    public P getInitialPosition() {
        return mInitialPosition;
    }

    /**
     * Sets initial position to start the estimation of radio source position.
     * If not defined, centroid of provided fingerprints will be used.
     * @param initialPosition initial position to start the estimation of radio
     *                        source position.
     * @throws LockedException if estimator is locked.
     */
    public void setInitialPosition(P initialPosition) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mInitialPosition = initialPosition;
    }

    /**
     * Gets initial exponent typically used on free space for path loss propagation
     * in terms of distance.
     * On different environments path loss exponent might have different value:
     * - Free space: 2.0
     * - Urban Area: 2.7 to 3.5
     * - Suburban Area: 3 to 5
     * - Indoor (line-of-sight): 1.6 to 1.8
     *
     * If path loss exponent estimation is enabled, estimation will start at this
     * value and will converge to the most appropriate value.
     * If path loss exponent estimation is disabled, this value will be assumed
     * to be exact and the estimated path loss exponent will be equal to this
     * value.
     * @return initial path loss exponent.
     */
    public double getInitialPathLossExponent() {
        return mInitialPathLossExponent;
    }

    /**
     * Sets initial exponent typically used on free space for path loss propagation
     * in terms of distance.
     * On different environments path loss exponent might have different value:
     * - Free space: 2.0
     * - Urban Area: 2.7 to 3.5
     * - Suburban Area: 3 to 5
     * - Indoor (line-of-sight): 1.6 to 1.8
     *
     * If path loss exponent estimation is enabled, estimation will start at this
     * value and will converge to the most appropriate value.
     * If path loss exponent estimation is disabled, this value will be assumed
     * to be exact and the estimated path loss exponent will be equal to this
     * value.
     * @param initialPathLossExponent initial path loss exponent.
     * @throws LockedException if estimator is locked.
     */
    public void setInitialPathLossExponent(double initialPathLossExponent)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mInitialPathLossExponent = initialPathLossExponent;
    }

    /**
     * Indicates whether transmitted power estimation is enabled or not.
     * @return true if transmitted power estimation is enabled, false otherwise.
     */
    public boolean isTransmittedPowerEstimationEnabled() {
        return mTransmittedPowerEstimationEnabled;
    }

    /**
     * Specifies whether transmitted power estimation is enabled or not.
     * @param transmittedPowerEstimationEnabled true if transmitted power estimation is enabled,
     *                                          false otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setTransmittedPowerEstimationEnabled(boolean transmittedPowerEstimationEnabled)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mTransmittedPowerEstimationEnabled = transmittedPowerEstimationEnabled;
    }

    /**
     * Indicates whether path loss estimation is enabled or not.
     * @return true if path loss estimation is enabled, false otherwise.
     */
    public boolean isPathLossEstimationEnabled() {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator2D.html#L835">835</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator3D.html#L325">325</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator2D.html#L840">840</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                initialPathLossExponent, listener);
        internalSetQualityScores(qualityScores);
    }

    /**
     * Gets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on distance between estimated position and distances
     * provided for each sample.
     *
     * @return threshold to determine whether samples are inliers or not.
     */
    public double getThreshold() {
        return mThreshold;
    }

    /**
     * Sets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on distance between estimated position and distances
     * provided for each sample.
     *
     * @param threshold threshold to determine whether samples are inliers or not.
     * @throws IllegalArgumentException if provided value is equal or less than zero.
     * @throws LockedException if this solver is locked.
     */
    public void setThreshold(double threshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (threshold &lt;= MIN_THRESHOLD) {
            throw new IllegalArgumentException();
        }
        mThreshold = threshold;
    }

    /**
     * Returns quality scores corresponding to each pair of
     * positions and distances (i.e. sample).
     * The larger the score value the better the quality of the sample.
     * This implementation always returns null.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @return quality scores corresponding to each sample.
     */
    @Override
    public double[] getQualityScores() {
        return mQualityScores;
    }

    /**
     * Sets quality scores corresponding to each pair of positions and
     * distances (i.e. sample).
     * The larger the score value the better the quality of the sample.
     * This implementation makes no action.
     * Subclasses using quality scores must implement proper behaviour.
     *
     * @param qualityScores quality scores corresponding to each pair of
     *                      matched points.
     * @throws IllegalArgumentException if provided quality scores length
     * is smaller than minimum required samples.
     * @throws LockedException if robust solver is locked because an
     * estimation is already in progress.
     */
    public void setQualityScores(double[] qualityScores) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetQualityScores(qualityScores);
    }

    /**
     * Indicates whether solver is ready to find a solution.
     *
     * @return true if solver is ready, false otherwise.
     */
    @Override
    public boolean isReady() {
        return super.isReady() &amp;&amp; mQualityScores != null &amp;&amp;
                mQualityScores.length == mReadings.size();
    }

    /**
     * Indicates whether inliers must be computed and kept.
     *
     * @return true if inliers must be computed and kept, false if inliers
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepInliersEnabled() {
        return mComputeAndKeepInliers;
    }

    /**
     * Specifies whether inliers must be computed and kept.
     *
     * @param computeAndKeepInliers true if inliers must be computed and kept,
     *                              false if inliers only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepInliersEnabled(boolean computeAndKeepInliers)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mComputeAndKeepInliers = computeAndKeepInliers;
    }

    /**
     * Indicates whether residuals must be computed and kept.
     *
     * @return true if residuals must be computed and kept, false if residuals
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepResidualsEnabled() {
        return mComputeAndKeepResiduals;
    }

    /**
     * Specifies whether residuals must be computed and kept.
     *
     * @param computeAndKeepResiduals true if residuals must be computed and kept,
     *                                false if residuals only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepResidualsEnabled(boolean computeAndKeepResiduals)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mComputeAndKeepResiduals = computeAndKeepResiduals;
    }

    /**
     * Robustly estimates position, transmitted power and pathloss exponent for a
     * radio source.
     *
     * @throws LockedException if instance is busy during estimation.
     * @throws NotReadyException if estimator is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     * (i.e. numerical instability, no solution available, etc).
     */
    @Override
    public void estimate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        PROSACRobustEstimator&lt;Solution&lt;Point2D&gt;&gt; innerEstimator =</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator3D.html#L834">834</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator2D.html#L325">325</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator3D.html#L839">839</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>                initialPathLossExponent, listener);
        internalSetQualityScores(qualityScores);
    }

    /**
     * Gets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on distance between estimated position and distances
     * provided for each sample.
     *
     * @return threshold to determine whether samples are inliers or not.
     */
    public double getThreshold() {
        return mThreshold;
    }

    /**
     * Sets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on distance between estimated position and distances
     * provided for each sample.
     *
     * @param threshold threshold to determine whether samples are inliers or not.
     * @throws IllegalArgumentException if provided value is equal or less than zero.
     * @throws LockedException if this solver is locked.
     */
    public void setThreshold(double threshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (threshold &lt;= MIN_THRESHOLD) {
            throw new IllegalArgumentException();
        }
        mThreshold = threshold;
    }

    /**
     * Returns quality scores corresponding to each pair of
     * positions and distances (i.e. sample).
     * The larger the score value the better the quality of the sample.
     * This implementation always returns null.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @return quality scores corresponding to each sample.
     */
    @Override
    public double[] getQualityScores() {
        return mQualityScores;
    }

    /**
     * Sets quality scores corresponding to each pair of positions and
     * distances (i.e. sample).
     * The larger the score value the better the quality of the sample.
     * This implementation makes no action.
     * Subclasses using quality scores must implement proper behaviour.
     *
     * @param qualityScores quality scores corresponding to each pair of
     *                      matched points.
     * @throws IllegalArgumentException if provided quality scores length
     * is smaller than minimum required samples.
     * @throws LockedException if robust solver is locked because an
     * estimation is already in progress.
     */
    public void setQualityScores(double[] qualityScores)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetQualityScores(qualityScores);
    }

    /**
     * Indicates whether solver is ready to find a solution.
     *
     * @return true if solver is ready, false otherwise.
     */
    @Override
    public boolean isReady() {
        return super.isReady() &amp;&amp; mQualityScores != null &amp;&amp;
                mQualityScores.length == mReadings.size();
    }

    /**
     * Indicates whether inliers must be computed and kept.
     *
     * @return true if inliers must be computed and kept, false if inliers
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepInliersEnabled() {
        return mComputeAndKeepInliers;
    }

    /**
     * Specifies whether inliers must be computed and kept.
     *
     * @param computeAndKeepInliers true if inliers must be computed and kept,
     *                              false if inliers only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepInliersEnabled(boolean computeAndKeepInliers)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mComputeAndKeepInliers = computeAndKeepInliers;
    }

    /**
     * Indicates whether residuals must be computed and kept.
     *
     * @return true if residuals must be computed and kept, false if residuals
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepResidualsEnabled() {
        return mComputeAndKeepResiduals;
    }

    /**
     * Specifies whether residuals must be computed and kept.
     *
     * @param computeAndKeepResiduals true if residuals must be computed and kept,
     *                                false if residuals only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepResidualsEnabled(boolean computeAndKeepResiduals)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mComputeAndKeepResiduals = computeAndKeepResiduals;
    }

    /**
     * Robustly estimates position, transmitted power and pathloss exponent for a
     * radio source.
     *
     * @throws LockedException if instance is busy during estimation.
     * @throws NotReadyException if estimator is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     * (i.e. numerical instability, no solution available, etc).
     */
    @Override
    public void estimate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        PROSACRobustEstimator&lt;Solution&lt;Point3D&gt;&gt; innerEstimator =</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/lateration/NonLinearLeastSquaresLateration3DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/NonLinearLeastSquaresLateration3DSolver.html#L359">359</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/lateration/RobustLateration3DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/RobustLateration3DSolver.html#L1353">1353</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    public void internalSetSpheres(Sphere[] spheres) {
        if (spheres == null || spheres.length &lt; getMinRequiredPositionsAndDistances()) {
            throw new IllegalArgumentException();
        }

        Point3D[] positions = new Point3D[spheres.length];
        double[] distances = new double[spheres.length];
        for (int i = 0; i &lt; spheres.length; i++) {
            Sphere sphere = spheres[i];
            positions[i] = sphere.getCenter();
            distances[i] = sphere.getRadius();
        }

        internalSetPositionsAndDistances(positions, distances);
    }

    /**
     * Internally sets spheres defining positions and euclidean distances along with the standard
     * deviations of provided spheres radii.
     * @param spheres spheres defining positions and distances.
     * @param radiusStandardDeviations standard deviations of circles radii.
     * @throws IllegalArgumentException if spheres is null, length of arrays is less than
     * 2 or don't have the same length.
     */
    private void internalSetSpheresAndStandardDeviations(Sphere[] spheres,
            double[] radiusStandardDeviations) {
        if (spheres == null || spheres.length &lt; getMinRequiredPositionsAndDistances()) {
            throw new IllegalArgumentException();
        }

        if (radiusStandardDeviations == null) {
            throw new IllegalArgumentException();
        }

        if (radiusStandardDeviations.length != spheres.length) {
            throw new IllegalArgumentException();
        }

        Point3D[] positions = new Point3D[spheres.length];
        double[] distances = new double[spheres.length];
        for (int i = 0; i &lt; spheres.length; i++) {
            Sphere sphere = spheres[i];
            positions[i] = sphere.getCenter();
            distances[i] = sphere.getRadius();
        }

        internalSetPositionsDistancesAndStandardDeviations(positions, distances,
                radiusStandardDeviations);

    }</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator2D.html#L2785">2785</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator2D.html#L850">850</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>        List&lt;? extends RssiReadingLocated&lt;S, Point2D&gt;&gt; readings = getReadings();
        if (readings == null || readings.isEmpty()) {
            return null;
        }
        S source = readings.get(0).getSource();

        Point2D estimatedPosition = getEstimatedPosition();
        if (estimatedPosition == null) {
            return null;
        }

        Matrix estimatedPositionCovariance = getEstimatedPositionCovariance();

        Double transmittedPowerVariance =
                getEstimatedTransmittedPowerVariance();
        Double transmittedPowerStandardDeviation = transmittedPowerVariance != null ?
                Math.sqrt(transmittedPowerVariance) : null;

        Double pathlossExponentVariance =
                getEstimatedPathLossExponentVariance();
        Double pathlossExponentStandardDeviation = pathlossExponentVariance != null ?
                Math.sqrt(pathlossExponentVariance) : null;

        if (source instanceof WifiAccessPoint) {
            WifiAccessPoint accessPoint = (WifiAccessPoint) source;
            return new WifiAccessPointWithPowerAndLocated2D(accessPoint.getBssid(),
                    source.getFrequency(), accessPoint.getSsid(),
                    getEstimatedTransmittedPowerdBm(),
                    transmittedPowerStandardDeviation,
                    getEstimatedPathLossExponent(),
                    pathlossExponentStandardDeviation,
                    estimatedPosition,
                    estimatedPositionCovariance);
        } else if(source instanceof Beacon) {
            Beacon beacon = (Beacon) source;
            return new BeaconWithPowerAndLocated2D(beacon.getIdentifiers(),
                    getEstimatedTransmittedPowerdBm(), beacon.getFrequency(),
                    beacon.getBluetoothAddress(), beacon.getBeaconTypeCode(),
                    beacon.getManufacturer(), beacon.getServiceUuid(),
                    beacon.getBluetoothName(),
                    getEstimatedPathLossExponent(),
                    transmittedPowerStandardDeviation,
                    pathlossExponentStandardDeviation,
                    estimatedPosition, estimatedPositionCovariance);
        }else {
            return null;
        }
    }

    /**
     * Solves preliminar solution for a subset of samples.
     *
     * @param samplesIndices indices of subset samples.
     * @param solutions instance where solution will be stored.
     */
    @Override
    protected void solvePreliminarSolutions(int[] samplesIndices,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/calibration/KnownBiasAndFrameAccelerometerLinearLeastSquaresCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/KnownBiasAndFrameAccelerometerLinearLeastSquaresCalibrator.html#L1084">1084</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/calibration/KnownBiasAndFrameAccelerometerNonLinearLeastSquaresCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/KnownBiasAndFrameAccelerometerNonLinearLeastSquaresCalibrator.html#L2723">2723</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>        } catch (final AlgebraException e) {
            throw new CalibrationException(e);
        } finally {
            mRunning = false;
        }
    }

    /**
     * Gets estimated accelerometer scale factors and ross coupling errors.
     * This is the product of matrix Ta containing cross coupling errors and Ka
     * containing scaling factors.
     * So tat:
     * &lt;pre&gt;
     *     Ma = [sx    mxy  mxz] = Ta*Ka
     *          [myx   sy   myz]
     *          [mzx   mzy  sz ]
     * &lt;/pre&gt;
     * Where:
     * &lt;pre&gt;
     *     Ka = [sx 0   0 ]
     *          [0  sy  0 ]
     *          [0  0   sz]
     * &lt;/pre&gt;
     * and
     * &lt;pre&gt;
     *     Ta = [1          -alphaXy    alphaXz ]
     *          [alphaYx    1           -alphaYz]
     *          [-alphaZx   alphaZy     1       ]
     * &lt;/pre&gt;
     * Hence:
     * &lt;pre&gt;
     *     Ma = [sx    mxy  mxz] = Ta*Ka =  [sx             -sy * alphaXy   sz * alphaXz ]
     *          [myx   sy   myz]            [sx * alphaYx   sy              -sz * alphaYz]
     *          [mzx   mzy  sz ]            [-sx * alphaZx  sy * alphaZy    sz           ]
     * &lt;/pre&gt;
     * This instance allows any 3x3 matrix however, typically alphaYx, alphaZx and alphaZy
     * are considered to be zero if the accelerometer z-axis is assumed to be the same
     * as the body z-axis. When this is assumed, myx = mzx = mzy = 0 and the Ma matrix
     * becomes upper diagonal:
     * &lt;pre&gt;
     *     Ma = [sx    mxy  mxz]
     *          [0     sy   myz]
     *          [0     0    sz ]
     * &lt;/pre&gt;
     * Values of this matrix are unitless.
     *
     * @return estimated accelerometer scale factors and cross coupling errors, or null
     * if not available.
     */
    @Override
    public Matrix getEstimatedMa() {
        return mEstimatedMa;
    }

    /**
     * Gets estimated x-axis scale factor.
     *
     * @return estimated x-axis scale factor or null if not available.
     */
    @Override
    public Double getEstimatedSx() {
        return mEstimatedMa != null ?
                mEstimatedMa.getElementAt(0, 0) : null;
    }

    /**
     * Gets estimated y-axis scale factor.
     *
     * @return estimated y-axis scale factor or null if not available.
     */
    @Override
    public Double getEstimatedSy() {
        return mEstimatedMa != null ?
                mEstimatedMa.getElementAt(1, 1) : null;
    }

    /**
     * Gets estimated z-axis scale factor.
     *
     * @return estimated z-axis scale factor or null if not available.
     */
    @Override
    public Double getEstimatedSz() {
        return mEstimatedMa != null ?
                mEstimatedMa.getElementAt(2, 2) : null;
    }

    /**
     * Gets estimated x-y cross-coupling error.
     *
     * @return estimated x-y cross-coupling error or null if not available.
     */
    @Override
    public Double getEstimatedMxy() {
        return mEstimatedMa != null ?
                mEstimatedMa.getElementAt(0, 1) : null;
    }

    /**
     * Gets estimated x-z cross-coupling error.
     *
     * @return estimated x-z cross-coupling error or null if not available.
     */
    @Override
    public Double getEstimatedMxz() {
        return mEstimatedMa != null ?
                mEstimatedMa.getElementAt(0, 2) : null;
    }

    /**
     * Gets estimated y-x cross-coupling error.
     *
     * @return estimated y-x cross-coupling error or null if not available.
     */
    @Override
    public Double getEstimatedMyx() {
        return mEstimatedMa != null ?
                mEstimatedMa.getElementAt(1, 0) : null;
    }

    /**
     * Gets estimated y-z cross-coupling error.
     *
     * @return estimated y-z cross-coupling error or null if not available.
     */
    @Override
    public Double getEstimatedMyz() {
        return mEstimatedMa != null ?
                mEstimatedMa.getElementAt(1, 2) : null;
    }

    /**
     * Gets estimated z-x cross-coupling error.
     *
     * @return estimated z-x cross-coupling error or null if not available.
     */
    @Override
    public Double getEstimatedMzx() {
        return mEstimatedMa != null ?
                mEstimatedMa.getElementAt(2, 0) : null;
    }

    /**
     * Gets estimated z-y cross-coupling error.
     *
     * @return estimated z-y cross-coupling error or null if not available.
     */
    @Override
    public Double getEstimatedMzy() {
        return mEstimatedMa != null ?
                mEstimatedMa.getElementAt(2, 1) : null;
    }</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRangingAndRssiRadioSourceEstimator2D.html#L372">372</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRssiRadioSourceEstimator2D.html#L383">383</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>            RobustRangingAndRssiRadioSourceEstimatorListener&lt;S, Point2D&gt; listener) {
        super(readings, initialPosition, initialTransmittedPowerdBm,
                initialPathLossExponent, listener);
    }

    /**
     * Returns threshold to determine whether samples are inliers or not.
     *
     * @return threshold to determine whether samples are inliers or not.
     */
    public double getThreshold() {
        return mThreshold;
    }

    /**
     * Sets threshold to determine whether samples are inliers or not.
     *
     * @param threshold threshold to be set.
     * @throws IllegalArgumentException if provided value is equal or less than
     * zero.
     * @throws LockedException if robust estimator is locked because an
     * estimation is already in progress.
     */
    public void setThreshold(double threshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (threshold &lt;= MIN_THRESHOLD) {
            throw new IllegalArgumentException();
        }
        mThreshold = threshold;
    }

    /**
     * Robustly estimates position, transmitted power and pathloss exponent for a
     * radio source.
     *
     * @throws LockedException if instance is busy during estimation.
     * @throws NotReadyException if estimator is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     * (i.e. numerical instability, no solution available, etc).
     */
    @Override
    public void estimate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        MSACRobustEstimator&lt;Solution&lt;Point2D&gt;&gt; innerEstimator =
                new MSACRobustEstimator&lt;&gt;(
                        new MSACRobustEstimatorListener&lt;Solution&lt;Point2D&gt;&gt;() {
                    @Override
                    public double getThreshold() {
                        return mThreshold;
                    }

                    @Override
                    public int getTotalSamples() {
                        return mReadings.size();
                    }

                    @Override
                    public int getSubsetSize() {
                        return Math.max(mPreliminarySubsetSize, getMinReadings());
                    }

                    @Override
                    public void estimatePreliminarSolutions(int[] samplesIndices,
                            List&lt;Solution&lt;Point2D&gt;&gt; solutions) {
                        solvePreliminarSolutions(samplesIndices, solutions);
                    }

                    @Override
                    public double computeResidual(Solution&lt;Point2D&gt; currentEstimation, int i) {
                        return residual(currentEstimation, i);
                    }

                    @Override
                    public boolean isReady() {
                        return MSACRobustRangingAndRssiRadioSourceEstimator2D.this.isReady();</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRangingAndRssiRadioSourceEstimator3D.html#L372">372</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRssiRadioSourceEstimator3D.html#L383">383</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>            RobustRangingAndRssiRadioSourceEstimatorListener&lt;S, Point3D&gt; listener) {
        super(readings, initialPosition, initialTransmittedPowerdBm,
                initialPathLossExponent, listener);
    }

    /**
     * Returns threshold to determine whether samples are inliers or not.
     *
     * @return threshold to determine whether samples are inliers or not.
     */
    public double getThreshold() {
        return mThreshold;
    }

    /**
     * Sets threshold to determine whether samples are inliers or not.
     *
     * @param threshold threshold to be set.
     * @throws IllegalArgumentException if provided value is equal or less than
     * zero.
     * @throws LockedException if robust estimator is locked because an
     * estimation is already in progress.
     */
    public void setThreshold(double threshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (threshold &lt;= MIN_THRESHOLD) {
            throw new IllegalArgumentException();
        }
        mThreshold = threshold;
    }

    /**
     * Robustly estimates position, transmitted power and pathloss exponent for a
     * radio source.
     *
     * @throws LockedException if instance is busy during estimation.
     * @throws NotReadyException if estimator is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     * (i.e. numerical instability, no solution available, etc).
     */
    @Override
    public void estimate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        MSACRobustEstimator&lt;Solution&lt;Point3D&gt;&gt; innerEstimator =
                new MSACRobustEstimator&lt;&gt;(
                        new MSACRobustEstimatorListener&lt;Solution&lt;Point3D&gt;&gt;() {
                            @Override
                            public double getThreshold() {
                                return mThreshold;
                            }

                            @Override
                            public int getTotalSamples() {
                                return mReadings.size();
                            }

                            @Override
                            public int getSubsetSize() {
                                return Math.max(mPreliminarySubsetSize, getMinReadings());
                            }

                            @Override
                            public void estimatePreliminarSolutions(int[] samplesIndices,
                                                                    List&lt;Solution&lt;Point3D&gt;&gt; solutions) {
                                solvePreliminarSolutions(samplesIndices, solutions);
                            }

                            @Override
                            public double computeResidual(Solution&lt;Point3D&gt; currentEstimation, int i) {
                                return residual(currentEstimation, i);
                            }

                            @Override
                            public boolean isReady() {
                                return MSACRobustRangingAndRssiRadioSourceEstimator3D.this.isReady();</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/frames/NEDFrame.java</td>
<td><a href="./xref/com/irurueta/navigation/frames/NEDFrame.html#L883">883</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/NEDVelocity.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/NEDVelocity.html#L186">186</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>        return new Speed(getVelocityNorm(), SpeedUnit.METERS_PER_SECOND);
    }

    /**
     * Gets coordinate of velocity of body frame with respect ECEF frame and
     * resolved along North axis.
     *
     * @param result instance where North velocity coordinate will be stored.
     */
    public void getSpeedN(final Speed result) {
        result.setValue(mVn);
        result.setUnit(SpeedUnit.METERS_PER_SECOND);
    }

    /**
     * Gets coordinate of velocity of body frame with respect ECEF frame and
     * resolved along North axis.
     *
     * @return North velocity coordinate.
     */
    public Speed getSpeedN() {
        return new Speed(mVn, SpeedUnit.METERS_PER_SECOND);
    }

    /**
     * Sets coordinate of velocity of body frame with respect ECEF frame and
     * resolved along North axis.
     *
     * @param speedN North velocity coordinate to be set.
     */
    public void setSpeedN(final Speed speedN) {
        mVn = SpeedConverter.convert(speedN.getValue().doubleValue(),
                speedN.getUnit(), SpeedUnit.METERS_PER_SECOND);
    }

    /**
     * Gets coordinate of velocity of body frame with respect ECEF frame and
     * resolved along East axis.
     *
     * @param result instance where East velocity coordinate will be stored.
     */
    public void getSpeedE(final Speed result) {
        result.setValue(mVe);
        result.setUnit(SpeedUnit.METERS_PER_SECOND);
    }

    /**
     * Gets coordinate of velocity of body frame with respect ECEF frame and
     * resolved along East axis.
     *
     * @return East velocity coordinate.
     */
    public Speed getSpeedE() {
        return new Speed(mVe, SpeedUnit.METERS_PER_SECOND);
    }

    /**
     * Sets coordinate of velocity of body frame with respect ECEF frame and
     * resolved along East axis.
     *
     * @param speedE East velocity coordinate to be set.
     */
    public void setSpeedE(final Speed speedE) {
        mVe = SpeedConverter.convert(speedE.getValue().doubleValue(),
                speedE.getUnit(), SpeedUnit.METERS_PER_SECOND);
    }

    /**
     * Gets coordinate of velocity of body frame with respect ECEF frame and
     * resolved along Down axis.
     *
     * @param result instance where Down velocity coordinate will be stored.
     */
    public void getSpeedD(final Speed result) {
        result.setValue(mVd);
        result.setUnit(SpeedUnit.METERS_PER_SECOND);
    }

    /**
     * Gets coordinate of velocity of body frame with respect ECEF frame and
     * resolved along Down axis.
     *
     * @return Down velocity coordinate.
     */
    public Speed getSpeedD() {
        return new Speed(mVd, SpeedUnit.METERS_PER_SECOND);
    }

    /**
     * Sets coordinate of velocity of body frame with respect ECEF frame and
     * resolved along Down axis.
     *
     * @param speedD Down velocity coordinate to be set.
     */
    public void setSpeedD(final Speed speedD) {
        mVd = SpeedConverter.convert(speedD.getValue().doubleValue(),
                speedD.getUnit(), SpeedUnit.METERS_PER_SECOND);
    }

    /**
     * Sets velocity coordinates of body frame resolved along North, East, Down
     * axes.
     *
     * @param speedN North velocity coordinate.
     * @param speedE East velocity coordinate.
     * @param speedD Down velocity coordinate.
     */
    public void setSpeedCoordinates(final Speed speedN, final Speed speedE,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator2D.html#L2807">2807</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RssiRadioSourceEstimator2D.html#L411">411</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator2D.html#L850">850</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>        List&lt;? extends RangingAndRssiReadingLocated&lt;S, Point2D&gt;&gt; readings = getReadings();
        if (readings == null || readings.isEmpty()) {
            return null;
        }
        S source = readings.get(0).getSource();

        Point2D estimatedPosition = getEstimatedPosition();
        if (estimatedPosition == null) {
            return null;
        }

        Matrix estimatedPositionCovariance = getEstimatedPositionCovariance();

        Double transmittedPowerVariance =
                getEstimatedTransmittedPowerVariance();
        Double transmittedPowerStandardDeviation = transmittedPowerVariance != null ?
                Math.sqrt(transmittedPowerVariance) : null;

        Double pathlossExponentVariance =
                getEstimatedPathLossExponentVariance();
        Double pathlossExponentStandardDeviation = pathlossExponentVariance != null ?
                Math.sqrt(pathlossExponentVariance) : null;

        if (source instanceof WifiAccessPoint) {
            WifiAccessPoint accessPoint = (WifiAccessPoint) source;
            return new WifiAccessPointWithPowerAndLocated2D(accessPoint.getBssid(),
                    source.getFrequency(), accessPoint.getSsid(),
                    getEstimatedTransmittedPowerdBm(),
                    transmittedPowerStandardDeviation,
                    getEstimatedPathLossExponent(),
                    pathlossExponentStandardDeviation,
                    estimatedPosition,
                    estimatedPositionCovariance);
        } else if(source instanceof Beacon) {
            Beacon beacon = (Beacon) source;
            return new BeaconWithPowerAndLocated2D(beacon.getIdentifiers(),
                    getEstimatedTransmittedPowerdBm(), beacon.getFrequency(),
                    beacon.getBluetoothAddress(), beacon.getBeaconTypeCode(),
                    beacon.getManufacturer(), beacon.getServiceUuid(),
                    beacon.getBluetoothName(),
                    getEstimatedPathLossExponent(),
                    transmittedPowerStandardDeviation,
                    pathlossExponentStandardDeviation,
                    estimatedPosition, estimatedPositionCovariance);
        }else {
            return null;
        }
    }</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator3D.html#L2809">2809</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator3D.html#L2786">2786</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator3D.html#L849">849</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>        List&lt;? extends RangingAndRssiReadingLocated&lt;S, Point3D&gt;&gt; readings = getReadings();
        if (readings == null || readings.isEmpty()) {
            return null;
        }
        S source = readings.get(0).getSource();

        Point3D estimatedPosition = getEstimatedPosition();
        if (estimatedPosition == null) {
            return null;
        }

        Matrix estimatedPositionCovariance = getEstimatedPositionCovariance();

        Double transmittedPowerVariance =
                getEstimatedTransmittedPowerVariance();
        Double transmittedPowerStandardDeviation = transmittedPowerVariance != null ?
                Math.sqrt(transmittedPowerVariance) : null;

        Double pathlossExponentVariance =
                getEstimatedPathLossExponentVariance();
        Double pathlossExponentStandardDeviation = pathlossExponentVariance != null ?
                Math.sqrt(pathlossExponentVariance) : null;

        if (source instanceof WifiAccessPoint) {
            WifiAccessPoint accessPoint = (WifiAccessPoint) source;
            return new WifiAccessPointWithPowerAndLocated3D(accessPoint.getBssid(),
                    source.getFrequency(), accessPoint.getSsid(),
                    getEstimatedTransmittedPowerdBm(),
                    transmittedPowerStandardDeviation,
                    getEstimatedPathLossExponent(),
                    pathlossExponentStandardDeviation,
                    estimatedPosition,
                    estimatedPositionCovariance);
        } else if(source instanceof Beacon) {
            Beacon beacon = (Beacon) source;
            return new BeaconWithPowerAndLocated3D(beacon.getIdentifiers(),
                    getEstimatedTransmittedPowerdBm(), beacon.getFrequency(),
                    beacon.getBluetoothAddress(), beacon.getBeaconTypeCode(),
                    beacon.getManufacturer(), beacon.getServiceUuid(),
                    beacon.getBluetoothName(),
                    getEstimatedPathLossExponent(),
                    transmittedPowerStandardDeviation,
                    pathlossExponentStandardDeviation,
                    estimatedPosition, estimatedPositionCovariance);
        }else {
            return null;
        }
    }</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/calibration/PROSACRobustKnownBiasAndFrameAccelerometerCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/PROSACRobustKnownBiasAndFrameAccelerometerCalibrator.html#L1573">1573</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/calibration/PROSACRobustKnownFrameAccelerometerCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/PROSACRobustKnownFrameAccelerometerCalibrator.html#L347">347</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>        this(measurements, bias, commonAxisUsed, listener);
        internalSetQualityScores(qualityScores);
    }

    /**
     * Gets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on norm between measured specific forces and the
     * ones generated with estimated calibration parameters provided for each sample.
     *
     * @return threshold to determine whether samples are inliers or not.
     */
    public double getThreshold() {
        return mThreshold;
    }

    /**
     * Sets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on norm between measured specific forces and the
     * ones generated with estimated calibration parameters provided for each sample.
     *
     * @param threshold threshold to determine whether samples are inliers or not.
     * @throws IllegalArgumentException if provided value is equal or less than zero.
     * @throws LockedException          if calibrator is currently running.
     */
    public void setThreshold(double threshold) throws LockedException {
        if (mRunning) {
            throw new LockedException();
        }
        if (threshold &lt;= MIN_THRESHOLD) {
            throw new IllegalArgumentException();
        }
        mThreshold = threshold;
    }

    /**
     * Returns quality scores corresponding to each provided sample.
     * The larger the score value the better the quality of the sample.
     *
     * @return quality scores corresponding to each sample.
     */
    @Override
    public double[] getQualityScores() {
        return mQualityScores;
    }

    /**
     * Sets quality scores corresponding to each provided sample.
     * The larger the score value the better the quality of the sample.
     *
     * @param qualityScores quality scores corresponding to each sample.
     * @throws IllegalArgumentException if provided quality scores length
     *                                  is smaller than minimum required samples.
     * @throws LockedException          if calibrator is currently running.
     */
    @Override
    public void setQualityScores(double[] qualityScores)
            throws LockedException {
        if (mRunning) {
            throw new LockedException();
        }
        internalSetQualityScores(qualityScores);
    }

    /**
     * Indicates whether solver is ready to find a solution.
     *
     * @return true if solver is ready, false otherwise.
     */
    @Override
    public boolean isReady() {
        return super.isReady() &amp;&amp; mQualityScores != null &amp;&amp;
                mQualityScores.length == mMeasurements.size();
    }

    /**
     * Indicates whether inliers must be computed and kept.
     *
     * @return true if inliers must be computed and kept, false if inliers
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepInliersEnabled() {
        return mComputeAndKeepInliers;
    }

    /**
     * Specifies whether inliers must be computed and kept.
     *
     * @param computeAndKeepInliers true if inliers must be computed and kept,
     *                              false if inliers only need to be computed but not kept.
     * @throws LockedException if calibrator is currently running.
     */
    public void setComputeAndKeepInliersEnabled(boolean computeAndKeepInliers)
            throws LockedException {
        if (mRunning) {
            throw new LockedException();
        }
        mComputeAndKeepInliers = computeAndKeepInliers;
    }

    /**
     * Indicates whether residuals must be computed and kept.
     *
     * @return true if residuals must be computed and kept, false if residuals
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepResiduals() {
        return mComputeAndKeepResiduals;
    }

    /**
     * Specifies whether residuals must be computed and kept.
     *
     * @param computeAndKeepResiduals true if residuals must be computed and kept,
     *                                false if residuals only need to be computed but not kept.
     * @throws LockedException if calibrator is currently running.
     */
    public void setComputeAndKeepResidualsEnabled(boolean computeAndKeepResiduals)
            throws LockedException {
        if (mRunning) {
            throw new LockedException();
        }
        mComputeAndKeepResiduals = computeAndKeepResiduals;
    }

    /**
     * Estimates accelerometer calibration parameters containing scale factors
     * and cross-coupling errors.
     *
     * @throws LockedException      if calibrator is currently running.
     * @throws NotReadyException    if calibrator is not ready.
     * @throws CalibrationException if estimation fails for numerical reasons.
     */
    @Override
    public void calibrate() throws LockedException, NotReadyException, CalibrationException {
        if (mRunning) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        final PROSACRobustEstimator&lt;Matrix&gt; innerEstimator =</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/frames/ECIorECEFFrame.java</td>
<td><a href="./xref/com/irurueta/navigation/frames/ECIorECEFFrame.html#L431">431</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/gnss/GNSSEstimation.java</td>
<td><a href="./xref/com/irurueta/navigation/gnss/GNSSEstimation.html#L534">534</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>        return new Speed(getVelocityNorm(), SpeedUnit.METERS_PER_SECOND);
    }

    /**
     * Gets x coordinate of velocity of body frame resolved along ECEF-frame axes.
     *
     * @param result instance where x coordinate of velocity will be stored.
     */
    public void getSpeedX(final Speed result) {
        result.setValue(mVx);
        result.setUnit(SpeedUnit.METERS_PER_SECOND);
    }

    /**
     * Gets x coordinate of velocity of body frame resolved along ECI or ECEF-frame axes.
     *
     * @return x coordinate of velocity of body frame resolved along ECI or ECEF-frame axes.
     */
    public Speed getSpeedX() {
        return new Speed(mVx, SpeedUnit.METERS_PER_SECOND);
    }

    /**
     * Sets x coordinate of velocity of body frame resolved along ECI or ECEF-frame axes.
     *
     * @param speedX x coordinate of velocity of body frame resolved along ECI or ECEF-frame
     *               axes to be set.
     */
    public void setSpeedX(final Speed speedX) {
        mVx = SpeedConverter.convert(speedX.getValue().doubleValue(),
                speedX.getUnit(), SpeedUnit.METERS_PER_SECOND);
    }

    /**
     * Gets y coordinate of velocity of body frame resolved along ECI or ECEF-frame axes.
     *
     * @param result instance where y coordinate of velocity will be stored.
     */
    public void getSpeedY(final Speed result) {
        result.setValue(mVy);
        result.setUnit(SpeedUnit.METERS_PER_SECOND);
    }

    /**
     * Gets y coordinate of velocity of body frame resolved along ECI or ECEF-frame axes.
     *
     * @return y coordinate of velocity of body frame resolved along ECI or ECEF-frame axes.
     */
    public Speed getSpeedY() {
        return new Speed(mVy, SpeedUnit.METERS_PER_SECOND);
    }

    /**
     * Sets y coordinate of velocity of body frame resolved along ECI or ECEF-frame axes.
     *
     * @param speedY y coordinate of velocity of body frame resolved along ECI or ECEF-frame
     *               axes to be set.
     */
    public void setSpeedY(final Speed speedY) {
        mVy = SpeedConverter.convert(speedY.getValue().doubleValue(),
                speedY.getUnit(), SpeedUnit.METERS_PER_SECOND);
    }

    /**
     * Gets z coordinate of velocity of body frame resolved along ECI or ECEF-frame axes.
     *
     * @param result instance where z coordinate of velocity will be stored.
     */
    public void getSpeedZ(final Speed result) {
        result.setValue(mVz);
        result.setUnit(SpeedUnit.METERS_PER_SECOND);
    }

    /**
     * Gets z coordinate of velocity of body frame resolved along ECI or ECEF-frame axes.
     *
     * @return z coordinate of velocity of body frame resolved along ECI or ECEF-frame axes.
     */
    public Speed getSpeedZ() {
        return new Speed(mVz, SpeedUnit.METERS_PER_SECOND);
    }

    /**
     * Sets z coordinate of velocity of body frame resolved along ECI or ECEF-frame axes.
     *
     * @param speedZ z coordinate of velocity of body frame resolved along ECI or ECEF-frame
     *               axes to be set.
     */
    public void setSpeedZ(final Speed speedZ) {
        mVz = SpeedConverter.convert(speedZ.getValue().doubleValue(),
                speedZ.getUnit(), SpeedUnit.METERS_PER_SECOND);
    }

    /**
     * Sets velocity coordinates of body frame resolved along ECI or ECEF-frame axes.
     *
     * @param speedX x coordinate of velocity to be set.
     * @param speedY y coordinate of velocity to be set.
     * @param speedZ z coordinate of velocity to be set.
     */
    public void setSpeedCoordinates(final Speed speedX,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/gnss/ECEFPositionAndVelocity.java</td>
<td><a href="./xref/com/irurueta/navigation/gnss/ECEFPositionAndVelocity.html#L661">661</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/INSLooselyCoupledKalmanState.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/INSLooselyCoupledKalmanState.html#L1341">1341</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/INSTightlyCoupledKalmanState.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/INSTightlyCoupledKalmanState.html#L1514">1514</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    }

    /**
     * Gets x coordinate of velocity resolved in ECEF axes.
     *
     * @param result instance where x coordinate of velocity will be stored.
     */
    public void getSpeedX(final Speed result) {
        result.setValue(mVx);
        result.setUnit(SpeedUnit.METERS_PER_SECOND);
    }

    /**
     * Gets x coordinate of velocity resolved in ECEF axes.
     *
     * @return x coordinate of velocity.
     */
    public Speed getSpeedX() {
        return new Speed(mVx, SpeedUnit.METERS_PER_SECOND);
    }

    /**
     * Sets x coordinate of velocity resolved in ECEF axes.
     *
     * @param vx x coordinate of velocity.
     */
    public void setSpeedX(final Speed vx) {
        mVx = SpeedConverter.convert(vx.getValue().doubleValue(),
                vx.getUnit(), SpeedUnit.METERS_PER_SECOND);
    }

    /**
     * Gets y coordinate of velocity resolved in ECEF axes.
     *
     * @param result instance where y coordinate of velocity will be stored.
     */
    public void getSpeedY(final Speed result) {
        result.setValue(mVy);
        result.setUnit(SpeedUnit.METERS_PER_SECOND);
    }

    /**
     * Gets y coordinate of velocity resolved in ECEF axes.
     *
     * @return y coordinate of velocity.
     */
    public Speed getSpeedY() {
        return new Speed(mVy, SpeedUnit.METERS_PER_SECOND);
    }

    /**
     * Sets y coordinate of velocity resolved in ECEF axes.
     *
     * @param vy y coordinate of velocity.
     */
    public void setSpeedY(final Speed vy) {
        mVy = SpeedConverter.convert(vy.getValue().doubleValue(),
                vy.getUnit(), SpeedUnit.METERS_PER_SECOND);
    }

    /**
     * Gets z coordinate of velocity resolved in ECEF axes.
     *
     * @param result instance where z coordinate of velocity will be stored.
     */
    public void getSpeedZ(final Speed result) {
        result.setValue(mVz);
        result.setUnit(SpeedUnit.METERS_PER_SECOND);
    }

    /**
     * Gets z coordinate of velocity resolved in ECEF axes.
     *
     * @return z coordinate of velocity.
     */
    public Speed getSpeedZ() {
        return new Speed(mVz, SpeedUnit.METERS_PER_SECOND);
    }

    /**
     * Sets z coordinate of velocity resolved in ECEF axes.
     *
     * @param vz z coordinate of velocity.
     */
    public void setSpeedZ(final Speed vz) {
        mVz = SpeedConverter.convert(vz.getValue().doubleValue(),
                vz.getUnit(), SpeedUnit.METERS_PER_SECOND);
    }

    /**
     * Sets coordinates of velocity resolved in ECEF axes.
     *
     * @param vx x coordinate of velocity.
     * @param vy y coordinate of velocity.
     * @param vz z coordinate of velocity.
     */
    public void setSpeedCoordinates(final Speed vx, final Speed vy, final Speed vz) {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/calibration/KnownBiasAndFrameAccelerometerLinearLeastSquaresCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/KnownBiasAndFrameAccelerometerLinearLeastSquaresCalibrator.html#L1087">1087</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/calibration/KnownFrameAccelerometerNonLinearLeastSquaresCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/KnownFrameAccelerometerNonLinearLeastSquaresCalibrator.html#L3172">3172</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>            mRunning = false;
        }
    }

    /**
     * Gets estimated accelerometer scale factors and ross coupling errors.
     * This is the product of matrix Ta containing cross coupling errors and Ka
     * containing scaling factors.
     * So tat:
     * &lt;pre&gt;
     *     Ma = [sx    mxy  mxz] = Ta*Ka
     *          [myx   sy   myz]
     *          [mzx   mzy  sz ]
     * &lt;/pre&gt;
     * Where:
     * &lt;pre&gt;
     *     Ka = [sx 0   0 ]
     *          [0  sy  0 ]
     *          [0  0   sz]
     * &lt;/pre&gt;
     * and
     * &lt;pre&gt;
     *     Ta = [1          -alphaXy    alphaXz ]
     *          [alphaYx    1           -alphaYz]
     *          [-alphaZx   alphaZy     1       ]
     * &lt;/pre&gt;
     * Hence:
     * &lt;pre&gt;
     *     Ma = [sx    mxy  mxz] = Ta*Ka =  [sx             -sy * alphaXy   sz * alphaXz ]
     *          [myx   sy   myz]            [sx * alphaYx   sy              -sz * alphaYz]
     *          [mzx   mzy  sz ]            [-sx * alphaZx  sy * alphaZy    sz           ]
     * &lt;/pre&gt;
     * This instance allows any 3x3 matrix however, typically alphaYx, alphaZx and alphaZy
     * are considered to be zero if the accelerometer z-axis is assumed to be the same
     * as the body z-axis. When this is assumed, myx = mzx = mzy = 0 and the Ma matrix
     * becomes upper diagonal:
     * &lt;pre&gt;
     *     Ma = [sx    mxy  mxz]
     *          [0     sy   myz]
     *          [0     0    sz ]
     * &lt;/pre&gt;
     * Values of this matrix are unitless.
     *
     * @return estimated accelerometer scale factors and cross coupling errors, or null
     * if not available.
     */
    @Override
    public Matrix getEstimatedMa() {
        return mEstimatedMa;
    }

    /**
     * Gets estimated x-axis scale factor.
     *
     * @return estimated x-axis scale factor or null if not available.
     */
    @Override
    public Double getEstimatedSx() {
        return mEstimatedMa != null ?
                mEstimatedMa.getElementAt(0, 0) : null;
    }

    /**
     * Gets estimated y-axis scale factor.
     *
     * @return estimated y-axis scale factor or null if not available.
     */
    @Override
    public Double getEstimatedSy() {
        return mEstimatedMa != null ?
                mEstimatedMa.getElementAt(1, 1) : null;
    }

    /**
     * Gets estimated z-axis scale factor.
     *
     * @return estimated z-axis scale factor or null if not available.
     */
    @Override
    public Double getEstimatedSz() {
        return mEstimatedMa != null ?
                mEstimatedMa.getElementAt(2, 2) : null;
    }

    /**
     * Gets estimated x-y cross-coupling error.
     *
     * @return estimated x-y cross-coupling error or null if not available.
     */
    @Override
    public Double getEstimatedMxy() {
        return mEstimatedMa != null ?
                mEstimatedMa.getElementAt(0, 1) : null;
    }

    /**
     * Gets estimated x-z cross-coupling error.
     *
     * @return estimated x-z cross-coupling error or null if not available.
     */
    @Override
    public Double getEstimatedMxz() {
        return mEstimatedMa != null ?
                mEstimatedMa.getElementAt(0, 2) : null;
    }

    /**
     * Gets estimated y-x cross-coupling error.
     *
     * @return estimated y-x cross-coupling error or null if not available.
     */
    @Override
    public Double getEstimatedMyx() {
        return mEstimatedMa != null ?
                mEstimatedMa.getElementAt(1, 0) : null;
    }

    /**
     * Gets estimated y-z cross-coupling error.
     *
     * @return estimated y-z cross-coupling error or null if not available.
     */
    @Override
    public Double getEstimatedMyz() {
        return mEstimatedMa != null ?
                mEstimatedMa.getElementAt(1, 2) : null;
    }

    /**
     * Gets estimated z-x cross-coupling error.
     *
     * @return estimated z-x cross-coupling error or null if not available.
     */
    @Override
    public Double getEstimatedMzx() {
        return mEstimatedMa != null ?
                mEstimatedMa.getElementAt(2, 0) : null;
    }

    /**
     * Gets estimated z-y cross-coupling error.
     *
     * @return estimated z-y cross-coupling error or null if not available.
     */
    @Override
    public Double getEstimatedMzy() {
        return mEstimatedMa != null ?
                mEstimatedMa.getElementAt(2, 1) : null;
    }</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/calibration/KnownBiasAndFrameAccelerometerNonLinearLeastSquaresCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/KnownBiasAndFrameAccelerometerNonLinearLeastSquaresCalibrator.html#L2726">2726</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/calibration/KnownFrameAccelerometerLinearLeastSquaresCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/KnownFrameAccelerometerLinearLeastSquaresCalibrator.html#L610">610</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>            mRunning = false;
        }
    }

    /**
     * Gets estimated accelerometer scale factors and ross coupling errors.
     * This is the product of matrix Ta containing cross coupling errors and Ka
     * containing scaling factors.
     * So tat:
     * &lt;pre&gt;
     *     Ma = [sx    mxy  mxz] = Ta*Ka
     *          [myx   sy   myz]
     *          [mzx   mzy  sz ]
     * &lt;/pre&gt;
     * Where:
     * &lt;pre&gt;
     *     Ka = [sx 0   0 ]
     *          [0  sy  0 ]
     *          [0  0   sz]
     * &lt;/pre&gt;
     * and
     * &lt;pre&gt;
     *     Ta = [1          -alphaXy    alphaXz ]
     *          [alphaYx    1           -alphaYz]
     *          [-alphaZx   alphaZy     1       ]
     * &lt;/pre&gt;
     * Hence:
     * &lt;pre&gt;
     *     Ma = [sx    mxy  mxz] = Ta*Ka =  [sx             -sy * alphaXy   sz * alphaXz ]
     *          [myx   sy   myz]            [sx * alphaYx   sy              -sz * alphaYz]
     *          [mzx   mzy  sz ]            [-sx * alphaZx  sy * alphaZy    sz           ]
     * &lt;/pre&gt;
     * This instance allows any 3x3 matrix however, typically alphaYx, alphaZx and alphaZy
     * are considered to be zero if the accelerometer z-axis is assumed to be the same
     * as the body z-axis. When this is assumed, myx = mzx = mzy = 0 and the Ma matrix
     * becomes upper diagonal:
     * &lt;pre&gt;
     *     Ma = [sx    mxy  mxz]
     *          [0     sy   myz]
     *          [0     0    sz ]
     * &lt;/pre&gt;
     * Values of this matrix are unitless.
     *
     * @return estimated accelerometer scale factors and cross coupling errors, or null
     * if not available.
     */
    @Override
    public Matrix getEstimatedMa() {
        return mEstimatedMa;
    }

    /**
     * Gets estimated x-axis scale factor.
     *
     * @return estimated x-axis scale factor or null if not available.
     */
    @Override
    public Double getEstimatedSx() {
        return mEstimatedMa != null ?
                mEstimatedMa.getElementAt(0, 0) : null;
    }

    /**
     * Gets estimated y-axis scale factor.
     *
     * @return estimated y-axis scale factor or null if not available.
     */
    @Override
    public Double getEstimatedSy() {
        return mEstimatedMa != null ?
                mEstimatedMa.getElementAt(1, 1) : null;
    }

    /**
     * Gets estimated z-axis scale factor.
     *
     * @return estimated z-axis scale factor or null if not available.
     */
    @Override
    public Double getEstimatedSz() {
        return mEstimatedMa != null ?
                mEstimatedMa.getElementAt(2, 2) : null;
    }

    /**
     * Gets estimated x-y cross-coupling error.
     *
     * @return estimated x-y cross-coupling error or null if not available.
     */
    @Override
    public Double getEstimatedMxy() {
        return mEstimatedMa != null ?
                mEstimatedMa.getElementAt(0, 1) : null;
    }

    /**
     * Gets estimated x-z cross-coupling error.
     *
     * @return estimated x-z cross-coupling error or null if not available.
     */
    @Override
    public Double getEstimatedMxz() {
        return mEstimatedMa != null ?
                mEstimatedMa.getElementAt(0, 2) : null;
    }

    /**
     * Gets estimated y-x cross-coupling error.
     *
     * @return estimated y-x cross-coupling error or null if not available.
     */
    @Override
    public Double getEstimatedMyx() {
        return mEstimatedMa != null ?
                mEstimatedMa.getElementAt(1, 0) : null;
    }

    /**
     * Gets estimated y-z cross-coupling error.
     *
     * @return estimated y-z cross-coupling error or null if not available.
     */
    @Override
    public Double getEstimatedMyz() {
        return mEstimatedMa != null ?
                mEstimatedMa.getElementAt(1, 2) : null;
    }

    /**
     * Gets estimated z-x cross-coupling error.
     *
     * @return estimated z-x cross-coupling error or null if not available.
     */
    @Override
    public Double getEstimatedMzx() {
        return mEstimatedMa != null ?
                mEstimatedMa.getElementAt(2, 0) : null;
    }

    /**
     * Gets estimated z-y cross-coupling error.
     *
     * @return estimated z-y cross-coupling error or null if not available.
     */
    @Override
    public Double getEstimatedMzy() {
        return mEstimatedMa != null ?
                mEstimatedMa.getElementAt(2, 1) : null;
    }</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/PROMedSRobustMixedPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROMedSRobustMixedPositionEstimator3D.html#L361">361</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/PROMedSRobustRangingAndRssiPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROMedSRobustRangingAndRssiPositionEstimator3D.html#L361">361</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/PROMedSRobustRangingPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROMedSRobustRangingPositionEstimator3D.html#L360">360</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/PROMedSRobustRssiPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROMedSRobustRssiPositionEstimator3D.html#L364">364</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>        internalSetFingerprintReadingsQualityScores(fingerprintReadingsQualityScores);
    }

    /**
     * Returns quality scores corresponding to each radio source.
     * The larger the score value the better the quality of the sample.
     *
     * @return quality scores corresponding to each radio source.
     */
    public double[] getSourceQualityScores() {
        return mSourceQualityScores;
    }

    /**
     * Sets quality scores corresponding to each radio source.
     * The larger the score value the better the quality of the radio source.
     *
     * @param sourceQualityScores quality scores corresponding to each radio source.
     * @throws LockedException          if this instance is locked.
     * @throws IllegalArgumentException if provided quality scores length is smaller
     *                                  than minimum required samples.
     */
    public void setSourceQualityScores(double[] sourceQualityScores)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetSourceQualityScores(sourceQualityScores);
    }

    /**
     * Gets quality scores corresponding to each reading within provided fingerprint.
     * The larger the score value the better the quality of the reading.
     * This implementation always returns null.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @return quality scores corresponding to each reading within provided
     * fingerprint.
     */
    public double[] getFingerprintReadingsQualityScores() {
        return mFingerprintReadingsQualityScores;
    }

    /**
     * Sets quality scores corresponding to each reading within provided fingerprint.
     * The larger the score value the better the quality of the reading.
     * This implementation makes no action.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @param fingerprintReadingsQualityScores quality scores corresponding to each
     *                                         reading within provided fingerprint.
     * @throws LockedException          if this instance is locked.
     * @throws IllegalArgumentException if provided quality scores length is smaller
     *                                  than minimum required samples.
     */
    public void setFingerprintReadingsQualityScores(
            double[] fingerprintReadingsQualityScores) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetFingerprintReadingsQualityScores(fingerprintReadingsQualityScores);
    }

    /**
     * Returns threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value, the
     * algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algrithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @return stop threshold to stop the algorithm prematurely when a certain
     * accuracy has been reached.
     */
    public double getStopThreshold() {
        return ((PROMedSRobustLateration3DSolver) mLaterationSolver).
                getStopThreshold();
    }

    /**
     * Sets threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value,
     * the algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algorithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @param stopThreshold stop threshold to stop the algorithm prematurely
     *                      when a certain accuracy has been reached.
     * @throws IllegalArgumentException if provided value is zero or negative.
     * @throws LockedException if this solver is locked.
     */
    public void setStopThreshold(double stopThreshold) throws LockedException {
        ((PROMedSRobustLateration3DSolver) mLaterationSolver).
                setStopThreshold(stopThreshold);
    }

    /**
     * Returns method being used for robust estimation.
     * @return method being used for robust estimation.
     */
    @Override
    public RobustEstimatorMethod getMethod() {
        return RobustEstimatorMethod.PROMedS;
    }

    /**
     * Initializes robust lateration solver.
     */
    private void init() {
        mLaterationSolver = new PROMedSRobustLateration3DSolver(
                mTrilaterationSolverListener);
    }

    /**
     * Sets quality scores corresponding to each provided located radio source.
     * This method is used internally and does not check whether instance is
     * locked or not.
     * @param sourceQualityScores quality scores to be set.
     * @throws IllegalArgumentException if provided quality scores length
     * is smaller than 3 samples.
     */
    private void internalSetSourceQualityScores(double[] sourceQualityScores) {
        if (sourceQualityScores == null ||
                sourceQualityScores.length &lt; getMinRequiredSources()) {
            throw new IllegalArgumentException();
        }

        mSourceQualityScores = sourceQualityScores;

        buildPositionsDistancesDistanceStandardDeviationsAndQualityScores();
    }

    /**
     * Sets quality scores corresponding to each provided reading within provided
     * fingerprint.
     * This method is used internally and does not check whether instance is locked
     * or not.
     * @param fingerprintReadingsQualityScores quality scores to be set.
     * @throws IllegalArgumentException if provided quality scores lengt is
     * smaller than 3 samples.
     */
    private void internalSetFingerprintReadingsQualityScores(
            double[] fingerprintReadingsQualityScores) {
        if (fingerprintReadingsQualityScores == null ||
                fingerprintReadingsQualityScores.length &lt; getMinRequiredSources()) {
            throw new IllegalArgumentException();
        }

        mFingerprintReadingsQualityScores = fingerprintReadingsQualityScores;

        buildPositionsDistancesDistanceStandardDeviationsAndQualityScores();
    }
}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator.html#L443">443</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustMixedRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustMixedRadioSourceEstimator.html#L1597">1597</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator.html#L1580">1580</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    }

    /**
     * Gets initial transmitted power to start the estimation of radio source
     * transmitted power (expressed in dBm's).
     * If not defined, average value of received power readings will be used.
     * @return initial transmitted power to start the estimation of radio source
     * transmitted power.
     */
    public Double getInitialTransmittedPowerdBm() {
        return mInitialTransmittedPowerdBm;
    }

    /**
     * Sets initial transmitted power to start the estimation of radio source
     * transmitted power (expressed in dBm's).
     * If not defined, average value of received power readings will be used.
     * @param initialTransmittedPowerdBm initial transmitted power to start the
     *                                   estimation of radio source transmitted
     *                                   power.
     * @throws LockedException if estimator is locked.
     */
    public void setInitialTransmittedPowerdBm(Double initialTransmittedPowerdBm)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mInitialTransmittedPowerdBm = initialTransmittedPowerdBm;
    }

    /**
     * Gets initial transmitted power to start the estimation of radio source
     * transmitted power (expressed in mW).
     * If not defined, average value of received power readings will be used.
     * @return initial transmitted power to start the estimation of radio source
     * transmitted power.
     */
    public Double getInitialTransmittedPower() {
        return mInitialTransmittedPowerdBm != null ?
                Utils.dBmToPower(mInitialTransmittedPowerdBm) : null;
    }

    /**
     * Sets initial transmitted power to start the estimation of radio source
     * transmitted power (expressed in mW).
     * If not defined, average value of received power readings will be used.
     * @param initialTransmittedPower initial transmitted power to start the
     *                                estimation of radio source transmitted power.
     * @throws LockedException if estimator is locked.
     * @throws IllegalArgumentException if provided value is negative.
     */
    public void setInitialTransmittedPower(Double initialTransmittedPower)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (initialTransmittedPower != null) {
            if (initialTransmittedPower &lt; 0.0) {
                throw new IllegalArgumentException();
            }
            mInitialTransmittedPowerdBm = Utils.powerTodBm(
                    initialTransmittedPower);
        } else {
            mInitialTransmittedPowerdBm = null;
        }
    }

    /**
     * Gets initial position to start the estimation of radio source position.
     * If not defined, centroid of provided fingerprints will be used.
     * @return initial position to start the estimation of radio source position.
     */
    public P getInitialPosition() {
        return mInitialPosition;
    }

    /**
     * Sets initial position to start the estimation of radio source position.
     * If not defined, centroid of provided fingerprints will be used.
     * @param initialPosition initial position to start the estimation of radio
     *                        source position.
     * @throws LockedException if estimator is locked.
     */
    public void setInitialPosition(P initialPosition) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mInitialPosition = initialPosition;
    }

    /**
     * Gets initial exponent typically used on free space for path loss propagation
     * in terms of distance.
     * On different environments path loss exponent might have different value:
     * - Free space: 2.0
     * - Urban Area: 2.7 to 3.5
     * - Suburban Area: 3 to 5
     * - Indoor (line-of-sight): 1.6 to 1.8
     *
     * If path loss exponent estimation is enabled, estimation will start at this
     * value and will converge to the most appropriate value.
     * If path loss exponent estimation is disabled, this value will be assumed
     * to be exact and the estimated path loss exponent will be equal to this
     * value.
     * @return initial path loss exponent.
     */
    public double getInitialPathLossExponent() {
        return mInitialPathLossExponent;
    }

    /**
     * Sets initial exponent typically used on free space for path loss propagation
     * in terms of distance.
     * On different environments path loss exponent might have different value:
     * - Free space: 2.0
     * - Urban Area: 2.7 to 3.5
     * - Suburban Area: 3 to 5
     * - Indoor (line-of-sight): 1.6 to 1.8
     *
     * If path loss exponent estimation is enabled, estimation will start at this
     * value and will converge to the most appropriate value.
     * If path loss exponent estimation is disabled, this value will be assumed
     * to be exact and the estimated path loss exponent will be equal to this
     * value.
     * @param initialPathLossExponent initial path loss exponent.
     * @throws LockedException if estimator is locked.
     */
    public void setInitialPathLossExponent(double initialPathLossExponent)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mInitialPathLossExponent = initialPathLossExponent;
    }

    /**
     * Indicates whether transmitted power estimation is enabled or not.
     * @return true if transmitted power estimation is enabled, false otherwise.
     */
    public boolean isTransmittedPowerEstimationEnabled() {
        return mTransmittedPowerEstimationEnabled;
    }

    /**
     * Specifies whether transmitted power estimation is enabled or not.
     * @param transmittedPowerEstimationEnabled true if transmitted power estimation is enabled,
     *                                          false otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setTransmittedPowerEstimationEnabled(boolean transmittedPowerEstimationEnabled)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mTransmittedPowerEstimationEnabled = transmittedPowerEstimationEnabled;
    }

    /**
     * Indicates whether radio source position estimation is enabled or not.
     * @return true if position estimation is enabled, false otherwise.
     */
    public boolean isPositionEstimationEnabled() {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/estimators/ECEFKinematicsEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/estimators/ECEFKinematicsEstimator.html#L2171">2171</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/estimators/ECEFKinematicsEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/estimators/ECEFKinematicsEstimator.html#L2216">2216</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/estimators/ECIKinematicsEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/estimators/ECIKinematicsEstimator.html#L1197">1197</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/estimators/ECIKinematicsEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/estimators/ECIKinematicsEstimator.html#L1242">1242</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    public static void estimateKinematics(final double timeInterval,
                                          final CoordinateTransformation c,
                                          final CoordinateTransformation oldC,
                                          final Speed vx, final Speed vy, final Speed vz,
                                          final Speed oldVx, final Speed oldVy, final Speed oldVz,
                                          final double x, final double y, final double z,
                                          final BodyKinematics result) {
        estimateKinematics(timeInterval, c, oldC,
                SpeedConverter.convert(vx.getValue().doubleValue(), vx.getUnit(), SpeedUnit.METERS_PER_SECOND),
                SpeedConverter.convert(vy.getValue().doubleValue(), vy.getUnit(), SpeedUnit.METERS_PER_SECOND),
                SpeedConverter.convert(vz.getValue().doubleValue(), vz.getUnit(), SpeedUnit.METERS_PER_SECOND),
                SpeedConverter.convert(oldVx.getValue().doubleValue(), oldVx.getUnit(), SpeedUnit.METERS_PER_SECOND),
                SpeedConverter.convert(oldVy.getValue().doubleValue(), oldVy.getUnit(), SpeedUnit.METERS_PER_SECOND),
                SpeedConverter.convert(oldVz.getValue().doubleValue(), oldVz.getUnit(), SpeedUnit.METERS_PER_SECOND),
                x, y, z, result);
    }

    /**
     * Estimates body kinematics (specific force applied to a body and its angular rates).
     *
     * @param timeInterval time interval between epochs.
     * @param c            body-to-ECEF frame coordinate transformation matrix.
     * @param oldC         previous body-to-ECEF-frame coordinate transformation matrix.
     * @param vx           velocity of body frame x coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param vy           velocity of body frame y coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param vz           velocity of body frame z coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param oldVx        previous velocity of body frame x coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldVy        previous velocity of body frame y coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldVz        previous velocity of body frame z coordinate with respect ECEF
     *                     frame, resolved along EVEF-frame axes.
     * @param x            cartesian x coordinate of body position expressed in meters (m)
     *                     with respect ECEF frame, resolved along ECEF-frame axes.
     * @param y            cartesian y coordinate of body position expressed in meters (m)
     *                     with respect ECEF frame, resolved along ECEF-frame axes.
     * @param z            cartesian z coordinate of body position expressed in meters (m)
     *                     with respect ECEF frame, resolved along ECEF-frame axes.
     * @param result       instance where body kinematics estimation will be stored.
     * @throws IllegalArgumentException if provided time interval is negative or coordinated transformation matrices
     *                                  are not ECEF frame valid.
     */
    public static void estimateKinematics(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/estimators/ECEFKinematicsEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/estimators/ECEFKinematicsEstimator.html#L2955">2955</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/estimators/ECIKinematicsEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/estimators/ECIKinematicsEstimator.html#L1617">1617</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>                                                                final ECEFFrame frame, final ECEFFrame oldFrame) {
        final BodyKinematics result = new BodyKinematics();
        estimateKinematics(timeInterval, frame, oldFrame, result);
        return result;
    }

    /**
     * Estimates body kinematics (specific force applied to a body and its angular rates).
     *
     * @param timeInterval time interval between epochs expressed in seconds (s).
     * @param c            body-to-ECEF frame coordinate transformation matrix.
     * @param oldC         previous body-to-ECEF-frame coordinate transformation matrix.
     * @param vx           velocity of body frame x coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param vy           velocity of body frame y coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param vz           velocity of body frame z coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param oldVx        previous velocity of body frame x coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldVy        previous velocity of body frame y coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldVz        previous velocity of body frame z coordinate with respect ECEF
     *                     frame, resolved along EVEF-frame axes.
     * @param x            cartesian x coordinate of body position expressed in meters (m)
     *                     with respect ECEF frame, resolved along ECEF-frame axes.
     * @param y            cartesian y coordinate of body position expressed in meters (m)
     *                     with respect ECEF frame, resolved along ECEF-frame axes.
     * @param z            cartesian z coordinate of body position expressed in meters (m)
     *                     with respect ECEF frame, resolved along ECEF-frame axes.
     * @return a new body kinematics instance.
     * @throws IllegalArgumentException if provided time interval is negative or coordinated transformation matrices
     *                                  are not ECEF frame valid.
     */
    public static BodyKinematics estimateKinematicsAndReturnNew(final double timeInterval,
                                                                final CoordinateTransformation c,
                                                                final CoordinateTransformation oldC,
                                                                final Speed vx, final Speed vy, final Speed vz,
                                                                final Speed oldVx, final Speed oldVy, final Speed oldVz,
                                                                final double x, final double y, final double z) {
        final BodyKinematics result = new BodyKinematics();
        estimateKinematics(timeInterval, c, oldC, vx, vy, vz, oldVx, oldVy, oldVz,
                x, y, z, result);
        return result;
    }

    /**
     * Estimates body kinematics (specific force applied to a body and its angular rates).
     *
     * @param timeInterval time interval between epochs.
     * @param c            body-to-ECEF frame coordinate transformation matrix.
     * @param oldC         previous body-to-ECEF-frame coordinate transformation matrix.
     * @param vx           velocity of body frame x coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param vy           velocity of body frame y coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param vz           velocity of body frame z coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param oldVx        previous velocity of body frame x coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldVy        previous velocity of body frame y coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldVz        previous velocity of body frame z coordinate with respect ECEF
     *                     frame, resolved along EVEF-frame axes.
     * @param x            cartesian x coordinate of body position expressed in meters (m)
     *                     with respect ECEF frame, resolved along ECEF-frame axes.
     * @param y            cartesian y coordinate of body position expressed in meters (m)
     *                     with respect ECEF frame, resolved along ECEF-frame axes.
     * @param z            cartesian z coordinate of body position expressed in meters (m)
     *                     with respect ECEF frame, resolved along ECEF-frame axes.
     * @return a new body kinematics instance.
     * @throws IllegalArgumentException if provided time interval is negative or coordinated transformation matrices
     *                                  are not ECEF frame valid.
     */
    public static BodyKinematics estimateKinematicsAndReturnNew(final Time timeInterval,
                                                                final CoordinateTransformation c,
                                                                final CoordinateTransformation oldC,
                                                                final Speed vx, final Speed vy, final Speed vz,
                                                                final Speed oldVx, final Speed oldVy, final Speed oldVz,
                                                                final double x, final double y, final double z) {
        final BodyKinematics result = new BodyKinematics();
        estimateKinematics(timeInterval, c, oldC, vx, vy, vz, oldVx, oldVy, oldVz,
                x, y, z, result);
        return result;
    }

    /**
     * Estimates body kinematics (specific force applied to a body and its angular rates).
     *
     * @param timeInterval time interval between epochs expressed in seconds (s).
     * @param c            body-to-ECEF frame coordinate transformation matrix.
     * @param oldC         previous body-to-ECEF-frame coordinate transformation matrix.
     * @param vx           velocity of body frame x coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param vy           velocity of body frame y coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param vz           velocity of body frame z coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param oldVx        previous velocity of body frame x coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldVy        previous velocity of body frame y coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldVz        previous velocity of body frame z coordinate with respect ECEF
     *                     frame, resolved along EVEF-frame axes.
     * @param position     cartesian body position resolved along ECEF-frame axes.
     * @return a new body kinematics instance.
     * @throws IllegalArgumentException if provided time interval is negative or coordinated transformation matrices
     *                                  are not ECEF frame valid.
     */
    public static BodyKinematics estimateKinematicsAndReturnNew(final double timeInterval,
                                                                final CoordinateTransformation c,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/RobustMixedPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/RobustMixedPositionEstimator2D.html#L973">973</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/RobustRangingAndRssiPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/RobustRangingAndRssiPositionEstimator2D.html#L969">969</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/RobustRangingPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/RobustRangingPositionEstimator2D.html#L977">977</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/RobustRssiPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/RobustRssiPositionEstimator2D.html#L969">969</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>            RobustMixedPositionEstimatorListener&lt;Point2D&gt; listener) {
        return create(sourceQualityScores, fingerprintReadingQualityScores,
                sources, fingerprint, listener, DEFAULT_ROBUST_METHOD);
    }

    /**
     * Sets positions, distances and standard deviations of distances on internal
     * lateration solver.
     *
     * @param positions                     positions to be set.
     * @param distances                     distances to be set.
     * @param distanceStandardDeviations    standard deviations of distances to be set.
     * @param distanceQualityScores         distance quality scores or null if not
     *                                      required.
     */
    @Override
    protected void setPositionsDistancesDistanceStandardDeviationsAndQualityScores(
            List&lt;Point2D&gt; positions, List&lt;Double&gt; distances,
            List&lt;Double&gt; distanceStandardDeviations,
            List&lt;Double&gt; distanceQualityScores) {
        int size = positions.size();
        Point2D[] positionsArray = new InhomogeneousPoint2D[size];
        positionsArray = positions.toArray(positionsArray);

        double[] distancesArray = new double[size];
        double[] distanceStandardDeviationsArray = new double[size];

        double[] qualityScoresArray = null;
        if (distanceQualityScores != null) {
            qualityScoresArray = new double[size];
        }

        for (int i = 0; i &lt; size; i++) {
            distancesArray[i] = distances.get(i);
            distanceStandardDeviationsArray[i] = distanceStandardDeviations.get(i);

            if (qualityScoresArray != null) {
                qualityScoresArray[i] = distanceQualityScores.get(i);
            }
        }

        try {
            mLaterationSolver.setPositionsDistancesAndStandardDeviations(
                    positionsArray, distancesArray, distanceStandardDeviationsArray);

            if (qualityScoresArray != null) {
                mLaterationSolver.setQualityScores(qualityScoresArray);
            }
        } catch (LockedException e) {
            throw new IllegalArgumentException(e);
        }
    }
}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/RobustRangingAndRssiPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/RobustRangingAndRssiPositionEstimator3D.html#L969">969</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/RobustRssiPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/RobustRssiPositionEstimator3D.html#L969">969</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>            RobustRangingAndRssiPositionEstimatorListener&lt;Point3D&gt; listener) {
        return create(sourceQualityScores, fingerprintReadingQualityScores,
                sources, fingerprint, listener, DEFAULT_ROBUST_METHOD);
    }

    /**
     * Sets positions, distances and standard deviations of distances on internal
     * lateration solver.
     *
     * @param positions                     positions to be set.
     * @param distances                     distances to be set.
     * @param distanceStandardDeviations    standard deviations of distances to be set.
     * @param distanceQualityScores         distance quality scores or null if not
     *                                      required.
     */
    @Override
    protected void setPositionsDistancesDistanceStandardDeviationsAndQualityScores(
            List&lt;Point3D&gt; positions, List&lt;Double&gt; distances,
            List&lt;Double&gt; distanceStandardDeviations,
            List&lt;Double&gt; distanceQualityScores) {
        int size = positions.size();
        Point3D[] positionsArray = new InhomogeneousPoint3D[size];
        positionsArray = positions.toArray(positionsArray);

        double[] distancesArray = new double[size];
        double[] distanceStandardDeviationsArray = new double[size];

        double[] qualityScoresArray = null;
        if (distanceQualityScores != null) {
            qualityScoresArray = new double[size];
        }

        for (int i = 0; i &lt; size; i++) {
            distancesArray[i] = distances.get(i);
            distanceStandardDeviationsArray[i] = distanceStandardDeviations.get(i);

            if (qualityScoresArray != null) {
                qualityScoresArray[i] = distanceQualityScores.get(i);
            }
        }

        try {
            mLaterationSolver.setPositionsDistancesAndStandardDeviations(
                    positionsArray, distancesArray, distanceStandardDeviationsArray);

            if (qualityScoresArray != null) {
                mLaterationSolver.setQualityScores(qualityScoresArray);
            }
        } catch (LockedException e) {
            throw new IllegalArgumentException(e);
        }
    }
}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/MixedRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MixedRadioSourceEstimator.html#L494">494</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RangingAndRssiRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RangingAndRssiRadioSourceEstimator.html#L484">484</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RssiRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RssiRadioSourceEstimator.html#L487">487</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>            MixedRadioSourceEstimatorListener&lt;S, P&gt; listener) {
        this(readings, initialPosition, initialTransmittedPowerdBm, listener);
        mInitialPathLossExponent = initialPathLossExponent;
    }

    /**
     * Gets initial transmitted power to start the estimation of radio source
     * transmitted power (expressed in dBm's).
     * If not defined, average value of received power readings will be used.
     *
     * If transmitted power estimation is enabled, estimation will start at this
     * value and will converte the most appropriate value.
     * If transmitted power estimation is disabled, this value will be assumed to be
     * exact and the estimated transmitted power will be equal to this value
     * (converted to dBm's).
     * @return initial transmitted power to start the estimation of radio source
     * transmitted power.
     */
    public Double getInitialTransmittedPowerdBm() {
        return mInitialTransmittedPowerdBm;
    }

    /**
     * Sets initial transmitted power to start the estimation of radio source
     * transmitted power (expressed in dBm's).
     * If not defined, average value of received power readings will be used.
     *
     * If transmitted power estimation is enabled, estimation will start at this
     * value and will converte the most appropriate value.
     * If transmitted power estimation is disabled, this value will be assumed to be
     * exact and the estimated transmitted power will be equal to this value
     * (converted to dBm's).
     * @param initialTransmittedPowerdBm initial transmitted power to start the
     *                                   estimation of radio source transmitted
     *                                   power.
     * @throws LockedException if estimator is locked.
     */
    public void setInitialTransmittedPowerdBm(Double initialTransmittedPowerdBm)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mInitialTransmittedPowerdBm = initialTransmittedPowerdBm;
    }

    /**
     * Gets initial transmitted power to start the estimation of radio source
     * transmitted power (expressed in mW).
     * If not defined, average value of received power readings will be used.
     *
     * If transmitted power estimation is enabled, estimation will start at this
     * value and will converte the most appropriate value.
     * If transmitted power estimation is disabled, this value will be assumed to be
     * exact and the estimated transmitted power will be equal to this value
     * (converted to dBm's).
     * @return initial transmitted power to start the estimation of radio source
     * transmitted power.
     */
    public Double getInitialTransmittedPower() {
        return mInitialTransmittedPowerdBm != null ?
                Utils.dBmToPower(mInitialTransmittedPowerdBm) : null;
    }

    /**
     * Sets initial transmitted power to start the estimation of radio source
     * transmitted power (expressed in mW).
     * If not defined, average value of received power readings will be used.
     *
     * If transmitted power estimation is enabled, estimation will start at this
     * value and will converte the most appropriate value.
     * If transmitted power estimation is disabled, this value will be assumed to be
     * exact and the estimated transmitted power will be equal to this value
     * (converted to dBm's).
     * @param initialTransmittedPower initial transmitted power to start the
     *                                estimation of radio source transmitted power.
     * @throws LockedException if estimator is locked.
     * @throws IllegalArgumentException if provided value is negative.
     */
    public void setInitialTransmittedPower(Double initialTransmittedPower)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (initialTransmittedPower != null) {
            if (initialTransmittedPower &lt; 0.0) {
                throw new IllegalArgumentException();
            }
            mInitialTransmittedPowerdBm = Utils.powerTodBm(
                    initialTransmittedPower);
        } else {
            mInitialTransmittedPowerdBm = null;
        }
    }

    /**
     * Indicates whether transmitted power estimation is enabled or not.
     * @return true if transmitted power estimation is enabled, false otherwise.
     */
    public boolean isTransmittedPowerEstimationEnabled() {
        return mTransmittedPowerEstimationEnabled;
    }

    /**
     * Specifies whether transmitted power estimation is enabled or not.
     * @param transmittedPowerEstimationEnabled true if transmitted power estimation is enabled,
     *                                          false otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setTransmittedPowerEstimationEnabled(boolean transmittedPowerEstimationEnabled)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mTransmittedPowerEstimationEnabled = transmittedPowerEstimationEnabled;
    }

    /**
     * Gets initial position to start the estimation of radio source position.
     * If not defined, centroid of provided readings will be used.
     *
     * If position estimation is enabled, estimation will start at this value
     * and will converge to the most appropriate value.
     * If position estimation is disabled, this value will be assumed to
     * be exact and the estimated position will be equal to this value.
     * @return initial position to start the estimation of radio source position.
     */
    public P getInitialPosition() {
        return mInitialPosition;
    }

    /**
     * Sets initial position to start the estimation of radio source position.
     * If not defined, centroid of provided fingerprints will be used.
     *
     * If position estimation is enabled, estimation will start at this value
     * and will converge to the most appropriate value.
     * If position estimation is disabled, this value will be assumed to
     * be exact and the estimated position will be equal to this value.
     * @param initialPosition initial position to start the estimation of radio
     *                        source position.
     * @throws LockedException if estimator is locked.
     */
    public void setInitialPosition(P initialPosition) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mInitialPosition = initialPosition;
    }

    /**
     * Gets initial exponent typically used on free space for path loss propagation
     * in terms of distance.
     * On different environments path loss exponent might have different value:
     * - Free space: 2.0
     * - Urban Area: 2.7 to 3.5
     * - Suburban Area: 3 to 5
     * - Indoor (line-of-sight): 1.6 to 1.8
     *
     * If path loss exponent estimation is enabled, estimation will start at this
     * value and will converge to the most appropriate value.
     * If path loss exponent estimation is disabled, this value will be assumed
     * to be exact and the estimated path loss exponent will be equal to this
     * value.
     * @return initial path loss exponent.
     */
    public double getInitialPathLossExponent() {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/NonLinearMixedPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/NonLinearMixedPositionEstimator2D.html#L287">287</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/NonLinearRangingAndRssiPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/NonLinearRangingAndRssiPositionEstimator2D.html#L286">286</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/NonLinearRangingPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/NonLinearRangingPositionEstimator2D.html#L287">287</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>            MixedPositionEstimatorListener&lt;Point2D&gt; listener) {
        super(initialPosition, listener);
        init();
        internalSetSources(sources);
        internalSetFingerprint(fingerprint);
    }

    /**
     * Gets estimated position.
     *
     * @return estimated position.
     */
    public Point2D getEstimatedPosition() {
        if (mEstimatedPositionCoordinates == null) {
            return null;
        }

        InhomogeneousPoint2D result = new InhomogeneousPoint2D();
        getEstimatedPosition(result);
        return result;
    }

    /**
     * Sets positions, distances and standard deviations of distances on internal
     * lateration solver.
     *
     * @param positions positions to be set.
     * @param distances distances to be set.
     * @param distanceStandardDeviations standard deviations of distances to be set.
     */
    @Override
    @SuppressWarnings(&quot;Duplicates&quot;)
    protected void setPositionsDistancesAndDistanceStandardDeviations(
            List&lt;Point2D&gt; positions, List&lt;Double&gt; distances,
            List&lt;Double&gt; distanceStandardDeviations) {

        int size = positions.size();
        Point2D[] positionsArray = new InhomogeneousPoint2D[size];
        positionsArray = positions.toArray(positionsArray);

        double[] distancesArray = new double[size];
        double[] distanceStandardDeviationsArray = new double[size];
        for (int i = 0; i &lt; size; i++) {
            distancesArray[i] = distances.get(i);
            distanceStandardDeviationsArray[i] = distanceStandardDeviations.get(i);
        }

        try {
            mTrilaterationSolver.setPositionsDistancesAndStandardDeviations(
                    positionsArray, distancesArray, distanceStandardDeviationsArray);
        } catch (LockedException e) {
            throw new IllegalArgumentException(e);
        }
    }

    /**
     * Initializes lateration solver.
     */
    private void init() {
        mTrilaterationSolver = new NonLinearLeastSquaresLateration2DSolver(
                mLaterationSolverListener);
    }
}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/NonLinearMixedPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/NonLinearMixedPositionEstimator3D.html#L290">290</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/NonLinearRangingAndRssiPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/NonLinearRangingAndRssiPositionEstimator3D.html#L290">290</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/NonLinearRangingPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/NonLinearRangingPositionEstimator3D.html#L287">287</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>            MixedPositionEstimatorListener&lt;Point3D&gt; listener) {
        super(initialPosition, listener);
        init();
        internalSetSources(sources);
        internalSetFingerprint(fingerprint);
    }

    /**
     * Gets estimated position.
     *
     * @return estimated position.
     */
    public Point3D getEstimatedPosition() {
        if (mEstimatedPositionCoordinates == null) {
            return null;
        }

        InhomogeneousPoint3D result = new InhomogeneousPoint3D();
        getEstimatedPosition(result);
        return result;
    }

    /**
     * Sets positions, distances and standard deviations of distances on internal
     * lateration solver.
     *
     * @param positions positions to be set.
     * @param distances distances to be set.
     * @param distanceStandardDeviations standard deviations of distances to be set.
     */
    @Override
    @SuppressWarnings(&quot;Duplicates&quot;)
    protected void setPositionsDistancesAndDistanceStandardDeviations(
            List&lt;Point3D&gt; positions, List&lt;Double&gt; distances,
            List&lt;Double&gt; distanceStandardDeviations) {

        int size = positions.size();
        Point3D[] positionsArray = new InhomogeneousPoint3D[size];
        positionsArray = positions.toArray(positionsArray);

        double[] distancesArray = new double[size];
        double[] distanceStandardDeviationsArray = new double[size];
        for (int i = 0; i &lt; size; i++) {
            distancesArray[i] = distances.get(i);
            distanceStandardDeviationsArray[i] = distanceStandardDeviations.get(i);
        }

        try {
            mTrilaterationSolver.setPositionsDistancesAndStandardDeviations(
                    positionsArray, distancesArray, distanceStandardDeviationsArray);
        } catch (LockedException e) {
            throw new IllegalArgumentException(e);
        }
    }

    /**
     * Initializes lateration solver.
     */
    private void init() {
        mTrilaterationSolver = new NonLinearLeastSquaresLateration3DSolver(
                mLaterationSolverListener);
    }
}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/calibration/KnownFrameAccelerometerLinearLeastSquaresCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/KnownFrameAccelerometerLinearLeastSquaresCalibrator.html#L816">816</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/calibration/KnownFrameAccelerometerLinearLeastSquaresCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/KnownFrameAccelerometerLinearLeastSquaresCalibrator.html#L926">926</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>        final Matrix a = new Matrix(rows, COMMON_Z_AXIS_UNKNOWNS);
        final Matrix b = new Matrix(rows, 1);
        int i = 0;
        for (final FrameBodyKinematics measurement : mMeasurements) {
            final BodyKinematics measuredKinematics = measurement.getKinematics();
            final ECEFFrame ecefFrame = measurement.getFrame();
            final ECEFFrame previousEcefFrame = measurement.getPreviousFrame();
            final double timeInterval = measurement.getTimeInterval();

            ECEFKinematicsEstimator.estimateKinematics(timeInterval, ecefFrame,
                    previousEcefFrame, expectedKinematics);

            final double fMeasX = measuredKinematics.getFx();
            final double fMeasY = measuredKinematics.getFy();
            final double fMeasZ = measuredKinematics.getFz();

            final double fTrueX = expectedKinematics.getFx();
            final double fTrueY = expectedKinematics.getFy();
            final double fTrueZ = expectedKinematics.getFz();

            a.setElementAt(i, 0, 1.0);
            a.setElementAt(i, 3, fTrueX);
            a.setElementAt(i, 6, fTrueY);
            a.setElementAt(i, 7, fTrueZ);

            b.setElementAtIndex(i, fMeasX - fTrueX);
            i++;

            a.setElementAt(i, 1, 1.0);
            a.setElementAt(i, 4, fTrueY);
            a.setElementAt(i, 8, fTrueZ);</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/estimators/ECEFKinematicsEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/estimators/ECEFKinematicsEstimator.html#L1544">1544</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/estimators/ECIKinematicsEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/estimators/ECIKinematicsEstimator.html#L818">818</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>        return estimateKinematicsAndReturnNew(timeInterval, c, oldC, velocity, oldVelocity, position);
    }

    /**
     * Estimates body kinematics (specific force applied to a body and its angular rates).
     *
     * @param timeInterval time interval between epochs expressed in seconds (s).
     * @param c            boy-to-ECEF frame coordinate transformation matrix.
     * @param oldC         previous body-to-ECEF-frame coordinate transformation matrix.
     * @param vx           velocity of body frame x coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param vy           velocity of body frame y coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param vz           velocity of body frame z coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param oldVx        previous velocity of body frame x coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldVy        previous velocity of body frame y coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldVz        previous velocity of body frame z coordinate with respect ECEF
     *                     frame, resolved along EVEF-frame axes.
     * @param position     body position expressed in meters (m) with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @return a new body kinematics instance.
     * @throws IllegalArgumentException if provided time interval is negative or coordinated transformation matrices
     *                                  are not ECEF frame valid.
     */
    public BodyKinematics estimateAndReturnNew(final double timeInterval,
                                               final CoordinateTransformation c,
                                               final CoordinateTransformation oldC,
                                               final Speed vx, final Speed vy, final Speed vz,
                                               final Speed oldVx, final Speed oldVy, final Speed oldVz,
                                               final Point3D position) {
        return estimateKinematicsAndReturnNew(timeInterval, c, oldC, vx, vy, vz,
                oldVx, oldVy, oldVz, position);
    }

    /**
     * Estimates body kinematics (specific force applied to a body and its angular rates).
     *
     * @param timeInterval time interval between epochs.
     * @param c            boy-to-ECEF frame coordinate transformation matrix.
     * @param oldC         previous body-to-ECEF-frame coordinate transformation matrix.
     * @param vx           velocity of body frame x coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param vy           velocity of body frame y coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param vz           velocity of body frame z coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param oldVx        previous velocity of body frame x coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldVy        previous velocity of body frame y coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldVz        previous velocity of body frame z coordinate with respect ECEF
     *                     frame, resolved along EVEF-frame axes.
     * @param position     body position expressed in meters (m) with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @return a new body kinematics instance.
     * @throws IllegalArgumentException if provided time interval is negative or coordinated transformation matrices
     *                                  are not ECEF frame valid.
     */
    public BodyKinematics estimateAndReturnNew(final Time timeInterval,
                                               final CoordinateTransformation c,
                                               final CoordinateTransformation oldC,
                                               final Speed vx, final Speed vy, final Speed vz,
                                               final Speed oldVx, final Speed oldVy, final Speed oldVz,
                                               final Point3D position) {
        return estimateKinematicsAndReturnNew(timeInterval, c, oldC, vx, vy, vz,
                oldVx, oldVy, oldVz, position);
    }

    /**
     * Estimates body kinematics (specific force applied to a body and its angular rates)..
     *
     * @param timeInterval time interval between epochs expressed in seconds (s).
     * @param c            body-to-ECEF-frame coordinate transformation.
     * @param oldC         previous body-to-ECEF-frame coordinate transformation matrix.
     * @param vx           x coordinate of velocity of body frame expressed in meters per second (m/s) and resolved
     *                     along ECEF-frame axes.
     * @param vy           y coordinate of velocity of body frame expressed in meters per second (m/s) and resolved
     *                     along ECEF-frame axes.
     * @param vz           z coordinate of velocity of body frame expressed in meters per second (m/s) and resolved
     *                     along ECEF-frame axes.
     * @param oldVx        x coordinate of previous velocity of body frame expressed in meters per second (m/s) and
     *                     resolved along ECEF-frame axes.
     * @param oldVy        y coordinate of previous velocity of body frame expressed in meters per second (m/s) and
     *                     resolved along ECEF-frame axes.
     * @param oldVz        z coordinate of previous velocity of body frame expressed in meters per second (m/s) and
     *                     resolved along ECEF-frame axes.
     * @param x            cartesian x coordinate of body position expressed in meters (m) and resolved along
     *                     ECEF-frame axes.
     * @param y            cartesian y coordinate of body position expressed in meters (m) and resolved along
     *                     ECEF-frame axes.
     * @param z            cartesian z coordinate of body position expressed in meters (m) and resolved along
     *                     ECEF-frame axes.
     * @param result       instance where estimated body kinematics will be stored.
     * @throws IllegalArgumentException if provided time interval is negative or coordinated transformation matrices
     *                                  are not ECEF frame valid.
     */
    public static void estimateKinematics(final double timeInterval,
                                          final CoordinateTransformation c,
                                          final CoordinateTransformation oldC,
                                          final double vx, final double vy, final double vz,
                                          final double oldVx, final double oldVy, final double oldVz,
                                          final double x, final double y, final double z,
                                          final BodyKinematics result) {
        if (timeInterval &lt; 0.0
                || !ECEFFrame.isValidCoordinateTransformation(c)</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/lateration/PROSACRobustLateration2DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/PROSACRobustLateration2DSolver.html#L379">379</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/lateration/PROSACRobustLateration3DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/PROSACRobustLateration3DSolver.html#L379">379</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>        super(circles, distanceStandardDeviations, listener);
        internalSetQualityScores(qualityScores);
    }

    /**
     * Gets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on distance between estimated position and distances
     * provided for each sample.
     * @return threshold to determine whether samples are inliers or not.
     */
    public double getThreshold() {
        return mThreshold;
    }

    /**
     * Sets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on distance between estimated position and distances
     * provided for each sample.
     * @param threshold threshold to determine whether samples are inliers or not.
     * @throws IllegalArgumentException if provided value is equal or less than zero.
     * @throws LockedException if this solver is locked.
     */
    public void setThreshold(double threshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (threshold &lt;= MIN_THRESHOLD) {
            throw new IllegalArgumentException();
        }
        mThreshold = threshold;
    }

    /**
     * Returns quality scores corresponding to each pair of
     * positions and distances (i.e. sample).
     * The larger the score value the better the quality of the sample.
     * @return quality scores corresponding to each sample.
     */
    @Override
    public double[] getQualityScores() {
        return mQualityScores;
    }

    /**
     * Sets quality scores corresponding to each pair of positions and
     * distances (i.e. sample).
     * The larger the score value the better the quality of the sample.
     * @param qualityScores quality scores corresponding to each pair of
     *                      matched points.
     * @throws IllegalArgumentException if provided quality scores length
     * is smaller than minimum required samples.
     * @throws LockedException if robust solver is locked because an
     * estimation is already in progress.
     */
    @Override
    public void setQualityScores(double[] qualityScores)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetQualityScores(qualityScores);
    }

    /**
     * Indicates whether solver is ready to find a solution.
     * @return true if solver is ready, false otherwise.
     */
    @Override
    public boolean isReady() {
        return super.isReady() &amp;&amp; mQualityScores != null &amp;&amp;
                mQualityScores.length == mDistances.length;
    }

    /**
     * Indicates whether inliers must be computed and kept.
     * @return true if inliers must be computed and kept, false if inliers
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepInliersEnabled() {
        return mComputeAndKeepInliers;
    }

    /**
     * Specifies whether inliers must be computed and kept.
     * @param computeAndKeepInliers true if inliers must be computed and kept,
     *                              false if inliers only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepInliersEnabled(boolean computeAndKeepInliers)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mComputeAndKeepInliers = computeAndKeepInliers;
    }

    /**
     * Indicates whether residuals must be computed and kept.
     * @return true if residuals must be computed and kept, false if residuals
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepResiduals() {
        return mComputeAndKeepResiduals;
    }

    /**
     * Specifies whether residuals must be computed and kept.
     * @param computeAndKeepResiduals true if residuals must be computed and kept,
     *                                false if residuals only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepResidualsEnabled(boolean computeAndKeepResiduals)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mComputeAndKeepResiduals = computeAndKeepResiduals;
    }

    /**
     * Solves the lateration problem.
     * @return estimated position.
     * @throws LockedException if instance is busy solving the lateration problem.
     * @throws NotReadyException is solver is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     * (i.e. numerical instability, no solution available, etc).
     */
    @Override
    public Point2D solve() throws LockedException, NotReadyException,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/lateration/RobustLateration2DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/RobustLateration2DSolver.html#L1248">1248</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/lateration/RobustLateration3DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/RobustLateration3DSolver.html#L1247">1247</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>            Point2D[] inlierPositions = new Point2D[nInliers];
            double[] inlierDistances = new double[nInliers];
            double[] inlierStandardDeviations = null;
            if (mDistanceStandardDeviations != null) {
                inlierStandardDeviations = new double[nInliers];
            }
            int pos = 0;
            for (int i = 0; i &lt; nSamples; i++) {
                if (inliers.get(i)) {
                    //sample is inlier
                    inlierPositions[pos] = mPositions[i];
                    inlierDistances[pos] = mDistances[i];
                    if (inlierStandardDeviations != null) {
                        inlierStandardDeviations[pos] = mDistanceStandardDeviations[i];
                    }
                    pos++;
                }
            }

            try {
                mNonLinearSolver.setInitialPosition(position);
                if (inlierStandardDeviations != null) {
                    mNonLinearSolver.setPositionsDistancesAndStandardDeviations(
                            inlierPositions, inlierDistances, inlierStandardDeviations);
                } else {
                    mNonLinearSolver.setPositionsAndDistances(
                            inlierPositions, inlierDistances);
                }
                mNonLinearSolver.solve();

                if (mKeepCovariance) {
                    //keep covariance
                    mCovariance = mNonLinearSolver.getCovariance();
                } else {
                    mCovariance = null;
                }

                mEstimatedPosition = mNonLinearSolver.getEstimatedPosition();
            } catch (Exception e) {
                //refinement failed, so we return input value
                mCovariance = null;
                mEstimatedPosition = position;
            }
        } else {
            mCovariance = null;
            mEstimatedPosition = position;
        }

        return mEstimatedPosition;
    }

    /**
     * Solves a preliminar solution for a subset of samples picked by a robust estimator.
     * @param samplesIndices indices of samples picked by the robust estimator.
     * @param solutions list where estimated preliminar solution will be stored.
     */
    protected void solvePreliminarSolutions(int[] samplesIndices, List&lt;Point2D&gt; solutions) {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/estimators/ECEFKinematicsEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/estimators/ECEFKinematicsEstimator.html#L648">648</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/estimators/ECIKinematicsEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/estimators/ECIKinematicsEstimator.html#L338">338</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                         final ECEFFrame frame,
                         final CoordinateTransformation oldC,
                         final Speed oldVx, final Speed oldVy, final Speed oldVz,
                         final BodyKinematics result) {
        estimateKinematics(timeInterval, frame, oldC, oldVx, oldVy, oldVz, result);
    }

    /**
     * Estimates body kinematics (specific force applied to a body and its angular rates).
     *
     * @param timeInterval time interval between epochs expressed in seconds (s).
     * @param c            body-to-ECEF frame coordinate transformation matrix.
     * @param oldC         previous body-to-ECEF-frame coordinate transformation matrix.
     * @param vx           velocity of body frame x coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per
     *                     second (m/s).
     * @param vy           velocity of body frame y coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per
     *                     second (m/s).
     * @param vz           velocity of body frame z coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per
     *                     second (m/s).
     * @param oldVx        previous velocity of body frame x coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters
     *                     per second (m/s).
     * @param oldVy        previous velocity of body frame y coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters
     *                     per second (m/s).
     * @param oldVz        previous velocity of body frame z coordinate with respect ECEF
     *                     frame, resolved along EVEF-frame axes and expressed in meters
     *                     per second (m/s).
     * @param position     body position expressed in meters (m) with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param result       instance where body kinematics estimation will be stored.
     * @throws IllegalArgumentException if provided time interval is negative or coordinated transformation matrices
     *                                  are not ECEF frame valid.
     */
    public void estimate(final double timeInterval,
                         final CoordinateTransformation c,
                         final CoordinateTransformation oldC,
                         final double vx, final double vy, final double vz,
                         final double oldVx, final double oldVy, final double oldVz,
                         final Point3D position, final BodyKinematics result) {
        estimateKinematics(timeInterval, c, oldC, vx, vy, vz, oldVx, oldVy, oldVz,
                position, result);
    }

    /**
     * Estimates body kinematics (specific force applied to a body and its angular rates).
     *
     * @param timeInterval time interval between epochs.
     * @param c            body-to-ECEF frame coordinate transformation matrix.
     * @param oldC         previous body-to-ECEF-frame coordinate transformation matrix.
     * @param vx           velocity of body frame x coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per
     *                     second (m/s).
     * @param vy           velocity of body frame y coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per
     *                     second (m/s).
     * @param vz           velocity of body frame z coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per
     *                     second (m/s).
     * @param oldVx        previous velocity of body frame x coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters
     *                     per second (m/s).
     * @param oldVy        previous velocity of body frame y coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters
     *                     per second (m/s).
     * @param oldVz        previous velocity of body frame z coordinate with respect ECEF
     *                     frame, resolved along EVEF-frame axes and expressed in meters
     *                     per second (m/s).
     * @param position     body position expressed in meters (m) with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param result       instance where body kinematics estimation will be stored.
     * @throws IllegalArgumentException if provided time interval is negative or coordinated transformation matrices
     *                                  are not ECEF frame valid.
     */
    public void estimate(final Time timeInterval,
                         final CoordinateTransformation c,
                         final CoordinateTransformation oldC,
                         final double vx, final double vy, final double vz,
                         final double oldVx, final double oldVy, final double oldVz,
                         final Point3D position, final BodyKinematics result) {
        estimateKinematics(timeInterval, c, oldC, vx, vy, vz, oldVx, oldVy, oldVz,
                position, result);
    }

    /**
     * Estimates body kinematics (specific force applied to a body and its angular rates).
     *
     * @param timeInterval time interval between epochs expressed in seconds (s).
     * @param c            body-to-ECEF frame coordinate transformation matrix.
     * @param oldC         previous body-to-ECEF-frame coordinate transformation matrix.
     * @param velocity     velocity of body frame with respect ECEF frame.
     * @param oldVelocity  previous velocity of body frame with respect ECEF frame.
     * @param position     body position expressed in meters (m) with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param result       instance where body kinematics estimation will be stored.
     * @throws IllegalArgumentException if provided time interval is negative or coordinated transformation matrices
     *                                  are not ECEF frame valid.
     */
    public void estimate(final double timeInterval,
                         final CoordinateTransformation c,
                         final CoordinateTransformation oldC,
                         final ECEFVelocity velocity,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/SequentialRobustMixedPositionEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/SequentialRobustMixedPositionEstimator.html#L41">41</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/SequentialRobustRangingAndRssiPositionEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/SequentialRobustRangingAndRssiPositionEstimator.html#L38">38</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>public abstract class SequentialRobustMixedPositionEstimator&lt;P extends Point&lt;?&gt;&gt; {

    /**
     * Default robust estimator method for robust position estimation using ranging
     * data when no robust method is provided.
     */
    public static final RobustEstimatorMethod DEFAULT_RANGING_ROBUST_METHOD =
            RobustEstimatorMethod.PROMedS;

    /**
     * Default robust method for coarse robust position estimation using RSSI
     * data when no robust method is provided.
     */
    public static final RobustEstimatorMethod DEFAULT_RSSI_ROBUST_METHOD =
            RobustEstimatorMethod.PROMedS;

    /**
     * Indicates that by default located radio source position covariance is taken
     * into account (if available) to determine distance standard deviation for ranging
     * measurements.
     */
    public static final boolean DEFAULT_USE_RANGING_RADIO_SOURCE_POSITION_COVARIANCE =
            true;

    /**
     * Indicates that by default located radio source position covariance is taken
     * into account (if available) to determine distance standard deviation for RSSI
     * measurements.
     */
    public static final boolean DEFAULT_USE_RSSI_RADIO_SOURCE_POSITION_COVARIANCE =
            true;

    /**
     * Indicates that by default readings are distributed evenly among radio sources
     * taking into account quality scores of both radio sources and ranging readings.
     */
    public static final boolean DEFAULT_EVENLY_DISTRIBUTE_RANGING_READINGS = true;

    /**
     * Indicates that by default readings are distributed evenly among radio sources
     * taking into account quality scores of both radio sources and RSSI readings.
     */
    public static final boolean DEFAULT_EVENLY_DISTRIBUTE_RSSI_READINGS = true;

    /**
     * Distance standard deviation assumed for provided distances as a fallback when
     * none can be determined.
     */
    public static final double FALLBACK_DISTANCE_STANDARD_DEVIATION =
            RobustPositionEstimator.FALLBACK_DISTANCE_STANDARD_DEVIATION;

    /**
     * Default amount of progress variation before notifying a change in estimation progress.
     * By default this is set to 5%.
     */
    public static final float DEFAULT_PROGRESS_DELTA = 0.05f;

    /**
     * Minimum allowed value for progress delta.
     */
    public static final float MIN_PROGRESS_DELTA = 0.0f;

    /**
     * Maximum allowed value for progress delta.
     */
    public static final float MAX_PROGRESS_DELTA = 1.0f;

    /**
     * Constant defining default confidence of the estimated result, which is
     * 99%. This means that with a probability of 99% estimation will be
     * accurate because chosen subsamples will be inliers.
     */
    public static final double DEFAULT_CONFIDENCE = 0.99;

    /**
     * Default maximum allowed number of iterations.
     */
    public static final int DEFAULT_MAX_ITERATIONS = 5000;

    /**
     * Minimum allowed confidence value.
     */
    public static final double MIN_CONFIDENCE = 0.0;

    /**
     * Maximum allowed confidence value.
     */
    public static final double MAX_CONFIDENCE = 1.0;

    /**
     * Minimum allowed number of iterations.
     */
    public static final int MIN_ITERATIONS = 1;

    /**
     * Indicates that result is refined by default using all found inliers.
     */
    public static final boolean DEFAULT_REFINE_RESULT = true;

    /**
     * Indicates that covariance is kept by default after refining result.
     */
    public static final boolean DEFAULT_KEEP_COVARIANCE = true;

    /**
     * Indicates that by default a linear solver is used for preliminary solution
     * estimation using ranging measurements.
     * The result obtained on each preliminary solution might be later refined.
     */
    public static final boolean DEFAULT_USE_RANGING_LINEAR_SOLVER = true;

    /**
     * Indicates that by default a linear solver is used for preliminary solution
     * estimation using RSSI measurements.
     * The result obtained on each preliminary solution might be later refined.
     */
    public static final boolean DEFAULT_USE_RSSI_LINEAR_SOLVER = true;

    /**
     * Indicates that by default an homogeneous linear solver is used either to
     * estimate preliminary solutions or an initial solution for preliminary solutions
     * that will be later refined on the ranging fine estimation.
     */
    public static final boolean DEFAULT_USE_RANGING_HOMOGENEOUS_LINEAR_SOLVER = false;

    /**
     * Indicates that by default an homogeneous linear solver is used either to
     * estimate preliminary solutions or an initial solution for preliminary solutions
     * that will be later refined on the RSSI coarse estimation.
     */
    public static final boolean DEFAULT_USE_RSSI_HOMOGENEOUS_LINEAR_SOLVER = false;

    /**
     * Indicates that by default preliminary ranging solutions are refined.
     */
    public static final boolean DEFAULT_REFINE_RANGING_PRELIMINARY_SOLUTIONS = true;

    /**
     * Indicates that by default preliminary RSSI solutions are refined.
     */
    public static final boolean DEFAULT_REFINE_RSSI_PRELIMINARY_SOLUTIONS = true;

    /**
     * Internal robust estimator for position estimation using ranging readings.
     */
    protected RobustRangingPositionEstimator&lt;P&gt; mRangingEstimator;

    /**
     * Internal robust estimator for coarse position estimation using RSSI readings.
     */
    protected RobustRssiPositionEstimator&lt;P&gt; mRssiEstimator;

    /**
     * Robust method used for robust position estimation using ranging data.
     */
    protected RobustEstimatorMethod mRangingRobustMethod =
            DEFAULT_RANGING_ROBUST_METHOD;

    /**
     * Robust method used for coarse robust position estimation using RSSI data.
     */
    protected RobustEstimatorMethod mRssiRobustMethod =
            DEFAULT_RSSI_ROBUST_METHOD;

    /**
     * Size of subsets to be checked during robust estimation.
     */
    protected int mRangingPreliminarySubsetSize;

    /**
     * Size of subsets to be checked during RSSI robust estimation.
     */
    protected int mRssiPreliminarySubsetSize;</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator.html#L759">759</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator.html#L738">738</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>        RangingAndRssiReadingLocated&lt;S, P&gt; reading = mReadings.get(i);
        double frequency = reading.getSource().getFrequency();

        double pathLossExponent = currentEstimation.getEstimatedPathLossExponent();

        //compute k as the constant part of the isotropic received power formula
        //so that: Pr = Pte*k^n/d^n
        double k = RssiRadioSourceEstimator.SPEED_OF_LIGHT /
                (4.0 * Math.PI * frequency);
        final double kdB = 10.0 * pathLossExponent * Math.log10(k);

        //get distance from estimated radio source position and reading position
        P readingPosition = reading.getPosition();
        P radioSourcePosition = currentEstimation.getEstimatedPosition();

        double sqrDistance = radioSourcePosition.sqrDistanceTo(readingPosition);

        double transmittedPowerdBm = currentEstimation.
                getEstimatedTransmittedPowerdBm();

        //compute expected received power assuming isotropic transmission
        //and compare agains measured RSSI at fingerprint location
        double expectedRSSI = kdB + transmittedPowerdBm -
                5.0 * pathLossExponent * Math.log10(sqrDistance);
        double rssi = reading.getRssi();

        return Math.abs(expectedRSSI - rssi);
    }

    /**
     * Contains a solution obtained during robust estimation for a subset of
     * samples.
     * @param &lt;P&gt; a {@link Point} type.
     */
    static class Solution&lt;P extends Point&lt;?&gt;&gt; {
        /**
         * Estimated position for a subset of samples.
         */
        private P mEstimatedPosition;

        /**
         * Estimated transmitted power expressed in dBm's for a subset of samples.
         */
        private double mEstimatedTransmittedPowerdBm;

        /**
         * Estimated path loss exponent for a subset of samples.
         */
        private double mEstimatedPathLossExponent;

        /**
         * Constructor.
         * @param estimatedPosition estimated position for a subset of samples.
         * @param estimatedTransmittedPowerdBm estimated transmitted power expressed
         *                                     in dBm's for a subset of samples.
         * @param estimatedPathLossExponent estimated path loss exponent.
         */
        public Solution(P estimatedPosition, double estimatedTransmittedPowerdBm,
                        double estimatedPathLossExponent) {
            mEstimatedPosition = estimatedPosition;
            mEstimatedTransmittedPowerdBm = estimatedTransmittedPowerdBm;
            mEstimatedPathLossExponent = estimatedPathLossExponent;
        }

        /**
         * Gets estimated position for a subset of samples.
         * @return estimated position for a subset of samples.
         */
        public P getEstimatedPosition() {
            return mEstimatedPosition;
        }

        /**
         * Gets estimated transmitted power expressed in dBm's for a subset of
         * samples.
         * @return estimated transmitted power expressed in dBm's for a subset
         * of samples.
         */
        public double getEstimatedTransmittedPowerdBm() {
            return mEstimatedTransmittedPowerdBm;
        }

        /**
         * Gets estimated path loss exponent.
         * @return estimated path loss exponent.
         */
        public double getEstimatedPathLossExponent() {
            return mEstimatedPathLossExponent;
        }
    }
}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/estimators/ECEFKinematicsEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/estimators/ECEFKinematicsEstimator.html#L53">53</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/estimators/ECIKinematicsEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/estimators/ECIKinematicsEstimator.html#L45">45</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    private static final double SCALING_THRESHOLD = 2e-5;

    /**
     * Alpha threshold.
     */
    private static final double ALPHA_THRESHOLD = 1e-8;

    /**
     * Number of rows.
     */
    private static final int ROWS = 3;

    /**
     * Estimates body kinematics (specific force applied to a body and its angular rates).
     *
     * @param timeInterval time interval between epochs expressed in seconds (s).
     * @param c            body-to-ECEF frame coordinate transformation matrix.
     * @param oldC         previous body-to-ECEF-frame coordinate transformation matrix.
     * @param vx           velocity of body frame x coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per
     *                     second (m/s).
     * @param vy           velocity of body frame y coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per
     *                     second (m/s).
     * @param vz           velocity of body frame z coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per
     *                     second (m/s).
     * @param oldVx        previous velocity of body frame x coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters
     *                     per second (m/s).
     * @param oldVy        previous velocity of body frame y coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters
     *                     per second (m/s).
     * @param oldVz        previous velocity of body frame z coordinate with respect ECEF
     *                     frame, resolved along EVEF-frame axes and expressed in meters
     *                     per second (m/s).
     * @param x            cartesian x coordinate of body position expressed in meters (m)
     *                     with respect ECEF frame, resolved along ECEF-frame axes.
     * @param y            cartesian y coordinate of body position expressed in meters (m)
     *                     with respect ECEF frame, resolved along ECEF-frame axes.
     * @param z            cartesian z coordinate of body position expressed in meters (m)
     *                     with respect ECEF frame, resolved along ECEF-frame axes.
     * @param result       instance where body kinematics estimation will be stored.
     * @throws IllegalArgumentException if provided time interval is negative or coordinated transformation matrices
     *                                  are not ECEF frame valid.
     */
    public void estimate(final double timeInterval,
                         final CoordinateTransformation c,
                         final CoordinateTransformation oldC,
                         final double vx, final double vy, final double vz,
                         final double oldVx, final double oldVy, final double oldVz,
                         final double x, final double y, final double z,
                         final BodyKinematics result) {
        estimateKinematics(timeInterval, c, oldC, vx, vy, vz, oldVx, oldVy, oldVz,
                x, y, z, result);
    }

    /**
     * Estimates body kinematics (specific force applied to a body and its angular rates).
     *
     * @param timeInterval time interval between epochs.
     * @param c            boy-to-ECEF frame coordinate transformation matrix.
     * @param oldC         previous body-to-ECEF-frame coordinate transformation matrix.
     * @param vx           velocity of body frame x coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per
     *                     second (m/s).
     * @param vy           velocity of body frame y coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per
     *                     second (m/s).
     * @param vz           velocity of body frame z coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per
     *                     second (m/s).
     * @param oldVx        previous velocity of body frame x coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters
     *                     per second (m/s).
     * @param oldVy        previous velocity of body frame y coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters
     *                     per second (m/s).
     * @param oldVz        previous velocity of body frame z coordinate with respect ECEF
     *                     frame, resolved along EVEF-frame axes and expressed in meters
     *                     per second (m/s).
     * @param x            cartesian x coordinate of body position expressed in meters (m)
     *                     with respect ECEF frame, resolved along ECEF-frame axes.
     * @param y            cartesian y coordinate of body position expressed in meters (m)
     *                     with respect ECEF frame, resolved along ECEF-frame axes.
     * @param z            cartesian z coordinate of body position expressed in meters (m)
     *                     with respect ECEF frame, resolved along ECEF-frame axes.
     * @param result       instance where body kinematics estimation will be stored.
     * @throws IllegalArgumentException if provided time interval is negative or coordinated transformation matrices
     *                                  are not ECEF frame valid.
     */
    public void estimate(final Time timeInterval,
                         final CoordinateTransformation c,
                         final CoordinateTransformation oldC,
                         final double vx, final double vy, final double vz,
                         final double oldVx, final double oldVy, final double oldVz,
                         final double x, final double y, final double z,
                         final BodyKinematics result) {
        estimateKinematics(timeInterval, c, oldC, vx, vy, vz, oldVx, oldVy, oldVz,
                x, y, z, result);
    }

    /**
     * Estimates body kinematics (specific force applied to a body and its angular rates).
     *
     * @param timeInterval time interval between epochs expressed in seconds (s).
     * @param c            boy-to-ECEF frame coordinate transformation matrix.
     * @param oldC         previous body-to-ECEF-frame coordinate transformation matrix.
     * @param velocity     velocity of body frame with respect ECEF frame.
     * @param oldVelocity  previous velocity of body frame with respect ECEF frame.
     * @param x            cartesian x coordinate of body position expressed in meters (m)
     *                     with respect ECEF frame, resolved along ECEF-frame axes.
     * @param y            cartesian y coordinate of body position expressed in meters (m)
     *                     with respect ECEF frame, resolved along ECEF-frame axes.
     * @param z            cartesian z coordinate of body position expressed in meters (m)
     *                     with respect ECEF frame, resolved along ECEF-frame axes.
     * @param result       instance where body kinematics estimation will be stored.
     * @throws IllegalArgumentException if provided time interval is negative or coordinated transformation matrices
     *                                  are not ECEF frame valid.
     */
    public void estimate(final double timeInterval,
                         final CoordinateTransformation c,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/estimators/ECEFKinematicsEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/estimators/ECEFKinematicsEstimator.html#L454">454</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/estimators/ECIKinematicsEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/estimators/ECIKinematicsEstimator.html#L214">214</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                         final ECEFFrame frame, final ECEFFrame oldFrame,
                         final BodyKinematics result) {
        estimateKinematics(timeInterval, frame, oldFrame, result);
    }

    /**
     * Estimates body kinematics (specific force applied to a body and its angular rates).
     *
     * @param timeInterval time interval between epochs expressed in seconds (s).
     * @param c            body-to-ECEF frame coordinate transformation matrix.
     * @param oldC         previous body-to-ECEF-frame coordinate transformation matrix.
     * @param vx           velocity of body frame x coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param vy           velocity of body frame y coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param vz           velocity of body frame z coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param oldVx        previous velocity of body frame x coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldVy        previous velocity of body frame y coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldVz        previous velocity of body frame z coordinate with respect ECEF
     *                     frame, resolved along EVEF-frame axes.
     * @param x            cartesian x coordinate of body position expressed in meters (m)
     *                     with respect ECEF frame, resolved along ECEF-frame axes.
     * @param y            cartesian y coordinate of body position expressed in meters (m)
     *                     with respect ECEF frame, resolved along ECEF-frame axes.
     * @param z            cartesian z coordinate of body position expressed in meters (m)
     *                     with respect ECEF frame, resolved along ECEF-frame axes.
     * @param result       instance where body kinematics estimation will be stored.
     * @throws IllegalArgumentException if provided time interval is negative or coordinated transformation matrices
     *                                  are not ECEF frame valid.
     */
    public void estimate(final double timeInterval,
                         final CoordinateTransformation c,
                         final CoordinateTransformation oldC,
                         final Speed vx, final Speed vy, final Speed vz,
                         final Speed oldVx, final Speed oldVy, final Speed oldVz,
                         final double x, final double y, final double z,
                         final BodyKinematics result) {
        estimateKinematics(timeInterval, c, oldC, vx, vy, vz, oldVx, oldVy, oldVz,
                x, y, z, result);
    }

    /**
     * Estimates body kinematics (specific force applied to a body and its angular rates).
     *
     * @param timeInterval time interval between epochs.
     * @param c            body-to-ECEF frame coordinate transformation matrix.
     * @param oldC         previous body-to-ECEF-frame coordinate transformation matrix.
     * @param vx           velocity of body frame x coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param vy           velocity of body frame y coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param vz           velocity of body frame z coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param oldVx        previous velocity of body frame x coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldVy        previous velocity of body frame y coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldVz        previous velocity of body frame z coordinate with respect ECEF
     *                     frame, resolved along EVEF-frame axes.
     * @param x            cartesian x coordinate of body position expressed in meters (m)
     *                     with respect ECEF frame, resolved along ECEF-frame axes.
     * @param y            cartesian y coordinate of body position expressed in meters (m)
     *                     with respect ECEF frame, resolved along ECEF-frame axes.
     * @param z            cartesian z coordinate of body position expressed in meters (m)
     *                     with respect ECEF frame, resolved along ECEF-frame axes.
     * @param result       instance where body kinematics estimation will be stored.
     * @throws IllegalArgumentException if provided time interval is negative or coordinated transformation matrices
     *                                  are not ECEF frame valid.
     */
    public void estimate(final Time timeInterval,
                         final CoordinateTransformation c,
                         final CoordinateTransformation oldC,
                         final Speed vx, final Speed vy, final Speed vz,
                         final Speed oldVx, final Speed oldVy, final Speed oldVz,
                         final double x, final double y, final double z,
                         final BodyKinematics result) {
        estimateKinematics(timeInterval, c, oldC, vx, vy, vz,
                oldVx, oldVy, oldVz, x, y, z, result);
    }

    /**
     * Estimates body kinematics (specific force applied to a body and its angular rates).
     *
     * @param timeInterval time interval between epochs expressed in seconds (s).
     * @param c            body-to-ECEF frame coordinate transformation matrix.
     * @param oldC         previous body-to-ECEF-frame coordinate transformation matrix.
     * @param vx           velocity of body frame x coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param vy           velocity of body frame y coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param vz           velocity of body frame z coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param oldVx        previous velocity of body frame x coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldVy        previous velocity of body frame y coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldVz        previous velocity of body frame z coordinate with respect ECEF
     *                     frame, resolved along EVEF-frame axes.
     * @param position     cartesian body position resolved along ECEF-frame axes.
     * @param result       instance where body kinematics estimation will be stored.
     * @throws IllegalArgumentException if provided time interval is negative or coordinated transformation matrices
     *                                  are not ECEF frame valid.
     */
    public void estimate(final double timeInterval,
                         final CoordinateTransformation c,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RangingRadioSourceEstimator2D.html#L174">174</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRangingRadioSourceEstimator2D.html#L696">696</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public RadioSourceLocated&lt;Point2D&gt; getEstimatedRadioSource() {
        List&lt;? extends RangingReadingLocated&lt;S, Point2D&gt;&gt; readings = getReadings();
        if (readings == null || readings.isEmpty()) {
            return null;
        }
        S source = readings.get(0).getSource();

        Point2D estimatedPosition = getEstimatedPosition();
        if (estimatedPosition == null) {
            return null;
        }

        Matrix estimatedPositionCovariance = getEstimatedPositionCovariance();

        if (source instanceof WifiAccessPoint) {
            WifiAccessPoint accessPoint = (WifiAccessPoint)source;
            return new WifiAccessPointLocated2D(accessPoint.getBssid(),
                    accessPoint.getFrequency(), accessPoint.getSsid(),
                    estimatedPosition, estimatedPositionCovariance);
        } else if (source instanceof Beacon) {
            Beacon beacon = (Beacon)source;
            return new BeaconLocated2D(beacon.getIdentifiers(),
                    beacon.getTransmittedPower(), beacon.getFrequency(),
                    beacon.getBluetoothAddress(), beacon.getBeaconTypeCode(),
                    beacon.getManufacturer(), beacon.getServiceUuid(),
                    beacon.getBluetoothName(), estimatedPosition,
                    estimatedPositionCovariance);
        } else {
            return null;
        }
    }

    /**
     * Builds an instance of a linear lateration solver if needed.
     */
    @Override</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RangingRadioSourceEstimator3D.html#L174">174</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRangingRadioSourceEstimator3D.html#L698">698</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public RadioSourceLocated&lt;Point3D&gt; getEstimatedRadioSource() {
        List&lt;? extends RangingReadingLocated&lt;S, Point3D&gt;&gt; readings = getReadings();
        if (readings == null || readings.isEmpty()) {
            return null;
        }
        S source = readings.get(0).getSource();

        Point3D estimatedPosition = getEstimatedPosition();
        if (estimatedPosition == null) {
            return null;
        }

        Matrix estimatedPositionCovariance = getEstimatedPositionCovariance();

        if (source instanceof WifiAccessPoint) {
            WifiAccessPoint accessPoint = (WifiAccessPoint)source;
            return new WifiAccessPointLocated3D(accessPoint.getBssid(),
                    accessPoint.getFrequency(), accessPoint.getSsid(),
                    estimatedPosition, estimatedPositionCovariance);
        } else if (source instanceof Beacon) {
            Beacon beacon = (Beacon)source;
            return new BeaconLocated3D(beacon.getIdentifiers(),
                    beacon.getTransmittedPower(), beacon.getFrequency(),
                    beacon.getBluetoothAddress(), beacon.getBeaconTypeCode(),
                    beacon.getManufacturer(), beacon.getServiceUuid(),
                    beacon.getBluetoothName(), estimatedPosition,
                    estimatedPositionCovariance);
        } else {
            return null;
        }
    }

    /**
     * Builds an instance of a linear lateration solver if needed.
     */
    @Override</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/RobustMixedPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/RobustMixedPositionEstimator3D.html#L980">980</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/RobustRangingAndRssiPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/RobustRangingAndRssiPositionEstimator3D.html#L972">972</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/RobustRssiPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/RobustRssiPositionEstimator3D.html#L972">972</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    }

    /**
     * Sets positions, distances and standard deviations of distances on internal
     * lateration solver.
     *
     * @param positions                     positions to be set.
     * @param distances                     distances to be set.
     * @param distanceStandardDeviations    standard deviations of distances to be set.
     * @param distanceQualityScores         distance quality scores or null if not
     *                                      required.
     */
    @Override
    protected void setPositionsDistancesDistanceStandardDeviationsAndQualityScores(
            List&lt;Point3D&gt; positions, List&lt;Double&gt; distances,
            List&lt;Double&gt; distanceStandardDeviations,
            List&lt;Double&gt; distanceQualityScores) {
        int size = positions.size();
        Point3D[] positionsArray = new InhomogeneousPoint3D[size];
        positionsArray = positions.toArray(positionsArray);

        double[] distancesArray = new double[size];
        double[] distanceStandardDeviationsArray = new double[size];

        double[] qualityScoresArray = null;
        if (distanceQualityScores != null) {
            qualityScoresArray = new double[size];
        }

        for (int i = 0; i &lt; size; i++) {
            distancesArray[i] = distances.get(i);
            distanceStandardDeviationsArray[i] = distanceStandardDeviations.get(i);

            if (qualityScoresArray != null) {
                qualityScoresArray[i] = distanceQualityScores.get(i);
            }
        }

        try {
            mLaterationSolver.setPositionsDistancesAndStandardDeviations(
                    positionsArray, distancesArray, distanceStandardDeviationsArray);

            if (qualityScoresArray != null) {
                mLaterationSolver.setQualityScores(qualityScoresArray);
            }
        } catch (LockedException e) {
            throw new IllegalArgumentException(e);
        }
    }
}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/MixedRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MixedRadioSourceEstimator.html#L1088">1088</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustMixedRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustMixedRadioSourceEstimator.html#L2400">2400</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    private RangingReadingLocated&lt;S, P&gt; createRangingReading(RangingAndRssiReadingLocated&lt;S, P&gt; reading) {
        return new RangingReadingLocated&lt;&gt;(reading.getSource(),
                reading.getDistance(), reading.getPosition(),
                reading.getDistanceStandardDeviation(),
                reading.getPositionCovariance());
    }

    /**
     * Creates an RSSI reading from a ranging and RSSI reading.
     * @param reading input reading to convert from.
     * @return an RSSI reading containing only the RSSI data of input reading.
     */
    private RssiReadingLocated&lt;S, P&gt; createRssiReading(RangingAndRssiReadingLocated&lt;S, P&gt; reading) {
        return new RssiReadingLocated&lt;&gt;(reading.getSource(),
                reading.getRssi(), reading.getPosition(),
                reading.getRssiStandardDeviation(),
                reading.getPositionCovariance());
    }

    /**
     * Checks number of available ranging readings and number of available RSSI readings. Also determines
     * whether position must be estimated using ranging data or RSSI data.
     * @param readings readings to be checked.
     */
    private void checkReadings(List&lt;? extends ReadingLocated&lt;P&gt;&gt; readings) {
        mNumRangingReadings = mNumRssiReadings = 0;

        if (readings == null) {
            return;
        }

        for (ReadingLocated&lt;P&gt; reading : readings) {
            if (reading instanceof RangingReadingLocated) {
                mNumRangingReadings++;

            } else if (reading instanceof RssiReadingLocated) {
                mNumRssiReadings++;

            } else if (reading instanceof RangingAndRssiReadingLocated) {
                mNumRangingReadings++;
                mNumRssiReadings++;
            }
        }

        mRssiPositionEnabled = mNumRangingReadings &lt; getMinRangingReadings();
    }
}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/LinearMixedPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/LinearMixedPositionEstimator2D.html#L155">155</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/LinearRangingAndRssiPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/LinearRangingAndRssiPositionEstimator2D.html#L152">152</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/LinearRangingPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/LinearRangingPositionEstimator2D.html#L152">152</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/LinearRssiPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/LinearRssiPositionEstimator2D.html#L153">153</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>            MixedPositionEstimatorListener&lt;Point2D&gt; listener) {
        super(listener);
        init();
        internalSetSources(sources);
        internalSetFingerprint(fingerprint);
    }

    /**
     * Gets estimated position.
     * @return estimated position.
     */
    @Override
    public Point2D getEstimatedPosition() {
        if(mEstimatedPositionCoordinates == null) {
            return null;
        }

        InhomogeneousPoint2D result = new InhomogeneousPoint2D();
        getEstimatedPosition(result);
        return result;
    }

    /**
     * Sets positions and distances on internal lateration solver.
     * @param positions positions to be set.
     * @param distances distances to be set.
     * @throws IllegalArgumentException if something fails.
     */
    @Override
    @SuppressWarnings(&quot;Duplicates&quot;)
    protected void setPositionsAndDistances(List&lt;Point2D&gt; positions,
                                            List&lt;Double&gt; distances) {
        int size = positions.size();
        Point2D[] positionsArray = new InhomogeneousPoint2D[size];
        positionsArray = positions.toArray(positionsArray);

        double[] distancesArray = new double[size];
        for (int i = 0; i &lt; size; i++) {
            distancesArray[i] = distances.get(i);
        }

        try {
            mHomogeneousTrilaterationSolver.setPositionsAndDistances(positionsArray,
                    distancesArray);
            mInhomogeneousTrilaterationSolver.setPositionsAndDistances(positionsArray,
                    distancesArray);
        } catch (LockedException e) {
            throw new IllegalArgumentException(e);
        }
    }

    /**
     * Initializes lateration solver.
     */
    private void init() {
        mHomogeneousTrilaterationSolver = new HomogeneousLinearLeastSquaresLateration2DSolver(
                mLaterationSolverListener);
        mInhomogeneousTrilaterationSolver = new InhomogeneousLinearLeastSquaresLateration2DSolver(
                mLaterationSolverListener);
    }
}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/LinearMixedPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/LinearMixedPositionEstimator3D.html#L155">155</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/LinearRangingAndRssiPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/LinearRangingAndRssiPositionEstimator3D.html#L155">155</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/LinearRangingPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/LinearRangingPositionEstimator3D.html#L155">155</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/LinearRssiPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/LinearRssiPositionEstimator3D.html#L153">153</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>            MixedPositionEstimatorListener&lt;Point3D&gt; listener) {
        super(listener);
        init();
        internalSetSources(sources);
        internalSetFingerprint(fingerprint);
    }

    /**
     * Gets estimated position.
     * @return estimated position.
     */
    @Override
    public Point3D getEstimatedPosition() {
        if(mEstimatedPositionCoordinates == null) {
            return null;
        }

        InhomogeneousPoint3D result = new InhomogeneousPoint3D();
        getEstimatedPosition(result);
        return result;
    }

    /**
     * Sets positions and distances on internal lateration solver.
     * @param positions positions to be set.
     * @param distances distances to be set.
     * @throws IllegalArgumentException if something fails.
     */
    @Override
    @SuppressWarnings(&quot;Duplicates&quot;)
    protected void setPositionsAndDistances(List&lt;Point3D&gt; positions,
                                            List&lt;Double&gt; distances) {
        int size = positions.size();
        Point3D[] positionsArray = new InhomogeneousPoint3D[size];
        positionsArray = positions.toArray(positionsArray);

        double[] distancesArray = new double[size];
        for (int i = 0; i &lt; size; i++) {
            distancesArray[i] = distances.get(i);
        }

        try {
            mHomogeneousTrilaterationSolver.setPositionsAndDistances(positionsArray,
                    distancesArray);
            mInhomogeneousTrilaterationSolver.setPositionsAndDistances(positionsArray,
                    distancesArray);
        } catch (LockedException e) {
            throw new IllegalArgumentException(e);
        }
    }

    /**
     * Initializes lateration solver.
     */
    private void init() {
        mHomogeneousTrilaterationSolver = new HomogeneousLinearLeastSquaresLateration3DSolver(
                mLaterationSolverListener);
        mInhomogeneousTrilaterationSolver = new InhomogeneousLinearLeastSquaresLateration3DSolver(
                mLaterationSolverListener);
    }
}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/calibration/KnownBiasAndFrameAccelerometerLinearLeastSquaresCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/KnownBiasAndFrameAccelerometerLinearLeastSquaresCalibrator.html#L1348">1348</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/calibration/KnownFrameAccelerometerLinearLeastSquaresCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/KnownFrameAccelerometerLinearLeastSquaresCalibrator.html#L870">870</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>        final double myz = unknowns.getElementAtIndex(5);

        fillMa(sx, sy, sz, mxy, mxz, 0.0, myz, 0.0, 0.0);
    }

    /**
     * Internal method to perform general calibration.
     *
     * @throws AlgebraException if there are numerical errors.
     */
    private void calibrateGeneral() throws AlgebraException {
        // The accelerometer model is:
        // fmeas = ba + (I + Ma) * ftrue + w

        // Ideally a least squares solution tries to minimize noise component, so:
        // fmeas = ba + (I + Ma) * ftrue

        // Hence:
        //  [fmeasx] = [bx] + ( [1  0   0] + [sx    mxy mxz])   [ftruex]
        //  [fmeasy] = [by]     [0  1   0]   [myx   sy  myz]    [ftruey]
        //  [fmeasz] = [bz]     [0  0   1]   [mzx   mzy sz ]    [ftruez]

        //  [fmeasx] = [bx] +   [1+sx   mxy     mxz ][ftruex]
        //  [fmeasy]   [by]     [myx    1+sy    myz ][ftruey]
        //  [fmeasz]   [bz]     [mzx    mzy     1+sz][ftruez]

        //  fmeasx = bx + (1+sx) * ftruex + mxy * ftruey + mxz * ftruez
        //  fmeasy = by + myx * ftruex + (1+sy) * ftruey + myz * ftruez
        //  fmeasz = bz + mzx * ftruex + mzy * ftruey + (1+sz) * ftruez

        // Where the unknowns are: sx, sy, sz, mxy mxz, myx, myz, mzx, mzy
        // Reordering:
        //  fmeasx = bx + ftruex + sx * ftruex + mxy * ftruey + mxz * ftruez
        //  fmeasy = by + myx * ftruex + ftruey + sy * ftruey + myz * ftruez
        //  fmeasz = bz + mzx * ftruex + mzy * ftruey + ftruez + sz * ftruez

        //  fmeasx - ftruex - bx = sx * ftruex + mxy * ftruey + mxz * ftruez
        //  fmeasy - ftruey - by = myx * ftruex + sy * ftruey + myz * ftruez
        //  fmeasz - ftruez - bz = mzx * ftruex + mzy * ftruey + sz * ftruez

        // [ftruex  0       0       ftruey  ftruez  0       0       0       0     ][sx ] = [fmeasx - ftruex - bx]
        // [0       ftruey  0       0       0       ftruex  ftruez  0       0     ][sy ]   [fmeasy - ftruey - by]
        // [0       0       ftruez  0       0       0       0       ftruex  ftruey][sz ]   [fmeasz - ftruez - bz]
        //                                                                         [mxy]
        //                                                                         [mxz]
        //                                                                         [myx]
        //                                                                         [myz]
        //                                                                         [mzx]
        //                                                                         [mzy]

        final BodyKinematics expectedKinematics = new BodyKinematics();

        final int rows = EQUATIONS_PER_MEASUREMENT * mMeasurements.size();
        final Matrix a = new Matrix(rows, GENERAL_UNKNOWNS);
        final Matrix b = new Matrix(rows, 1);
        int i = 0;
        for (final FrameBodyKinematics measurement : mMeasurements) {
            final BodyKinematics measuredKinematics = measurement.getKinematics();
            final ECEFFrame ecefFrame = measurement.getFrame();
            final ECEFFrame previousEcefFrame = measurement.getPreviousFrame();
            final double timeInterval = measurement.getTimeInterval();

            ECEFKinematicsEstimator.estimateKinematics(timeInterval, ecefFrame,
                    previousEcefFrame, expectedKinematics);

            final double fMeasX = measuredKinematics.getFx();
            final double fMeasY = measuredKinematics.getFy();
            final double fMeasZ = measuredKinematics.getFz();

            final double fTrueX = expectedKinematics.getFx();
            final double fTrueY = expectedKinematics.getFy();
            final double fTrueZ = expectedKinematics.getFz();

            a.setElementAt(i, 0, fTrueX);</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/RobustMixedPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/RobustMixedPositionEstimator3D.html#L993">993</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/RobustRangingAndRssiPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/RobustRangingAndRssiPositionEstimator3D.html#L985">985</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/RobustRangingPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/RobustRangingPositionEstimator3D.html#L994">994</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/RobustRssiPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/RobustRssiPositionEstimator3D.html#L984">984</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    protected void setPositionsDistancesDistanceStandardDeviationsAndQualityScores(
            List&lt;Point3D&gt; positions, List&lt;Double&gt; distances,
            List&lt;Double&gt; distanceStandardDeviations,
            List&lt;Double&gt; distanceQualityScores) {
        int size = positions.size();
        Point3D[] positionsArray = new InhomogeneousPoint3D[size];
        positionsArray = positions.toArray(positionsArray);

        double[] distancesArray = new double[size];
        double[] distanceStandardDeviationsArray = new double[size];

        double[] qualityScoresArray = null;
        if (distanceQualityScores != null) {
            qualityScoresArray = new double[size];
        }

        for (int i = 0; i &lt; size; i++) {
            distancesArray[i] = distances.get(i);
            distanceStandardDeviationsArray[i] = distanceStandardDeviations.get(i);

            if (qualityScoresArray != null) {
                qualityScoresArray[i] = distanceQualityScores.get(i);
            }
        }

        try {
            mLaterationSolver.setPositionsDistancesAndStandardDeviations(
                    positionsArray, distancesArray, distanceStandardDeviationsArray);

            if (qualityScoresArray != null) {
                mLaterationSolver.setQualityScores(qualityScoresArray);
            }
        } catch (LockedException e) {
            throw new IllegalArgumentException(e);
        }
    }
}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/SequentialRobustMixedPositionEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/SequentialRobustMixedPositionEstimator.html#L2026">2026</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/SequentialRobustRangingAndRssiPositionEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/SequentialRobustRangingAndRssiPositionEstimator.html#L1909">1909</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    private void internalSetFingerprint(Fingerprint&lt;? extends RadioSource, ? extends Reading&lt;? extends RadioSource&gt;&gt; fingerprint) {
        if (fingerprint == null) {
            throw new IllegalArgumentException();
        }

        mFingerprint = fingerprint;
    }

    /**
     * Sets quality scores corresponding to each provided located radio source.
     * This method is used internally and does not check whether instance is
     * locked or not.
     * @param sourceQualityScores quality scores to be set.
     * @throws IllegalArgumentException if provided quality scores length is
     * smaller than 3 samples for 2D or 4 samples for 3D.
     */
    private void internalSetSourceQualityScores(double[] sourceQualityScores) {
        if (sourceQualityScores == null ||
                sourceQualityScores.length &lt; getMinRequiredSources()) {
            throw new IllegalArgumentException();
        }

        mSourceQualityScores = sourceQualityScores;
    }

    /**
     * Sets quality scores corresponding to each provided reading within provided
     * fingerprint.
     * This method is used internally and does not check whether instance is locked
     * or not.
     * @param fingerprintReadingsQualityScores quality scores to be set.
     * @throws IllegalArgumentException if provided quality scores length is smaller
     * than 3 samples for 2D or 4 samples for 3D.
     */
    private void internalSetFingerprintReadingsQualityScores(
            double[] fingerprintReadingsQualityScores) {
        if (fingerprintReadingsQualityScores == null ||
                fingerprintReadingsQualityScores.length &lt; getMinRequiredSources()) {
            throw new IllegalArgumentException();
        }

        mFingerprintReadingsQualityScores = fingerprintReadingsQualityScores;
    }

    /**
     * Creates a ranging reading from a ranging and RSSI reading.
     *
     * @param reading input reading to convert from.
     * @return a ranging reading containing only the ranging data of input reading.
     */
    private RangingReading&lt;RadioSource&gt; createRangingReading(
            RangingAndRssiReading&lt;? extends RadioSource&gt; reading) {
        return new RangingReading&lt;&gt;(reading.getSource(),
                reading.getDistance(),
                reading.getDistanceStandardDeviation(),
                reading.getNumAttemptedMeasurements(),
                reading.getNumSuccessfulMeasurements());
    }

    /**
     * Creates an RSSI reading from a ranging and RSSI reading.
     *
     * @param reading input reading to convert from.
     * @return an RSSI reading containing only the RSSI data of input reading.
     */
    private RssiReading&lt;RadioSource&gt; createRssiReading(
            RangingAndRssiReading&lt;? extends RadioSource&gt; reading) {
        return new RssiReading&lt;&gt;(reading.getSource(), reading.getRssi(),
                reading.getRssiStandardDeviation());
    }</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/estimators/ECEFKinematicsEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/estimators/ECEFKinematicsEstimator.html#L1415">1415</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/estimators/ECIKinematicsEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/estimators/ECIKinematicsEstimator.html#L749">749</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>                                               final ECEFFrame frame,
                                               final CoordinateTransformation oldC,
                                               final Speed oldVx, final Speed oldVy, final Speed oldVz) {
        return estimateKinematicsAndReturnNew(timeInterval, frame, oldC, oldVx, oldVy, oldVz);
    }

    /**
     * Estimates body kinematics (specific force applied to a body and its angular rates).
     *
     * @param timeInterval time interval between epochs expressed in seconds (s).
     * @param c            body-to-ECEF frame coordinate transformation matrix.
     * @param oldC         previous body-to-ECEF-frame coordinate transformation matrix.
     * @param vx           velocity of body frame x coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per
     *                     second (m/s).
     * @param vy           velocity of body frame y coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per
     *                     second (m/s).
     * @param vz           velocity of body frame z coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per
     *                     second (m/s).
     * @param oldVx        previous velocity of body frame x coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters
     *                     per second (m/s).
     * @param oldVy        previous velocity of body frame y coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters
     *                     per second (m/s).
     * @param oldVz        previous velocity of body frame z coordinate with respect ECEF
     *                     frame, resolved along EVEF-frame axes and expressed in meters
     *                     per second (m/s).
     * @param position     body position expressed in meters (m) with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @return a new body kinematics instance.
     * @throws IllegalArgumentException if provided time interval is negative or coordinated transformation matrices
     *                                  are not ECEF frame valid.
     */
    public BodyKinematics estimateAndReturnNew(final double timeInterval,
                                               final CoordinateTransformation c,
                                               final CoordinateTransformation oldC,
                                               final double vx, final double vy, final double vz,
                                               final double oldVx, final double oldVy, final double oldVz,
                                               final Point3D position) {
        return estimateKinematicsAndReturnNew(timeInterval, c, oldC, vx, vy, vz,
                oldVx, oldVy, oldVz, position);
    }

    /**
     * Estimates body kinematics (specific force applied to a body and its angular rates).
     *
     * @param timeInterval time interval between epochs.
     * @param c            body-to-ECEF frame coordinate transformation matrix.
     * @param oldC         previous body-to-ECEF-frame coordinate transformation matrix.
     * @param vx           velocity of body frame x coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per
     *                     second (m/s).
     * @param vy           velocity of body frame y coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per
     *                     second (m/s).
     * @param vz           velocity of body frame z coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per
     *                     second (m/s).
     * @param oldVx        previous velocity of body frame x coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters
     *                     per second (m/s).
     * @param oldVy        previous velocity of body frame y coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters
     *                     per second (m/s).
     * @param oldVz        previous velocity of body frame z coordinate with respect ECEF
     *                     frame, resolved along EVEF-frame axes and expressed in meters
     *                     per second (m/s).
     * @param position     body position expressed in meters (m) with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @return a new body kinematics instance.
     * @throws IllegalArgumentException if provided time interval is negative or coordinated transformation matrices
     *                                  are not ECEF frame valid.
     */
    public BodyKinematics estimateAndReturnNew(final Time timeInterval,
                                               final CoordinateTransformation c,
                                               final CoordinateTransformation oldC,
                                               final double vx, final double vy, final double vz,
                                               final double oldVx, final double oldVy, final double oldVz,
                                               final Point3D position) {
        return estimateKinematicsAndReturnNew(timeInterval, c, oldC, vx, vy, vz, oldVx, oldVy, oldVz,
                position);
    }

    /**
     * Estimates body kinematics (specific force applied to a body and its angular rates).
     *
     * @param timeInterval time interval between epochs expressed in seconds (s).
     * @param c            body-to-ECEF frame coordinate transformation matrix.
     * @param oldC         previous body-to-ECEF-frame coordinate transformation matrix.
     * @param velocity     velocity of body frame with respect ECEF frame.
     * @param oldVelocity  previous velocity of body frame with respect ECEF frame.
     * @param position     body position expressed in meters (m) with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @return a new body kinematics instance.
     * @throws IllegalArgumentException if provided time interval is negative or coordinated transformation matrices
     *                                  are not ECEF frame valid.
     */
    public BodyKinematics estimateAndReturnNew(final double timeInterval,
                                               final CoordinateTransformation c,
                                               final CoordinateTransformation oldC,
                                               final ECEFVelocity velocity,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator2D.html#L831">831</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator3D.html#L831">831</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator2D.html#L842">842</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator3D.html#L841">841</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>            RobustRangingAndRssiRadioSourceEstimatorListener&lt;S, Point2D&gt; listener) {
        super(readings, initialPosition, initialTransmittedPowerdBm,
                initialPathLossExponent, listener);
        internalSetQualityScores(qualityScores);
    }

    /**
     * Returns threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value, the
     * algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algorithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @return stop threshold to stop the algorithm prematurely when a certain
     * accuracy has been reached.
     */
    public double getStopThreshold() {
        return mStopThreshold;
    }

    /**
     * Sets threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value,
     * the algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algorithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @param stopThreshold stop threshold to stop the algorithm prematurely
     *                      when a certain accuracy has been reached.
     * @throws IllegalArgumentException if provided value is zero or negative.
     * @throws LockedException if this solver is locked.
     */
    public void setStopThreshold(double stopThreshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (stopThreshold &lt;= MIN_STOP_THRESHOLD) {
            throw new IllegalArgumentException();
        }

        mStopThreshold = stopThreshold;
    }

    /**
     * Returns quality scores corresponding to each pair of
     * positions and distances (i.e. sample).
     * The larger the score value the better the quality of the sample.
     * This implementation always returns null.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @return quality scores corresponding to each sample.
     */
    @Override
    public double[] getQualityScores() {
        return mQualityScores;
    }

    /**
     * Sets quality scores corresponding to each pair of positions and
     * distances (i.e. sample).
     * The larger the score value the better the quality of the sample.
     * This implementation makes no action.
     * Subclasses using quality scores must implement proper behaviour.
     *
     * @param qualityScores quality scores corresponding to each pair of
     *                      matched points.
     * @throws IllegalArgumentException if provided quality scores length
     * is smaller than minimum required samples.
     * @throws LockedException if robust solver is locked because an
     * estimation is already in progress.
     */
    public void setQualityScores(double[] qualityScores) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetQualityScores(qualityScores);
    }

    /**
     * Indicates whether solver is ready to find a solution.
     *
     * @return true if solver is ready, false otherwise.
     */
    @Override
    public boolean isReady() {
        return super.isReady() &amp;&amp; mQualityScores != null &amp;&amp;
                mQualityScores.length == mReadings.size();
    }

    /**
     * Robustly estimates position, transmitted power and pathloss exponent for a
     * radio source.
     *
     * @throws LockedException if instance is busy during estimation.
     * @throws NotReadyException if estimator is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     * (i.e. numerical instability, no solution available, etc).
     */
    @Override
    public void estimate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        PROMedSRobustEstimator&lt;Solution&lt;Point2D&gt;&gt; innerEstimator =</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/calibration/KnownBiasAndFrameAccelerometerLinearLeastSquaresCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/KnownBiasAndFrameAccelerometerLinearLeastSquaresCalibrator.html#L1290">1290</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/calibration/KnownBiasAndFrameAccelerometerLinearLeastSquaresCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/KnownBiasAndFrameAccelerometerLinearLeastSquaresCalibrator.html#L1401">1401</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>        final Matrix a = new Matrix(rows, COMMON_Z_AXIS_UNKNOWNS);
        final Matrix b = new Matrix(rows, 1);
        int i = 0;
        for (final FrameBodyKinematics measurement : mMeasurements) {
            final BodyKinematics measuredKinematics = measurement.getKinematics();
            final ECEFFrame ecefFrame = measurement.getFrame();
            final ECEFFrame previousEcefFrame = measurement.getPreviousFrame();
            final double timeInterval = measurement.getTimeInterval();

            ECEFKinematicsEstimator.estimateKinematics(timeInterval, ecefFrame,
                    previousEcefFrame, expectedKinematics);

            final double fMeasX = measuredKinematics.getFx();
            final double fMeasY = measuredKinematics.getFy();
            final double fMeasZ = measuredKinematics.getFz();

            final double fTrueX = expectedKinematics.getFx();
            final double fTrueY = expectedKinematics.getFy();
            final double fTrueZ = expectedKinematics.getFz();

            a.setElementAt(i, 0, fTrueX);
            a.setElementAt(i, 1, 0.0);
            a.setElementAt(i, 2, 0.0);
            a.setElementAt(i, 3, fTrueY);
            a.setElementAt(i, 4, fTrueZ);
            a.setElementAt(i, 5, 0.0);</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/NonLinearMixedPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/NonLinearMixedPositionEstimator2D.html#L299">299</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/NonLinearRangingAndRssiPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/NonLinearRangingAndRssiPositionEstimator2D.html#L298">298</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/NonLinearRangingPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/NonLinearRangingPositionEstimator2D.html#L299">299</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/NonLinearRssiPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/NonLinearRssiPositionEstimator2D.html#L300">300</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    public Point2D getEstimatedPosition() {
        if (mEstimatedPositionCoordinates == null) {
            return null;
        }

        InhomogeneousPoint2D result = new InhomogeneousPoint2D();
        getEstimatedPosition(result);
        return result;
    }

    /**
     * Sets positions, distances and standard deviations of distances on internal
     * lateration solver.
     *
     * @param positions positions to be set.
     * @param distances distances to be set.
     * @param distanceStandardDeviations standard deviations of distances to be set.
     */
    @Override
    @SuppressWarnings(&quot;Duplicates&quot;)
    protected void setPositionsDistancesAndDistanceStandardDeviations(
            List&lt;Point2D&gt; positions, List&lt;Double&gt; distances,
            List&lt;Double&gt; distanceStandardDeviations) {

        int size = positions.size();
        Point2D[] positionsArray = new InhomogeneousPoint2D[size];
        positionsArray = positions.toArray(positionsArray);

        double[] distancesArray = new double[size];
        double[] distanceStandardDeviationsArray = new double[size];
        for (int i = 0; i &lt; size; i++) {
            distancesArray[i] = distances.get(i);
            distanceStandardDeviationsArray[i] = distanceStandardDeviations.get(i);
        }

        try {
            mTrilaterationSolver.setPositionsDistancesAndStandardDeviations(
                    positionsArray, distancesArray, distanceStandardDeviationsArray);
        } catch (LockedException e) {
            throw new IllegalArgumentException(e);
        }
    }

    /**
     * Initializes lateration solver.
     */
    private void init() {
        mTrilaterationSolver = new NonLinearLeastSquaresLateration2DSolver(
                mLaterationSolverListener);
    }
}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/NonLinearMixedPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/NonLinearMixedPositionEstimator3D.html#L302">302</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/NonLinearRangingAndRssiPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/NonLinearRangingAndRssiPositionEstimator3D.html#L302">302</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/NonLinearRangingPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/NonLinearRangingPositionEstimator3D.html#L299">299</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/NonLinearRssiPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/NonLinearRssiPositionEstimator3D.html#L301">301</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    public Point3D getEstimatedPosition() {
        if (mEstimatedPositionCoordinates == null) {
            return null;
        }

        InhomogeneousPoint3D result = new InhomogeneousPoint3D();
        getEstimatedPosition(result);
        return result;
    }

    /**
     * Sets positions, distances and standard deviations of distances on internal
     * lateration solver.
     *
     * @param positions positions to be set.
     * @param distances distances to be set.
     * @param distanceStandardDeviations standard deviations of distances to be set.
     */
    @Override
    @SuppressWarnings(&quot;Duplicates&quot;)
    protected void setPositionsDistancesAndDistanceStandardDeviations(
            List&lt;Point3D&gt; positions, List&lt;Double&gt; distances,
            List&lt;Double&gt; distanceStandardDeviations) {

        int size = positions.size();
        Point3D[] positionsArray = new InhomogeneousPoint3D[size];
        positionsArray = positions.toArray(positionsArray);

        double[] distancesArray = new double[size];
        double[] distanceStandardDeviationsArray = new double[size];
        for (int i = 0; i &lt; size; i++) {
            distancesArray[i] = distances.get(i);
            distanceStandardDeviationsArray[i] = distanceStandardDeviations.get(i);
        }

        try {
            mTrilaterationSolver.setPositionsDistancesAndStandardDeviations(
                    positionsArray, distancesArray, distanceStandardDeviationsArray);
        } catch (LockedException e) {
            throw new IllegalArgumentException(e);
        }
    }

    /**
     * Initializes lateration solver.
     */
    private void init() {
        mTrilaterationSolver = new NonLinearLeastSquaresLateration3DSolver(
                mLaterationSolverListener);
    }
}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/MixedRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MixedRadioSourceEstimator2D.html#L351">351</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustMixedRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustMixedRadioSourceEstimator2D.html#L847">847</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    public RadioSourceLocated&lt;Point2D&gt; getEstimatedRadioSource() {
        List&lt;? extends ReadingLocated&lt;Point2D&gt;&gt; readings = getReadings();
        if (readings == null || readings.isEmpty()) {
            return null;
        }

        S source;
        ReadingLocated&lt;Point2D&gt; reading = readings.get(0);
        if (reading instanceof RangingReadingLocated) {
            source = ((RangingReadingLocated&lt;S, Point2D&gt;)reading).getSource();
        } else if (reading instanceof RssiReadingLocated) {
            source = ((RssiReadingLocated&lt;S, Point2D&gt;)reading).getSource();
        } else if (reading instanceof RangingAndRssiReadingLocated) {
            source = ((RangingAndRssiReadingLocated&lt;S, Point2D&gt;)reading).getSource();
        } else {
            return null;
        }

        Point2D estimatedPosition = getEstimatedPosition();
        if (estimatedPosition == null) {
            return null;
        }

        Matrix estimatedPositionCovariance = getEstimatedPositionCovariance();

        Double transmittedPowerdBm = getEstimatedTransmittedPowerdBm();

        Double transmittedPowerVariance = getEstimatedTransmittedPowerVariance();
        Double transmittedPowerStandardDeviation = transmittedPowerVariance != null ?
                Math.sqrt(transmittedPowerVariance) : null;</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/MixedRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MixedRadioSourceEstimator3D.html#L351">351</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustMixedRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustMixedRadioSourceEstimator3D.html#L849">849</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    public RadioSourceLocated&lt;Point3D&gt; getEstimatedRadioSource() {
        List&lt;? extends ReadingLocated&lt;Point3D&gt;&gt; readings = getReadings();
        if (readings == null || readings.isEmpty()) {
            return null;
        }

        S source;
        ReadingLocated&lt;Point3D&gt; reading = readings.get(0);
        if (reading instanceof RangingReadingLocated) {
            source = ((RangingReadingLocated&lt;S, Point3D&gt;)reading).getSource();
        } else if (reading instanceof RssiReadingLocated) {
            source = ((RssiReadingLocated&lt;S, Point3D&gt;)reading).getSource();
        } else if (reading instanceof RangingAndRssiReadingLocated) {
            source = ((RangingAndRssiReadingLocated&lt;S, Point3D&gt;)reading).getSource();
        } else {
            return null;
        }

        Point3D estimatedPosition = getEstimatedPosition();
        if (estimatedPosition == null) {
            return null;
        }

        Matrix estimatedPositionCovariance = getEstimatedPositionCovariance();

        Double transmittedPowerdBm = getEstimatedTransmittedPowerdBm();

        Double transmittedPowerVariance = getEstimatedTransmittedPowerVariance();
        Double transmittedPowerStandardDeviation = transmittedPowerVariance != null ?
                Math.sqrt(transmittedPowerVariance) : null;</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator2D.html#L2889">2889</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator2D.html#L2863">2863</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>                    mUseReadingPositionCovariances);

            mInnerEstimator.estimate();

            Point2D estimatedPosition = mInnerEstimator.getEstimatedPosition();
            double estimatedTransmittedPowerdBm =
                    mInnerEstimator.getEstimatedTransmittedPowerdBm();
            double estimatedPathLossExponent =
                    mInnerEstimator.getEstimatedPathLossExponent();
            solutions.add(new Solution&lt;&gt;(estimatedPosition,
                    estimatedTransmittedPowerdBm, estimatedPathLossExponent));
        } catch(NavigationException ignore) {
            //if anything fails, no solution is added
        }
    }

    /**
     * Attempts to refine estimated position and transmitted power contained in
     * provided solution if refinement is requested.
     * This method sets a refined result and transmitted power or provided input
     * result if refinement is not requested or has failed.
     * If refinement is enabled and it is requested to keep covariance, this method
     * will also keep covariance of refined result.
     * solution if not requested or refinement failed.
     *
     * @param result result to be refined.
     */
    protected void attemptRefine(Solution&lt;Point2D&gt; result) {
        Point2D initialPosition = result.getEstimatedPosition();
        double initialTransmittedPowerdBm =
                result.getEstimatedTransmittedPowerdBm();
        double initialPathLossExponent = result.getEstimatedPathLossExponent();

        if (mRefineResult &amp;&amp; mInliersData != null) {
            BitSet inliers = mInliersData.getInliers();
            int nSamples = mReadings.size();

            mInnerReadings.clear();

            for (int i = 0; i &lt; nSamples; i++) {
                if (inliers.get(i)) {
                    //sample is inlier
                    mInnerReadings.add(mReadings.get(i));
                }
            }

            try {
                mInnerEstimator.setInitialPosition(initialPosition);
                mInnerEstimator.setInitialTransmittedPowerdBm(initialTransmittedPowerdBm);
                mInnerEstimator.setInitialPathLossExponent(initialPathLossExponent);
                mInnerEstimator.setTransmittedPowerEstimationEnabled(
                        mTransmittedPowerEstimationEnabled);
                mInnerEstimator.setPathLossEstimationEnabled(</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator3D.html#L2891">2891</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator3D.html#L2863">2863</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>                    mUseReadingPositionCovariances);

            mInnerEstimator.estimate();

            Point3D estimatedPosition = mInnerEstimator.getEstimatedPosition();
            double estimatedTransmittedPowerdBm =
                    mInnerEstimator.getEstimatedTransmittedPowerdBm();
            double estimatedPathLossExponent =
                    mInnerEstimator.getEstimatedPathLossExponent();
            solutions.add(new Solution&lt;&gt;(estimatedPosition,
                    estimatedTransmittedPowerdBm, estimatedPathLossExponent));
        } catch(NavigationException ignore) {
            //if anything fails, no solution is added
        }
    }

    /**
     * Attempts to refine estimated position and transmitted power contained in
     * provided solution if refinement is requested.
     * This method sets a refined result and transmitted power or provided input
     * result if refinement is not requested or has failed.
     * If refinement is enabled and it is requested to keep covariance, this method
     * will also keep covariance of refined result.
     * solution if not requested or refinement failed.
     *
     * @param result result to be refined.
     */
    protected void attemptRefine(Solution&lt;Point3D&gt; result) {
        Point3D initialPosition = result.getEstimatedPosition();
        double initialTransmittedPowerdBm =
                result.getEstimatedTransmittedPowerdBm();
        double initialPathLossExponent = result.getEstimatedPathLossExponent();

        if (mRefineResult &amp;&amp; mInliersData != null) {
            BitSet inliers = mInliersData.getInliers();
            int nSamples = mReadings.size();

            mInnerReadings.clear();

            for (int i = 0; i &lt; nSamples; i++) {
                if (inliers.get(i)) {
                    //sample is inlier
                    mInnerReadings.add(mReadings.get(i));
                }
            }

            try {
                mInnerEstimator.setInitialPosition(initialPosition);
                mInnerEstimator.setInitialTransmittedPowerdBm(initialTransmittedPowerdBm);
                mInnerEstimator.setInitialPathLossExponent(initialPathLossExponent);
                mInnerEstimator.setTransmittedPowerEstimationEnabled(
                        mTransmittedPowerEstimationEnabled);
                mInnerEstimator.setPathLossEstimationEnabled(</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/calibration/KnownBiasAndFrameAccelerometerNonLinearLeastSquaresCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/KnownBiasAndFrameAccelerometerNonLinearLeastSquaresCalibrator.html#L3060">3060</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/calibration/KnownFrameAccelerometerNonLinearLeastSquaresCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/KnownFrameAccelerometerNonLinearLeastSquaresCalibrator.html#L3548">3548</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>        if (mEstimatedMa == null) {
            mEstimatedMa = new Matrix(BodyKinematics.COMPONENTS,
                    BodyKinematics.COMPONENTS);
        } else {
            mEstimatedMa.initialize(0.0);
        }

        mEstimatedMa.setElementAt(0, 0, sx);

        mEstimatedMa.setElementAt(0, 1, mxy);
        mEstimatedMa.setElementAt(1, 1, sy);

        mEstimatedMa.setElementAt(0, 2, mxz);
        mEstimatedMa.setElementAt(1, 2, myz);
        mEstimatedMa.setElementAt(2, 2, sz);

        mEstimatedCovariance = mFitter.getCovar();
        mEstimatedChiSq = mFitter.getChisq();
    }

    /**
     * Internal method to perform general calibration.
     *
     * @throws AlgebraException                         if there are numerical errors.
     * @throws FittingException                         if no convergence to solution is found.
     * @throws com.irurueta.numerical.NotReadyException if fitter is not ready.
     */
    private void calibrateGeneral() throws AlgebraException, FittingException,
            com.irurueta.numerical.NotReadyException {
        // The accelerometer model is:
        // fmeas = ba + (I + Ma) * ftrue + w

        // Ideally a least squares solution tries to minimize noise component, so:
        // fmeas = ba + (I + Ma) * ftrue

        // Hence:
        //  [fmeasx] = [bx] + ( [1  0   0] + [sx    mxy mxz])   [ftruex]
        //  [fmeasy] = [by]     [0  1   0]   [myx   sy  myz]    [ftruey]
        //  [fmeasz] = [bz]     [0  0   1]   [mzx   mzy sz ]    [ftruez]

        //  [fmeasx] = [bx] +   [1+sx   mxy     mxz ][ftruex]
        //  [fmeasy]   [by]     [myx    1+sy    myz ][ftruey]
        //  [fmeasz]   [bz]     [mzx    mzy     1+sz][ftruez]

        //  fmeasx = bx + (1+sx) * ftruex + mxy * ftruey + mxz * ftruez
        //  fmeasy = by + myx * ftruex + (1+sy) * ftruey + myz * ftruez
        //  fmeasz = bz + mzx * ftruex + mzy * ftruey + (1+sz) * ftruez

        // Where the unknowns are: sx, sy, sz, mxy mxz, myx, myz, mzx, mzy
        // Reordering:
        //  fmeasx = bx + ftruex + sx * ftruex + mxy * ftruey + mxz * ftruez
        //  fmeasy = by + myx * ftruex + ftruey + sy * ftruey + myz * ftruez
        //  fmeasz = bz + mzx * ftruex + mzy * ftruey + ftruez + sz * ftruez

        //  fmeasx - ftruex - bx = sx * ftruex + mxy * ftruey + mxz * ftruez
        //  fmeasy - ftruey - by = myx * ftruex + sy * ftruey + myz * ftruez
        //  fmeasz - ftruez - bz = mzx * ftruex + mzy * ftruey + sz * ftruez

        // [ftruex  0       0       ftruey  ftruez  0       0       0       0     ][sx ] = [fmeasx - ftruex - bx]
        // [0       ftruey  0       0       0       ftruex  ftruez  0       0     ][sy ]   [fmeasy - ftruey - by]
        // [0       0       ftruez  0       0       0       0       ftruex  ftruey][sz ]   [fmeasz - ftruez - bz]
        //                                                                         [mxy]
        //                                                                         [mxz]
        //                                                                         [myx]
        //                                                                         [myz]
        //                                                                         [mzx]
        //                                                                         [mzy]

        mFitter.setFunctionEvaluator(new LevenbergMarquardtMultiVariateFunctionEvaluator() {
            @Override
            public int getNumberOfDimensions() {
                // Input points are true specific force coordinates
                return BodyKinematics.COMPONENTS;
            }

            @Override
            public int getNumberOfVariables() {
                // The multivariate function returns the components of measured specific force
                return BodyKinematics.COMPONENTS;
            }

            @Override
            public double[] createInitialParametersArray() {
                final double[] initial = new double[GENERAL_UNKNOWNS];

                initial[0] = mInitialSx;</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/estimators/ECEFKinematicsEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/estimators/ECEFKinematicsEstimator.html#L1229">1229</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/estimators/ECIKinematicsEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/estimators/ECIKinematicsEstimator.html#L629">629</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>                                               final ECEFFrame oldFrame) {
        return estimateKinematicsAndReturnNew(timeInterval, frame, oldFrame);
    }

    /**
     * Estimates body kinematics (specific force applied to a body and its angular rates).
     *
     * @param timeInterval time interval between epochs expressed in seconds (s).
     * @param c            body-to-ECEF frame coordinate transformation matrix.
     * @param oldC         previous body-to-ECEF-frame coordinate transformation matrix.
     * @param vx           velocity of body frame x coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param vy           velocity of body frame y coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param vz           velocity of body frame z coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param oldVx        previous velocity of body frame x coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldVy        previous velocity of body frame y coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldVz        previous velocity of body frame z coordinate with respect ECEF
     *                     frame, resolved along EVEF-frame axes.
     * @param x            cartesian x coordinate of body position expressed in meters (m)
     *                     with respect ECEF frame, resolved along ECEF-frame axes.
     * @param y            cartesian y coordinate of body position expressed in meters (m)
     *                     with respect ECEF frame, resolved along ECEF-frame axes.
     * @param z            cartesian z coordinate of body position expressed in meters (m)
     *                     with respect ECEF frame, resolved along ECEF-frame axes.
     * @return a new body kinematics instance.
     * @throws IllegalArgumentException if provided time interval is negative or coordinated transformation matrices
     *                                  are not ECEF frame valid.
     */
    public BodyKinematics estimateAndReturnNew(final double timeInterval,
                                               final CoordinateTransformation c,
                                               final CoordinateTransformation oldC,
                                               final Speed vx, final Speed vy, final Speed vz,
                                               final Speed oldVx, final Speed oldVy, final Speed oldVz,
                                               final double x, final double y, final double z) {
        return estimateKinematicsAndReturnNew(timeInterval, c, oldC, vx, vy, vz,
                oldVx, oldVy, oldVz, x, y, z);
    }

    /**
     * Estimates body kinematics (specific force applied to a body and its angular rates).
     *
     * @param timeInterval time interval between epochs.
     * @param c            body-to-ECEF frame coordinate transformation matrix.
     * @param oldC         previous body-to-ECEF-frame coordinate transformation matrix.
     * @param vx           velocity of body frame x coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param vy           velocity of body frame y coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param vz           velocity of body frame z coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param oldVx        previous velocity of body frame x coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldVy        previous velocity of body frame y coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldVz        previous velocity of body frame z coordinate with respect ECEF
     *                     frame, resolved along EVEF-frame axes.
     * @param x            cartesian x coordinate of body position expressed in meters (m)
     *                     with respect ECEF frame, resolved along ECEF-frame axes.
     * @param y            cartesian y coordinate of body position expressed in meters (m)
     *                     with respect ECEF frame, resolved along ECEF-frame axes.
     * @param z            cartesian z coordinate of body position expressed in meters (m)
     *                     with respect ECEF frame, resolved along ECEF-frame axes.
     * @return a new body kinematics instance.
     * @throws IllegalArgumentException if provided time interval is negative or coordinated transformation matrices
     *                                  are not ECEF frame valid.
     */
    public BodyKinematics estimateAndReturnNew(final Time timeInterval,
                                               final CoordinateTransformation c,
                                               final CoordinateTransformation oldC,
                                               final Speed vx, final Speed vy, final Speed vz,
                                               final Speed oldVx, final Speed oldVy, final Speed oldVz,
                                               final double x, final double y, final double z) {
        return estimateKinematicsAndReturnNew(timeInterval, c, oldC, vx, vy, vz,
                oldVx, oldVy, oldVz, x, y, z);
    }

    /**
     * Estimates body kinematics (specific force applied to a body and its angular rates).
     *
     * @param timeInterval time interval between epochs expressed in seconds (s).
     * @param c            body-to-ECEF frame coordinate transformation matrix.
     * @param oldC         previous body-to-ECEF-frame coordinate transformation matrix.
     * @param vx           velocity of body frame x coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param vy           velocity of body frame y coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param vz           velocity of body frame z coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param oldVx        previous velocity of body frame x coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldVy        previous velocity of body frame y coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldVz        previous velocity of body frame z coordinate with respect ECEF
     *                     frame, resolved along EVEF-frame axes.
     * @param position     cartesian body position resolved along ECEF-frame axes.
     * @return a new body kinematics instance.
     * @throws IllegalArgumentException if provided time interval is negative or coordinated transformation matrices
     *                                  are not ECEF frame valid.
     */
    public BodyKinematics estimateAndReturnNew(final double timeInterval,
                                               final CoordinateTransformation c,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator2D.html#L328">328</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator3D.html#L328">328</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>            RobustRangingRadioSourceEstimatorListener&lt;S, Point2D&gt; listener) {
        super(readings, initialPosition, listener);
        internalSetQualityScores(qualityScores);
    }

    /**
     * Returns threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value, the
     * algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algorithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @return stop threshold to stop the algorithm prematurely when a certain
     * accuracy has been reached.
     */
    public double getStopThreshold() {
        return mStopThreshold;
    }

    /**
     * Sets threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value,
     * the algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algorithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @param stopThreshold stop threshold to stop the algorithm prematurely
     *                      when a certain accuracy has been reached.
     * @throws IllegalArgumentException if provided value is zero or negative.
     * @throws LockedException if this solver is locked.
     */
    public void setStopThreshold(double stopThreshold)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (stopThreshold &lt;= MIN_STOP_THRESHOLD) {
            throw new IllegalArgumentException();
        }

        mStopThreshold = stopThreshold;
    }

    /**
     * Returns quality scores corresponding to each pair of
     * positions and distances (i.e. sample).
     * The larger the score value the better the quality of the sample.
     * This implementation always returns null.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @return quality scores corresponding to each sample.
     */
    @Override
    public double[] getQualityScores() {
        return mQualityScores;
    }

    /**
     * Sets quality scores corresponding to each pair of positions and
     * distances (i.e. sample).
     * The larger the score value the better the quality of the sample.
     * This implementation makes no action.
     * Subclasses using quality scores must implement proper behaviour.
     *
     * @param qualityScores quality scores corresponding to each pair of
     *                      matched points.
     * @throws IllegalArgumentException if provided quality scores length
     * is smaller than minimum required samples.
     * @throws LockedException if robust solver is locked because an
     * estimation is already in progress.
     */
    public void setQualityScores(double[] qualityScores) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetQualityScores(qualityScores);
    }

    /**
     * Indicates whether solver is ready to find a solution.
     *
     * @return true if solver is ready, false otherwise.
     */
    @Override
    public boolean isReady() {
        return super.isReady() &amp;&amp; mQualityScores != null &amp;&amp;
                mQualityScores.length == mReadings.size();
    }

    /**
     * Robustly estimates position for a radio source.
     *
     * @throws LockedException if instance is busy during estimation.
     * @throws NotReadyException if estimator is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     * (i.e. numerical instability, no solution available, etc).
     */
    @Override
    public void estimate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        PROMedSRobustEstimator&lt;Solution&lt;Point2D&gt;&gt; innerEstimator =</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator2D.html#L394">394</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator3D.html#L394">394</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator2D.html#L405">405</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator3D.html#L405">405</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>            RobustRangingAndRssiRadioSourceEstimatorListener&lt;S, Point2D&gt; listener) {
        super(readings, initialPosition, initialTransmittedPowerdBm,
                initialPathLossExponent, listener);
    }

    /**
     * Gets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on received power (RSSI) expressed
     * in dBm's between received value that should have been received on estimated
     * isotropical model and actual measured value.
     *
     * @return threshold to determine whether samples are inliers or not.
     */
    public double getThreshold() {
        return mThreshold;
    }

    /**
     * Sets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on received power (RSSI) expressed
     * in dBm's between received value that should have been received on estimated
     * isotropical model and actual measured value.
     *
     * @param threshold threshold to determine whether samples are inliers or not.
     * @throws IllegalArgumentException if provided value is equal or less than zero.
     * @throws LockedException if this estimator is locked.
     */
    public void setThreshold(double threshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (threshold &lt;= MIN_THRESHOLD) {
            throw new IllegalArgumentException();
        }
        mThreshold = threshold;
    }


    /**
     * Indicates whether inliers must be computed and kept.
     *
     * @return true if inliers must be computed and kept, false if inliers
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepInliersEnabled() {
        return mComputeAndKeepInliers;
    }

    /**
     * Specifies whether inliers must be computed and kept.
     *
     * @param computeAndKeepInliers true if inliers must be computed and kept,
     *                              false if inliers only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepInliersEnabled(boolean computeAndKeepInliers)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mComputeAndKeepInliers = computeAndKeepInliers;
    }

    /**
     * Indicates whether residuals must be computed and kept.
     *
     * @return true if residuals must be computed and kept, false if residuals
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepResidualsEnabled() {
        return mComputeAndKeepResiduals;
    }

    /**
     * Specifies whether residuals must be computed and kept.
     *
     * @param computeAndKeepResiduals true if residuals must be computed and kept,
     *                                false if residuals only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepResidualsEnabled(boolean computeAndKeepResiduals)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mComputeAndKeepResiduals = computeAndKeepResiduals;
    }

    /**
     * Robustly estimates position, transmitted power and pathloss exponent for a
     * radio source.
     *
     * @throws LockedException if instance is busy during estimation.
     * @throws NotReadyException if estimator is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     * (i.e. numerical instability, no solution available, etc).
     */
    @Override
    public void estimate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        RANSACRobustEstimator&lt;Solution&lt;Point2D&gt;&gt; innerEstimator =</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator2D.html#L172">172</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator3D.html#L172">172</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>            RobustRangingRadioSourceEstimatorListener&lt;S, Point2D&gt; listener) {
        super(readings, initialPosition, listener);
    }

    /**
     * Gets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on ranging distances.
     *
     * @return threshold to determine whether samples are inliers or not.
     */
    public double getThreshold() {
        return mThreshold;
    }

    /**
     * Sets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on ranging distances.
     *
     * @param threshold threshold to determine whether samples are inliers or not.
     * @throws IllegalArgumentException if provided value is equal or less than zero.
     * @throws LockedException if this estimator is locked.
     */
    public void setThreshold(double threshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (threshold &lt;= MIN_THRESHOLD) {
            throw new IllegalArgumentException();
        }
        mThreshold = threshold;
    }


    /**
     * Indicates whether inliers must be computed and kept.
     *
     * @return true if inliers must be computed and kept, false if inliers
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepInliersEnabled() {
        return mComputeAndKeepInliers;
    }

    /**
     * Specifies whether inliers must be computed and kept.
     *
     * @param computeAndKeepInliers true if inliers must be computed and kept,
     *                              false if inliers only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepInliersEnabled(boolean computeAndKeepInliers)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mComputeAndKeepInliers = computeAndKeepInliers;
    }

    /**
     * Indicates whether residuals must be computed and kept.
     *
     * @return true if residuals must be computed and kept, false if residuals
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepResidualsEnabled() {
        return mComputeAndKeepResiduals;
    }

    /**
     * Specifies whether residuals must be computed and kept.
     *
     * @param computeAndKeepResiduals true if residuals must be computed and kept,
     *                                false if residuals only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepResidualsEnabled(boolean computeAndKeepResiduals)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mComputeAndKeepResiduals = computeAndKeepResiduals;
    }

    /**
     * Robustly estimates position for a radio source.
     *
     * @throws LockedException if instance is busy during estimation.
     * @throws NotReadyException if estimator is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     * (i.e. numerical instability, no solution available, etc).
     */
    @Override
    public void estimate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        RANSACRobustEstimator&lt;Solution&lt;Point2D&gt;&gt; innerEstimator =</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/estimators/ECEFKinematicsEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/estimators/ECEFKinematicsEstimator.html#L1756">1756</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/estimators/ECIKinematicsEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/estimators/ECIKinematicsEstimator.html#L1015">1015</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>                final double specificForceZ = invAveCbe.getElementAtIndex(2);

                // save result data
                result.setSpecificForceCoordinates(specificForceX, specificForceY,
                        specificForceZ);
                result.setAngularRateCoordinates(angularRateX, angularRateY,
                        angularRateZ);

            } catch (final AlgebraException ignore) {
                // never happens
            }
        } else {
            // If time interval is zero, set angular rate and specific force to zero
            result.setSpecificForceCoordinates(0.0, 0.0, 0.0);
            result.setAngularRateCoordinates(0.0, 0.0, 0.0);
        }
    }

    /**
     * Estimates body kinematics (specific force applied to a body and its angular rates).
     *
     * @param timeInterval time interval between epochs.
     * @param c            boy-to-ECEF frame coordinate transformation matrix.
     * @param oldC         previous body-to-ECEF-frame coordinate transformation matrix.
     * @param vx           velocity of body frame x coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per
     *                     second (m/s).
     * @param vy           velocity of body frame y coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per
     *                     second (m/s).
     * @param vz           velocity of body frame z coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per
     *                     second (m/s).
     * @param oldVx        previous velocity of body frame x coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters
     *                     per second (m/s).
     * @param oldVy        previous velocity of body frame y coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters
     *                     per second (m/s).
     * @param oldVz        previous velocity of body frame z coordinate with respect ECEF
     *                     frame, resolved along EVEF-frame axes and expressed in meters
     *                     per second (m/s).
     * @param x            cartesian x coordinate of body position expressed in meters (m)
     *                     with respect ECEF frame, resolved along ECEF-frame axes.
     * @param y            cartesian y coordinate of body position expressed in meters (m)
     *                     with respect ECEF frame, resolved along ECEF-frame axes.
     * @param z            cartesian z coordinate of body position expressed in meters (m)
     *                     with respect ECEF frame, resolved along ECEF-frame axes.
     * @param result       instance where body kinematics estimation will be stored.
     * @throws IllegalArgumentException if provided time interval is negative or coordinated transformation matrices
     *                                  are not ECEF frame valid.
     */
    public static void estimateKinematics(final Time timeInterval,
                                          final CoordinateTransformation c,
                                          final CoordinateTransformation oldC,
                                          final double vx, final double vy, final double vz,
                                          final double oldVx, final double oldVy, final double oldVz,
                                          final double x, final double y, final double z,
                                          final BodyKinematics result) {
        estimateKinematics(TimeConverter.convert(timeInterval.getValue().doubleValue(),
                timeInterval.getUnit(), TimeUnit.SECOND),
                c, oldC, vx, vy, vz, oldVx, oldVy, oldVz, x, y, z, result);
    }

    /**
     * Estimates body kinematics (specific force applied to a body and its angular rates).
     *
     * @param timeInterval time interval between epochs expressed in seconds (s).
     * @param c            boy-to-ECEF frame coordinate transformation matrix.
     * @param oldC         previous body-to-ECEF-frame coordinate transformation matrix.
     * @param velocity     velocity of body frame with respect ECEF frame.
     * @param oldVelocity  previous velocity of body frame with respect ECEF frame.
     * @param x            cartesian x coordinate of body position expressed in meters (m)
     *                     with respect ECEF frame, resolved along ECEF-frame axes.
     * @param y            cartesian y coordinate of body position expressed in meters (m)
     *                     with respect ECEF frame, resolved along ECEF-frame axes.
     * @param z            cartesian z coordinate of body position expressed in meters (m)
     *                     with respect ECEF frame, resolved along ECEF-frame axes.
     * @param result       instance where body kinematics estimation will be stored.
     * @throws IllegalArgumentException if provided time interval is negative or coordinated transformation matrices
     *                                  are not ECEF frame valid.
     */
    public static void estimateKinematics(final double timeInterval,
                                          final CoordinateTransformation c,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRangingRadioSourceEstimator2D.html#L810">810</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRangingRadioSourceEstimator3D.html#L812">812</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>        Point2D initialPosition = result.getEstimatedPosition();

        if (mRefineResult &amp;&amp; mInliersData != null) {
            BitSet inliers = mInliersData.getInliers();
            int nSamples = mReadings.size();

            mInnerReadings.clear();

            for (int i = 0; i &lt; nSamples; i++) {
                if (inliers.get(i)) {
                    //sample is inlier
                    mInnerReadings.add(mReadings.get(i));
                }
            }

            try {
                mInnerEstimator.setInitialPosition(initialPosition);
                mInnerEstimator.setReadings(mInnerReadings);

                mInnerEstimator.setNonLinearSolverEnabled(true);
                mInnerEstimator.setUseReadingPositionCovariances(
                        mUseReadingPositionCovariances);
                mInnerEstimator.estimate();

                Matrix cov = mInnerEstimator.getEstimatedCovariance();
                if (mKeepCovariance &amp;&amp; cov != null) {
                    //keep covariance
                    mEstimatedPositionCovariance = mCovariance = cov;

                } else {
                    mCovariance = null;
                    mEstimatedPositionCovariance = null;
                }

                mEstimatedPosition = mInnerEstimator.getEstimatedPosition();
            } catch (Exception e) {
                //refinement failed, so we return input value, and covariance
                //becomes unavailable
                mCovariance = null;
                mEstimatedPositionCovariance = null;

                mEstimatedPosition = initialPosition;
            }
        } else {
            mCovariance = null;
            mEstimatedPositionCovariance = null;

            mEstimatedPosition = initialPosition;
        }
    }
}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L15723">15723</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L7485">7485</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    private static double convertTimeToDouble(final Time time) {
        return TimeConverter.convert(time.getValue().doubleValue(), time.getUnit(),
                TimeUnit.SECOND);
    }

    /**
     * Converts provided distance instance into its corresponding value expressed in
     * meters.
     *
     * @param distance distance instance to be converted.
     * @return converted value expressed in meters.
     */
    private static double convertDistanceToDouble(final Distance distance) {
        return DistanceConverter.convert(distance.getValue().doubleValue(),
                distance.getUnit(), DistanceUnit.METER);
    }

    /**
     * Converts provided speed instance into its corresponding value expressed in
     * meters per second.
     *
     * @param speed speed instance to be converted.
     * @return converted value expressed in meters per second.
     */
    private static double convertSpeedToDouble(final Speed speed) {
        return SpeedConverter.convert(speed.getValue().doubleValue(),
                speed.getUnit(), SpeedUnit.METERS_PER_SECOND);
    }

    /**
     * Converts provided acceleration instance into its corresponding value expressed
     * in meters per squared second.
     *
     * @param acceleration acceleration instance to be converted.
     * @return converted value expressed in meters per squared second.
     */
    private static double convertAccelerationToDouble(final Acceleration acceleration) {
        return AccelerationConverter.convert(acceleration.getValue().doubleValue(),
                acceleration.getUnit(), AccelerationUnit.METERS_PER_SQUARED_SECOND);
    }

    /**
     * Converts provided angular speed into its corresponding value expressed in
     * radians per second.
     *
     * @param angularSpeed angular speed instance to be converted.
     * @return converted value expressed in radians per second.
     */
    private static double convertAngularSpeedToDouble(final AngularSpeed angularSpeed) {
        return AngularSpeedConverter.convert(angularSpeed.getValue().doubleValue(),
                angularSpeed.getUnit(), AngularSpeedUnit.RADIANS_PER_SECOND);
    }
}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRangingAndRssiRadioSourceEstimator2D.html#L374">374</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRangingRadioSourceEstimator2D.html#L151">151</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRssiRadioSourceEstimator2D.html#L385">385</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                initialPathLossExponent, listener);
    }

    /**
     * Returns threshold to determine whether samples are inliers or not.
     *
     * @return threshold to determine whether samples are inliers or not.
     */
    public double getThreshold() {
        return mThreshold;
    }

    /**
     * Sets threshold to determine whether samples are inliers or not.
     *
     * @param threshold threshold to be set.
     * @throws IllegalArgumentException if provided value is equal or less than
     * zero.
     * @throws LockedException if robust estimator is locked because an
     * estimation is already in progress.
     */
    public void setThreshold(double threshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (threshold &lt;= MIN_THRESHOLD) {
            throw new IllegalArgumentException();
        }
        mThreshold = threshold;
    }

    /**
     * Robustly estimates position, transmitted power and pathloss exponent for a
     * radio source.
     *
     * @throws LockedException if instance is busy during estimation.
     * @throws NotReadyException if estimator is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     * (i.e. numerical instability, no solution available, etc).
     */
    @Override
    public void estimate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        MSACRobustEstimator&lt;Solution&lt;Point2D&gt;&gt; innerEstimator =
                new MSACRobustEstimator&lt;&gt;(
                        new MSACRobustEstimatorListener&lt;Solution&lt;Point2D&gt;&gt;() {
                    @Override
                    public double getThreshold() {
                        return mThreshold;
                    }

                    @Override
                    public int getTotalSamples() {
                        return mReadings.size();
                    }

                    @Override
                    public int getSubsetSize() {
                        return Math.max(mPreliminarySubsetSize, getMinReadings());
                    }

                    @Override
                    public void estimatePreliminarSolutions(int[] samplesIndices,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRangingAndRssiRadioSourceEstimator3D.html#L374">374</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRangingRadioSourceEstimator3D.html#L151">151</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRssiRadioSourceEstimator3D.html#L385">385</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>                initialPathLossExponent, listener);
    }

    /**
     * Returns threshold to determine whether samples are inliers or not.
     *
     * @return threshold to determine whether samples are inliers or not.
     */
    public double getThreshold() {
        return mThreshold;
    }

    /**
     * Sets threshold to determine whether samples are inliers or not.
     *
     * @param threshold threshold to be set.
     * @throws IllegalArgumentException if provided value is equal or less than
     * zero.
     * @throws LockedException if robust estimator is locked because an
     * estimation is already in progress.
     */
    public void setThreshold(double threshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (threshold &lt;= MIN_THRESHOLD) {
            throw new IllegalArgumentException();
        }
        mThreshold = threshold;
    }

    /**
     * Robustly estimates position, transmitted power and pathloss exponent for a
     * radio source.
     *
     * @throws LockedException if instance is busy during estimation.
     * @throws NotReadyException if estimator is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     * (i.e. numerical instability, no solution available, etc).
     */
    @Override
    public void estimate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        MSACRobustEstimator&lt;Solution&lt;Point3D&gt;&gt; innerEstimator =
                new MSACRobustEstimator&lt;&gt;(
                        new MSACRobustEstimatorListener&lt;Solution&lt;Point3D&gt;&gt;() {
                            @Override
                            public double getThreshold() {
                                return mThreshold;
                            }

                            @Override
                            public int getTotalSamples() {
                                return mReadings.size();
                            }

                            @Override
                            public int getSubsetSize() {
                                return Math.max(mPreliminarySubsetSize, getMinReadings());
                            }

                            @Override
                            public void estimatePreliminarSolutions(int[] samplesIndices,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator2D.html#L833">833</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator3D.html#L329">329</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator2D.html#L844">844</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                initialPathLossExponent, listener);
        internalSetQualityScores(qualityScores);
    }

    /**
     * Returns threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value, the
     * algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algorithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @return stop threshold to stop the algorithm prematurely when a certain
     * accuracy has been reached.
     */
    public double getStopThreshold() {
        return mStopThreshold;
    }

    /**
     * Sets threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value,
     * the algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algorithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @param stopThreshold stop threshold to stop the algorithm prematurely
     *                      when a certain accuracy has been reached.
     * @throws IllegalArgumentException if provided value is zero or negative.
     * @throws LockedException if this solver is locked.
     */
    public void setStopThreshold(double stopThreshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (stopThreshold &lt;= MIN_STOP_THRESHOLD) {
            throw new IllegalArgumentException();
        }

        mStopThreshold = stopThreshold;
    }

    /**
     * Returns quality scores corresponding to each pair of
     * positions and distances (i.e. sample).
     * The larger the score value the better the quality of the sample.
     * This implementation always returns null.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @return quality scores corresponding to each sample.
     */
    @Override
    public double[] getQualityScores() {
        return mQualityScores;
    }

    /**
     * Sets quality scores corresponding to each pair of positions and
     * distances (i.e. sample).
     * The larger the score value the better the quality of the sample.
     * This implementation makes no action.
     * Subclasses using quality scores must implement proper behaviour.
     *
     * @param qualityScores quality scores corresponding to each pair of
     *                      matched points.
     * @throws IllegalArgumentException if provided quality scores length
     * is smaller than minimum required samples.
     * @throws LockedException if robust solver is locked because an
     * estimation is already in progress.
     */
    public void setQualityScores(double[] qualityScores) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetQualityScores(qualityScores);
    }

    /**
     * Indicates whether solver is ready to find a solution.
     *
     * @return true if solver is ready, false otherwise.
     */
    @Override
    public boolean isReady() {
        return super.isReady() &amp;&amp; mQualityScores != null &amp;&amp;
                mQualityScores.length == mReadings.size();
    }

    /**
     * Robustly estimates position, transmitted power and pathloss exponent for a
     * radio source.
     *
     * @throws LockedException if instance is busy during estimation.
     * @throws NotReadyException if estimator is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     * (i.e. numerical instability, no solution available, etc).
     */
    @Override
    public void estimate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        PROMedSRobustEstimator&lt;Solution&lt;Point2D&gt;&gt; innerEstimator =</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator3D.html#L833">833</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator2D.html#L329">329</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator3D.html#L843">843</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>                initialPathLossExponent, listener);
        internalSetQualityScores(qualityScores);
    }

    /**
     * Returns threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value, the
     * algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algorithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @return stop threshold to stop the algorithm prematurely when a certain
     * accuracy has been reached.
     */
    public double getStopThreshold() {
        return mStopThreshold;
    }

    /**
     * Sets threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value,
     * the algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algorithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @param stopThreshold stop threshold to stop the algorithm prematurely
     *                      when a certain accuracy has been reached.
     * @throws IllegalArgumentException if provided value is zero or negative.
     * @throws LockedException if this solver is locked.
     */
    public void setStopThreshold(double stopThreshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (stopThreshold &lt;= MIN_STOP_THRESHOLD) {
            throw new IllegalArgumentException();
        }

        mStopThreshold = stopThreshold;
    }

    /**
     * Returns quality scores corresponding to each pair of
     * positions and distances (i.e. sample).
     * The larger the score value the better the quality of the sample.
     * This implementation always returns null.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @return quality scores corresponding to each sample.
     */
    @Override
    public double[] getQualityScores() {
        return mQualityScores;
    }

    /**
     * Sets quality scores corresponding to each pair of positions and
     * distances (i.e. sample).
     * The larger the score value the better the quality of the sample.
     * This implementation makes no action.
     * Subclasses using quality scores must implement proper behaviour.
     *
     * @param qualityScores quality scores corresponding to each pair of
     *                      matched points.
     * @throws IllegalArgumentException if provided quality scores length
     * is smaller than minimum required samples.
     * @throws LockedException if robust solver is locked because an
     * estimation is already in progress.
     */
    public void setQualityScores(double[] qualityScores) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetQualityScores(qualityScores);
    }

    /**
     * Indicates whether solver is ready to find a solution.
     *
     * @return true if solver is ready, false otherwise.
     */
    @Override
    public boolean isReady() {
        return super.isReady() &amp;&amp; mQualityScores != null &amp;&amp;
                mQualityScores.length == mReadings.size();
    }

    /**
     * Robustly estimates position, transmitted power and pathloss exponent for a
     * radio source.
     *
     * @throws LockedException if instance is busy during estimation.
     * @throws NotReadyException if estimator is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     * (i.e. numerical instability, no solution available, etc).
     */
    @Override
    public void estimate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        PROMedSRobustEstimator&lt;Solution&lt;Point3D&gt;&gt; innerEstimator =</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/INSLooselyCoupledKalmanState.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/INSLooselyCoupledKalmanState.html#L2068">2068</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/INSTightlyCoupledKalmanState.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/INSTightlyCoupledKalmanState.html#L2345">2345</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    public boolean equals(final INSLooselyCoupledKalmanState other,
                          final double threshold) {
        if (other == null) {
            return false;
        }

        return Math.abs(mVx - other.mVx) &lt;= threshold
                &amp;&amp; Math.abs(mVy - other.mVy) &lt;= threshold
                &amp;&amp; Math.abs(mVz - other.mVz) &lt;= threshold
                &amp;&amp; Math.abs(mX - other.mX) &lt;= threshold
                &amp;&amp; Math.abs(mY - other.mY) &lt;= threshold
                &amp;&amp; Math.abs(mZ - other.mZ) &lt;= threshold
                &amp;&amp; Math.abs(mAccelerationBiasX - other.mAccelerationBiasX) &lt;= threshold
                &amp;&amp; Math.abs(mAccelerationBiasY - other.mAccelerationBiasY) &lt;= threshold
                &amp;&amp; Math.abs(mAccelerationBiasZ - other.mAccelerationBiasZ) &lt;= threshold
                &amp;&amp; Math.abs(mGyroBiasX - other.mGyroBiasX) &lt;= threshold
                &amp;&amp; Math.abs(mGyroBiasY - other.mGyroBiasY) &lt;= threshold
                &amp;&amp; Math.abs(mGyroBiasZ - other.mGyroBiasZ) &lt;= threshold
                &amp;&amp; other.mBodyToEcefCoordinateTransformationMatrix != null &amp;&amp;</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/calibration/KnownBiasAndFrameAccelerometerNonLinearLeastSquaresCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/KnownBiasAndFrameAccelerometerNonLinearLeastSquaresCalibrator.html#L2658">2658</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/calibration/KnownFrameAccelerometerNonLinearLeastSquaresCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/KnownFrameAccelerometerNonLinearLeastSquaresCalibrator.html#L2923">2923</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>            final KnownBiasAndFrameAccelerometerNonLinearLeastSquaresCalibratorListener listener)
            throws LockedException {
        if (mRunning) {
            throw new LockedException();
        }

        mListener = listener;
    }

    /**
     * Indicates whether calibrator is ready to start.
     *
     * @return true if calibrator is ready, false otherwise.
     */
    @Override
    public boolean isReady() {
        return mMeasurements != null &amp;&amp; mMeasurements.size() &gt;= MINIMUM_MEASUREMENTS;
    }

    /**
     * Indicates whether calibrator is currently running or not.
     *
     * @return true if calibrator is running, false otherwise.
     */
    @Override
    public boolean isRunning() {
        return mRunning;
    }

    /**
     * Estimates accelerometer calibration parameters containing bias, scale factors
     * and cross-coupling errors.
     *
     * @throws LockedException      if calibrator is currently running.
     * @throws NotReadyException    if calibrator is not ready.
     * @throws CalibrationException if estimation fails for numerical reasons.
     */
    @Override
    public void calibrate() throws LockedException, NotReadyException, CalibrationException {
        if (mRunning) {
            throw new LockedException();
        }

        if (!isReady()) {
            throw new NotReadyException();
        }

        try {
            mRunning = true;

            if (mListener != null) {
                mListener.onCalibrateStart(this);
            }

            if (mCommonAxisUsed) {
                calibrateCommonAxis();
            } else {
                calibrateGeneral();
            }

            if (mListener != null) {
                mListener.onCalibrateEnd(this);
            }

        } catch (final AlgebraException | FittingException |
                com.irurueta.numerical.NotReadyException e) {
            throw new CalibrationException(e);
        } finally {
            mRunning = false;
        }
    }

    /**
     * Gets estimated accelerometer scale factors and ross coupling errors.
     * This is the product of matrix Ta containing cross coupling errors and Ka
     * containing scaling factors.
     * So tat:
     * &lt;pre&gt;
     *     Ma = [sx    mxy  mxz] = Ta*Ka
     *          [myx   sy   myz]
     *          [mzx   mzy  sz ]
     * &lt;/pre&gt;
     * Where:
     * &lt;pre&gt;
     *     Ka = [sx 0   0 ]
     *          [0  sy  0 ]
     *          [0  0   sz]
     * &lt;/pre&gt;
     * and
     * &lt;pre&gt;
     *     Ta = [1          -alphaXy    alphaXz ]
     *          [alphaYx    1           -alphaYz]
     *          [-alphaZx   alphaZy     1       ]
     * &lt;/pre&gt;
     * Hence:
     * &lt;pre&gt;
     *     Ma = [sx    mxy  mxz] = Ta*Ka =  [sx             -sy * alphaXy   sz * alphaXz ]
     *          [myx   sy   myz]            [sx * alphaYx   sy              -sz * alphaYz]
     *          [mzx   mzy  sz ]            [-sx * alphaZx  sy * alphaZy    sz           ]
     * &lt;/pre&gt;
     * This instance allows any 3x3 matrix however, typically alphaYx, alphaZx and alphaZy
     * are considered to be zero if the accelerometer z-axis is assumed to be the same
     * as the body z-axis. When this is assumed, myx = mzx = mzy = 0 and the Ma matrix
     * becomes upper diagonal:
     * &lt;pre&gt;
     *     Ma = [sx    mxy  mxz]
     *          [0     sy   myz]
     *          [0     0    sz ]
     * &lt;/pre&gt;
     * Values of this matrix are unitless.
     *
     * @return estimated accelerometer scale factors and cross coupling errors, or null
     * if not available.
     */
    @Override
    public Matrix getEstimatedMa() {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/fingerprint/SecondOrderNonLinearFingerprintPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/fingerprint/SecondOrderNonLinearFingerprintPositionEstimator3D.html#L150">150</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/fingerprint/ThirdOrderNonLinearFingerprintPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/fingerprint/ThirdOrderNonLinearFingerprintPositionEstimator3D.html#L147">147</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    }

    /**
     * Evaluates a non-linear multi dimension function at provided point using
     * provided parameters and returns its evaluation and derivatives of the
     * function respect the function parameters.
     * @param i number of sample being evaluated.
     * @param point point where function will be evaluated.
     * @param params initial parameters estimation to be tried. These will
     * change as the Levenberg-Marquard algorithm iterates to the best solution.
     * These are used as input parameters along with point to evaluate function.
     * @param derivatives partial derivatives of the function respect to each
     * provided parameter.
     * @return function evaluation at provided point.
     */
    @Override
    @SuppressWarnings(&quot;Duplicates&quot;)
    protected double evaluate(int i, double[] point, double[] params, double[] derivatives) {
        //This method implements received power at point pi = (xi, yi, zi) and its derivatives

        //Pr(pi) = Pr(p1)
        // - 10*n*(x1 - xa)/(ln(10)*d1a^2)*(xi - x1)
        // - 10*n*(y1 - ya)/(ln(10)*d1a^2)*(yi - y1)
        // - 10*n*(z1 - za)/(ln(10)*d1a^2)*(zi - z1)
        // - 5*n*((y1 - ya)^2 + (z1 - za)^2 - (x1 - xa)^2)/(ln(10)*d1a^4)*(xi - x1)^2
        // - 5*n*((x1 - xa)^2 - (y1 - ya)^2 + (z1 - za)^2)/(ln(10)*d1a^4)*(yi - y1)^2
        // - 5*n*((x1 - xa)^2 + (y1 - ya)^2 - (z1 - za)^2)/(ln(10)*d1a^4)*(zi - z1)^2
        // + 20*n*(x1 - xa)*(y1 - ya)/(ln(10)*d1a^4)*(xi - x1)*(yi - y1)
        // + 20*n*(y1 - ya)*(z1 - za)/(ln(10)*d1a^4)*(yi - y1)*(zi - z1)
        // + 20*n*(x1 - xa)*(z1 - za)/(ln(10)*d1a^4)*(xi - x1)*(zi - z1)

        double xi = params[0];
        double yi = params[1];
        double zi = params[2];

        //received power
        double pr = point[0];

        //fingerprint coordinates
        double x1 = point[1];
        double y1 = point[2];
        double z1 = point[3];

        //radio source coordinates
        double xa = point[4];
        double ya = point[5];
        double za = point[6];

        //path loss exponent
        double n = point[7];

        double ln10 = Math.log(10.0);

        double diffXi1 = xi - x1;
        double diffYi1 = yi - y1;
        double diffZi1 = zi - z1;

        double diffX1a = x1 - xa;
        double diffY1a = y1 - ya;
        double diffZ1a = z1 - za;

        double diffXi12 = diffXi1 * diffXi1;
        double diffYi12 = diffYi1 * diffYi1;
        double diffZi12 = diffZi1 * diffZi1;

        double diffX1a2 = diffX1a * diffX1a;</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/calibration/PROMedSRobustKnownBiasAndFrameAccelerometerCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/PROMedSRobustKnownBiasAndFrameAccelerometerCalibrator.html#L1575">1575</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/calibration/PROMedSRobustKnownFrameAccelerometerCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/PROMedSRobustKnownFrameAccelerometerCalibrator.html#L351">351</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>        this(measurements, bias, commonAxisUsed, listener);
        internalSetQualityScores(qualityScores);
    }

    /**
     * Returns threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value, the
     * algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algrithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @return stop threshold to stop the algorithm prematurely when a certain
     * accuracy has been reached.
     */
    public double getStopThreshold() {
        return mStopThreshold;
    }

    /**
     * Sets threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value,
     * the algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algorithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @param stopThreshold stop threshold to stop the algorithm prematurely
     *                      when a certain accuracy has been reached.
     * @throws IllegalArgumentException if provided value is zero or negative.
     * @throws LockedException          if calibrator is currently running.
     */
    public void setStopThreshold(double stopThreshold) throws LockedException {
        if (mRunning) {
            throw new LockedException();
        }
        if (stopThreshold &lt;= MIN_STOP_THRESHOLD) {
            throw new IllegalArgumentException();
        }

        mStopThreshold = stopThreshold;
    }

    /**
     * Returns quality scores corresponding to each provided sample.
     * The larger the score value the better the quality of the sample.
     *
     * @return quality scores corresponding to each sample.
     */
    @Override
    public double[] getQualityScores() {
        return mQualityScores;
    }

    /**
     * Sets quality scores corresponding to each provided sample.
     * The larger the score value the better the quality of the sample.
     *
     * @param qualityScores quality scores corresponding to each sample.
     * @throws IllegalArgumentException if provided quality scores length
     *                                  is smaller than minimum required samples.
     * @throws LockedException          if calibrator is currently running.
     */
    @Override
    public void setQualityScores(double[] qualityScores)
            throws LockedException {
        if (mRunning) {
            throw new LockedException();
        }
        internalSetQualityScores(qualityScores);
    }

    /**
     * Indicates whether solver is ready to find a solution.
     *
     * @return true if solver is ready, false otherwise.
     */
    @Override
    public boolean isReady() {
        return super.isReady() &amp;&amp; mQualityScores != null &amp;&amp;
                mQualityScores.length == mMeasurements.size();
    }

    /**
     * Estimates accelerometer calibration parameters containing scale factors
     * and cross-coupling errors.
     *
     * @throws LockedException      if calibrator is currently running.
     * @throws NotReadyException    if calibrator is not ready.
     * @throws CalibrationException if estimation fails for numerical reasons.
     */
    @Override
    public void calibrate() throws LockedException, NotReadyException, CalibrationException {
        if (mRunning) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        final PROMedSRobustEstimator&lt;Matrix&gt; innerEstimator =</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/RANSACRobustMixedPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/RANSACRobustMixedPositionEstimator2D.html#L146">146</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/RANSACRobustRangingAndRssiPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/RANSACRobustRangingAndRssiPositionEstimator2D.html#L146">146</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/RANSACRobustRangingPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/RANSACRobustRangingPositionEstimator2D.html#L146">146</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/RANSACRobustRssiPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/RANSACRobustRssiPositionEstimator2D.html#L145">145</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>            RobustMixedPositionEstimatorListener&lt;Point2D&gt; listener) {
        super(listener);
        init();
        internalSetSources(sources);
        internalSetFingerprint(fingerprint);
    }

    /**
     * Gets threshold to determine whether samples are inliers or not when testing
     * possible solutions.
     * The threshold refers to the amount of error on distance between estimated
     * position and distances provided for each sample.
     *
     * @return threshold to determine whether samples are inliers or not.
     */
    public double getThreshold() {
        return ((RANSACRobustLateration2DSolver) mLaterationSolver).
                getThreshold();
    }

    /**
     * Sets threshold to determine whether samples are inliers or not when testing
     * possible solutions.
     * The threshold refers to the amount of error on distance between estimated position
     * and distances provided for each sample.
     *
     * @param threshold threshold to determine whether samples are inliers or not.
     * @throws IllegalArgumentException if provided value is equal or less than zero.
     * @throws LockedException          if this estimator is locked.
     */
    public void setThreshold(double threshold) throws LockedException {
        ((RANSACRobustLateration2DSolver) mLaterationSolver).
                setThreshold(threshold);
    }

    /**
     * Indicates whether inliers must be computed and kept.
     *
     * @return true if inliers must be computed and kept, false if inliers
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepInliersEnabled() {
        return ((RANSACRobustLateration2DSolver) mLaterationSolver).
                isComputeAndKeepInliersEnabled();
    }

    /**
     * Specifies whether inliers must be computed and kept.
     *
     * @param computeAndKeepInliers true if inliers must be computed and kept,
     *                              false if inliers only need to be computed but not
     *                              kept.
     * @throws LockedException if this estimator is locked.
     */
    public void setComputeAndKeepInliersEnabled(boolean computeAndKeepInliers)
            throws LockedException {
        ((RANSACRobustLateration2DSolver) mLaterationSolver).
                setComputeAndKeepInliersEnabled(computeAndKeepInliers);
    }

    /**
     * Indicates whether residuals must be computed and kept.
     *
     * @return true if residuals must be computed and kept, false if residuals
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepResiduals() {
        return ((RANSACRobustLateration2DSolver) mLaterationSolver).
                isComputeAndKeepResiduals();
    }

    /**
     * Specifies whether residuals must be computed and kept.
     *
     * @param computeAndKeepResiduals true if residuals must be computed and kept,
     *                                false if residuals only need to be computed but not kept.
     * @throws LockedException if this estimator is locked.
     */
    public void setComputeAndKeepResidualsEnabled(boolean computeAndKeepResiduals)
            throws LockedException {
        ((RANSACRobustLateration2DSolver) mLaterationSolver).
                setComputeAndKeepResidualsEnabled(computeAndKeepResiduals);
    }

    /**
     * Returns method being used for robust estimation.
     *
     * @return method being used for robust estimation.
     */
    @Override
    public RobustEstimatorMethod getMethod() {
        return RobustEstimatorMethod.RANSAC;
    }

    /**
     * Initializes robust lateration solver.
     */
    private void init() {
        mLaterationSolver = new RANSACRobustLateration2DSolver(
                mTrilaterationSolverListener);
    }
}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/RANSACRobustMixedPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/RANSACRobustMixedPositionEstimator3D.html#L146">146</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/RANSACRobustRangingAndRssiPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/RANSACRobustRangingAndRssiPositionEstimator3D.html#L146">146</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/RANSACRobustRangingPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/RANSACRobustRangingPositionEstimator3D.html#L146">146</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/RANSACRobustRssiPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/RANSACRobustRssiPositionEstimator3D.html#L145">145</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>            RobustMixedPositionEstimatorListener&lt;Point3D&gt; listener) {
        super(listener);
        init();
        internalSetSources(sources);
        internalSetFingerprint(fingerprint);
    }

    /**
     * Gets threshold to determine whether samples are inliers or not when testing
     * possible solutions.
     * The threshold refers to the amount of error on distance between estimated
     * position and distances provided for each sample.
     *
     * @return threshold to determine whether samples are inliers or not.
     */
    public double getThreshold() {
        return ((RANSACRobustLateration3DSolver) mLaterationSolver).
                getThreshold();
    }

    /**
     * Sets threshold to determine whether samples are inliers or not when testing
     * possible solutions.
     * The threshold refers to the amount of error on distance between estimated position
     * and distances provided for each sample.
     *
     * @param threshold threshold to determine whether samples are inliers or not.
     * @throws IllegalArgumentException if provided value is equal or less than zero.
     * @throws LockedException          if this estimator is locked.
     */
    public void setThreshold(double threshold) throws LockedException {
        ((RANSACRobustLateration3DSolver) mLaterationSolver).
                setThreshold(threshold);
    }

    /**
     * Indicates whether inliers must be computed and kept.
     *
     * @return true if inliers must be computed and kept, false if inliers
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepInliersEnabled() {
        return ((RANSACRobustLateration3DSolver) mLaterationSolver).
                isComputeAndKeepInliersEnabled();
    }

    /**
     * Specifies whether inliers must be computed and kept.
     *
     * @param computeAndKeepInliers true if inliers must be computed and kept,
     *                              false if inliers only need to be computed but not
     *                              kept.
     * @throws LockedException if this estimator is locked.
     */
    public void setComputeAndKeepInliersEnabled(boolean computeAndKeepInliers)
            throws LockedException {
        ((RANSACRobustLateration3DSolver) mLaterationSolver).
                setComputeAndKeepInliersEnabled(computeAndKeepInliers);
    }

    /**
     * Indicates whether residuals must be computed and kept.
     *
     * @return true if residuals must be computed and kept, false if residuals
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepResiduals() {
        return ((RANSACRobustLateration3DSolver) mLaterationSolver).
                isComputeAndKeepResiduals();
    }

    /**
     * Specifies whether residuals must be computed and kept.
     *
     * @param computeAndKeepResiduals true if residuals must be computed and kept,
     *                                false if residuals only need to be computed but not kept.
     * @throws LockedException if this estimator is locked.
     */
    public void setComputeAndKeepResidualsEnabled(boolean computeAndKeepResiduals)
            throws LockedException {
        ((RANSACRobustLateration3DSolver) mLaterationSolver).
                setComputeAndKeepResidualsEnabled(computeAndKeepResiduals);
    }

    /**
     * Returns method being used for robust estimation.
     *
     * @return method being used for robust estimation.
     */
    @Override
    public RobustEstimatorMethod getMethod() {
        return RobustEstimatorMethod.RANSAC;
    }

    /**
     * Initializes robust lateration solver.
     */
    private void init() {
        mLaterationSolver = new RANSACRobustLateration3DSolver(
                mTrilaterationSolverListener);
    }
}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator2D.html#L396">396</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator3D.html#L173">173</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator2D.html#L407">407</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                initialPathLossExponent, listener);
    }

    /**
     * Gets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on received power (RSSI) expressed
     * in dBm's between received value that should have been received on estimated
     * isotropical model and actual measured value.
     *
     * @return threshold to determine whether samples are inliers or not.
     */
    public double getThreshold() {
        return mThreshold;
    }

    /**
     * Sets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on received power (RSSI) expressed
     * in dBm's between received value that should have been received on estimated
     * isotropical model and actual measured value.
     *
     * @param threshold threshold to determine whether samples are inliers or not.
     * @throws IllegalArgumentException if provided value is equal or less than zero.
     * @throws LockedException if this estimator is locked.
     */
    public void setThreshold(double threshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (threshold &lt;= MIN_THRESHOLD) {
            throw new IllegalArgumentException();
        }
        mThreshold = threshold;
    }


    /**
     * Indicates whether inliers must be computed and kept.
     *
     * @return true if inliers must be computed and kept, false if inliers
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepInliersEnabled() {
        return mComputeAndKeepInliers;
    }

    /**
     * Specifies whether inliers must be computed and kept.
     *
     * @param computeAndKeepInliers true if inliers must be computed and kept,
     *                              false if inliers only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepInliersEnabled(boolean computeAndKeepInliers)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mComputeAndKeepInliers = computeAndKeepInliers;
    }

    /**
     * Indicates whether residuals must be computed and kept.
     *
     * @return true if residuals must be computed and kept, false if residuals
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepResidualsEnabled() {
        return mComputeAndKeepResiduals;
    }

    /**
     * Specifies whether residuals must be computed and kept.
     *
     * @param computeAndKeepResiduals true if residuals must be computed and kept,
     *                                false if residuals only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepResidualsEnabled(boolean computeAndKeepResiduals)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mComputeAndKeepResiduals = computeAndKeepResiduals;
    }

    /**
     * Robustly estimates position, transmitted power and pathloss exponent for a
     * radio source.
     *
     * @throws LockedException if instance is busy during estimation.
     * @throws NotReadyException if estimator is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     * (i.e. numerical instability, no solution available, etc).
     */
    @Override
    public void estimate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        RANSACRobustEstimator&lt;Solution&lt;Point2D&gt;&gt; innerEstimator =</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator3D.html#L396">396</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator2D.html#L173">173</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator3D.html#L407">407</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>                initialPathLossExponent, listener);
    }

    /**
     * Gets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on received power (RSSI) expressed
     * in dBm's between received value that should have been received on estimated
     * isotropical model and actual measured value.
     *
     * @return threshold to determine whether samples are inliers or not.
     */
    public double getThreshold() {
        return mThreshold;
    }

    /**
     * Sets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on received power (RSSI) expressed
     * in dBm's between received value that should have been received on estimated
     * isotropical model and actual measured value.
     *
     * @param threshold threshold to determine whether samples are inliers or not.
     * @throws IllegalArgumentException if provided value is equal or less than zero.
     * @throws LockedException if this estimator is locked.
     */
    public void setThreshold(double threshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (threshold &lt;= MIN_THRESHOLD) {
            throw new IllegalArgumentException();
        }
        mThreshold = threshold;
    }


    /**
     * Indicates whether inliers must be computed and kept.
     *
     * @return true if inliers must be computed and kept, false if inliers
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepInliersEnabled() {
        return mComputeAndKeepInliers;
    }

    /**
     * Specifies whether inliers must be computed and kept.
     *
     * @param computeAndKeepInliers true if inliers must be computed and kept,
     *                              false if inliers only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepInliersEnabled(boolean computeAndKeepInliers)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mComputeAndKeepInliers = computeAndKeepInliers;
    }

    /**
     * Indicates whether residuals must be computed and kept.
     *
     * @return true if residuals must be computed and kept, false if residuals
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepResidualsEnabled() {
        return mComputeAndKeepResiduals;
    }

    /**
     * Specifies whether residuals must be computed and kept.
     *
     * @param computeAndKeepResiduals true if residuals must be computed and kept,
     *                                false if residuals only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepResidualsEnabled(boolean computeAndKeepResiduals)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mComputeAndKeepResiduals = computeAndKeepResiduals;
    }

    /**
     * Robustly estimates position, transmitted power and pathloss exponent for a
     * radio source.
     *
     * @throws LockedException if instance is busy during estimation.
     * @throws NotReadyException if estimator is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     * (i.e. numerical instability, no solution available, etc).
     */
    @Override
    public void estimate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        RANSACRobustEstimator&lt;Solution&lt;Point3D&gt;&gt; innerEstimator =</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustMixedRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustMixedRadioSourceEstimator.html#L2368">2368</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator.html#L2240">2240</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>            List&lt;? extends ReadingLocated&lt;P&gt;&gt; readings) {
        if (!areValidReadings(readings)) {
            throw new IllegalArgumentException();
        }

        mReadings = readings;
    }

    /**
     * Sets quality scores corresponding to each provided sample.
     * This method is used internally and does not check whether instance is
     * locked or not.
     *
     * @param qualityScores quality scores to be set.
     * @throws IllegalArgumentException if provided quality scores length
     * is smaller than required minimum.
     */
    private void internalSetQualityScores(double[] qualityScores) {
        if (qualityScores == null ||
                qualityScores.length &lt; getMinReadings()) {
            throw new IllegalArgumentException();
        }

        mQualityScores = qualityScores;
    }

    /**
     * Creates a ranging reading from a ranging and RSSI reading.
     *
     * @param reading input reading to convert from.
     * @return a ranging reading containing only the ranging data of input reading.
     */
    private RangingReadingLocated&lt;S, P&gt; createRangingReading(RangingAndRssiReadingLocated&lt;S, P&gt; reading) {
        return new RangingReadingLocated&lt;&gt;(reading.getSource(),
                reading.getDistance(), reading.getPosition(),
                reading.getDistanceStandardDeviation(),
                reading.getPositionCovariance());
    }

    /**
     * Creates an RSSI reading from a ranging and RSSI reading.
     *
     * @param reading input reading to convert from.
     * @return an RSSI reading containing only the RSSI data of input reading.
     */
    private RssiReadingLocated&lt;S, P&gt; createRssiReading(RangingAndRssiReadingLocated&lt;S, P&gt; reading) {
        return new RssiReadingLocated&lt;&gt;(reading.getSource(),
                reading.getRssi(), reading.getPosition(),
                reading.getRssiStandardDeviation(),
                reading.getPositionCovariance());
    }</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator2D.html#L1051">1051</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator2D.html#L541">541</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator2D.html#L1056">1056</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                                    PROSACRobustRangingAndRssiRadioSourceEstimator2D.this, progress);
                        }
                    }
                });

        try {
            mLocked = true;
            mInliersData = null;
            innerEstimator.setComputeAndKeepInliersEnabled(
                    mComputeAndKeepInliers || mRefineResult);
            innerEstimator.setComputeAndKeepResidualsEnabled(
                    mComputeAndKeepResiduals || mRefineResult);
            innerEstimator.setConfidence(mConfidence);
            innerEstimator.setMaxIterations(mMaxIterations);
            innerEstimator.setProgressDelta(mProgressDelta);
            Solution&lt;Point2D&gt; result = innerEstimator.estimate();
            mInliersData = innerEstimator.getInliersData();
            attemptRefine(result);

        } catch (com.irurueta.numerical.LockedException e) {
            throw new LockedException(e);
        } catch (com.irurueta.numerical.NotReadyException e) {
            throw new NotReadyException(e);
        } finally {
            mLocked = false;
        }
    }

    /**
     * Returns method being used for robust estimation.
     *
     * @return method being used for robust estimation.
     */
    @Override
    public RobustEstimatorMethod getMethod() {
        return RobustEstimatorMethod.PROSAC;
    }

    /**
     * Sets quality scores corresponding to each provided sample.
     * This method is used internally and does not check whether instance is
     * locked or not.
     *
     * @param qualityScores quality scores to be set.
     * @throws IllegalArgumentException if provided quality scores length
     * is smaller than required minimum.
     */
    private void internalSetQualityScores(double[] qualityScores) {
        if (qualityScores == null ||
                qualityScores.length &lt; getMinReadings()) {
            throw new IllegalArgumentException();
        }

        mQualityScores = qualityScores;
    }
}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator3D.html#L1051">1051</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator3D.html#L541">541</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator3D.html#L1055">1055</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>                                            PROSACRobustRangingAndRssiRadioSourceEstimator3D.this, progress);
                                }
                            }
                        });

        try {
            mLocked = true;
            mInliersData = null;
            innerEstimator.setComputeAndKeepInliersEnabled(
                    mComputeAndKeepInliers || mRefineResult);
            innerEstimator.setComputeAndKeepResidualsEnabled(
                    mComputeAndKeepResiduals || mRefineResult);
            innerEstimator.setConfidence(mConfidence);
            innerEstimator.setMaxIterations(mMaxIterations);
            innerEstimator.setProgressDelta(mProgressDelta);
            Solution&lt;Point3D&gt; result = innerEstimator.estimate();
            mInliersData = innerEstimator.getInliersData();
            attemptRefine(result);

        } catch (com.irurueta.numerical.LockedException e) {
            throw new LockedException(e);
        } catch (com.irurueta.numerical.NotReadyException e) {
            throw new NotReadyException(e);
        } finally {
            mLocked = false;
        }
    }

    /**
     * Returns method being used for robust estimation.
     *
     * @return method being used for robust estimation.
     */
    @Override
    public RobustEstimatorMethod getMethod() {
        return RobustEstimatorMethod.PROSAC;
    }

    /**
     * Sets quality scores corresponding to each provided sample.
     * This method is used internally and does not check whether instance is
     * locked or not.
     *
     * @param qualityScores quality scores to be set.
     * @throws IllegalArgumentException if provided quality scores length
     * is smaller than required minimum.
     */
    private void internalSetQualityScores(double[] qualityScores) {
        if (qualityScores == null ||
                qualityScores.length &lt; getMinReadings()) {
            throw new IllegalArgumentException();
        }

        mQualityScores = qualityScores;
    }
}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/lateration/HomogeneousLinearLeastSquaresLateration2DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/HomogeneousLinearLeastSquaresLateration2DSolver.html#L119">119</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/lateration/InhomogeneousLinearLeastSquaresLateration2DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/InhomogeneousLinearLeastSquaresLateration2DSolver.html#L119">119</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/lateration/NonLinearLeastSquaresLateration2DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/NonLinearLeastSquaresLateration2DSolver.html#L316">316</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>        internalSetCircles(circles);
    }

    /**
     * Gets number of dimensions of provided points.
     * @return always returns 2 dimensions.
     */
    @Override
    public int getNumberOfDimensions() {
        return Point2D.POINT2D_INHOMOGENEOUS_COORDINATES_LENGTH;
    }

    /**
     * Minimum required number of positions and distances.
     * At least 3 positions and distances will be required to linearly solve a 2D problem.
     * @return minimum required number of positions and distances.
     */
    @Override
    public int getMinRequiredPositionsAndDistances() {
        return Point2D.POINT2D_INHOMOGENEOUS_COORDINATES_LENGTH + 1;
    }

    /**
     * Gets estimated position.
     * @return estimated position.
     */
    @Override
    public Point2D getEstimatedPosition() {
        if (mEstimatedPositionCoordinates == null) {
            return null;
        }

        InhomogeneousPoint2D position = new InhomogeneousPoint2D();
        getEstimatedPosition(position);
        return position;
    }

    /**
     * Internally sets circles defining positions and euclidean distances.
     * @param circles circles defining positions and distances.
     * @throws IllegalArgumentException if circles is null or length of array of circles
     * is less than 3.
     */
    private void internalSetCircles(Circle[] circles) {
        if (circles == null || circles.length &lt; getMinRequiredPositionsAndDistances()) {
            throw new IllegalArgumentException();
        }

        Point2D[] positions = new Point2D[circles.length];
        double[] distances = new double[circles.length];
        for (int i = 0; i &lt; circles.length; i++) {
            Circle circle = circles[i];
            positions[i] = circle.getCenter();
            distances[i] = circle.getRadius();
        }

        internalSetPositionsAndDistances(positions, distances);
    }</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/frames/ECIorECEFFrame.java</td>
<td><a href="./xref/com/irurueta/navigation/frames/ECIorECEFFrame.html#L101">101</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/ECEFPosition.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/ECEFPosition.html#L96">96</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>        setCoordinateTransformation(c);
    }

    /**
     * Gets cartesian x coordinate of body position expressed in meters (m) and resolved along ECI or ECEF-frame axes.
     *
     * @return cartesian x coordinate of body position.
     */
    public double getX() {
        return mX;
    }

    /**
     * Sets cartesian x coordinate of body position expressed in meters (m) and resolved along ECI or ECEF-frame axes.
     *
     * @param x cartesian x coordinate of body position.
     */
    public void setX(final double x) {
        mX = x;
    }

    /**
     * Gets cartesian y coordinate of body position expressed in meters (m) and resolved along ECI or ECEF-frame axes.
     *
     * @return cartesian y coordinate of body position.
     */
    public double getY() {
        return mY;
    }

    /**
     * Sets cartesian y coordinate of body position expressed in meters (m) and resolved along ECI or ECEF-frame axes.
     *
     * @param y cartesian y coordinate of body position.
     */
    public void setY(final double y) {
        mY = y;
    }

    /**
     * Gets cartesian z coordinate of body position expressed in meters (m) and resolved along ECI or ECEF-frame axes.
     *
     * @return cartesian z coordinate of body position.
     */
    public double getZ() {
        return mZ;
    }

    /**
     * Sets cartesian z coordinate of body position expressed in meters (m) and resolved along ECI or ECEF-frame axes.
     *
     * @param z cartesian z coordinate of body position.
     */
    public void setZ(final double z) {
        mZ = z;
    }

    /**
     * Sets cartesian coordinates of body position expressed in meters (m) and resolved along ECI or ECEF-frame axes.
     *
     * @param x cartesian x coordinate of body position, resolved along ECI or ECEF-frame axes.
     * @param y cartesian y coordinate of body position, resolved along ECI or ECEF-frame axes.
     * @param z cartesian z coordinate of body position, resolved along ECI or ECEF-frame axes.
     */
    public void setCoordinates(final double x, final double y, final double z) {
        mX = x;
        mY = y;
        mZ = z;
    }

    /**
     * Gets body position expressed in meters (m) and resolved along ECI or ECEF-frame axes.
     *
     * @return body position.
     */
    public Point3D getPosition() {
        return new InhomogeneousPoint3D(mX, mY, mZ);
    }

    /**
     * Gets body position expressed in meters (m) and resolved along ECI or ECEF-frame axes.
     *
     * @param result instance where position data is copied to.
     */
    public void getPosition(final Point3D result) {
        result.setInhomogeneousCoordinates(mX, mY, mZ);
    }

    /**
     * Sets body position expressed in meters (m) and resolved along ECI or ECEF-frame axes.
     *
     * @param point body position to be set.
     */
    public void setPosition(final Point3D point) {
        mX = point.getInhomX();
        mY = point.getInhomY();
        mZ = point.getInhomZ();
    }

    /**
     * Gets cartesian x coordinate of body position resolved along ECI or ECEF-frame axes.
     *
     * @param result instance where cartesian x coordinate of body position will be stored.
     */
    public void getPositionX(final Distance result) {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/INSLooselyCoupledKalmanEpochEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/INSLooselyCoupledKalmanEpochEstimator.html#L774">774</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/INSTightlyCoupledKalmanEpochEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/INSTightlyCoupledKalmanEpochEstimator.html#L192">192</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                INSLooselyCoupledKalmanState.NUM_PARAMS);

        final double gyroNoisePSD = config.getGyroNoisePSD();
        final double gyroNoiseValue = gyroNoisePSD * propagationInterval;
        for (int i = 0; i &lt; 3; i++) {
            qPrimeMatrix.setElementAt(i, i, gyroNoiseValue);
        }

        final double accelNoisePSD = config.getAccelerometerNoisePSD();
        final double accelNoiseValue = accelNoisePSD * propagationInterval;
        for (int i = 3; i &lt; 6; i++) {
            qPrimeMatrix.setElementAt(i, i, accelNoiseValue);
        }

        final double accelBiasPSD = config.getAccelerometerBiasPSD();
        final double accelBiasValue = accelBiasPSD * propagationInterval;
        for (int i = 9; i &lt; 12; i++) {
            qPrimeMatrix.setElementAt(i, i, accelBiasValue);
        }

        final double gyroBiasPSD = config.getGyroBiasPSD();
        final double gyroBiasValue = gyroBiasPSD * propagationInterval;
        for (int i = 12; i &lt; 15; i++) {
            qPrimeMatrix.setElementAt(i, i, gyroBiasValue);
        }


        // 3. Propagate state estimates using (3.14) noting that all states are zero
        // due to closed-loop correction.
        // x_est_propagated(1:15, 1) = 0;

        // 4. Propagate state estimation error covariance matrix using (3.46)
        final Matrix pMatrixOld = previousState.getCovariance();</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/LMedSRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/LMedSRobustRangingRadioSourceEstimator2D.html#L175">175</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/LMedSRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/LMedSRobustRssiRadioSourceEstimator2D.html#L409">409</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>        super(readings, initialPosition, listener);
    }

    /**
     * Returns threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value, the
     * algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algrithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @return stop threshold to stop the algorithm prematurely when a certain
     * accuracy has been reached.
     */
    public double getStopThreshold() {
        return mStopThreshold;
    }

    /**
     * Sets threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value,
     * the algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algorithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @param stopThreshold stop threshold to stop the algorithm prematurely
     *                      when a certain accuracy has been reached.
     * @throws IllegalArgumentException if provided value is zero or negative.
     * @throws LockedException if this solver is locked.
     */
    public void setStopThreshold(double stopThreshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (stopThreshold &lt;= MIN_STOP_THRESHOLD) {
            throw new IllegalArgumentException();
        }

        mStopThreshold = stopThreshold;
    }

    /**
     * Robustly estimates position for a radio source.
     *
     * @throws LockedException if instance is busy during estimation.
     * @throws NotReadyException if estimator is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     * (i.e. numerical instability, no solution available, etc).
     */
    @Override
    public void estimate() throws LockedException, NotReadyException,
            RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        LMedSRobustEstimator&lt;Solution&lt;Point2D&gt;&gt; innerEstimator =
                new LMedSRobustEstimator&lt;&gt;(
                        new LMedSRobustEstimatorListener&lt;Solution&lt;Point2D&gt;&gt;() {
                    @Override
                    public int getTotalSamples() {
                        return mReadings.size();
                    }

                    @Override
                    public int getSubsetSize() {
                        return Math.max(mPreliminarySubsetSize, getMinReadings());
                    }

                    @Override
                    public void estimatePreliminarSolutions(int[] sampleIndices,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/LMedSRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/LMedSRobustRangingRadioSourceEstimator3D.html#L175">175</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/LMedSRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/LMedSRobustRssiRadioSourceEstimator3D.html#L409">409</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>        super(readings, initialPosition, listener);
    }

    /**
     * Returns threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value, the
     * algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algrithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @return stop threshold to stop the algorithm prematurely when a certain
     * accuracy has been reached.
     */
    public double getStopThreshold() {
        return mStopThreshold;
    }

    /**
     * Sets threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value,
     * the algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algorithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @param stopThreshold stop threshold to stop the algorithm prematurely
     *                      when a certain accuracy has been reached.
     * @throws IllegalArgumentException if provided value is zero or negative.
     * @throws LockedException if this solver is locked.
     */
    public void setStopThreshold(double stopThreshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (stopThreshold &lt;= MIN_STOP_THRESHOLD) {
            throw new IllegalArgumentException();
        }

        mStopThreshold = stopThreshold;
    }

    /**
     * Robustly estimates position for a radio source.
     *
     * @throws LockedException if instance is busy during estimation.
     * @throws NotReadyException if estimator is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     * (i.e. numerical instability, no solution available, etc).
     */
    @Override
    public void estimate() throws LockedException, NotReadyException,
            RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        LMedSRobustEstimator&lt;Solution&lt;Point3D&gt;&gt; innerEstimator =
                new LMedSRobustEstimator&lt;&gt;(
                        new LMedSRobustEstimatorListener&lt;Solution&lt;Point3D&gt;&gt;() {
                    @Override
                    public int getTotalSamples() {
                        return mReadings.size();
                    }

                    @Override
                    public int getSubsetSize() {
                        return Math.max(mPreliminarySubsetSize, getMinReadings());
                    }

                    @Override
                    public void estimatePreliminarSolutions(int[] sampleIndices,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/calibration/RANSACRobustKnownBiasAndFrameAccelerometerCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/RANSACRobustKnownBiasAndFrameAccelerometerCalibrator.html#L726">726</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/calibration/RANSACRobustKnownFrameAccelerometerCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/RANSACRobustKnownFrameAccelerometerCalibrator.html#L187">187</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>        super(measurements, bias, commonAxisUsed, listener);
    }

    /**
     * Gets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on norm between measured specific forces and the
     * ones generated with estimated calibration parameters provided for each sample.
     *
     * @return threshold to determine whether samples are inliers or not.
     */
    public double getThreshold() {
        return mThreshold;
    }

    /**
     * Sets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on norm between measured specific forces and the
     * ones generated with estimated calibration parameters provided for each sample.
     *
     * @param threshold threshold to determine whether samples are inliers or not.
     * @throws IllegalArgumentException if provided value is equal or less than zero.
     * @throws LockedException          if calibrator is currently running.
     */
    public void setThreshold(double threshold) throws LockedException {
        if (mRunning) {
            throw new LockedException();
        }
        if (threshold &lt;= MIN_THRESHOLD) {
            throw new IllegalArgumentException();
        }
        mThreshold = threshold;
    }

    /**
     * Indicates whether inliers must be computed and kept.
     *
     * @return true if inliers must be computed and kept, false if inliers
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepInliersEnabled() {
        return mComputeAndKeepInliers;
    }

    /**
     * Specifies whether inliers must be computed and kept.
     *
     * @param computeAndKeepInliers true if inliers must be computed and kept,
     *                              false if inliers only need to be computed but not kept.
     * @throws LockedException if calibrator is currently running.
     */
    public void setComputeAndKeepInliersEnabled(boolean computeAndKeepInliers)
            throws LockedException {
        if (mRunning) {
            throw new LockedException();
        }
        mComputeAndKeepInliers = computeAndKeepInliers;
    }

    /**
     * Indicates whether residuals must be computed and kept.
     *
     * @return true if residuals must be computed and kept, false if residuals
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepResiduals() {
        return mComputeAndKeepResiduals;
    }

    /**
     * Specifies whether residuals must be computed and kept.
     *
     * @param computeAndKeepResiduals true if residuals must be computed and kept,
     *                                false if residuals only need to be computed but not kept.
     * @throws LockedException if calibrator is currently running.
     */
    public void setComputeAndKeepResidualsEnabled(boolean computeAndKeepResiduals)
            throws LockedException {
        if (mRunning) {
            throw new LockedException();
        }
        mComputeAndKeepResiduals = computeAndKeepResiduals;
    }

    /**
     * Estimates accelerometer calibration parameters containing scale factors
     * and cross-coupling errors.
     *
     * @throws LockedException      if calibrator is currently running.
     * @throws NotReadyException    if calibrator is not ready.
     * @throws CalibrationException if estimation fails for numerical reasons.
     */
    @Override
    public void calibrate() throws LockedException, NotReadyException, CalibrationException {
        if (mRunning) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        final RANSACRobustEstimator&lt;Matrix&gt; innerEstimator =</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/gnss/GNSSKalmanFilteredEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/gnss/GNSSKalmanFilteredEstimator.html#L267">267</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/INSGNSSTightlyCoupledKalmanFilteredEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/INSGNSSTightlyCoupledKalmanFilteredEstimator.html#L1151">1151</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public void setListener(final GNSSKalmanFilteredEstimatorListener listener)
            throws LockedException {
        if (mRunning) {
            throw new LockedException();
        }

        mListener = listener;
    }

    /**
     * Gets minimum epoch interval expressed in seconds (s) between consecutive
     * propagations or measurements expressed in seconds.
     * Attempting to propagate results using Kalman filter or updating measurements
     * when intervals are less than this value, will be ignored.
     *
     * @return minimum epoch interval between consecutive propagations or
     * measurements.
     */
    public double getEpochInterval() {
        return mEpochInterval;
    }

    /**
     * Sets minimum epoch interval expressed in seconds (s) between consecutive
     * propagations or measurements expressed in seconds.
     * Attempting to propagate results using Kalman filter or updating measurements
     * when intervals are less than this value, will be ignored.
     *
     * @param epochInterval minimum epoch interval expressed in seconds (s) between
     *                      consecutive propagations or measurements.
     * @throws LockedException          if this estimator is already running.
     * @throws IllegalArgumentException if provided epoch interval is negative.
     */
    public void setEpochInterval(final double epochInterval) throws LockedException {
        if (mRunning) {
            throw new LockedException();
        }

        if (epochInterval &lt; 0.0) {
            throw new IllegalArgumentException();
        }

        mEpochInterval = epochInterval;
    }

    /**
     * Gets minimum epoch interval between consecutive propagations or measurements.
     * Attempting to propagate results using Kalman filter or updating measurements
     * when intervals are less than this value, will be ignored.
     *
     * @param result instance where minimum epoch interval will be stored.
     */
    public void getEpochIntervalAsTime(final Time result) {
        result.setValue(mEpochInterval);
        result.setUnit(TimeUnit.SECOND);
    }

    /**
     * Gets minimum epoch interval between consecutive propagations or measurements.
     * Attempting to propagate results using Kalman filter or updating measurements
     * when intervals are less than this value, will be ignored.
     *
     * @return minimum epoch interval.
     */
    public Time getEpochIntervalAsTime() {
        return new Time(mEpochInterval, TimeUnit.SECOND);
    }

    /**
     * Sets minimum epoch interval between consecutive propagations or measurements.
     * Attempting to propagate results using Kalman filter or updating measurements
     * when intervals are less than this value, will be ignored.
     *
     * @param epochInterval minimum epoch interval.
     * @throws LockedException          if this estimator is already running.
     * @throws IllegalArgumentException if provided epoch interval is negative.
     */
    public void setEpochInterval(final Time epochInterval) throws LockedException {
        final double epochIntervalSeconds = TimeConverter.convert(
                epochInterval.getValue().doubleValue(),
                epochInterval.getUnit(), TimeUnit.SECOND);
        setEpochInterval(epochIntervalSeconds);
    }

    /**
     * Gets GNSS Kalman configuration parameters (usually obtained through
     * calibration).
     *
     * @param result instance where GNSS Kalman configuration parameters will be
     *               stored.
     * @return true if result instance is updated, false otherwise.
     */
    public boolean getConfig(final GNSSKalmanConfig result) {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/fingerprint/SecondOrderNonLinearFingerprintPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/fingerprint/SecondOrderNonLinearFingerprintPositionEstimator3D.html#L222">222</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/fingerprint/ThirdOrderNonLinearFingerprintPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/fingerprint/ThirdOrderNonLinearFingerprintPositionEstimator3D.html#L434">434</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>        double value1 = - 10.0 * n * diffX1a / (ln10 * d1a2);
        double value2 = - 10.0 * n * diffY1a / (ln10 * d1a2);
        double value3 = - 10.0 * n * diffZ1a / (ln10 * d1a2);
        double value4 = - 5.0 * n * (-diffX1a2 + diffY1a2 + diffZ1a2) / (ln10 * d1a4);
        double value5 = - 5.0 * n * (diffX1a2 - diffY1a2 + diffZ1a2) / (ln10 * d1a4);
        double value6 = - 5.0 * n * (diffX1a2 + diffY1a2 - diffZ1a2) / (ln10 * d1a4);
        double value7 = 20.0 * n * diffX1a * diffY1a / (ln10 * d1a4);
        double value8 = 20.0 * n * diffY1a * diffZ1a / (ln10 * d1a4);
        double value9 = 20.0 * n * diffX1a * diffZ1a / (ln10 * d1a4);

        double result = pr</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator2D.html#L1024">1024</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator2D.html#L520">520</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator2D.html#L1035">1035</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>                                    PROMedSRobustRangingAndRssiRadioSourceEstimator2D.this, progress);
                        }
                    }
                });

        try {
            mLocked = true;
            mInliersData = null;

            //inlier thresholds are disabled to obtain a less restrictive amount of inliers
            innerEstimator.setUseInlierThresholds(false);

            innerEstimator.setConfidence(mConfidence);
            innerEstimator.setMaxIterations(mMaxIterations);
            innerEstimator.setProgressDelta(mProgressDelta);
            Solution&lt;Point2D&gt; result = innerEstimator.estimate();
            mInliersData = innerEstimator.getInliersData();
            attemptRefine(result);

        } catch (com.irurueta.numerical.LockedException e) {
            throw new LockedException(e);
        } catch (com.irurueta.numerical.NotReadyException e) {
            throw new NotReadyException(e);
        } finally {
            mLocked = false;
        }
    }

    /**
     * Returns method being used for robust estimation.
     *
     * @return method being used for robust estimation.
     */
    @Override
    public RobustEstimatorMethod getMethod() {
        return RobustEstimatorMethod.PROMedS;
    }

    /**
     * Sets quality scores corresponding to each provided sample.
     * This method is used internally and does not check whether instance is
     * locked or not.
     *
     * @param qualityScores quality scores to be set.
     * @throws IllegalArgumentException if provided quality scores length
     * is smaller than 3 samples.
     */
    private void internalSetQualityScores(double[] qualityScores) {
        if (qualityScores == null ||
                qualityScores.length &lt; getMinReadings()) {
            throw new IllegalArgumentException();
        }

        mQualityScores = qualityScores;
    }
}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator3D.html#L1024">1024</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator3D.html#L519">519</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator3D.html#L1034">1034</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                                            PROMedSRobustRangingAndRssiRadioSourceEstimator3D.this, progress);
                                }
                            }
                        });

        try {
            mLocked = true;
            mInliersData = null;

            //inlier thresholds are disabled to obtain a less restrictive amount of inliers
            innerEstimator.setUseInlierThresholds(false);

            innerEstimator.setConfidence(mConfidence);
            innerEstimator.setMaxIterations(mMaxIterations);
            innerEstimator.setProgressDelta(mProgressDelta);
            Solution&lt;Point3D&gt; result = innerEstimator.estimate();
            mInliersData = innerEstimator.getInliersData();
            attemptRefine(result);

        } catch (com.irurueta.numerical.LockedException e) {
            throw new LockedException(e);
        } catch (com.irurueta.numerical.NotReadyException e) {
            throw new NotReadyException(e);
        } finally {
            mLocked = false;
        }
    }

    /**
     * Returns method being used for robust estimation.
     *
     * @return method being used for robust estimation.
     */
    @Override
    public RobustEstimatorMethod getMethod() {
        return RobustEstimatorMethod.PROMedS;
    }

    /**
     * Sets quality scores corresponding to each provided sample.
     * This method is used internally and does not check whether instance is
     * locked or not.
     *
     * @param qualityScores quality scores to be set.
     * @throws IllegalArgumentException if provided quality scores length
     * is smaller than 3 samples.
     */
    private void internalSetQualityScores(double[] qualityScores) {
        if (qualityScores == null ||
                qualityScores.length &lt; getMinReadings()) {
            throw new IllegalArgumentException();
        }

        mQualityScores = qualityScores;
    }
}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/gnss/GNSSKalmanFilteredEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/gnss/GNSSKalmanFilteredEstimator.html#L267">267</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/INSGNSSTightlyCoupledKalmanFilteredEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/INSGNSSTightlyCoupledKalmanFilteredEstimator.html#L1151">1151</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/INSLooselyCoupledKalmanFilteredEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/INSLooselyCoupledKalmanFilteredEstimator.html#L1049">1049</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    public void setListener(final GNSSKalmanFilteredEstimatorListener listener)
            throws LockedException {
        if (mRunning) {
            throw new LockedException();
        }

        mListener = listener;
    }

    /**
     * Gets minimum epoch interval expressed in seconds (s) between consecutive
     * propagations or measurements expressed in seconds.
     * Attempting to propagate results using Kalman filter or updating measurements
     * when intervals are less than this value, will be ignored.
     *
     * @return minimum epoch interval between consecutive propagations or
     * measurements.
     */
    public double getEpochInterval() {
        return mEpochInterval;
    }

    /**
     * Sets minimum epoch interval expressed in seconds (s) between consecutive
     * propagations or measurements expressed in seconds.
     * Attempting to propagate results using Kalman filter or updating measurements
     * when intervals are less than this value, will be ignored.
     *
     * @param epochInterval minimum epoch interval expressed in seconds (s) between
     *                      consecutive propagations or measurements.
     * @throws LockedException          if this estimator is already running.
     * @throws IllegalArgumentException if provided epoch interval is negative.
     */
    public void setEpochInterval(final double epochInterval) throws LockedException {
        if (mRunning) {
            throw new LockedException();
        }

        if (epochInterval &lt; 0.0) {
            throw new IllegalArgumentException();
        }

        mEpochInterval = epochInterval;
    }

    /**
     * Gets minimum epoch interval between consecutive propagations or measurements.
     * Attempting to propagate results using Kalman filter or updating measurements
     * when intervals are less than this value, will be ignored.
     *
     * @param result instance where minimum epoch interval will be stored.
     */
    public void getEpochIntervalAsTime(final Time result) {
        result.setValue(mEpochInterval);
        result.setUnit(TimeUnit.SECOND);
    }

    /**
     * Gets minimum epoch interval between consecutive propagations or measurements.
     * Attempting to propagate results using Kalman filter or updating measurements
     * when intervals are less than this value, will be ignored.
     *
     * @return minimum epoch interval.
     */
    public Time getEpochIntervalAsTime() {
        return new Time(mEpochInterval, TimeUnit.SECOND);
    }

    /**
     * Sets minimum epoch interval between consecutive propagations or measurements.
     * Attempting to propagate results using Kalman filter or updating measurements
     * when intervals are less than this value, will be ignored.
     *
     * @param epochInterval minimum epoch interval.
     * @throws LockedException          if this estimator is already running.
     * @throws IllegalArgumentException if provided epoch interval is negative.
     */
    public void setEpochInterval(final Time epochInterval) throws LockedException {
        final double epochIntervalSeconds = TimeConverter.convert(
                epochInterval.getValue().doubleValue(),
                epochInterval.getUnit(), TimeUnit.SECOND);
        setEpochInterval(epochIntervalSeconds);
    }

    /**
     * Gets GNSS Kalman configuration parameters (usually obtained through
     * calibration).
     *
     * @param result instance where GNSS Kalman configuration parameters will be
     *               stored.
     * @return true if result instance is updated, false otherwise.
     */
    public boolean getConfig(final GNSSKalmanConfig result) {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/fingerprint/NonLinearFingerprintPositionAndRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/fingerprint/NonLinearFingerprintPositionAndRadioSourceEstimator.html#L462">462</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/fingerprint/NonLinearFingerprintPositionEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/fingerprint/NonLinearFingerprintPositionEstimator.html#L314">314</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>        if (fallbackRssiStandardDeviation &lt; TINY) {
            throw new IllegalArgumentException();
        }
        mFallbackRssiStandardDeviation = fallbackRssiStandardDeviation;
    }

    /**
     * Indicates whether measured RSSI standard deviation of closest fingerprint must be
     * propagated into measured RSSI reading variance at unknown location.
     * @return true to propagate RSSI standard deviation of closest fingerprint,
     * false otherwise.
     */
    public boolean isFingerprintRssiStandardDeviationPropagated() {
        return mPropagateFingerprintRssiStandardDeviation;
    }

    /**
     * Specifies whether measured RSSI standard deviation of closest fingerprint must be
     * propagated into measured RSSI reading variance at unknown location.
     * @param propagateFingerprintRssiStandardDeviation true to propagate RSSI standard
     *                                                  deviation of closest fingerprint,
     *                                                  false otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setFingerprintRssiStandardDeviationPropagated(
            boolean propagateFingerprintRssiStandardDeviation) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mPropagateFingerprintRssiStandardDeviation =
                propagateFingerprintRssiStandardDeviation;
    }

    /**
     * Indicates whether path-loss exponent standard deviation of radio source must be
     * propagated into measured RSSI reading variance at unknown location.
     * @return true to propagate  path-loss exponent standard deviation of radio source,
     * false otherwise.
     */
    public boolean isPathlossExponentStandardDeviationPropagated() {
        return mPropagatePathlossExponentStandardDeviation;
    }

    /**
     * Specifies whether path-loss exponent standard deviation of radio source must be
     * propagated into measured RSSI reading variance at unknown location.
     * @param propagatePathlossExponentStandardDeviation true to propagate path-loss
     *                                                   exponent standard deviation of
     *                                                   radio source, false otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setPathlossExponentStandardDeviationPropagated(
            boolean propagatePathlossExponentStandardDeviation) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mPropagatePathlossExponentStandardDeviation =
                propagatePathlossExponentStandardDeviation;
    }

    /**
     * Indicates whether covariance of closest fingerprint position must be propagated
     * into measured RSSI reading variance at unknown location.
     * @return true to propagate fingerprint position covariance, false otherwise.
     */
    public boolean isFingerprintPositionCovariancePropagated() {
        return mPropagateFingerprintPositionCovariance;
    }

    /**
     * Specifies whether covariance of closest fingerprint position must be propagated
     * into measured RSSI reading variance at unknown location.
     * @param propagateFingerprintPositionCovariance true to propagate fingerprint
     *                                               position covariance, false otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setFingerprintPositionCovariancePropagated(
            boolean propagateFingerprintPositionCovariance) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mPropagateFingerprintPositionCovariance =
                propagateFingerprintPositionCovariance;
    }

    /**
     * Indicates whether covariance of radio source position must be propagated into
     * measured RSSI reading variance at unknown location.
     * @return true to propagate radio source position covariance, false otherwise.
     */
    public boolean isRadioSourcePositionCovariancePropagated() {
        return mPropagateRadioSourcePositionCovariance;
    }

    /**
     * Specifies whether covariance of radio source position must be propagated into
     * measured RSSI reading variance at unknown location.
     * @param propagateRadioSourcePositionCovariance true to propagate radio source
     *                                               position covariance, false otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setRadioSourcePositionCovariancePropagated(
            boolean propagateRadioSourcePositionCovariance) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mPropagateRadioSourcePositionCovariance =
                propagateRadioSourcePositionCovariance;
    }</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/calibration/KnownBiasAndFrameAccelerometerLinearLeastSquaresCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/KnownBiasAndFrameAccelerometerLinearLeastSquaresCalibrator.html#L1474">1474</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/calibration/KnownFrameAccelerometerLinearLeastSquaresCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/KnownFrameAccelerometerLinearLeastSquaresCalibrator.html#L1005">1005</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    }

    /**
     * Fills scale factor and cross coupling error matrix with estimated values.
     *
     * @param sx  x scale factor
     * @param sy  y scale factor
     * @param sz  z scale factor
     * @param mxy x-y cross coupling
     * @param mxz x-z cross coupling
     * @param myx y-x cross coupling
     * @param myz y-z cross coupling
     * @param mzx z-x cross coupling
     * @param mzy z-y cross coupling
     * @throws WrongSizeException never happens.
     */
    private void fillMa(final double sx, final double sy, final double sz,
                        final double mxy, final double mxz, final double myx,
                        final double myz, final double mzx, final double mzy)
            throws WrongSizeException {
        if (mEstimatedMa == null) {
            mEstimatedMa = new Matrix(BodyKinematics.COMPONENTS,
                    BodyKinematics.COMPONENTS);
        }

        mEstimatedMa.setElementAt(0, 0, sx);
        mEstimatedMa.setElementAt(1, 0, myx);
        mEstimatedMa.setElementAt(2, 0, mzx);

        mEstimatedMa.setElementAt(0, 1, mxy);
        mEstimatedMa.setElementAt(1, 1, sy);
        mEstimatedMa.setElementAt(2, 1, mzy);

        mEstimatedMa.setElementAt(0, 2, mxz);
        mEstimatedMa.setElementAt(1, 2, myz);
        mEstimatedMa.setElementAt(2, 2, sz);
    }</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/fingerprint/FirstOrderNonLinearFingerprintPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/fingerprint/FirstOrderNonLinearFingerprintPositionEstimator3D.html#L150">150</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/fingerprint/SecondOrderNonLinearFingerprintPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/fingerprint/SecondOrderNonLinearFingerprintPositionEstimator3D.html#L150">150</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/fingerprint/ThirdOrderNonLinearFingerprintPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/fingerprint/ThirdOrderNonLinearFingerprintPositionEstimator3D.html#L147">147</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    }

    /**
     * Evaluates a non-linear multi dimension function at provided point using
     * provided parameters and returns its evaluation and derivatives of the
     * function respect the function parameters.
     * @param i number of sample being evaluated.
     * @param point point where function will be evaluated.
     * @param params initial parameters estimation to be tried. These will
     * change as the Levenberg-Marquard algorithm iterates to the best solution.
     * These are used as input parameters along with point to evaluate function.
     * @param derivatives partial derivatives of the function respect to each
     * provided parameter.
     * @return function evaluation at provided point.
     */
    @Override
    @SuppressWarnings(&quot;Duplicates&quot;)
    protected double evaluate(int i, double[] point, double[] params, double[] derivatives) {
        //This method implements received power at point pi = (xi, yi, zi) and its derivatives

        //Pr(pi) = Pr(p1)
        //  - 10*n*(x1 - xa)/(ln(10)*d1a^2)*(xi - x1)
        //  - 10*n*(y1 - ya)/(ln(10)*d1a^2)*(yi - y1)
        //  - 10*n*(z1 - za)/(ln(10)*d1a^2)*(zi - z1)

        double xi = params[0];
        double yi = params[1];
        double zi = params[2];

        //received power
        double pr = point[0];

        //fingerprint coordinates
        double x1 = point[1];
        double y1 = point[2];
        double z1 = point[3];

        //radio source coordinates
        double xa = point[4];
        double ya = point[5];
        double za = point[6];

        //path loss exponent
        double n = point[7];

        double ln10 = Math.log(10.0);

        double diffXi1 = xi - x1;
        double diffYi1 = yi - y1;
        double diffZi1 = zi - z1;

        double diffX1a = x1 - xa;
        double diffY1a = y1 - ya;
        double diffZ1a = z1 - za;

        double diffX1a2 = diffX1a * diffX1a;</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/PositionEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PositionEstimator.html#L74">74</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/RobustPositionEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/RobustPositionEstimator.html#L137">137</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public PositionEstimator(L listener) {
        mListener = listener;
    }

    /**
     * Gets located radio sources ussed for lateration.
     *
     * @return located radio sources used for lateration.
     */
    public List&lt;? extends RadioSourceLocated&lt;P&gt;&gt; getSources() {
        return mSources;
    }

    /**
     * Sets located radio sources used for lateration.
     *
     * @param sources located radio sources used for lateration.
     * @throws LockedException          if estimator is locked.
     * @throws IllegalArgumentException if provided value is null or the number of provided
     *                                  sources is less than the required minimum.
     */
    public void setSources(List&lt;? extends RadioSourceLocated&lt;P&gt;&gt; sources)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }

        internalSetSources(sources);
    }

    /**
     * Gets fingerprint containing readings at an unknown location for provided located
     * radio sources.
     *
     * @return  fingerprint containing readings at an unknown location for provided
     *          located radio sources.
     */
    public Fingerprint&lt;? extends RadioSource, ? extends R&gt; getFingerprint() {
        return mFingerprint;
    }

    /**
     * Sets fingerprint containing readings at an unknown location for provided located
     * radio sources.
     * @param fingerprint fingerprint containing readings at an unknown location for
     *                    provided located radio sources.
     * @throws LockedException          if estimator is locked.
     * @throws IllegalArgumentException if provided value is null.
     */
    public void setFingerprint(Fingerprint&lt;? extends RadioSource, ? extends R&gt; fingerprint)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }

        internalSetFingerprint(fingerprint);
    }

    /**
     * Gets listener to be notified of events raised by this instance.
     *
     * @return listener to be notified of events raised by this instance.
     */
    public L getListener() {
        return mListener;
    }

    /**
     * Sets listener to be notified of events raised by this instance.
     *
     * @param listener listener to be notified of events raised by this instance.
     * @throws LockedException if estimator is locked.
     */
    public void setListener(L listener) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mListener = listener;
    }

    /**
     * Gets estimated inhomogeneous position coordinates.
     *
     * @return estimated inhomogeneous position coordinates.
     */
    public double[] getEstimatedPositionCoordinates() {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/fingerprint/NonLinearFingerprintPositionAndRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/fingerprint/NonLinearFingerprintPositionAndRadioSourceEstimator.html#L570">570</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/fingerprint/NonLinearFingerprintPositionEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/fingerprint/NonLinearFingerprintPositionEstimator.html#L438">438</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    }

    /**
     * Estimates position and radio sources based on provided located radio sources and readings of
     * such radio sources at an unknown location.
     * @throws LockedException if estimator is locked.
     * @throws NotReadyException if estimator is not ready.
     * @throws FingerprintEstimationException if estimation fails for some other reason.
     */
    @Override
    @SuppressWarnings(&quot;Duplicates&quot;)
    public void estimate() throws LockedException, NotReadyException,
            FingerprintEstimationException {

        if (!isReady()) {
            throw new NotReadyException();
        }
        if (isLocked()) {
            throw new LockedException();
        }

        try {
            mLocked = true;

            if (mListener != null) {
                mListener.onEstimateStart(this);
            }

            RadioSourceNoMeanKNearestFinder&lt;P, RadioSource&gt; noMeanfinder = null;
            RadioSourceKNearestFinder&lt;P, RadioSource&gt; finder = null;
            if (mUseNoMeanNearestFingerprintFinder) {
                //noinspection unchecked
                noMeanfinder = new RadioSourceNoMeanKNearestFinder&lt;&gt;(
                        (Collection&lt;? extends RssiFingerprintLocated&lt;RadioSource,
                                RssiReading&lt;RadioSource&gt;, P&gt;&gt;)mLocatedFingerprints);
            } else {
                //noinspection unchecked
                finder = new RadioSourceKNearestFinder&lt;&gt;(
                        (Collection&lt;? extends RssiFingerprintLocated&lt;RadioSource,
                                RssiReading&lt;RadioSource&gt;, P&gt;&gt;)mLocatedFingerprints);
            }

            mEstimatedPositionCoordinates = null;
            mCovariance = null;</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustMixedRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustMixedRadioSourceEstimator.html#L2321">2321</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator.html#L2187">2187</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>        }

        mRssiEstimator.setProgressDelta(2.0f * mProgressDelta);
        mRssiEstimator.setConfidence(mRssiConfidence);
        mRssiEstimator.setMaxIterations(mRssiMaxIterations);
        mRssiEstimator.setResultRefined(mRefineResult);
        mRssiEstimator.setCovarianceKept(mKeepCovariance);

        //initial position is not set because position estimated from ranging measures
        //will be later used
        mRssiEstimator.setInitialTransmittedPowerdBm(mInitialTransmittedPowerdBm);
        mRssiEstimator.setInitialPathLossExponent(mInitialPathLossExponent);

        mRssiEstimator.setTransmittedPowerEstimationEnabled(
                mTransmittedPowerEstimationEnabled);
        mRssiEstimator.setPathLossEstimationEnabled(mPathLossEstimationEnabled);

        mRssiEstimator.setListener(new RobustRssiRadioSourceEstimatorListener&lt;S, P&gt;() {
            @Override
            public void onEstimateStart(RobustRssiRadioSourceEstimator&lt;S, P&gt; estimator) { /* not used */ }

            @Override
            public void onEstimateEnd(RobustRssiRadioSourceEstimator&lt;S, P&gt; estimator) { /* not used */ }

            @Override
            public void onEstimateNextIteration(RobustRssiRadioSourceEstimator&lt;S, P&gt; estimator,
                                                int iteration) { /* not used */ }

            @Override
            public void onEstimateProgressChange(RobustRssiRadioSourceEstimator&lt;S, P&gt; estimator, float progress) {
                if (mListener != null) {
                    mListener.onEstimateProgressChange(</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/estimators/NEDPositionEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/estimators/NEDPositionEstimator.html#L2281">2281</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/estimators/NEDVelocityEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/estimators/NEDVelocityEstimator.html#L2383">2383</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>        estimatePosition(timeInterval, oldPosition, oldVelocity, velocity,
                result);
        return result;
    }

    /**
     * Converts provided time instance to seconds (s).
     *
     * @param time time instance to be converted.
     * @return provided time value expressed in seconds.
     */
    private static double convertTimeToDouble(final Time time) {
        return TimeConverter.convert(time.getValue().doubleValue(), time.getUnit(),
                TimeUnit.SECOND);
    }

    /**
     * Converts provided angle instance to radians (rad).
     *
     * @param angle angle instance to be converted.
     * @return provided angle value expressed in radians.
     */
    private static double convertAngleToDouble(final Angle angle) {
        return AngleConverter.convert(angle.getValue().doubleValue(), angle.getUnit(), AngleUnit.RADIANS);
    }

    /**
     * Converts provided distance instance to meters (m).
     *
     * @param distance distance instance to be converted.
     * @return provided distance value expressed in meters.
     */
    private static double convertDistanceToDouble(final Distance distance) {
        return DistanceConverter.convert(distance.getValue().doubleValue(), distance.getUnit(),
                DistanceUnit.METER);
    }

    /**
     * Converts provided speed instance to meters per second (m/s).
     *
     * @param speed speed instance to be converted.
     * @return provided speed value expressed in meters per second.
     */
    private static double convertSpeedToDouble(final Speed speed) {
        return SpeedConverter.convert(speed.getValue().doubleValue(), speed.getUnit(),
                SpeedUnit.METERS_PER_SECOND);
    }
}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/fingerprint/LinearFingerprintPositionEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/fingerprint/LinearFingerprintPositionEstimator.html#L99">99</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/fingerprint/NonLinearFingerprintPositionAndRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/fingerprint/NonLinearFingerprintPositionAndRadioSourceEstimator.html#L570">570</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/fingerprint/NonLinearFingerprintPositionEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/fingerprint/NonLinearFingerprintPositionEstimator.html#L438">438</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    }

    /**
     * Estimates position based on provided located radio sources and readings of such radio sources at
     * an unknown location.
     * @throws LockedException if estimator is locked.
     * @throws NotReadyException if estimator is not ready.
     * @throws FingerprintEstimationException if estimation fails for some other reason.
     */
    @Override
    @SuppressWarnings(&quot;Duplicates&quot;)
    public void estimate() throws LockedException, NotReadyException,
            FingerprintEstimationException {

        if (!isReady()) {
            throw new NotReadyException();
        }
        if (isLocked()) {
            throw new LockedException();
        }

        try {
            mLocked = true;

            if (mListener != null) {
                mListener.onEstimateStart(this);
            }

            RadioSourceNoMeanKNearestFinder&lt;P, RadioSource&gt; noMeanfinder = null;
            RadioSourceKNearestFinder&lt;P, RadioSource&gt; finder = null;
            if (mUseNoMeanNearestFingerprintFinder) {
                //noinspection unchecked
                noMeanfinder = new RadioSourceNoMeanKNearestFinder&lt;&gt;(
                        (Collection&lt;? extends RssiFingerprintLocated&lt;RadioSource,
                                RssiReading&lt;RadioSource&gt;, P&gt;&gt;)mLocatedFingerprints);
            } else {
                //noinspection unchecked
                finder = new RadioSourceKNearestFinder&lt;&gt;(
                        (Collection&lt;? extends RssiFingerprintLocated&lt;RadioSource,
                                RssiReading&lt;RadioSource&gt;, P&gt;&gt;)mLocatedFingerprints);
            }

            mEstimatedPositionCoordinates = null;</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/MixedRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MixedRadioSourceEstimator.html#L1038">1038</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RangingAndRssiRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RangingAndRssiRadioSourceEstimator.html#L957">957</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    public Double getEstimatedTransmittedPowerdBm() {
        return mEstimatedTransmittedPowerdBm;
    }

    /**
     * Gets estimated exponent typically used on free space for path loss propagation in
     * terms of distance.
     * On different environments path loss exponent might have different values:
     * - Free space: 2.0
     * - Urban Area: 2.7 to 3.5
     * - Suburban Area: 3 to 5
     * - Indoor (line-of-sight): 1.6 to 1.8
     * If path loss exponent estimation is not enabled, this value will always be equal to
     * {@link #DEFAULT_PATH_LOSS_EXPONENT}
     * @return estimated path loss exponent.
     */
    public double getEstimatedPathLossExponent() {
        return mEstimatedPathLossExponent;
    }

    /**
     * Gets estimated transmitted power variance.
     * This value will only be available when transmitted power
     * estimation is enabled.
     * @return estimated transmitted power variance or null.
     */
    public Double getEstimatedTransmittedPowerVariance() {
        return mEstimatedTransmittedPowerVariance;
    }

    /**
     * Gets estimated path loss exponent variance.
     * This value will only be available when pathloss
     * exponent estimation is enabled.
     * @return estimated path loss exponent variance or null.
     */
    public Double getEstimatedPathLossExponentVariance() {
        return mEstimatedPathLossExponentVariance;
    }

    /**
     * Creates inner estimators if needed.
     */
    protected abstract void createInnerEstimatorsIfNeeded();

    /**
     * Creates a ranging reading from a ranging and RSSI reading.
     * @param reading input reading to convert from.
     * @return a ranging reading containing only the ranging data of input reading.
     */
    private RangingReadingLocated&lt;S, P&gt; createRangingReading(RangingAndRssiReadingLocated&lt;S, P&gt; reading) {
        return new RangingReadingLocated&lt;&gt;(reading.getSource(),
                reading.getDistance(), reading.getPosition(),
                reading.getDistanceStandardDeviation(),
                reading.getPositionCovariance());
    }

    /**
     * Creates an RSSI reading from a ranging and RSSI reading.
     * @param reading input reading to convert from.
     * @return an RSSI reading containing only the RSSI data of input reading.
     */
    private RssiReadingLocated&lt;S, P&gt; createRssiReading(RangingAndRssiReadingLocated&lt;S, P&gt; reading) {
        return new RssiReadingLocated&lt;&gt;(reading.getSource(),
                reading.getRssi(), reading.getPosition(),
                reading.getRssiStandardDeviation(),
                reading.getPositionCovariance());
    }</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator3D.html#L2776">2776</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RssiRadioSourceEstimator3D.html#L399">399</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    }

    /**
     * Gets estimated located radio source with estimated transmitted power.
     *
     * @return estimated located radio source with estimated transmitted power or null.
     */
    @Override
    @SuppressWarnings(&quot;unchecked&quot;)
    public RadioSourceWithPowerAndLocated&lt;Point3D&gt; getEstimatedRadioSource() {
        List&lt;? extends RssiReadingLocated&lt;S, Point3D&gt;&gt; readings = getReadings();
        if (readings == null || readings.isEmpty()) {
            return null;
        }
        S source = readings.get(0).getSource();

        Point3D estimatedPosition = getEstimatedPosition();
        if (estimatedPosition == null) {
            return null;
        }

        Matrix estimatedPositionCovariance = getEstimatedPositionCovariance();

        Double transmittedPowerVariance =
                getEstimatedTransmittedPowerVariance();
        Double transmittedPowerStandardDeviation = transmittedPowerVariance != null ?
                Math.sqrt(transmittedPowerVariance) : null;

        Double pathlossExponentVariance =
                getEstimatedPathLossExponentVariance();
        Double pathlossExponentStandardDeviation = pathlossExponentVariance != null ?
                Math.sqrt(pathlossExponentVariance) : null;

        if (source instanceof WifiAccessPoint) {
            WifiAccessPoint accessPoint = (WifiAccessPoint) source;
            return new WifiAccessPointWithPowerAndLocated3D(accessPoint.getBssid(),</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/RobustMixedPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/RobustMixedPositionEstimator2D.html#L994">994</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/RobustMixedPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/RobustMixedPositionEstimator3D.html#L998">998</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/RobustRangingAndRssiPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/RobustRangingAndRssiPositionEstimator2D.html#L990">990</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/RobustRangingAndRssiPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/RobustRangingAndRssiPositionEstimator3D.html#L990">990</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/RobustRangingPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/RobustRangingPositionEstimator2D.html#L998">998</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/RobustRangingPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/RobustRangingPositionEstimator3D.html#L999">999</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/RobustRssiPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/RobustRssiPositionEstimator2D.html#L990">990</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/RobustRssiPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/RobustRssiPositionEstimator3D.html#L989">989</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>        Point2D[] positionsArray = new InhomogeneousPoint2D[size];
        positionsArray = positions.toArray(positionsArray);

        double[] distancesArray = new double[size];
        double[] distanceStandardDeviationsArray = new double[size];

        double[] qualityScoresArray = null;
        if (distanceQualityScores != null) {
            qualityScoresArray = new double[size];
        }

        for (int i = 0; i &lt; size; i++) {
            distancesArray[i] = distances.get(i);
            distanceStandardDeviationsArray[i] = distanceStandardDeviations.get(i);

            if (qualityScoresArray != null) {
                qualityScoresArray[i] = distanceQualityScores.get(i);
            }
        }

        try {
            mLaterationSolver.setPositionsDistancesAndStandardDeviations(
                    positionsArray, distancesArray, distanceStandardDeviationsArray);

            if (qualityScoresArray != null) {
                mLaterationSolver.setQualityScores(qualityScoresArray);
            }
        } catch (LockedException e) {
            throw new IllegalArgumentException(e);
        }
    }
}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/PROMedSRobustRssiPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROMedSRobustRssiPositionEstimator3D.html#L357">357</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/PROSACRobustRssiPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROSACRobustRssiPositionEstimator3D.html#L355">355</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    public PROMedSRobustRssiPositionEstimator3D(double[] sourceQualityScores,
            double[] fingerprintReadingQualityScores,
            List&lt;? extends RadioSourceLocated&lt;Point3D&gt;&gt; sources,
            RssiFingerprint&lt;? extends RadioSource, ? extends RssiReading&lt;? extends RadioSource&gt;&gt; fingerprint,
            RobustRssiPositionEstimatorListener&lt;Point3D&gt; listener) {
        this(sources, fingerprint, listener);
        internalSetSourceQualityScores(sourceQualityScores);
        internalSetFingerprintReadingsQualityScores(fingerprintReadingQualityScores);
    }

    /**
     * Returns quality scores corresponding to each radio source.
     * The larger the score value the better the quality of the sample.
     *
     * @return quality scores corresponding to each radio source.
     */
    public double[] getSourceQualityScores() {
        return mSourceQualityScores;
    }

    /**
     * Sets quality scores corresponding to each radio source.
     * The larger the score value the better the quality of the radio source.
     *
     * @param sourceQualityScores quality scores corresponding to each radio source.
     * @throws LockedException          if this instance is locked.
     * @throws IllegalArgumentException if provided quality scores length is smaller
     *                                  than minimum required samples.
     */
    public void setSourceQualityScores(double[] sourceQualityScores)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetSourceQualityScores(sourceQualityScores);
    }

    /**
     * Gets quality scores corresponding to each reading within provided fingerprint.
     * The larger the score value the better the quality of the reading.
     * This implementation always returns null.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @return quality scores corresponding to each reading within provided
     * fingerprint.
     */
    public double[] getFingerprintReadingsQualityScores() {
        return mFingerprintReadingsQualityScores;
    }

    /**
     * Sets quality scores corresponding to each reading within provided fingerprint.
     * The larger the score value the better the quality of the reading.
     * This implementation makes no action.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @param fingerprintReadingsQualityScores quality scores corresponding to each
     *                                         reading within provided fingerprint.
     * @throws LockedException          if this instance is locked.
     * @throws IllegalArgumentException if provided quality scores length is smaller
     *                                  than minimum required samples.
     */
    public void setFingerprintReadingsQualityScores(
            double[] fingerprintReadingsQualityScores) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetFingerprintReadingsQualityScores(fingerprintReadingsQualityScores);
    }

    /**
     * Returns threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value, the
     * algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algrithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @return stop threshold to stop the algorithm prematurely when a certain
     * accuracy has been reached.
     */
    public double getStopThreshold() {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L15725">15725</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L7487">7487</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L15618">15618</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                TimeUnit.SECOND);
    }

    /**
     * Converts provided distance instance into its corresponding value expressed in
     * meters.
     *
     * @param distance distance instance to be converted.
     * @return converted value expressed in meters.
     */
    private static double convertDistanceToDouble(final Distance distance) {
        return DistanceConverter.convert(distance.getValue().doubleValue(),
                distance.getUnit(), DistanceUnit.METER);
    }

    /**
     * Converts provided speed instance into its corresponding value expressed in
     * meters per second.
     *
     * @param speed speed instance to be converted.
     * @return converted value expressed in meters per second.
     */
    private static double convertSpeedToDouble(final Speed speed) {
        return SpeedConverter.convert(speed.getValue().doubleValue(),
                speed.getUnit(), SpeedUnit.METERS_PER_SECOND);
    }

    /**
     * Converts provided acceleration instance into its corresponding value expressed
     * in meters per squared second.
     *
     * @param acceleration acceleration instance to be converted.
     * @return converted value expressed in meters per squared second.
     */
    private static double convertAccelerationToDouble(final Acceleration acceleration) {
        return AccelerationConverter.convert(acceleration.getValue().doubleValue(),
                acceleration.getUnit(), AccelerationUnit.METERS_PER_SQUARED_SECOND);
    }

    /**
     * Converts provided angular speed into its corresponding value expressed in
     * radians per second.
     *
     * @param angularSpeed angular speed instance to be converted.
     * @return converted value expressed in radians per second.
     */
    private static double convertAngularSpeedToDouble(final AngularSpeed angularSpeed) {
        return AngularSpeedConverter.convert(angularSpeed.getValue().doubleValue(),
                angularSpeed.getUnit(), AngularSpeedUnit.RADIANS_PER_SECOND);
    }
}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/gnss/GNSSKalmanFilteredEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/gnss/GNSSKalmanFilteredEstimator.html#L458">458</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/INSGNSSTightlyCoupledKalmanFilteredEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/INSGNSSTightlyCoupledKalmanFilteredEstimator.html#L1497">1497</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public boolean getState(final GNSSKalmanState result) {
        if (mState != null) {
            result.copyFrom(mState);
            return true;
        } else {
            return false;
        }
    }

    /**
     * Gets timestamp expressed in seconds since epoch time when Kalman filter state
     * was last propagated.
     *
     * @return timestamp expressed in seconds since epoch time when Kalman filter
     * state was last propagated.
     */
    public Double getLastStateTimestamp() {
        return mLastStateTimestamp;
    }

    /**
     * Gets timestamp since epoch time when Kalman filter state was last propageted.
     *
     * @param result instance where timestamp since epoch time when Kalman filter
     *               state was last propagated will be stored.
     * @return true if result instance is updated, false otherwise.
     */
    public boolean getLastStateTimestampAsTime(final Time result) {
        if (mLastStateTimestamp != null) {
            result.setValue(mLastStateTimestamp);
            result.setUnit(TimeUnit.SECOND);
            return true;
        } else {
            return false;
        }
    }

    /**
     * Gets timestamp since epoch time when Kalman filter state was last propagated.
     *
     * @return timestamp since epoch time when Kalman filter state was last
     * propagated.
     */
    public Time getLastStateTimestampAsTime() {
        return mLastStateTimestamp != null ?
                new Time(mLastStateTimestamp, TimeUnit.SECOND) : null;
    }

    /**
     * Indicates whether this estimator is running or not.
     *
     * @return true if this estimator is running, false otherwise.
     */
    public boolean isRunning() {
        return mRunning;
    }

    /**
     * Indicates whether provided measurements are ready to
     * be used for an update.
     *
     * @param measurements measurements to be checked.
     * @return true if estimator is ready, false otherwise.
     */
    public static boolean isUpdateMeasurementsReady(
            final Collection&lt;GNSSMeasurement&gt; measurements) {
        return GNSSLeastSquaresPositionAndVelocityEstimator
                .isValidMeasurements(measurements);
    }

    /**
     * Updates GNSS measurements of this estimator when new satellite measurements
     * are available.
     * Calls to this method will be ignored if interval between provided timestamp
     * and last timestamp when Kalman filter was updated is less than epoch interval.
     *
     * @param measurements GNSS measurements to be updated.
     * @param timestamp    timestamp since epoch time when GNSS measurements were
     *                     updated.
     * @return true if measurements were updated, false otherwise.
     * @throws LockedException   if this estimator is already running.
     * @throws NotReadyException if estimator is not ready for measurements updates.
     * @throws GNSSException     if estimation fails due to numerical instabilities.
     */
    public boolean updateMeasurements(
            final Collection&lt;GNSSMeasurement&gt; measurements, final Time timestamp)
            throws LockedException, NotReadyException, GNSSException {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustMixedRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustMixedRadioSourceEstimator.html#L66">66</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator.html#L65">65</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>public abstract class SequentialRobustMixedRadioSourceEstimator&lt;S extends RadioSource,
        P extends Point&lt;P&gt;&gt; {

    /**
     * Default robust estimator method for robust position estimation using ranging
     * data when no robust method is provided.
     */
    public static final RobustEstimatorMethod DEFAULT_PANGING_ROBUST_METHOD =
            RobustEstimatorMethod.PROMedS;

    /**
     * Default robust estimator method for pathloss exponent and transmitted power
     * estimation using RSSI data when no robust method is provided.
     */
    public static final RobustEstimatorMethod DEFAULT_RSSI_ROBUST_METHOD =
            RobustEstimatorMethod.PROMedS;

    /**
     * Indicates that result is refined by default using all found inliers.
     */
    public static final boolean DEFAULT_REFINE_RESULT = true;

    /**
     * Indicates that covariance is kept by default after refining result.
     */
    public static final boolean DEFAULT_KEEP_COVARIANCE = true;

    /**
     * Default amount of progress variation before notifying a change in estimation progress.
     * By default this is set to 5%.
     */
    public static final float DEFAULT_PROGRESS_DELTA = 0.05f;

    /**
     * Minimum allowed value for progress delta.
     */
    public static final float MIN_PROGRESS_DELTA = 0.0f;

    /**
     * Maximum allowed value for progress delta.
     */
    public static final float MAX_PROGRESS_DELTA = 1.0f;

    /**
     * Constant defining default confidence of the estimated result, which is
     * 99%. This means that with a probability of 99% estimation will be
     * accurate because chosen subsamples will be inliers.
     */
    public static final double DEFAULT_CONFIDENCE = 0.99;

    /**
     * Default maximum allowed number of iterations.
     */
    public static final int DEFAULT_MAX_ITERATIONS = 5000;

    /**
     * Minimum allowed confidence value.
     */
    public static final double MIN_CONFIDENCE = 0.0;

    /**
     * Maximum allowed confidence value.
     */
    public static final double MAX_CONFIDENCE = 1.0;

    /**
     * Minimum allowed number of iterations.
     */
    public static final int MIN_ITERATIONS = 1;

    /**
     * Indicates that by default position covariances of readings must be taken into account to increase
     * the amount of standard deviation of each ranging measure by the amount of position standard deviation
     * assuming that both measures are statistically independent.
     */
    public static final boolean DEFAULT_USE_READING_POSITION_COVARIANCES = true;

    /**
     * Internal robust estimator for position estimation.
     */
    protected RobustRangingRadioSourceEstimator&lt;S, P&gt; mRangingEstimator;

    /**
     * Internal robust estimator for pathloss exponent and transmitted power
     * estimation.
     */
    protected RobustRssiRadioSourceEstimator&lt;S, P&gt; mRssiEstimator;

    /**
     * Robust method used for robust position estimation using ranging data.
     */
    protected RobustEstimatorMethod mRangingRobustMethod = DEFAULT_PANGING_ROBUST_METHOD;

    /**
     * Robust method used for pathloss exponent and transmitted power estimation
     * using RSSI data.
     */
    protected RobustEstimatorMethod mRssiRobustMethod = DEFAULT_RSSI_ROBUST_METHOD;

    /**
     * Size of subsets to be checked during ranging robust estimation.
     */
    protected int mRangingPreliminarySubsetSize;

    /**
     * Size of subsets to be checked during RSSI robust estimation.
     */
    protected int mRssiPreliminarySubsetSize;

    /**
     * Threshold to determine when samples are inliers or not used during robust
     * position estimation.
     * If not defined, default threshold will be used.
     */
    protected Double mRangingThreshold;

    /**
     * Threshold to determine when samples are inliers or not used during robust
     * pathloss exponent and transmitted power estimation.
     */
    protected Double mRssiThreshold;</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustMixedRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustMixedRadioSourceEstimator.html#L2240">2240</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator.html#L2127">2127</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                    rangingReadings.size() &lt; mRangingEstimator.getMinReadings();
        }

        mRangingEstimator.setProgressDelta(2.0f * mProgressDelta);
        mRangingEstimator.setConfidence(mRangingConfidence);
        mRangingEstimator.setMaxIterations(mRangingMaxIterations);
        mRangingEstimator.setResultRefined(mRefineResult);
        mRangingEstimator.setCovarianceKept(mKeepCovariance);
        mRangingEstimator.setUseReadingPositionCovariances(
                mUseReadingPositionCovariances);
        mRangingEstimator.setHomogeneousLinearSolverUsed(
                mUseHomogeneousRangingLinearSolver);

        mRangingEstimator.setInitialPosition(mInitialPosition);

        mRangingEstimator.setListener(new RobustRangingRadioSourceEstimatorListener&lt;S, P&gt;() {
            @Override
            public void onEstimateStart(RobustRangingRadioSourceEstimator&lt;S, P&gt; estimator) {
                //not used
            }

            @Override
            public void onEstimateEnd(RobustRangingRadioSourceEstimator&lt;S, P&gt; estimator) {
                //not used
            }

            @Override
            public void onEstimateNextIteration(RobustRangingRadioSourceEstimator&lt;S, P&gt; estimator,
                                                int iteration) {
                //not used
            }

            @Override
            public void onEstimateProgressChange(RobustRangingRadioSourceEstimator&lt;S, P&gt; estimator, float progress) {
                if (mListener != null) {
                    mListener.onEstimateProgressChange(</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/calibration/KnownBiasAndFrameAccelerometerLinearLeastSquaresCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/KnownBiasAndFrameAccelerometerLinearLeastSquaresCalibrator.html#L1026">1026</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/calibration/KnownFrameAccelerometerLinearLeastSquaresCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/KnownFrameAccelerometerLinearLeastSquaresCalibrator.html#L368">368</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    }

    /**
     * Indicates whether estimator is ready to start the estimator.
     *
     * @return true if estimator is ready, false otherwise.
     */
    @Override
    public boolean isReady() {
        return mMeasurements != null
                &amp;&amp; mMeasurements.size() &gt;= MINIMUM_MEASUREMENTS;
    }

    /**
     * Indicates whether estimator is currently running or not.
     *
     * @return true if estimator is running, false otherwise.
     */
    @Override
    public boolean isRunning() {
        return mRunning;
    }

    /**
     * Estimates accelerometer calibration parameters containing scale factors
     * and cross-coupling errors.
     *
     * @throws LockedException      if estimator is currently running.
     * @throws NotReadyException    if estimator is not ready.
     * @throws CalibrationException if estimation fails for numerical reasons.
     */
    @Override
    public void calibrate() throws LockedException, NotReadyException, CalibrationException {
        if (mRunning) {
            throw new LockedException();
        }

        if (!isReady()) {
            throw new NotReadyException();
        }

        try {
            mRunning = true;

            if (mListener != null) {
                mListener.onCalibrateStart(this);
            }

            if (mCommonAxisUsed) {
                calibrateCommonAxis();
            } else {
                calibrateGeneral();
            }

            if (mListener != null) {
                mListener.onCalibrateEnd(this);
            }

        } catch (final AlgebraException e) {
            throw new CalibrationException(e);
        } finally {
            mRunning = false;
        }
    }

    /**
     * Gets estimated accelerometer scale factors and ross coupling errors.
     * This is the product of matrix Ta containing cross coupling errors and Ka
     * containing scaling factors.
     * So tat:
     * &lt;pre&gt;
     *     Ma = [sx    mxy  mxz] = Ta*Ka
     *          [myx   sy   myz]
     *          [mzx   mzy  sz ]
     * &lt;/pre&gt;
     * Where:
     * &lt;pre&gt;
     *     Ka = [sx 0   0 ]
     *          [0  sy  0 ]
     *          [0  0   sz]
     * &lt;/pre&gt;
     * and
     * &lt;pre&gt;
     *     Ta = [1          -alphaXy    alphaXz ]
     *          [alphaYx    1           -alphaYz]
     *          [-alphaZx   alphaZy     1       ]
     * &lt;/pre&gt;
     * Hence:
     * &lt;pre&gt;
     *     Ma = [sx    mxy  mxz] = Ta*Ka =  [sx             -sy * alphaXy   sz * alphaXz ]
     *          [myx   sy   myz]            [sx * alphaYx   sy              -sz * alphaYz]
     *          [mzx   mzy  sz ]            [-sx * alphaZx  sy * alphaZy    sz           ]
     * &lt;/pre&gt;
     * This instance allows any 3x3 matrix however, typically alphaYx, alphaZx and alphaZy
     * are considered to be zero if the accelerometer z-axis is assumed to be the same
     * as the body z-axis. When this is assumed, myx = mzx = mzy = 0 and the Ma matrix
     * becomes upper diagonal:
     * &lt;pre&gt;
     *     Ma = [sx    mxy  mxz]
     *          [0     sy   myz]
     *          [0     0    sz ]
     * &lt;/pre&gt;
     * Values of this matrix are unitless.
     *
     * @return estimated accelerometer scale factors and cross coupling errors, or null
     * if not available.
     */
    @Override
    public Matrix getEstimatedMa() {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/calibration/KnownBiasAndFrameAccelerometerNonLinearLeastSquaresCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/KnownBiasAndFrameAccelerometerNonLinearLeastSquaresCalibrator.html#L2658">2658</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/calibration/KnownFrameAccelerometerLinearLeastSquaresCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/KnownFrameAccelerometerLinearLeastSquaresCalibrator.html#L361">361</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/calibration/KnownFrameAccelerometerNonLinearLeastSquaresCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/KnownFrameAccelerometerNonLinearLeastSquaresCalibrator.html#L2923">2923</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>            final KnownBiasAndFrameAccelerometerNonLinearLeastSquaresCalibratorListener listener)
            throws LockedException {
        if (mRunning) {
            throw new LockedException();
        }

        mListener = listener;
    }

    /**
     * Indicates whether calibrator is ready to start.
     *
     * @return true if calibrator is ready, false otherwise.
     */
    @Override
    public boolean isReady() {
        return mMeasurements != null &amp;&amp; mMeasurements.size() &gt;= MINIMUM_MEASUREMENTS;
    }

    /**
     * Indicates whether calibrator is currently running or not.
     *
     * @return true if calibrator is running, false otherwise.
     */
    @Override
    public boolean isRunning() {
        return mRunning;
    }

    /**
     * Estimates accelerometer calibration parameters containing bias, scale factors
     * and cross-coupling errors.
     *
     * @throws LockedException      if calibrator is currently running.
     * @throws NotReadyException    if calibrator is not ready.
     * @throws CalibrationException if estimation fails for numerical reasons.
     */
    @Override
    public void calibrate() throws LockedException, NotReadyException, CalibrationException {
        if (mRunning) {
            throw new LockedException();
        }

        if (!isReady()) {
            throw new NotReadyException();
        }

        try {
            mRunning = true;

            if (mListener != null) {
                mListener.onCalibrateStart(this);
            }

            if (mCommonAxisUsed) {
                calibrateCommonAxis();
            } else {
                calibrateGeneral();
            }

            if (mListener != null) {
                mListener.onCalibrateEnd(this);
            }

        } catch (final AlgebraException | FittingException |</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/estimators/ECEFKinematicsEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/estimators/ECEFKinematicsEstimator.html#L1725">1725</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L7755">7755</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>                        new double[]{alphaX, alphaY, alphaZ});

                if (alphaNorm &gt; ALPHA_THRESHOLD) {
                    final double alphaNorm2 = alphaNorm * alphaNorm;
                    final double value1 = (1.0 - Math.cos(alphaNorm)) / alphaNorm2;
                    final double value2 = (1.0 - Math.sin(alphaNorm) / alphaNorm) / alphaNorm2;
                    final Matrix tmp1 = alphaSkew1.multiplyByScalarAndReturnNew(value1);
                    final Matrix tmp2 = alphaSkew1.multiplyByScalarAndReturnNew(value2);
                    tmp2.multiply(alphaSkew1);

                    final Matrix tmp3 = Matrix.identity(ROWS, ROWS);
                    tmp3.add(tmp1);
                    tmp3.add(tmp2);

                    oldCbe.multiply(tmp3);
                }

                final Matrix alphaSkew2 = Utils.skewMatrix(
                        new double[]{0.0, 0.0, alpha});
                alphaSkew2.multiplyByScalar(0.5);
                alphaSkew2.multiply(oldCbe); // 0.5 * alphaSkew2 * oldCbe

                oldCbe.subtract(alphaSkew2); // oldCbe - 0.5 * alphaSkew2 * oldCbe</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustMixedRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustMixedRadioSourceEstimator2D.html#L903">903</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator2D.html#L886">886</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>                    beacon.getTransmittedPower(), beacon.getFrequency(),
                    beacon.getBluetoothAddress(), beacon.getBeaconTypeCode(),
                    beacon.getManufacturer(), beacon.getServiceUuid(),
                    beacon.getBluetoothName(),
                    getEstimatedPathLossExponent(),
                    transmittedPowerStandardDeviation,
                    pathlossExponentStandardDeviation,
                    estimatedPosition, estimatedPositionCovariance);
        }else {
            return null;
        }
    }

    /**
     * Builds ranging estimator.
     */
    @Override
    protected void buildRangingEstimatorIfNeeded() {
        if (mRangingEstimator == null || mRangingEstimator.getMethod() != mRangingRobustMethod) {
            mRangingEstimator = RobustRangingRadioSourceEstimator2D.create(mRangingRobustMethod);
        }
    }

    /**
     * build RSSI estimator.
     *
     * @throws LockedException if estimator is locked.
     */
    @Override
    protected void buildRssiEstimatorIfNeeded() throws LockedException {
        if (mRssiEstimator == null || mRssiEstimator.getMethod() != mRssiRobustMethod) {
            mRssiEstimator = RobustRssiRadioSourceEstimator2D.create(mRssiRobustMethod);

            // rssi estimator will never need position estimator, but to
            // ensure it is ready we need to provide an initial position
            mRssiEstimator.setPositionEstimationEnabled(false);
            mRssiEstimator.setInitialPosition(Point2D.create());
        }
    }</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustMixedRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustMixedRadioSourceEstimator3D.html#L905">905</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator3D.html#L885">885</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>                    beacon.getTransmittedPower(), beacon.getFrequency(),
                    beacon.getBluetoothAddress(), beacon.getBeaconTypeCode(),
                    beacon.getManufacturer(), beacon.getServiceUuid(),
                    beacon.getBluetoothName(),
                    getEstimatedPathLossExponent(),
                    transmittedPowerStandardDeviation,
                    pathlossExponentStandardDeviation,
                    estimatedPosition, estimatedPositionCovariance);
        }else {
            return null;
        }
    }

    /**
     * Builds ranging estimator.
     */
    @Override
    protected void buildRangingEstimatorIfNeeded() {
        if (mRangingEstimator == null || mRangingEstimator.getMethod() != mRangingRobustMethod) {
            mRangingEstimator = RobustRangingRadioSourceEstimator3D.create(mRangingRobustMethod);
        }
    }

    /**
     * Build RSSI estimator.
     *
     * @throws LockedException if estimator is locked.
     */
    @Override
    protected void buildRssiEstimatorIfNeeded() throws LockedException {
        if (mRssiEstimator == null || mRssiEstimator.getMethod() != mRssiRobustMethod) {
            mRssiEstimator = RobustRssiRadioSourceEstimator3D.create(mRssiRobustMethod);

            // rssi estimator will never need position estimator, but to
            // ensure it is ready we need to provide an initial position
            mRssiEstimator.setPositionEstimationEnabled(false);
            mRssiEstimator.setInitialPosition(Point3D.create());
        }
    }</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/calibration/PROSACRobustKnownBiasAndFrameAccelerometerCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/PROSACRobustKnownBiasAndFrameAccelerometerCalibrator.html#L1784">1784</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/calibration/RANSACRobustKnownBiasAndFrameAccelerometerCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/RANSACRobustKnownBiasAndFrameAccelerometerCalibrator.html#L888">888</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>                                    PROSACRobustKnownBiasAndFrameAccelerometerCalibrator.this, progress);
                        }
                    }
                });

        try {
            mRunning = true;
            mInliersData = null;
            innerEstimator.setComputeAndKeepInliersEnabled(
                    mComputeAndKeepInliers || mRefineResult);
            innerEstimator.setComputeAndKeepResidualsEnabled(
                    mComputeAndKeepResiduals || mRefineResult);
            innerEstimator.setConfidence(mConfidence);
            innerEstimator.setMaxIterations(mMaxIterations);
            innerEstimator.setProgressDelta(mProgressDelta);
            final Matrix preliminaryResult = innerEstimator.estimate();
            mInliersData = innerEstimator.getInliersData();

            attemptRefine(preliminaryResult);

        } catch (com.irurueta.numerical.LockedException e) {
            throw new LockedException(e);
        } catch (com.irurueta.numerical.NotReadyException e) {
            throw new NotReadyException(e);
        } catch (RobustEstimatorException e) {
            throw new CalibrationException(e);
        } finally {
            mRunning = false;
        }
    }

    /**
     * Returns method being used for robust estimation.
     *
     * @return method being used for robust estimation.
     */
    @Override
    public RobustEstimatorMethod getMethod() {
        return RobustEstimatorMethod.PROSAC;</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/calibration/PROSACRobustKnownFrameAccelerometerCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/PROSACRobustKnownFrameAccelerometerCalibrator.html#L553">553</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/calibration/RANSACRobustKnownFrameAccelerometerCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/RANSACRobustKnownFrameAccelerometerCalibrator.html#L348">348</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>                                    PROSACRobustKnownFrameAccelerometerCalibrator.this, progress);
                        }
                    }
                });

        try {
            mRunning = true;
            mInliersData = null;
            innerEstimator.setComputeAndKeepInliersEnabled(
                    mComputeAndKeepInliers || mRefineResult);
            innerEstimator.setComputeAndKeepResidualsEnabled(
                    mComputeAndKeepResiduals || mRefineResult);
            innerEstimator.setConfidence(mConfidence);
            innerEstimator.setMaxIterations(mMaxIterations);
            innerEstimator.setProgressDelta(mProgressDelta);
            final PreliminaryResult preliminaryResult = innerEstimator.estimate();
            mInliersData = innerEstimator.getInliersData();

            attemptRefine(preliminaryResult);

        } catch (com.irurueta.numerical.LockedException e) {
            throw new LockedException(e);
        } catch (com.irurueta.numerical.NotReadyException e) {
            throw new NotReadyException(e);
        } catch (RobustEstimatorException e) {
            throw new CalibrationException(e);
        } finally {
            mRunning = false;
        }
    }

    /**
     * Returns method being used for robust estimation.
     *
     * @return method being used for robust estimation.
     */
    @Override
    public RobustEstimatorMethod getMethod() {
        return RobustEstimatorMethod.PROSAC;</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/gnss/GNSSEstimation.java</td>
<td><a href="./xref/com/irurueta/navigation/gnss/GNSSEstimation.html#L707">707</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/INSLooselyCoupledKalmanState.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/INSLooselyCoupledKalmanState.html#L1573">1573</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/INSTightlyCoupledKalmanState.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/INSTightlyCoupledKalmanState.html#L1746">1746</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                clockDrift.getUnit(), SpeedUnit.METERS_PER_SECOND);
    }

    /**
     * Gets estimated ECEF user position expressed in meters (m).
     *
     * @param result instance where estimated ECEF user position will be stored.
     */
    public void getPosition(final Point3D result) {
        result.setInhomogeneousCoordinates(mX, mY, mZ);
    }

    /**
     * Gets estimated ECEF user position expressed in meters (m).
     *
     * @return estimated ECEF user position.
     */
    public Point3D getPosition() {
        return new InhomogeneousPoint3D(mX, mY, mZ);
    }

    /**
     * Sets estimated ECEF user position expressed in meters (m).
     *
     * @param position estimated ECEF user position.
     */
    public void setPosition(final Point3D position) {
        mX = position.getInhomX();
        mY = position.getInhomY();
        mZ = position.getInhomZ();
    }

    /**
     * Gets estimatedECEF user position.
     *
     * @param result instance where result will be stored.
     */
    public void getEcefPosition(final ECEFPosition result) {
        result.setCoordinates(mX, mY, mZ);
    }

    /**
     * Gets estimated ECEF user position.
     *
     * @return estimated ECEF user position.
     */
    public ECEFPosition getEcefPosition() {
        return new ECEFPosition(mX, mY, mZ);
    }

    /**
     * Sets estimated ECEF user position.
     *
     * @param ecefPosition estimated ECEF user position.
     */
    public void setEcefPosition(final ECEFPosition ecefPosition) {
        mX = ecefPosition.getX();
        mY = ecefPosition.getY();
        mZ = ecefPosition.getZ();
    }

    /**
     * Gets estimated ECEF user velocity.
     *
     * @param result instance where result will be stored.
     */
    public void getEcefVelocity(final ECEFVelocity result) {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator2D.html#L2967">2967</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator3D.html#L2969">2969</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator2D.html#L2943">2943</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator3D.html#L2943">2943</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                    if (mTransmittedPowerEstimationEnabled) {
                        //transmitted power estimation enabled
                        mEstimatedTransmittedPowerVariance = mCovariance.
                                getElementAt(pos, pos);
                        pos++;
                    } else {
                        //transmitted power estimation disabled
                        mEstimatedTransmittedPowerVariance = null;
                    }

                    if (mPathLossEstimationEnabled) {
                        //pathloss exponent estimation enabled
                        mEstimatedPathLossExponentVariance = mCovariance.
                                getElementAt(pos, pos);
                    } else {
                        //pathloss exponent estimation disabled
                        mEstimatedPathLossExponentVariance = null;
                    }
                } else {
                    mCovariance = null;
                    mEstimatedPositionCovariance = null;
                    mEstimatedTransmittedPowerVariance = null;
                    mEstimatedPathLossExponentVariance = null;
                }

                mEstimatedPosition = mInnerEstimator.getEstimatedPosition();
                mEstimatedTransmittedPowerdBm =
                        mInnerEstimator.getEstimatedTransmittedPowerdBm();
                mEstimatedPathLossExponent =
                        mInnerEstimator.getEstimatedPathLossExponent();
            } catch (Exception e) {
                //refinement failed, so we return input value, and covariance
                //becomes unavailable
                mCovariance = null;
                mEstimatedPositionCovariance = null;
                mEstimatedTransmittedPowerVariance = null;
                mEstimatedPathLossExponentVariance = null;

                mEstimatedPosition = initialPosition;
                mEstimatedTransmittedPowerdBm = initialTransmittedPowerdBm;
                mEstimatedPathLossExponent = initialPathLossExponent;
            }
        } else {
            mCovariance = null;
            mEstimatedPositionCovariance = null;
            mEstimatedTransmittedPowerVariance = null;
            mEstimatedPathLossExponentVariance = null;

            mEstimatedPosition = initialPosition;
            mEstimatedTransmittedPowerdBm = initialTransmittedPowerdBm;
            mEstimatedPathLossExponent = initialPathLossExponent;
        }
    }
}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/NonLinearMixedPositionEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/NonLinearMixedPositionEstimator.html#L349">349</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/NonLinearRangingAndRssiPositionEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/NonLinearRangingAndRssiPositionEstimator.html#L349">349</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/NonLinearRangingPositionEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/NonLinearRangingPositionEstimator.html#L349">349</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/NonLinearRssiPositionEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/NonLinearRssiPositionEstimator.html#L348">348</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                            NonLinearMixedPositionEstimator.this);
                }
            }
        };
    }

    /**
     * Builds positions, distances and standard deviation of distances for the internal
     * lateration solver.
     */
    @SuppressWarnings(&quot;Duplicates&quot;)
    private void buildPositionsDistancesAndDistanceStandardDeviations() {
        if (mTrilaterationSolver == null) {
            return;
        }

        int min = getMinRequiredSources();
        if (mSources == null || mFingerprint == null ||
                mSources.size() &lt; min ||
                mFingerprint.getReadings() == null ||
                mFingerprint.getReadings().size() &lt; min) {
            return;
        }

        List&lt;P&gt; positions = new ArrayList&lt;&gt;();
        List&lt;Double&gt; distances = new ArrayList&lt;&gt;();
        List&lt;Double&gt; distanceStandardDeviations = new ArrayList&lt;&gt;();
        PositionEstimatorHelper.buildPositionsDistancesAndDistanceStandardDeviations(
                mSources, mFingerprint, mUseRadioSourcePositionCovariance,
                mFallbackDistanceStandardDeviation, positions, distances,
                distanceStandardDeviations);

        setPositionsDistancesAndDistanceStandardDeviations(positions, distances,
                distanceStandardDeviations);
    }
}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/MixedRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MixedRadioSourceEstimator.html#L494">494</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RangingAndRssiRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RangingAndRssiRadioSourceEstimator.html#L484">484</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator.html#L442">442</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator.html#L439">439</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RssiRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RssiRadioSourceEstimator.html#L487">487</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>            MixedRadioSourceEstimatorListener&lt;S, P&gt; listener) {
        this(readings, initialPosition, initialTransmittedPowerdBm, listener);
        mInitialPathLossExponent = initialPathLossExponent;
    }

    /**
     * Gets initial transmitted power to start the estimation of radio source
     * transmitted power (expressed in dBm's).
     * If not defined, average value of received power readings will be used.
     *
     * If transmitted power estimation is enabled, estimation will start at this
     * value and will converte the most appropriate value.
     * If transmitted power estimation is disabled, this value will be assumed to be
     * exact and the estimated transmitted power will be equal to this value
     * (converted to dBm's).
     * @return initial transmitted power to start the estimation of radio source
     * transmitted power.
     */
    public Double getInitialTransmittedPowerdBm() {
        return mInitialTransmittedPowerdBm;
    }

    /**
     * Sets initial transmitted power to start the estimation of radio source
     * transmitted power (expressed in dBm's).
     * If not defined, average value of received power readings will be used.
     *
     * If transmitted power estimation is enabled, estimation will start at this
     * value and will converte the most appropriate value.
     * If transmitted power estimation is disabled, this value will be assumed to be
     * exact and the estimated transmitted power will be equal to this value
     * (converted to dBm's).
     * @param initialTransmittedPowerdBm initial transmitted power to start the
     *                                   estimation of radio source transmitted
     *                                   power.
     * @throws LockedException if estimator is locked.
     */
    public void setInitialTransmittedPowerdBm(Double initialTransmittedPowerdBm)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mInitialTransmittedPowerdBm = initialTransmittedPowerdBm;
    }

    /**
     * Gets initial transmitted power to start the estimation of radio source
     * transmitted power (expressed in mW).
     * If not defined, average value of received power readings will be used.
     *
     * If transmitted power estimation is enabled, estimation will start at this
     * value and will converte the most appropriate value.
     * If transmitted power estimation is disabled, this value will be assumed to be
     * exact and the estimated transmitted power will be equal to this value
     * (converted to dBm's).
     * @return initial transmitted power to start the estimation of radio source
     * transmitted power.
     */
    public Double getInitialTransmittedPower() {
        return mInitialTransmittedPowerdBm != null ?
                Utils.dBmToPower(mInitialTransmittedPowerdBm) : null;
    }

    /**
     * Sets initial transmitted power to start the estimation of radio source
     * transmitted power (expressed in mW).
     * If not defined, average value of received power readings will be used.
     *
     * If transmitted power estimation is enabled, estimation will start at this
     * value and will converte the most appropriate value.
     * If transmitted power estimation is disabled, this value will be assumed to be
     * exact and the estimated transmitted power will be equal to this value
     * (converted to dBm's).
     * @param initialTransmittedPower initial transmitted power to start the
     *                                estimation of radio source transmitted power.
     * @throws LockedException if estimator is locked.
     * @throws IllegalArgumentException if provided value is negative.
     */
    public void setInitialTransmittedPower(Double initialTransmittedPower)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (initialTransmittedPower != null) {
            if (initialTransmittedPower &lt; 0.0) {
                throw new IllegalArgumentException();
            }
            mInitialTransmittedPowerdBm = Utils.powerTodBm(
                    initialTransmittedPower);
        } else {
            mInitialTransmittedPowerdBm = null;
        }
    }

    /**
     * Indicates whether transmitted power estimation is enabled or not.
     * @return true if transmitted power estimation is enabled, false otherwise.
     */
    public boolean isTransmittedPowerEstimationEnabled() {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/estimators/NEDPositionEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/estimators/NEDPositionEstimator.html#L2292">2292</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/estimators/NEDVelocityEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/estimators/NEDVelocityEstimator.html#L2393">2393</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L15604">15604</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    private static double convertTimeToDouble(final Time time) {
        return TimeConverter.convert(time.getValue().doubleValue(), time.getUnit(),
                TimeUnit.SECOND);
    }

    /**
     * Converts provided angle instance to radians (rad).
     *
     * @param angle angle instance to be converted.
     * @return provided angle value expressed in radians.
     */
    private static double convertAngleToDouble(final Angle angle) {
        return AngleConverter.convert(angle.getValue().doubleValue(), angle.getUnit(), AngleUnit.RADIANS);
    }

    /**
     * Converts provided distance instance to meters (m).
     *
     * @param distance distance instance to be converted.
     * @return provided distance value expressed in meters.
     */
    private static double convertDistanceToDouble(final Distance distance) {
        return DistanceConverter.convert(distance.getValue().doubleValue(), distance.getUnit(),
                DistanceUnit.METER);
    }

    /**
     * Converts provided speed instance to meters per second (m/s).
     *
     * @param speed speed instance to be converted.
     * @return provided speed value expressed in meters per second.
     */
    private static double convertSpeedToDouble(final Speed speed) {
        return SpeedConverter.convert(speed.getValue().doubleValue(), speed.getUnit(),
                SpeedUnit.METERS_PER_SECOND);
    }</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/calibration/KnownBiasAndFrameAccelerometerLinearLeastSquaresCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/KnownBiasAndFrameAccelerometerLinearLeastSquaresCalibrator.html#L1290">1290</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/calibration/KnownFrameAccelerometerLinearLeastSquaresCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/KnownFrameAccelerometerLinearLeastSquaresCalibrator.html#L926">926</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>        final Matrix a = new Matrix(rows, COMMON_Z_AXIS_UNKNOWNS);
        final Matrix b = new Matrix(rows, 1);
        int i = 0;
        for (final FrameBodyKinematics measurement : mMeasurements) {
            final BodyKinematics measuredKinematics = measurement.getKinematics();
            final ECEFFrame ecefFrame = measurement.getFrame();
            final ECEFFrame previousEcefFrame = measurement.getPreviousFrame();
            final double timeInterval = measurement.getTimeInterval();

            ECEFKinematicsEstimator.estimateKinematics(timeInterval, ecefFrame,
                    previousEcefFrame, expectedKinematics);

            final double fMeasX = measuredKinematics.getFx();
            final double fMeasY = measuredKinematics.getFy();
            final double fMeasZ = measuredKinematics.getFz();

            final double fTrueX = expectedKinematics.getFx();
            final double fTrueY = expectedKinematics.getFy();
            final double fTrueZ = expectedKinematics.getFz();

            a.setElementAt(i, 0, fTrueX);</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/calibration/KnownBiasAndFrameAccelerometerLinearLeastSquaresCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/KnownBiasAndFrameAccelerometerLinearLeastSquaresCalibrator.html#L1401">1401</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/calibration/KnownFrameAccelerometerLinearLeastSquaresCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/KnownFrameAccelerometerLinearLeastSquaresCalibrator.html#L816">816</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>        final Matrix a = new Matrix(rows, GENERAL_UNKNOWNS);
        final Matrix b = new Matrix(rows, 1);
        int i = 0;
        for (final FrameBodyKinematics measurement : mMeasurements) {
            final BodyKinematics measuredKinematics = measurement.getKinematics();
            final ECEFFrame ecefFrame = measurement.getFrame();
            final ECEFFrame previousEcefFrame = measurement.getPreviousFrame();
            final double timeInterval = measurement.getTimeInterval();

            ECEFKinematicsEstimator.estimateKinematics(timeInterval, ecefFrame,
                    previousEcefFrame, expectedKinematics);

            final double fMeasX = measuredKinematics.getFx();
            final double fMeasY = measuredKinematics.getFy();
            final double fMeasZ = measuredKinematics.getFz();

            final double fTrueX = expectedKinematics.getFx();
            final double fTrueY = expectedKinematics.getFy();
            final double fTrueZ = expectedKinematics.getFz();

            a.setElementAt(i, 0, fTrueX);</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/calibration/RobustKnownBiasAndFrameAccelerometerCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/RobustKnownBiasAndFrameAccelerometerCalibrator.html#L4151">4151</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/calibration/RobustKnownBiasAndFrameAccelerometerCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/RobustKnownBiasAndFrameAccelerometerCalibrator.html#L4492">4492</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>            final double biasX, final double biasY, final double biasZ,
            final boolean commonAxisUsed,
            final RobustKnownBiasAndFrameAccelerometerCalibratorListener listener,
            final RobustEstimatorMethod method) {
        switch (method) {
            case RANSAC:
                return new RANSACRobustKnownBiasAndFrameAccelerometerCalibrator(
                        measurements, biasX, biasY, biasZ, commonAxisUsed, listener);
            case LMedS:
                return new LMedSRobustKnownBiasAndFrameAccelerometerCalibrator(
                        measurements, biasX, biasY, biasZ, commonAxisUsed, listener);
            case MSAC:
                return new MSACRobustKnownBiasAndFrameAccelerometerCalibrator(
                        measurements, biasX, biasY, biasZ, commonAxisUsed, listener);
            case PROSAC:
                return new PROSACRobustKnownBiasAndFrameAccelerometerCalibrator(
                        qualityScores, measurements, biasX, biasY, biasZ,
                        commonAxisUsed, listener);
            case PROMedS:
            default:
                return new PROMedSRobustKnownBiasAndFrameAccelerometerCalibrator(
                        qualityScores, measurements, biasX, biasY, biasZ,
                        commonAxisUsed, listener);
        }
    }

    /**
     * Creates a robust accelerometer calibrator.
     *
     * @param qualityScores quality scores corresponding to each provided
     *                      measurement. The larger the score value the better
     *                      the quality of the sample.
     * @param biasX         known x coordinate of accelerometer bias.
     * @param biasY         known y coordinate of accelerometer bias.
     * @param biasZ         known z coordinate of accelerometer bias.
     * @param method        robust estimator method.
     * @return a robust accelerometer calibrator.
     * @throws IllegalArgumentException if provided quality scores length
     *                                  is smaller than 4 samples.
     */
    public static RobustKnownBiasAndFrameAccelerometerCalibrator create(
            final double[] qualityScores,
            final Acceleration biasX, final Acceleration biasY, final Acceleration biasZ,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/lateration/NonLinearLeastSquaresLateration2DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/NonLinearLeastSquaresLateration2DSolver.html#L269">269</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/lateration/RobustLateration2DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/RobustLateration2DSolver.html#L237">237</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    }

    /**
     * Gets circles defined by provided positions and distances.
     * @return circles defined by provided positions and distances.
     */
    public Circle[] getCircles() {
        if (mPositions == null) {
            return null;
        }

        Circle[] result = new Circle[mPositions.length];

        for (int i = 0; i &lt; mPositions.length; i++) {
            result[i] = new Circle(mPositions[i], mDistances[i]);
        }
        return result;
    }

    /**
     * Sets circles defining positions and euclidean distances.
     * @param circles circles defining positions and distances.
     * @throws IllegalArgumentException if circles is null or length of array of circles
     * is less than 2.
     * @throws LockedException if instance is busy solving the lateration problem.
     */
    public void setCircles(Circle[] circles) throws LockedException {
        if(isLocked()) {
            throw new LockedException();
        }
        internalSetCircles(circles);
    }

    /**
     * Sets circles defining positions and euclidean distances along with the standard
     * deviations of provided circles radii.
     * @param circles circles defining positions and distances.
     * @param radiusStandardDeviations standard deviations of circles radii.
     * @throws IllegalArgumentException if circles is null, length of arrays is less than
     * 2 or don't have the same length.
     * @throws LockedException if instance is busy solving the lateration problem.
     */
    public void setCirclesAndStandardDeviations(Circle[] circles, double[] radiusStandardDeviations)
            throws LockedException {
        if(isLocked()) {
            throw new LockedException();
        }
        internalSetCirclesAndStandardDeviations(circles, radiusStandardDeviations);
    }</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/lateration/NonLinearLeastSquaresLateration3DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/NonLinearLeastSquaresLateration3DSolver.html#L269">269</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/lateration/RobustLateration3DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/RobustLateration3DSolver.html#L238">238</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    }

    /**
     * Gets spheres defined by provided positions and distances.
     * @return spheres defined by provided positions and distances.
     */
    public Sphere[] getSpheres() {
        if (mPositions == null) {
            return null;
        }

        Sphere[] result = new Sphere[mPositions.length];

        for (int i = 0; i &lt; mPositions.length; i++) {
            result[i] = new Sphere(mPositions[i], mDistances[i]);
        }
        return result;
    }

    /**
     * Sets spheres defining positions and euclidean distances.
     * @param spheres spheres defining positions and distances.
     * @throws IllegalArgumentException if spheres is null or length of array of spheres
     * is less than 2.
     * @throws LockedException if instance is busy solving the lateration problem.
     */
    public void setSpheres(Sphere[] spheres) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetSpheres(spheres);
    }

    /**
     * Sets spheres defining positions and euclidean distances along with the standard
     * deviations of provided spheres radii.
     * @param spheres spheres defining positions and distances.
     * @param radiusStandardDeviations standard deviations of circles radii.
     * @throws IllegalArgumentException if spheres is null, length of arrays is less than
     * 2 or don't have the same length.
     * @throws LockedException if instance is busy solving the lateration problem.
     */
    public void setSpheresAndStandardDeviations(Sphere[] spheres, double[] radiusStandardDeviations)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetSpheresAndStandardDeviations(spheres, radiusStandardDeviations);
    }</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/lateration/PROMedSRobustLateration2DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/PROMedSRobustLateration2DSolver.html#L383">383</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/lateration/PROMedSRobustLateration3DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/PROMedSRobustLateration3DSolver.html#L383">383</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>        super(circles, distanceStandardDeviations, listener);
        internalSetQualityScores(qualityScores);
    }

    /**
     * Returns threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value, the
     * algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algrithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     * @return stop threshold to stop the algorithm prematurely when a certain
     * accuracy has been reached.
     */
    public double getStopThreshold() {
        return mStopThreshold;
    }

    /**
     * Sets threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value,
     * the algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algorithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     * @param stopThreshold stop threshold to stop the algorithm prematurely
     *                      when a certain accuracy has been reached.
     * @throws IllegalArgumentException if provided value is zero or negative.
     * @throws LockedException if this solver is locked.
     */
    public void setStopThreshold(double stopThreshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (stopThreshold &lt;= MIN_STOP_THRESHOLD) {
            throw new IllegalArgumentException();
        }

        mStopThreshold = stopThreshold;
    }

    /**
     * Returns quality scores corresponding to each pair of
     * positions and distances (i.e. sample).
     * The larger the score value the better the quality of the sample.
     * @return quality scores corresponding to each sample.
     */
    @Override
    public double[] getQualityScores() {
        return mQualityScores;
    }

    /**
     * Sets quality scores corresponding to each pair of positions and
     * distances (i.e. sample).
     * The larger the score value the better the quality of the sample.
     * @param qualityScores quality scores corresponding to each pair of
     *                      matched points.
     * @throws IllegalArgumentException if provided quality scores length
     * is smaller than minimum required samples.
     * @throws LockedException if robust solver is locked because an
     * estimation is already in progress.
     */
    @Override
    public void setQualityScores(double[] qualityScores)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetQualityScores(qualityScores);
    }

    /**
     * Indicates whether solver is ready to find a solution.
     * @return true if solver is ready, false otherwise.
     */
    @Override
    public boolean isReady() {
        return super.isReady() &amp;&amp; mQualityScores != null &amp;&amp;
                mQualityScores.length == mDistances.length;
    }

    /**
     * Solves the lateration problem.
     * @return estimated position.
     * @throws LockedException if instance is busy solving the lateration problem.
     * @throws NotReadyException is solver is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     * (i.e. numerical instability, no solution available, etc).
     */
    @Override
    public Point2D solve() throws LockedException, NotReadyException,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/fingerprint/SecondOrderNonLinearFingerprintPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/fingerprint/SecondOrderNonLinearFingerprintPositionEstimator2D.html#L155">155</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/fingerprint/ThirdOrderNonLinearFingerprintPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/fingerprint/ThirdOrderNonLinearFingerprintPositionEstimator2D.html#L155">155</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    }

    /**
     * Evaluates a non-linear multi dimension function at provided point using
     * provided parameters and returns its evaluation and derivatives of the
     * function respect the function parameters.
     * @param i number of sample being evaluated.
     * @param point point where function will be evaluated.
     * @param params initial parameters estimation to be tried. These will
     * change as the Levenberg-Marquard algorithm iterates to the best solution.
     * These are used as input parameters along with point to evaluate function.
     * @param derivatives partial derivatives of the function respect to each
     * provided parameter.
     * @return function evaluation at provided point.
     */
    @Override
    @SuppressWarnings(&quot;Duplicates&quot;)
    protected double evaluate(int i, double[] point, double[] params, double[] derivatives) {
        //This method implements received power at point pi = (xi, yi) and its derivatives

        //Pr(pi) = Pr(p1)
        //  - 10*n*(x1 - xa)/(ln(10)*d1a^2)*(xi - x1)
        //  - 10*n*(y1 - ya)/(ln(10)*d1a^2)*(yi - y1)
        //  - 5*n*((y1 - ya)^2 - (x1 - xa)^2)/(ln(10)*d1a^4)*(xi - x1)^2
        //  - 5*n*((x1 - xa)^2 - (y1 - ya)^2)/(ln(10)*d1a^4)*(yi - y1)^2
        //  + 20*n*(x1 - xa)*(y1 - ya)/(ln(10)*d1a^4))*(xi - x1)*(yi - y1)

        double xi = params[0];
        double yi = params[1];

        //received power
        double pr = point[0];

        //fingerprint coordinates
        double x1 = point[1];
        double y1 = point[2];

        //radio source coordinates
        double xa = point[3];
        double ya = point[4];

        //path loss exponent
        double n = point[5];

        double ln10 = Math.log(10.0);

        double diffXi1 = xi - x1;
        double diffYi1 = yi - y1;

        double diffX1a = x1 - xa;
        double diffY1a = y1 - ya;

        double diffXi12 = diffXi1 * diffXi1;
        double diffYi12 = diffYi1 * diffYi1;

        double diffX1a2 = diffX1a * diffX1a;</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/MixedRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MixedRadioSourceEstimator2D.html#L402">402</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RangingAndRssiRadioSourceEstimator2D.html#L389">389</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>        } else if (source instanceof Beacon) {
            Beacon beacon = (Beacon)source;
            //transmitted power does not need to be estimated for beacons because
            //they broadcast such information
            return new BeaconWithPowerAndLocated2D(beacon.getIdentifiers(),
                    beacon.getTransmittedPower(), beacon.getFrequency(),
                    beacon.getBluetoothAddress(), beacon.getBeaconTypeCode(),
                    beacon.getManufacturer(), beacon.getServiceUuid(),
                    beacon.getBluetoothName(), pathLossExponent,
                    transmittedPowerStandardDeviation,
                    pathLossExponentStandardDeviation, estimatedPosition,
                    estimatedPositionCovariance);
        } else {
            return null;
        }
    }

    /**
     * Creates inner estimators if needed.
     */
    @Override
    protected void createInnerEstimatorsIfNeeded() {
        if (mRangingInnerEstimator == null) {
            mRangingInnerEstimator = new RangingRadioSourceEstimator2D&lt;&gt;();
        }

        if (mRssiInnerEstimator == null &amp;&amp;
                (mTransmittedPowerEstimationEnabled || mPathLossEstimationEnabled)) {
            mRssiInnerEstimator = new RssiRadioSourceEstimator2D&lt;&gt;();
        }
    }
}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/MixedRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MixedRadioSourceEstimator3D.html#L402">402</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RangingAndRssiRadioSourceEstimator3D.html#L389">389</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>        } else if (source instanceof Beacon) {
            Beacon beacon = (Beacon)source;
            //transmitted power does not need to be estimated for beacons because
            //they broadcast such information
            return new BeaconWithPowerAndLocated3D(beacon.getIdentifiers(),
                    beacon.getTransmittedPower(), beacon.getFrequency(),
                    beacon.getBluetoothAddress(), beacon.getBeaconTypeCode(),
                    beacon.getManufacturer(), beacon.getServiceUuid(),
                    beacon.getBluetoothName(), pathLossExponent,
                    transmittedPowerStandardDeviation,
                    pathLossExponentStandardDeviation, estimatedPosition,
                    estimatedPositionCovariance);
        } else {
            return null;
        }
    }

    /**
     * Creates inner estimators if needed.
     */
    @Override
    protected void createInnerEstimatorsIfNeeded() {
        if (mRangingInnerEstimator == null) {
            mRangingInnerEstimator = new RangingRadioSourceEstimator3D&lt;&gt;();
        }

        if (mRssiInnerEstimator == null &amp;&amp;
                (mTransmittedPowerEstimationEnabled || mPathLossEstimationEnabled)) {
            mRssiInnerEstimator = new RssiRadioSourceEstimator3D&lt;&gt;();
        }
    }
}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator2D.html#L562">562</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator2D.html#L334">334</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator2D.html#L573">573</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>                                    RANSACRobustRangingAndRssiRadioSourceEstimator2D.this, progress);
                        }
                    }
                });

        try {
            mLocked = true;
            mInliersData = null;
            innerEstimator.setComputeAndKeepInliersEnabled(
                    mComputeAndKeepInliers || mRefineResult);
            innerEstimator.setComputeAndKeepResidualsEnabled(
                    mComputeAndKeepResiduals || mRefineResult);
            innerEstimator.setConfidence(mConfidence);
            innerEstimator.setMaxIterations(mMaxIterations);
            innerEstimator.setProgressDelta(mProgressDelta);
            Solution&lt;Point2D&gt; result = innerEstimator.estimate();
            mInliersData = innerEstimator.getInliersData();
            attemptRefine(result);

        } catch (com.irurueta.numerical.LockedException e) {
            throw new LockedException(e);
        } catch (com.irurueta.numerical.NotReadyException e) {
            throw new NotReadyException(e);
        } finally {
            mLocked = false;
        }
    }

    /**
     * Returns method being used for robust estimation.
     *
     * @return method being used for robust estimation.
     */
    @Override
    public RobustEstimatorMethod getMethod() {
        return RobustEstimatorMethod.RANSAC;
    }
}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator3D.html#L562">562</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator3D.html#L334">334</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator3D.html#L572">572</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                                            RANSACRobustRangingAndRssiRadioSourceEstimator3D.this, progress);
                                }
                            }
                        });

        try {
            mLocked = true;
            mInliersData = null;
            innerEstimator.setComputeAndKeepInliersEnabled(
                    mComputeAndKeepInliers || mRefineResult);
            innerEstimator.setComputeAndKeepResidualsEnabled(
                    mComputeAndKeepResiduals || mRefineResult);
            innerEstimator.setConfidence(mConfidence);
            innerEstimator.setMaxIterations(mMaxIterations);
            innerEstimator.setProgressDelta(mProgressDelta);
            Solution&lt;Point3D&gt; result = innerEstimator.estimate();
            mInliersData = innerEstimator.getInliersData();
            attemptRefine(result);

        } catch (com.irurueta.numerical.LockedException e) {
            throw new LockedException(e);
        } catch (com.irurueta.numerical.NotReadyException e) {
            throw new NotReadyException(e);
        } finally {
            mLocked = false;
        }
    }

    /**
     * Returns method being used for robust estimation.
     *
     * @return method being used for robust estimation.
     */
    @Override
    public RobustEstimatorMethod getMethod() {
        return RobustEstimatorMethod.RANSAC;
    }
}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L10816">10816</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L10871">10871</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public static void navigateECEF(final double timeInterval,
                                    final Distance oldX,
                                    final Distance oldY,
                                    final Distance oldZ,
                                    final CoordinateTransformation oldC,
                                    final ECEFVelocity oldVelocity,
                                    final Acceleration fx,
                                    final Acceleration fy,
                                    final Acceleration fz,
                                    final AngularSpeed angularRateX,
                                    final AngularSpeed angularRateY,
                                    final AngularSpeed angularRateZ,
                                    final ECEFFrame result)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        navigateECEF(timeInterval, convertDistanceToDouble(oldX),
                convertDistanceToDouble(oldY), convertDistanceToDouble(oldZ), oldC,
                oldVelocity.getVx(), oldVelocity.getVy(), oldVelocity.getVz(),
                convertAccelerationToDouble(fx),
                convertAccelerationToDouble(fy), convertAccelerationToDouble(fz),
                convertAngularSpeedToDouble(angularRateX),
                convertAngularSpeedToDouble(angularRateY),
                convertAngularSpeedToDouble(angularRateZ),
                result);
    }

    /**
     * Runs precision ECEF-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldX         previous cartesian x-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldY         previous cartesian y-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldZ         previous cartesian z-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldC         previous body-to-ECEF-frame coordinate transformation.
     * @param oldVelocity  previous body velocity resolved along ECEF-frame axes.
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param result       instance where new estimated ECEF frame containing new body
     *                     position, velocity and coordinate transformation matrix will be stored.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-ECEF-frame coordinate transformation matrix are invalid.
     */
    public static void navigateECEF(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/gnss/GNSSEstimation.java</td>
<td><a href="./xref/com/irurueta/navigation/gnss/GNSSEstimation.html#L715">715</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/gnss/GNSSMeasurement.java</td>
<td><a href="./xref/com/irurueta/navigation/gnss/GNSSMeasurement.html#L485">485</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/INSLooselyCoupledKalmanState.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/INSLooselyCoupledKalmanState.html#L1582">1582</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/INSTightlyCoupledKalmanState.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/INSTightlyCoupledKalmanState.html#L1755">1755</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public void getPosition(final Point3D result) {
        result.setInhomogeneousCoordinates(mX, mY, mZ);
    }

    /**
     * Gets estimated ECEF user position expressed in meters (m).
     *
     * @return estimated ECEF user position.
     */
    public Point3D getPosition() {
        return new InhomogeneousPoint3D(mX, mY, mZ);
    }

    /**
     * Sets estimated ECEF user position expressed in meters (m).
     *
     * @param position estimated ECEF user position.
     */
    public void setPosition(final Point3D position) {
        mX = position.getInhomX();
        mY = position.getInhomY();
        mZ = position.getInhomZ();
    }

    /**
     * Gets estimatedECEF user position.
     *
     * @param result instance where result will be stored.
     */
    public void getEcefPosition(final ECEFPosition result) {
        result.setCoordinates(mX, mY, mZ);
    }

    /**
     * Gets estimated ECEF user position.
     *
     * @return estimated ECEF user position.
     */
    public ECEFPosition getEcefPosition() {
        return new ECEFPosition(mX, mY, mZ);
    }

    /**
     * Sets estimated ECEF user position.
     *
     * @param ecefPosition estimated ECEF user position.
     */
    public void setEcefPosition(final ECEFPosition ecefPosition) {
        mX = ecefPosition.getX();
        mY = ecefPosition.getY();
        mZ = ecefPosition.getZ();
    }

    /**
     * Gets estimated ECEF user velocity.
     *
     * @param result instance where result will be stored.
     */
    public void getEcefVelocity(final ECEFVelocity result) {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/gnss/GNSSEstimation.java</td>
<td><a href="./xref/com/irurueta/navigation/gnss/GNSSEstimation.html#L765">765</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/gnss/GNSSMeasurement.java</td>
<td><a href="./xref/com/irurueta/navigation/gnss/GNSSMeasurement.html#L704">704</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>        mZ = ecefPosition.getZ();
    }

    /**
     * Gets estimated ECEF user velocity.
     *
     * @param result instance where result will be stored.
     */
    public void getEcefVelocity(final ECEFVelocity result) {
        result.setCoordinates(mVx, mVy, mVz);
    }

    /**
     * Gets estimated ECEF user velocity.
     *
     * @return estimated ECEF user velocity.
     */
    public ECEFVelocity getEcefVelocity() {
        return new ECEFVelocity(mVx, mVy, mVz);
    }

    /**
     * Sets estimated ECEF user velocity.
     *
     * @param ecefVelocity estimated ECEF user velocity.
     */
    public void setEcefVelocity(final ECEFVelocity ecefVelocity) {
        mVx = ecefVelocity.getVx();
        mVy = ecefVelocity.getVy();
        mVz = ecefVelocity.getVz();
    }

    /**
     * Gets estimated ECEF user position and velocity.
     *
     * @param result instance where result will be stored.
     */
    public void getPositionAndVelocity(final ECEFPositionAndVelocity result) {
        result.setPositionCoordinates(mX, mY, mZ);
        result.setVelocityCoordinates(mVx, mVy, mVz);
    }

    /**
     * Gets estimated ECEF user position and velocity.
     *
     * @return estimated ECEF user position and velocity.
     */
    public ECEFPositionAndVelocity getPositionAndVelocity() {
        return new ECEFPositionAndVelocity(mX, mY, mZ, mVx, mVy, mVz);
    }

    /**
     * Sets estimated ECEF user position and velocity.
     *
     * @param positionAndVelocity estimated ECEF user position and velocity.
     */
    public void setPositionAndVelocity(
            final ECEFPositionAndVelocity positionAndVelocity) {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RangingRadioSourceEstimator2D.html#L259">259</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RangingRadioSourceEstimator3D.html#L259">259</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>        Point2D[] positionsArray = new InhomogeneousPoint2D[size];
        positionsArray = positions.toArray(positionsArray);

        double[] distancesArray = new double[size];
        double[] distanceStandardDeviationsArray = new double[size];
        for (int i = 0; i &lt; size; i++) {
            distancesArray[i] = distances.get(i);
            distanceStandardDeviationsArray[i] = distanceStandardDeviations.get(i);
        }

        if (mInitialPosition == null || !mNonLinearSolverEnabled) {
            if (mHomogeneousLinearSolver != null) {
                mHomogeneousLinearSolver.setPositionsAndDistances(positionsArray, distancesArray);
            }
            if (mInhomogeneousLinearSolver != null) {
                mInhomogeneousLinearSolver.setPositionsAndDistances(positionsArray, distancesArray);
            }
        }

        if (mNonLinearSolver != null &amp;&amp; mNonLinearSolverEnabled) {
            mNonLinearSolver.setPositionsDistancesAndStandardDeviations(positionsArray,
                    distancesArray, distanceStandardDeviationsArray);
        }
    }
}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/calibration/BodyKinematicsGenerator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/BodyKinematicsGenerator.html#L116">116</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/calibration/BodyKinematicsGenerator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/BodyKinematicsGenerator.html#L327">327</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                                final Collection&lt;BodyKinematics&gt; result) {
        try {
            final Matrix trueFibb = new Matrix(BodyKinematics.COMPONENTS, 1);
            final Matrix ma = errors.getAccelerometerScaleFactorAndCrossCouplingErrors();
            final Matrix ba = errors.getAccelerometerBiasesAsMatrix();
            final Matrix trueOmegaIbb = new Matrix(BodyKinematics.COMPONENTS, 1);
            final Matrix mg = errors.getGyroScaleFactorAndCrossCouplingErrors();
            final Matrix bg = errors.getGyroBiasesAsMatrix();
            final Matrix gg = errors.getGyroGDependentBiases();
            final Matrix identity = Matrix.identity(BodyKinematics.COMPONENTS,
                    BodyKinematics.COMPONENTS);
            final Matrix tmp33 = new Matrix(BodyKinematics.COMPONENTS,
                    BodyKinematics.COMPONENTS);
            final Matrix tmp31a = new Matrix(BodyKinematics.COMPONENTS, 1);
            final Matrix tmp31b = new Matrix(BodyKinematics.COMPONENTS, 1);</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/calibration/RobustKnownBiasAndFrameAccelerometerCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/RobustKnownBiasAndFrameAccelerometerCalibrator.html#L4054">4054</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/calibration/RobustKnownBiasAndFrameAccelerometerCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/RobustKnownBiasAndFrameAccelerometerCalibrator.html#L4401">4401</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>            final double biasX, final double biasY, final double biasZ,
            final boolean commonAxisUsed,
            final RobustKnownBiasAndFrameAccelerometerCalibratorListener listener,
            final RobustEstimatorMethod method) {
        switch (method) {
            case RANSAC:
                return new RANSACRobustKnownBiasAndFrameAccelerometerCalibrator(
                        biasX, biasY, biasZ, commonAxisUsed, listener);
            case LMedS:
                return new LMedSRobustKnownBiasAndFrameAccelerometerCalibrator(
                        biasX, biasY, biasZ, commonAxisUsed, listener);
            case MSAC:
                return new MSACRobustKnownBiasAndFrameAccelerometerCalibrator(
                        biasX, biasY, biasZ, commonAxisUsed, listener);
            case PROSAC:
                return new PROSACRobustKnownBiasAndFrameAccelerometerCalibrator(
                        qualityScores, biasX, biasY, biasZ, commonAxisUsed, listener);
            case PROMedS:
            default:
                return new PROMedSRobustKnownBiasAndFrameAccelerometerCalibrator(
                        qualityScores, biasX, biasY, biasZ, commonAxisUsed, listener);
        }
    }

    /**
     * Creates a robust accelerometer calibrator.
     *
     * @param qualityScores  quality scores corresponding to each provided
     *                       measurement. The larger the score value the better
     *                       the quality of the sample.
     * @param measurements   list of body kinematics measurements with standard
     *                       deviations taken at different frames (positions, orientations
     *                       and velocities).
     * @param biasX          known x coordinate of accelerometer bias expressed in meters per
     *                       squared second (m/s^2).
     * @param biasY          known y coordinate of accelerometer bias expressed in meters per
     *                       squared second (m/s^2).
     * @param biasZ          known z coordinate of accelerometer bias expressed in meters per
     *                       squared second (m/s^2).
     * @param commonAxisUsed indicates whether z-axis is assumed to be common for
     *                       accelerometer and gyroscope.
     * @param method         robust estimator method.
     * @return a robust accelerometer calibrator.
     * @throws IllegalArgumentException if provided quality scores length
     *                                  is smaller than 4 samples.
     */
    public static RobustKnownBiasAndFrameAccelerometerCalibrator create(
            final double[] qualityScores,
            final List&lt;StandardDeviationFrameBodyKinematics&gt; measurements,
            final double biasX, final double biasY, final double biasZ,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/lateration/RobustLateration2DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/RobustLateration2DSolver.html#L1317">1317</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/lateration/RobustLateration3DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/RobustLateration3DSolver.html#L1316">1316</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>            Point2D estimatedPosition = mInitialPosition;
            if (mUseLinearSolver) {
                if (mUseHomogeneousLinearSolver) {
                    mHomogeneousLinearSolver.setPositionsAndDistances(mInnerPositions, mInnerDistances);
                    mHomogeneousLinearSolver.solve();
                    estimatedPosition = mHomogeneousLinearSolver.getEstimatedPosition();
                } else {
                    mInhomogeneousLinearSolver.setPositionsAndDistances(mInnerPositions, mInnerDistances);
                    mInhomogeneousLinearSolver.solve();
                    estimatedPosition = mInhomogeneousLinearSolver.getEstimatedPosition();
                }
            }

            if (mRefinePreliminarySolutions || estimatedPosition == null) {
                mNonLinearSolver.setInitialPosition(estimatedPosition);
                if (mDistanceStandardDeviations != null) {
                    mNonLinearSolver.setPositionsDistancesAndStandardDeviations(mInnerPositions,
                            mInnerDistances, mInnerDistanceStandardDeviations);
                } else {
                    mNonLinearSolver.setPositionsAndDistances(mInnerPositions, mInnerDistances);
                }
                mNonLinearSolver.solve();
                estimatedPosition = mNonLinearSolver.getEstimatedPosition();
            }

            solutions.add(estimatedPosition);
        } catch (NavigationException ignore) {
            //if anything fails, no solution is added
        }
    }

    /**
     * Internally sets circles defining positions and euclidean distances.
     * @param circles circles defining positions and distances.
     * @throws IllegalArgumentException if circles is null or length of array of circles
     * is less than {@link #getMinRequiredPositionsAndDistances}.
     */
    private void internalSetCircles(Circle[] circles) {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/RadioSourceKNearestFinder.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/RadioSourceKNearestFinder.html#L183">183</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/RadioSourceNoMeanKNearestFinder.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/RadioSourceNoMeanKNearestFinder.html#L188">188</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>            double sqrDist = f.sqrDistanceTo(fingerprint);
            if (sqrDist &lt; maxSqrDist || nearestSqrDistances.size() &lt; k) {

                //find insertion point
                int pos = -1;
                int i = 0;
                for(Double sd : nearestSqrDistances) {
                    if (sqrDist &lt; sd) {
                        //insertion point found
                        pos = i;
                        break;
                    }
                    i++;
                }

                if (pos &gt;= 0) {
                    nearestSqrDistances.add(pos, sqrDist);
                    nearestFingerprints.add(pos, f);
                } else {
                    nearestSqrDistances.add(sqrDist);
                    nearestFingerprints.add(f);
                }

                //remove results exceeding required number of k neighbours to be found
                if (nearestFingerprints.size() &gt; k) {
                    nearestSqrDistances.remove(k);
                    nearestFingerprints.remove(k);
                }

                //update maxSqrDist to the largest squared distance value contained in result list distances
                maxSqrDist = nearestSqrDistances.get(nearestSqrDistances.size() - 1);
            }
        }
    }
}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/LinearMixedPositionEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/LinearMixedPositionEstimator.html#L248">248</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/LinearRangingAndRssiPositionEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/LinearRangingAndRssiPositionEstimator.html#L249">249</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/LinearRangingPositionEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/LinearRangingPositionEstimator.html#L246">246</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/LinearRssiPositionEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/LinearRssiPositionEstimator.html#L249">249</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                            LinearMixedPositionEstimator.this);
                }
            }
        };
    }

    /**
     * Builds positions and distances for the internal lateration solver.
     */
    @SuppressWarnings(&quot;Duplicates&quot;)
    private void buildPositionsAndDistances() {
        if ((mUseHomogeneousLinearSolver &amp;&amp; mHomogeneousTrilaterationSolver == null) ||
                (!mUseHomogeneousLinearSolver &amp;&amp; mInhomogeneousTrilaterationSolver == null)) {
            return;
        }

        int min = getMinRequiredSources();
        if (mSources == null || mFingerprint == null ||
                mSources.size() &lt; min ||
                mFingerprint.getReadings() == null ||
                mFingerprint.getReadings().size() &lt; min) {
            return;
        }

        List&lt;P&gt; positions = new ArrayList&lt;&gt;();
        List&lt;Double&gt; distances = new ArrayList&lt;&gt;();
        PositionEstimatorHelper.buildPositionsAndDistances(
                mSources, mFingerprint, positions, distances);

        setPositionsAndDistances(positions, distances);
    }
}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator2D.html#L1051">1051</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator2D.html#L541">541</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator2D.html#L1056">1056</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator2D.html#L562">562</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator2D.html#L334">334</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator2D.html#L573">573</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                                    PROSACRobustRangingAndRssiRadioSourceEstimator2D.this, progress);
                        }
                    }
                });

        try {
            mLocked = true;
            mInliersData = null;
            innerEstimator.setComputeAndKeepInliersEnabled(
                    mComputeAndKeepInliers || mRefineResult);
            innerEstimator.setComputeAndKeepResidualsEnabled(
                    mComputeAndKeepResiduals || mRefineResult);
            innerEstimator.setConfidence(mConfidence);
            innerEstimator.setMaxIterations(mMaxIterations);
            innerEstimator.setProgressDelta(mProgressDelta);
            Solution&lt;Point2D&gt; result = innerEstimator.estimate();
            mInliersData = innerEstimator.getInliersData();
            attemptRefine(result);

        } catch (com.irurueta.numerical.LockedException e) {
            throw new LockedException(e);
        } catch (com.irurueta.numerical.NotReadyException e) {
            throw new NotReadyException(e);
        } finally {
            mLocked = false;
        }
    }

    /**
     * Returns method being used for robust estimation.
     *
     * @return method being used for robust estimation.
     */
    @Override
    public RobustEstimatorMethod getMethod() {
        return RobustEstimatorMethod.PROSAC;</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator3D.html#L1051">1051</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator3D.html#L541">541</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator3D.html#L1055">1055</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator3D.html#L562">562</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator3D.html#L334">334</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator3D.html#L572">572</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                                            PROSACRobustRangingAndRssiRadioSourceEstimator3D.this, progress);
                                }
                            }
                        });

        try {
            mLocked = true;
            mInliersData = null;
            innerEstimator.setComputeAndKeepInliersEnabled(
                    mComputeAndKeepInliers || mRefineResult);
            innerEstimator.setComputeAndKeepResidualsEnabled(
                    mComputeAndKeepResiduals || mRefineResult);
            innerEstimator.setConfidence(mConfidence);
            innerEstimator.setMaxIterations(mMaxIterations);
            innerEstimator.setProgressDelta(mProgressDelta);
            Solution&lt;Point3D&gt; result = innerEstimator.estimate();
            mInliersData = innerEstimator.getInliersData();
            attemptRefine(result);

        } catch (com.irurueta.numerical.LockedException e) {
            throw new LockedException(e);
        } catch (com.irurueta.numerical.NotReadyException e) {
            throw new NotReadyException(e);
        } finally {
            mLocked = false;
        }
    }

    /**
     * Returns method being used for robust estimation.
     *
     * @return method being used for robust estimation.
     */
    @Override
    public RobustEstimatorMethod getMethod() {
        return RobustEstimatorMethod.PROSAC;</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/lateration/RANSACRobustLateration2DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/RANSACRobustLateration2DSolver.html#L194">194</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/lateration/RANSACRobustLateration3DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/RANSACRobustLateration3DSolver.html#L194">194</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>        super(circles, distanceStandardDeviations, listener);
    }

    /**
     * Gets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on distance between estimated position and distances
     * provided for each sample.
     * @return threshold to determine whether samples are inliers or not.
     */
    public double getThreshold() {
        return mThreshold;
    }

    /**
     * Sets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on distance between estimated position and distances
     * provided for each sample.
     * @param threshold threshold to determine whether samples are inliers or not.
     * @throws IllegalArgumentException if provided value is equal or less than zero.
     * @throws LockedException if this solver is locked.
     */
    public void setThreshold(double threshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (threshold &lt;= MIN_THRESHOLD) {
            throw new IllegalArgumentException();
        }
        mThreshold = threshold;
    }

    /**
     * Indicates whether inliers must be computed and kept.
     * @return true if inliers must be computed and kept, false if inliers
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepInliersEnabled() {
        return mComputeAndKeepInliers;
    }

    /**
     * Specifies whether inliers must be computed and kept.
     * @param computeAndKeepInliers true if inliers must be computed and kept,
     *                              false if inliers only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepInliersEnabled(boolean computeAndKeepInliers)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mComputeAndKeepInliers = computeAndKeepInliers;
    }

    /**
     * Indicates whether residuals must be computed and kept.
     * @return true if residuals must be computed and kept, false if residuals
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepResiduals() {
        return mComputeAndKeepResiduals;
    }

    /**
     * Specifies whether residuals must be computed and kept.
     * @param computeAndKeepResiduals true if residuals must be computed and kept,
     *                                false if residuals only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepResidualsEnabled(boolean computeAndKeepResiduals)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mComputeAndKeepResiduals = computeAndKeepResiduals;
    }

    /**
     * Solves the lateration problem.
     * @return estimated position.
     * @throws LockedException if instance is busy solving the lateration problem.
     * @throws NotReadyException is solver is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     * (i.e. numerical instability, no solution available, etc).
     */
    @Override
    public Point2D solve() throws LockedException, NotReadyException, RobustEstimatorException {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator3D.html#L2809">2809</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RssiRadioSourceEstimator3D.html#L408">408</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator3D.html#L849">849</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>        List&lt;? extends RangingAndRssiReadingLocated&lt;S, Point3D&gt;&gt; readings = getReadings();
        if (readings == null || readings.isEmpty()) {
            return null;
        }
        S source = readings.get(0).getSource();

        Point3D estimatedPosition = getEstimatedPosition();
        if (estimatedPosition == null) {
            return null;
        }

        Matrix estimatedPositionCovariance = getEstimatedPositionCovariance();

        Double transmittedPowerVariance =
                getEstimatedTransmittedPowerVariance();
        Double transmittedPowerStandardDeviation = transmittedPowerVariance != null ?
                Math.sqrt(transmittedPowerVariance) : null;

        Double pathlossExponentVariance =
                getEstimatedPathLossExponentVariance();
        Double pathlossExponentStandardDeviation = pathlossExponentVariance != null ?
                Math.sqrt(pathlossExponentVariance) : null;

        if (source instanceof WifiAccessPoint) {
            WifiAccessPoint accessPoint = (WifiAccessPoint) source;
            return new WifiAccessPointWithPowerAndLocated3D(accessPoint.getBssid(),</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/calibration/RobustKnownBiasAndFrameAccelerometerCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/RobustKnownBiasAndFrameAccelerometerCalibrator.html#L4103">4103</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/calibration/RobustKnownBiasAndFrameAccelerometerCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/RobustKnownBiasAndFrameAccelerometerCalibrator.html#L4447">4447</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>            final double biasX, final double biasY, final double biasZ,
            final boolean commonAxisUsed, final RobustEstimatorMethod method) {
        switch (method) {
            case RANSAC:
                return new RANSACRobustKnownBiasAndFrameAccelerometerCalibrator(
                        measurements, biasX, biasY, biasZ, commonAxisUsed);
            case LMedS:
                return new LMedSRobustKnownBiasAndFrameAccelerometerCalibrator(
                        measurements, biasX, biasY, biasZ, commonAxisUsed);
            case MSAC:
                return new MSACRobustKnownBiasAndFrameAccelerometerCalibrator(
                        measurements, biasX, biasY, biasZ, commonAxisUsed);
            case PROSAC:
                return new PROSACRobustKnownBiasAndFrameAccelerometerCalibrator(
                        qualityScores, measurements, biasX, biasY, biasZ, commonAxisUsed);
            case PROMedS:
            default:
                return new PROMedSRobustKnownBiasAndFrameAccelerometerCalibrator(
                        qualityScores, measurements, biasX, biasY, biasZ, commonAxisUsed);
        }
    }

    /**
     * Creates a robust accelerometer calibrator.
     *
     * @param qualityScores  quality scores corresponding to each provided
     *                       measurement. The larger the score value the better
     *                       the quality of the sample.
     * @param measurements   list of body kinematics measurements with standard
     *                       deviations taken at different frames (positions, orientations
     *                       and velocities).
     * @param biasX          known x coordinate of accelerometer bias expressed in meters per
     *                       squared second (m/s^2).
     * @param biasY          known y coordinate of accelerometer bias expressed in meters per
     *                       squared second (m/s^2).
     * @param biasZ          known z coordinate of accelerometer bias expressed in meters per
     *                       squared second (m/s^2).
     * @param commonAxisUsed indicates whether z-axis is assumed to be common for
     *                       accelerometer and gyroscope.
     * @param listener       listener to handle events raised by this calibrator.
     * @param method         robust estimator method.
     * @return a robust accelerometer calibrator.
     * @throws IllegalArgumentException if provided quality scores length
     *                                  is smaller than 4 samples.
     */
    public static RobustKnownBiasAndFrameAccelerometerCalibrator create(
            final double[] qualityScores,
            final List&lt;StandardDeviationFrameBodyKinematics&gt; measurements,
            final double biasX, final double biasY, final double biasZ,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/lateration/PROSACRobustLateration2DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/PROSACRobustLateration2DSolver.html#L578">578</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/lateration/RANSACRobustLateration2DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/RANSACRobustLateration2DSolver.html#L346">346</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>                            mListener.onSolveProgressChange(PROSACRobustLateration2DSolver.this,
                                    progress);
                        }
                    }
                });

        try {
            mLocked = true;
            mInliersData = null;
            innerEstimator.setComputeAndKeepInliersEnabled(
                    mComputeAndKeepInliers || mRefineResult);
            innerEstimator.setComputeAndKeepResidualsEnabled(
                    mComputeAndKeepResiduals || mRefineResult);
            innerEstimator.setConfidence(mConfidence);
            innerEstimator.setMaxIterations(mMaxIterations);
            innerEstimator.setProgressDelta(mProgressDelta);
            Point2D result = innerEstimator.estimate();
            mInliersData = innerEstimator.getInliersData();
            return attemptRefine(result);
        } catch (com.irurueta.numerical.LockedException e) {
            throw new LockedException(e);
        } catch (com.irurueta.numerical.NotReadyException e) {
            throw new NotReadyException(e);
        } finally {
            mLocked = false;
        }
    }

    /**
     * Returns method being used for robust estimation.
     * @return method being used for robust estimation.
     */
    @Override
    public RobustEstimatorMethod getMethod() {
        return RobustEstimatorMethod.PROSAC;</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/lateration/PROSACRobustLateration3DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/PROSACRobustLateration3DSolver.html#L578">578</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/lateration/RANSACRobustLateration3DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/RANSACRobustLateration3DSolver.html#L346">346</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>                            mListener.onSolveProgressChange(PROSACRobustLateration3DSolver.this,
                                    progress);
                        }
                    }
                });

        try {
            mLocked = true;
            mInliersData = null;
            innerEstimator.setComputeAndKeepInliersEnabled(
                    mComputeAndKeepInliers || mRefineResult);
            innerEstimator.setComputeAndKeepResidualsEnabled(
                    mComputeAndKeepResiduals || mRefineResult);
            innerEstimator.setConfidence(mConfidence);
            innerEstimator.setMaxIterations(mMaxIterations);
            innerEstimator.setProgressDelta(mProgressDelta);
            Point3D result = innerEstimator.estimate();
            mInliersData = innerEstimator.getInliersData();
            return attemptRefine(result);
        } catch (com.irurueta.numerical.LockedException e) {
            throw new LockedException(e);
        } catch (com.irurueta.numerical.NotReadyException e) {
            throw new NotReadyException(e);
        } finally {
            mLocked = false;
        }
    }

    /**
     * Returns method being used for robust estimation.
     * @return method being used for robust estimation.
     */
    @Override
    public RobustEstimatorMethod getMethod() {
        return RobustEstimatorMethod.PROSAC;</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/Utils.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/Utils.html#L741">741</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/Utils.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/Utils.html#L1904">1904</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>                    jacobian.setElementAtIndex(0, derivativeFingerprintRssi);
                    jacobian.setElementAtIndex(1, derivativePathLossExponent);
                    jacobian.setElementAtIndex(2, derivativeX1);
                    jacobian.setElementAtIndex(3, derivativeY1);
                    jacobian.setElementAtIndex(4, derivativeZ1);
                    jacobian.setElementAtIndex(5, derivativeXa);
                    jacobian.setElementAtIndex(6, derivativeYa);
                    jacobian.setElementAtIndex(7, derivativeZa);
                    jacobian.setElementAtIndex(8, derivativeXi);
                    jacobian.setElementAtIndex(9, derivativeYi);
                    jacobian.setElementAtIndex(10, derivativeZi);
                }

                @Override
                public int getNumberOfVariables() {
                    return 1;
                }
            }, mean, covariance);
        } catch (AlgebraException | StatisticsException e) {
            throw new IndoorException(e);
        }
    }

    /**
     * Propagates provided variances (fingerprint rssi variance, path-loss exponent variance,
     * fingerprint position covariance and radio source position covariance) into
     * rssi variance by considering the 2D 2nd order Taylor expression of received power.
     * Notice that any unknown variance is assumed to be zero.
     * @param fingerprintRssi closest located fingerprint reading RSSI expressed in dBm's.
     * @param pathLossExponent path-loss exponent.
     * @param fingerprintPosition position of closest fingerprint.
     * @param radioSourcePosition radio source position associated to fingerprint reading.
     * @param estimatedPosition  position to be estimated. Usually this is equal to the
     *                           initial position used by a non linear algorithm.
     * @param fingerprintRssiVariance variance of fingerprint RSSI or null if unknown.
     * @param pathLossExponentVariance variance of path-loss exponent or null if unknown.
     * @param fingerprintPositionCovariance covariance of fingerprint position or null if
     *                                      unknown.
     * @param radioSourcePositionCovariance covariance of radio source position or null
     *                                      if unknown.
     * @param estimatedPositionCovariance  covariance of position to be estimated or null
     *                                     if unknown. (This is usually unknown).
     * @return a normal distribution containing expected received RSSI value and its variance.
     * @throws IndoorException if something fails.
     */
    public static MultivariateNormalDist propagateVariancesToRssiVarianceSecondOrderNonLinear2D(</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/INSLooselyCoupledKalmanInitializer.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/INSLooselyCoupledKalmanInitializer.html#L64">64</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/INSTightlyCoupledKalmanInitializer.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/INSTightlyCoupledKalmanInitializer.html#L68">68</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>        result.initialize(0.0);

        for (int i = 0; i &lt; 3; i++) {
            result.setElementAt(i, i, initAttUnc2);
        }
        for (int i = 3; i &lt; 6; i++) {
            result.setElementAt(i, i, initVelUnc2);
        }
        for (int i = 6; i &lt; 9; i++) {
            result.setElementAt(i, i, initPosUnc2);
        }
        for (int i = 9; i &lt; 12; i++) {
            result.setElementAt(i, i, initBaUnc2);
        }
        for (int i = 12; i &lt; 15; i++) {
            result.setElementAt(i, i, initBgUnc2);
        }</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/Utils.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/Utils.html#L496">496</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/Utils.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/Utils.html#L1192">1192</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/Utils.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/Utils.html#L2146">2146</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/Utils.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/Utils.html#L2556">2556</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>            Double fingerprintRssiVariance,
            Double pathLossExponentVariance,
            Matrix fingerprintPositionCovariance,
            Matrix radioSourcePositionCovariance,
            Matrix estimatedPositionCovariance) throws IndoorException {

        if (fingerprintPosition == null || radioSourcePosition == null ||
                estimatedPosition == null) {
            return null;
        }

        //1st order Taylor expression of received power in 3D:
        //Pr(pi) = Pr(p1)
        //  - 10*n*(x1 - xa)/(ln(10)*d1a^2)*(xi - x1)
        //  - 10*n*(y1 - ya)/(ln(10)*d1a^2)*(yi - y1)
        //  - 10*n*(z1 - za)/(ln(10)*d1a^2)*(zi - z1)
        //where d1a^2 = (x1 - xa)^2 + (y1 - ya)^2 + (z1 - za)^2

        final double x1 = fingerprintPosition.getInhomX();
        final double y1 = fingerprintPosition.getInhomY();
        final double z1 = fingerprintPosition.getInhomZ();

        final double xa = radioSourcePosition.getInhomX();
        final double ya = radioSourcePosition.getInhomY();
        final double za = radioSourcePosition.getInhomZ();

        final double xi = estimatedPosition.getInhomX();
        final double yi = estimatedPosition.getInhomY();
        final double zi = estimatedPosition.getInhomZ();

        double[] mean = new double[] {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/calibration/KnownBiasAndFrameAccelerometerLinearLeastSquaresCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/KnownBiasAndFrameAccelerometerLinearLeastSquaresCalibrator.html#L1026">1026</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/calibration/KnownBiasAndFrameAccelerometerNonLinearLeastSquaresCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/KnownBiasAndFrameAccelerometerNonLinearLeastSquaresCalibrator.html#L2665">2665</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/calibration/KnownFrameAccelerometerNonLinearLeastSquaresCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/KnownFrameAccelerometerNonLinearLeastSquaresCalibrator.html#L2930">2930</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    }

    /**
     * Indicates whether estimator is ready to start the estimator.
     *
     * @return true if estimator is ready, false otherwise.
     */
    @Override
    public boolean isReady() {
        return mMeasurements != null
                &amp;&amp; mMeasurements.size() &gt;= MINIMUM_MEASUREMENTS;
    }

    /**
     * Indicates whether estimator is currently running or not.
     *
     * @return true if estimator is running, false otherwise.
     */
    @Override
    public boolean isRunning() {
        return mRunning;
    }

    /**
     * Estimates accelerometer calibration parameters containing scale factors
     * and cross-coupling errors.
     *
     * @throws LockedException      if estimator is currently running.
     * @throws NotReadyException    if estimator is not ready.
     * @throws CalibrationException if estimation fails for numerical reasons.
     */
    @Override
    public void calibrate() throws LockedException, NotReadyException, CalibrationException {
        if (mRunning) {
            throw new LockedException();
        }

        if (!isReady()) {
            throw new NotReadyException();
        }

        try {
            mRunning = true;

            if (mListener != null) {
                mListener.onCalibrateStart(this);
            }

            if (mCommonAxisUsed) {
                calibrateCommonAxis();
            } else {
                calibrateGeneral();
            }

            if (mListener != null) {
                mListener.onCalibrateEnd(this);
            }

        } catch (final AlgebraException e) {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/calibration/LMedSRobustKnownBiasAndFrameAccelerometerCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/LMedSRobustKnownBiasAndFrameAccelerometerCalibrator.html#L863">863</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/calibration/MSACRobustKnownBiasAndFrameAccelerometerCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/MSACRobustKnownBiasAndFrameAccelerometerCalibrator.html#L815">815</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                                    LMedSRobustKnownBiasAndFrameAccelerometerCalibrator.this, progress);
                        }
                    }
                });

        try {
            mRunning = true;
            mInliersData = null;
            innerEstimator.setConfidence(mConfidence);
            innerEstimator.setMaxIterations(mMaxIterations);
            innerEstimator.setProgressDelta(mProgressDelta);
            final Matrix preliminaryResult = innerEstimator.estimate();
            mInliersData = innerEstimator.getInliersData();

            attemptRefine(preliminaryResult);

        } catch (com.irurueta.numerical.LockedException e) {
            throw new LockedException(e);
        } catch (com.irurueta.numerical.NotReadyException e) {
            throw new NotReadyException(e);
        } catch (RobustEstimatorException e) {
            throw new CalibrationException(e);
        } finally {
            mRunning = false;
        }
    }

    /**
     * Returns method being used for robust estimation.
     *
     * @return method being used for robust estimation.
     */
    @Override
    public RobustEstimatorMethod getMethod() {
        return RobustEstimatorMethod.LMedS;</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/calibration/LMedSRobustKnownFrameAccelerometerCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/LMedSRobustKnownFrameAccelerometerCalibrator.html#L322">322</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/calibration/MSACRobustKnownFrameAccelerometerCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/MSACRobustKnownFrameAccelerometerCalibrator.html#L275">275</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                                    LMedSRobustKnownFrameAccelerometerCalibrator.this, progress);
                        }
                    }
                });

        try {
            mRunning = true;
            mInliersData = null;
            innerEstimator.setConfidence(mConfidence);
            innerEstimator.setMaxIterations(mMaxIterations);
            innerEstimator.setProgressDelta(mProgressDelta);
            final PreliminaryResult preliminaryResult = innerEstimator.estimate();
            mInliersData = innerEstimator.getInliersData();

            attemptRefine(preliminaryResult);

        } catch (com.irurueta.numerical.LockedException e) {
            throw new LockedException(e);
        } catch (com.irurueta.numerical.NotReadyException e) {
            throw new NotReadyException(e);
        } catch (RobustEstimatorException e) {
            throw new CalibrationException(e);
        } finally {
            mRunning = false;
        }
    }

    /**
     * Returns method being used for robust estimation.
     *
     * @return method being used for robust estimation.
     */
    @Override
    public RobustEstimatorMethod getMethod() {
        return RobustEstimatorMethod.LMedS;</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/calibration/PROMedSRobustKnownBiasAndFrameAccelerometerCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/PROMedSRobustKnownBiasAndFrameAccelerometerCalibrator.html#L1773">1773</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/calibration/PROMedSRobustKnownFrameAccelerometerCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/PROMedSRobustKnownFrameAccelerometerCalibrator.html#L545">545</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>            final Matrix preliminaryResult = innerEstimator.estimate();
            mInliersData = innerEstimator.getInliersData();

            attemptRefine(preliminaryResult);

        } catch (com.irurueta.numerical.LockedException e) {
            throw new LockedException(e);
        } catch (com.irurueta.numerical.NotReadyException e) {
            throw new NotReadyException(e);
        } catch (RobustEstimatorException e) {
            throw new CalibrationException(e);
        } finally {
            mRunning = false;
        }
    }

    /**
     * Returns method being used for robust estimation.
     *
     * @return method being used for robust estimation.
     */
    @Override
    public RobustEstimatorMethod getMethod() {
        return RobustEstimatorMethod.PROMedS;
    }

    /**
     * Sets quality scores corresponding to each provided sample.
     * This method is used internally and does not check whether instance is
     * locked or not.
     *
     * @param qualityScores quality scores to be set.
     * @throws IllegalArgumentException if provided quality scores length
     *                                  is smaller than 4 samples.
     */
    private void internalSetQualityScores(final double[] qualityScores) {
        if (qualityScores == null ||
                qualityScores.length &lt; MINIMUM_MEASUREMENTS) {
            throw new IllegalArgumentException();
        }

        mQualityScores = qualityScores;
    }
}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/calibration/PROSACRobustKnownBiasAndFrameAccelerometerCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/PROSACRobustKnownBiasAndFrameAccelerometerCalibrator.html#L1799">1799</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/calibration/PROSACRobustKnownFrameAccelerometerCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/PROSACRobustKnownFrameAccelerometerCalibrator.html#L568">568</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>            final Matrix preliminaryResult = innerEstimator.estimate();
            mInliersData = innerEstimator.getInliersData();

            attemptRefine(preliminaryResult);

        } catch (com.irurueta.numerical.LockedException e) {
            throw new LockedException(e);
        } catch (com.irurueta.numerical.NotReadyException e) {
            throw new NotReadyException(e);
        } catch (RobustEstimatorException e) {
            throw new CalibrationException(e);
        } finally {
            mRunning = false;
        }
    }

    /**
     * Returns method being used for robust estimation.
     *
     * @return method being used for robust estimation.
     */
    @Override
    public RobustEstimatorMethod getMethod() {
        return RobustEstimatorMethod.PROSAC;
    }

    /**
     * Sets quality scores corresponding to each provided sample.
     * This method is used internally and does not check whether instance is
     * locked or not.
     *
     * @param qualityScores quality scores to be set.
     * @throws IllegalArgumentException if provided quality scores length
     *                                  is smaller than 3 samples.
     */
    private void internalSetQualityScores(final double[] qualityScores) {
        if (qualityScores == null ||
                qualityScores.length &lt; MINIMUM_MEASUREMENTS) {
            throw new IllegalArgumentException();
        }

        mQualityScores = qualityScores;
    }
}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/calibration/RobustKnownBiasAndFrameAccelerometerCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/RobustKnownBiasAndFrameAccelerometerCalibrator.html#L2788">2788</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/calibration/RobustKnownBiasAndFrameAccelerometerCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/RobustKnownBiasAndFrameAccelerometerCalibrator.html#L3079">3079</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>            final double biasX, final double biasY, final double biasZ,
            final boolean commonAxisUsed,
            final RobustKnownBiasAndFrameAccelerometerCalibratorListener listener,
            final RobustEstimatorMethod method) {
        switch (method) {
            case RANSAC:
                return new RANSACRobustKnownBiasAndFrameAccelerometerCalibrator(
                        measurements, biasX, biasY, biasZ, commonAxisUsed, listener);
            case LMedS:
                return new LMedSRobustKnownBiasAndFrameAccelerometerCalibrator(
                        measurements, biasX, biasY, biasZ, commonAxisUsed, listener);
            case MSAC:
                return new MSACRobustKnownBiasAndFrameAccelerometerCalibrator(
                        measurements, biasX, biasY, biasZ, commonAxisUsed, listener);
            case PROSAC:
                return new PROSACRobustKnownBiasAndFrameAccelerometerCalibrator(
                        measurements, biasX, biasY, biasZ, commonAxisUsed, listener);
            case PROMedS:
            default:
                return new PROMedSRobustKnownBiasAndFrameAccelerometerCalibrator(
                        measurements, biasX, biasY, biasZ, commonAxisUsed, listener);
        }
    }

    /**
     * Creates a robust accelerometer calibrator.
     *
     * @param biasX  known x coordinate of accelerometer bias.
     * @param biasY  known y coordinate of accelerometer bias.
     * @param biasZ  known z coordinate of accelerometer bias.
     * @param method robust estimator method.
     * @return a robust accelerometer calibrator.
     */
    public static RobustKnownBiasAndFrameAccelerometerCalibrator create(
            final Acceleration biasX, final Acceleration biasY, final Acceleration biasZ,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/calibration/KnownBiasAndFrameAccelerometerNonLinearLeastSquaresCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/KnownBiasAndFrameAccelerometerNonLinearLeastSquaresCalibrator.html#L2537">2537</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/calibration/KnownFrameAccelerometerNonLinearLeastSquaresCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/KnownFrameAccelerometerNonLinearLeastSquaresCalibrator.html#L2802">2802</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/calibration/RobustKnownBiasAndFrameAccelerometerCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/RobustKnownBiasAndFrameAccelerometerCalibrator.html#L1668">1668</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/calibration/RobustKnownFrameAccelerometerCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/RobustKnownFrameAccelerometerCalibrator.html#L1147">1147</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public void setInitialMa(final Matrix initialMa) throws LockedException {
        if (mRunning) {
            throw new LockedException();
        }
        if (initialMa.getRows() != BodyKinematics.COMPONENTS ||
                initialMa.getColumns() != BodyKinematics.COMPONENTS) {
            throw new IllegalArgumentException();
        }

        mInitialSx = initialMa.getElementAtIndex(0);
        mInitialMyx = initialMa.getElementAtIndex(1);
        mInitialMzx = initialMa.getElementAtIndex(2);

        mInitialMxy = initialMa.getElementAtIndex(3);
        mInitialSy = initialMa.getElementAtIndex(4);
        mInitialMzy = initialMa.getElementAtIndex(5);

        mInitialMxz = initialMa.getElementAtIndex(6);
        mInitialMyz = initialMa.getElementAtIndex(7);
        mInitialSz = initialMa.getElementAtIndex(8);
    }</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L10710">10710</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L10763">10763</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public static void navigateECEF(final double timeInterval,
                                    final ECEFPosition oldPosition,
                                    final CoordinateTransformation oldC,
                                    final Speed oldSpeedX,
                                    final Speed oldSpeedY,
                                    final Speed oldSpeedZ,
                                    final Acceleration fx,
                                    final Acceleration fy,
                                    final Acceleration fz,
                                    final AngularSpeed angularRateX,
                                    final AngularSpeed angularRateY,
                                    final AngularSpeed angularRateZ,
                                    final ECEFFrame result)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        navigateECEF(timeInterval, oldPosition.getX(), oldPosition.getY(), oldPosition.getZ(),
                oldC, oldSpeedX, oldSpeedY, oldSpeedZ, convertAccelerationToDouble(fx),
                convertAccelerationToDouble(fy), convertAccelerationToDouble(fz),
                convertAngularSpeedToDouble(angularRateX),
                convertAngularSpeedToDouble(angularRateY),
                convertAngularSpeedToDouble(angularRateZ),
                result);
    }

    /**
     * Runs precision ECEF-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldPosition  previous cartesian position resolved along ECEF-frame axes.
     * @param oldC         previous body-to-ECEF-frame coordinate transformation.
     * @param oldSpeedX    previous velocity x-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param oldSpeedY    previous velocity y-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param oldSpeedZ    previous velocity z-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param result       instance where new estimated ECEF frame containing new body
     *                     position, velocity and coordinate transformation matrix will be stored.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-ECEF-frame coordinate transformation matrix are invalid.
     */
    public static void navigateECEF(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L11135">11135</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L11188">11188</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public static void navigateECEF(final double timeInterval,
                                    final ECEFPosition oldPosition,
                                    final CoordinateTransformation oldC,
                                    final double oldVx,
                                    final double oldVy,
                                    final double oldVz,
                                    final Acceleration fx,
                                    final Acceleration fy,
                                    final Acceleration fz,
                                    final AngularSpeed angularRateX,
                                    final AngularSpeed angularRateY,
                                    final AngularSpeed angularRateZ,
                                    final ECEFFrame result)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        navigateECEF(timeInterval, oldPosition.getX(), oldPosition.getY(), oldPosition.getZ(),
                oldC, oldVx, oldVy, oldVz,
                convertAccelerationToDouble(fx), convertAccelerationToDouble(fy),
                convertAccelerationToDouble(fz),
                convertAngularSpeedToDouble(angularRateX),
                convertAngularSpeedToDouble(angularRateY),
                convertAngularSpeedToDouble(angularRateZ), result);
    }

    /**
     * Runs precision ECEF-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldPosition  previous cartesian position resolved along ECEF-frame axes.
     * @param oldC         previous body-to-ECEF-frame coordinate transformation.
     * @param oldVx        previous velocity x-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param oldVy        previous velocity y-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param oldVz        previous velocity z-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param result       instance where new estimated ECEF frame containing new body
     *                     position, velocity and coordinate transformation matrix will be stored.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-ECEF-frame coordinate transformation matrix are invalid.
     */
    public static void navigateECEF(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L11241">11241</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L11294">11294</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public static void navigateECEF(final double timeInterval,
                                    final double oldX,
                                    final double oldY,
                                    final double oldZ,
                                    final CoordinateTransformation oldC,
                                    final ECEFVelocity oldVelocity,
                                    final Acceleration fx,
                                    final Acceleration fy,
                                    final Acceleration fz,
                                    final AngularSpeed angularRateX,
                                    final AngularSpeed angularRateY,
                                    final AngularSpeed angularRateZ,
                                    final ECEFFrame result)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        navigateECEF(timeInterval, oldX, oldY, oldZ, oldC,
                oldVelocity.getVx(), oldVelocity.getVy(), oldVelocity.getVz(),
                convertAccelerationToDouble(fx), convertAccelerationToDouble(fy),
                convertAccelerationToDouble(fz),
                convertAngularSpeedToDouble(angularRateX),
                convertAngularSpeedToDouble(angularRateY),
                convertAngularSpeedToDouble(angularRateZ), result);
    }

    /**
     * Runs precision ECEF-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldX         previous cartesian x-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldY         previous cartesian y-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldZ         previous cartesian z-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldC         previous body-to-ECEF-frame coordinate transformation.
     * @param oldVelocity  previous body velocity resolved along ECEF-frame axes.
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param result       instance where new estimated ECEF frame containing new body
     *                     position, velocity and coordinate transformation matrix will be stored.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-ECEF-frame coordinate transformation matrix are invalid.
     */
    public static void navigateECEF(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/INSGNSSLooselyCoupledKalmanFilteredEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/INSGNSSLooselyCoupledKalmanFilteredEstimator.html#L1596">1596</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/INSGNSSTightlyCoupledKalmanFilteredEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/INSGNSSTightlyCoupledKalmanFilteredEstimator.html#L1552">1552</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    }

    /**
     * Indicates whether provided measurements are ready to be
     * used for an update.
     *
     * @param measurements measurements to be checked.
     * @return true if estimator is ready, false otherwise.
     */
    public static boolean isUpdateMeasurementsReady(
            final Collection&lt;GNSSMeasurement&gt; measurements) {
        return GNSSLeastSquaresPositionAndVelocityEstimator
                .isValidMeasurements(measurements);
    }

    /**
     * Updates GNSS measurements of this estimator when new satellite measurements
     * are available.
     * Calls to this method will be ignored if interval between provided timestamp
     * and last timestamp when Kalman filter was updated is less than epoch interval.
     *
     * @param measurements GNSS measurements to be updated.
     * @param timestamp    timestamp since epoch time when GNSS measurements were
     *                     updated.
     * @return true if measurements were updated, false otherwise.
     * @throws LockedException   if this estimator is already running.
     * @throws NotReadyException if estimator is not ready for measurements updates.
     * @throws INSGNSSException  if estimation fails due to numerical instabilities.
     */
    public boolean updateMeasurements(
            final Collection&lt;GNSSMeasurement&gt; measurements, final Time timestamp)
            throws LockedException, NotReadyException, INSGNSSException {
        return updateMeasurements(measurements, TimeConverter.convert(
                timestamp.getValue().doubleValue(), timestamp.getUnit(),
                TimeUnit.SECOND));
    }

    /**
     * Updates GNSS measurements of this estimator when new satellite measurements
     * are available.
     * Call to this method will be ignored if interval between provided timestamp
     * and last timestamp when Kalman filter was updated is less than epoch interval.
     *
     * @param measurements GNSS measurements to be updated.
     * @param timestamp    timestamp expressed in seconds since epoch time when
     *                     GNSS measurements were updated.
     * @return true if measurements were updated, false otherwise.
     * @throws LockedException   if this estimator is already running.
     * @throws NotReadyException if estimator is not ready for measurements updates.
     * @throws INSGNSSException  if estimation fails due to numerical instabilities.
     */
    public boolean updateMeasurements(
            final Collection&lt;GNSSMeasurement&gt; measurements, final double timestamp)
            throws LockedException, NotReadyException, INSGNSSException {

        if (mRunning) {
            throw new LockedException();
        }

        if (!isUpdateMeasurementsReady(measurements)) {
            throw new NotReadyException();
        }</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRangingRadioSourceEstimator2D.html#L717">717</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRangingRadioSourceEstimator3D.html#L719">719</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>            return new BeaconLocated2D(beacon.getIdentifiers(),
                    beacon.getTransmittedPower(), beacon.getFrequency(),
                    beacon.getBluetoothAddress(), beacon.getBeaconTypeCode(),
                    beacon.getManufacturer(), beacon.getServiceUuid(),
                    beacon.getBluetoothName(), estimatedPosition,
                    estimatedPositionCovariance);
        } else {
            return null;
        }
    }

    /**
     * Indicates whether an homogeneous linear solver is used to estimate an initial
     * position.
     *
     * @return true if homogeneous linear solver is used, false if an inhomogeneous linear
     * one is used instead.
     */
    @Override
    public boolean isHomogeneousLinearSolverUsed() {
        return mInnerEstimator.isHomogeneousLinearSolverUsed();
    }

    /**
     * Specifies whether an homogeneous linear solver is used to estimate an initial
     * position.
     *
     * @param useHomogeneousLinearSolver true if homogeneous linear solver is used, false
     *                                   if an inhomogeneous linear one is used instead.
     * @throws LockedException if estimator is locked.
     */
    @Override
    public void setHomogeneousLinearSolverUsed(
            boolean useHomogeneousLinearSolver) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mInnerEstimator.setHomogeneousLinearSolverUsed(useHomogeneousLinearSolver);
    }

    /**
     * Solves preliminar solution for a subset of samples.
     *
     * @param samplesIndices    indices of subset samples.
     * @param solutions         instance where solution will be stored.
     */
    @Override
    protected void solvePreliminarSolutions(int[] samplesIndices,
            List&lt;Solution&lt;Point2D&gt;&gt; solutions) {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/calibration/RobustKnownBiasAndFrameAccelerometerCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/RobustKnownBiasAndFrameAccelerometerCalibrator.html#L59">59</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/calibration/RobustKnownFrameAccelerometerCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/RobustKnownFrameAccelerometerCalibrator.html#L58">58</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>public abstract class RobustKnownBiasAndFrameAccelerometerCalibrator {

    /**
     * Indicates whether by default a common z-axis is assumed for both the accelerometer
     * and gyroscope.
     */
    public static final boolean DEFAULT_USE_COMMON_Z_AXIS = false;

    /**
     * Required minimum number of measurements.
     */
    public static final int MINIMUM_MEASUREMENTS = 4;

    /**
     * Indicates that by default a linear calibrator is used for preliminary solution estimation.
     * The result obtained on each preliminary solution might be later refined.
     */
    public static final boolean DEFAULT_USE_LINEAR_CALIBRATOR = true;

    /**
     * Indicates that by default preliminary solutions are refined.
     */
    public static final boolean DEFAULT_REFINE_PRELIMINARY_SOLUTIONS = true;

    /**
     * Default robust estimator method when none is provided.
     */
    public static final RobustEstimatorMethod DEFAULT_ROBUST_METHOD =
            RobustEstimatorMethod.RANSAC;

    /**
     * Indicates that result is refined by default using a non-linear calibrator
     * (which uses a Levenberg-Marquardt fitter).
     */
    public static final boolean DEFAULT_REFINE_RESULT = true;

    /**
     * Indicates that covariance is kept by default after refining result.
     */
    public static final boolean DEFAULT_KEEP_COVARIANCE = true;

    /**
     * Default amount of progress variation before notifying a change in estimation progress.
     * By default this is set to 5%.
     */
    public static final float DEFAULT_PROGRESS_DELTA = 0.05f;

    /**
     * Minimum allowed value for progress delta.
     */
    public static final float MIN_PROGRESS_DELTA = 0.0f;

    /**
     * Maximum allowed value for progress delta.
     */
    public static final float MAX_PROGRESS_DELTA = 1.0f;

    /**
     * Constant defining default confidence of the estimated result, which is
     * 99%. This means that with a probability of 99% estimation will be
     * accurate because chosen subsamples will be inliers.
     */
    public static final double DEFAULT_CONFIDENCE = 0.99;

    /**
     * Default maximum allowed number of iterations.
     */
    public static final int DEFAULT_MAX_ITERATIONS = 5000;

    /**
     * Minimum allowed confidence value.
     */
    public static final double MIN_CONFIDENCE = 0.0;

    /**
     * Maximum allowed confidence value.
     */
    public static final double MAX_CONFIDENCE = 1.0;

    /**
     * Minimum allowed number of iterations.
     */
    public static final int MIN_ITERATIONS = 1;

    /**
     * Minimum allowed distance for a given circle or sphere.
     */
    public static final double EPSILON = 1e-7;

    /**
     * Contains a list of body kinematics measurements taken at different
     * frames (positions, orientations and velocities) and containing the standard
     * deviations of accelerometer and gyroscope measurements.
     * If a single device IMU needs to be calibrated, typically all measurements are
     * taken at the same position, with zero velocity and multiple orientations.
     * However, if we just want to calibrate a given IMU model (e.g. obtain
     * an average and less precise calibration for the IMU of a given phone model),
     * we could take measurements collected throughout the planet at multiple positions
     * while the phone remains static (e.g. while charging), hence each measurement
     * position will change, velocity will remain zero and orientation will be
     * typically constant at horizontal orientation while the phone remains on a
     * flat surface.
     */
    protected List&lt;StandardDeviationFrameBodyKinematics&gt; mMeasurements;

    /**
     * Listener to be notified of events such as when calibration starts, ends or its
     * progress significantly changes.
     */
    protected RobustKnownBiasAndFrameAccelerometerCalibratorListener mListener;</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/calibration/RobustKnownBiasAndFrameAccelerometerCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/RobustKnownBiasAndFrameAccelerometerCalibrator.html#L2703">2703</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/calibration/RobustKnownBiasAndFrameAccelerometerCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/RobustKnownBiasAndFrameAccelerometerCalibrator.html#L3000">3000</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>            final double biasX, final double biasY, final double biasZ,
            final boolean commonAxisUsed,
            final RobustKnownBiasAndFrameAccelerometerCalibratorListener listener,
            final RobustEstimatorMethod method) {
        switch (method) {
            case RANSAC:
                return new RANSACRobustKnownBiasAndFrameAccelerometerCalibrator(
                        biasX, biasY, biasZ, commonAxisUsed, listener);
            case LMedS:
                return new LMedSRobustKnownBiasAndFrameAccelerometerCalibrator(
                        biasX, biasY, biasZ, commonAxisUsed, listener);
            case MSAC:
                return new MSACRobustKnownBiasAndFrameAccelerometerCalibrator(
                        biasX, biasY, biasZ, commonAxisUsed, listener);
            case PROSAC:
                return new PROSACRobustKnownBiasAndFrameAccelerometerCalibrator(
                        biasX, biasY, biasZ, commonAxisUsed, listener);
            case PROMedS:
            default:
                return new PROMedSRobustKnownBiasAndFrameAccelerometerCalibrator(
                        biasX, biasY, biasZ, commonAxisUsed, listener);
        }
    }

    /**
     * Creates a robust accelerometer calibrator.
     *
     * @param measurements   list of body kinematics measurements with standard
     *                       deviations taken at different frames (positions, orientations
     *                       and velocities).
     * @param biasX          known x coordinate of accelerometer bias expressed in meters per
     *                       squared second (m/s^2).
     * @param biasY          known y coordinate of accelerometer bias expressed in meters per
     *                       squared second (m/s^2).
     * @param biasZ          known z coordinate of accelerometer bias expressed in meters per
     *                       squared second (m/s^2).
     * @param commonAxisUsed indicates whether z-axis is assumed to be common for
     *                       accelerometer and gyroscope.
     * @param method         robust estimator method.
     * @return a robust accelerometer calibrator.
     */
    public static RobustKnownBiasAndFrameAccelerometerCalibrator create(
            final List&lt;StandardDeviationFrameBodyKinematics&gt; measurements,
            final double biasX, final double biasY, final double biasZ,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/fingerprint/FirstOrderNonLinearFingerprintPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/fingerprint/FirstOrderNonLinearFingerprintPositionEstimator2D.html#L155">155</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/fingerprint/SecondOrderNonLinearFingerprintPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/fingerprint/SecondOrderNonLinearFingerprintPositionEstimator2D.html#L155">155</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/fingerprint/ThirdOrderNonLinearFingerprintPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/fingerprint/ThirdOrderNonLinearFingerprintPositionEstimator2D.html#L155">155</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    }

    /**
     * Evaluates a non-linear multi dimension function at provided point using
     * provided parameters and returns its evaluation and derivatives of the
     * function respect the function parameters.
     * @param i number of sample being evaluated.
     * @param point point where function will be evaluated.
     * @param params initial parameters estimation to be tried. These will
     * change as the Levenberg-Marquardt algorithm iterates to the best solution.
     * These are used as input parameters along with point to evaluate function.
     * @param derivatives partial derivatives of the function respect to each
     * provided parameter.
     * @return function evaluation at provided point.
     */
    @Override
    @SuppressWarnings(&quot;Duplicates&quot;)
    protected double evaluate(int i, double[] point, double[] params, double[] derivatives) {
        //This method implements received power at point pi = (xi, yi) and its derivatives

        //Pr(pi) = Pr(p1)
        //  - 10*n*(x1 - xa)/(ln(10)*d1a^2)*(xi - x1)
        //  - 10*n*(y1 - ya)/(ln(10)*d1a^2)*(yi - y1)

        double xi = params[0];
        double yi = params[1];

        //received power
        double pr = point[0];

        //fingerprint coordinates
        double x1 = point[1];
        double y1 = point[2];

        //radio source coordinates
        double xa = point[3];
        double ya = point[4];

        //path loss exponent
        double n = point[5];

        double ln10 = Math.log(10.0);

        double diffXi1 = xi - x1;
        double diffYi1 = yi - y1;

        double diffX1a = x1 - xa;
        double diffY1a = y1 - ya;

        double diffX1a2 = diffX1a * diffX1a;</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/calibration/RobustKnownBiasAndFrameAccelerometerCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/RobustKnownBiasAndFrameAccelerometerCalibrator.html#L3966">3966</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/calibration/RobustKnownBiasAndFrameAccelerometerCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/RobustKnownBiasAndFrameAccelerometerCalibrator.html#L4319">4319</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>            final double biasX, final double biasY, final double biasZ,
            final RobustKnownBiasAndFrameAccelerometerCalibratorListener listener,
            final RobustEstimatorMethod method) {
        switch (method) {
            case RANSAC:
                return new RANSACRobustKnownBiasAndFrameAccelerometerCalibrator(
                        measurements, biasX, biasY, biasZ, listener);
            case LMedS:
                return new LMedSRobustKnownBiasAndFrameAccelerometerCalibrator(
                        measurements, biasX, biasY, biasZ, listener);
            case MSAC:
                return new MSACRobustKnownBiasAndFrameAccelerometerCalibrator(
                        measurements, biasX, biasY, biasZ, listener);
            case PROSAC:
                return new PROSACRobustKnownBiasAndFrameAccelerometerCalibrator(
                        qualityScores, measurements, biasX, biasY, biasZ, listener);
            case PROMedS:
            default:
                return new PROMedSRobustKnownBiasAndFrameAccelerometerCalibrator(
                        qualityScores, measurements, biasX, biasY, biasZ, listener);
        }
    }

    /**
     * Creates a robust accelerometer calibrator.
     *
     * @param qualityScores  quality scores corresponding to each provided
     *                       measurement. The larger the score value the better
     *                       the quality of the sample.
     * @param biasX          known x coordinate of accelerometer bias expressed in meters per
     *                       squared second (m/s^2).
     * @param biasY          known y coordinate of accelerometer bias expressed in meters per
     *                       squared second (m/s^2).
     * @param biasZ          known z coordinate of accelerometer bias expressed in meters per
     *                       squared second (m/s^2).
     * @param commonAxisUsed indicates whether z-axis is assumed to be common for
     *                       accelerometer and gyroscope.
     * @param method         robust estimator method.
     * @return a robust accelerometer calibrator.
     * @throws IllegalArgumentException if provided quality scores length
     *                                  is smaller than 4 samples.
     */
    public static RobustKnownBiasAndFrameAccelerometerCalibrator create(
            final double[] qualityScores,
            final double biasX, final double biasY, final double biasZ,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/estimators/ECEFKinematicsEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/estimators/ECEFKinematicsEstimator.html#L2318">2318</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/estimators/ECEFKinematicsEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/estimators/ECEFKinematicsEstimator.html#L2347">2347</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    public static void estimateKinematics(final double timeInterval,
                                          final ECEFFrame frame,
                                          final CoordinateTransformation oldC,
                                          final Speed oldVx, final Speed oldVy, final Speed oldVz,
                                          final BodyKinematics result) {
        estimateKinematics(timeInterval, frame, oldC,
                SpeedConverter.convert(oldVx.getValue().doubleValue(), oldVx.getUnit(), SpeedUnit.METERS_PER_SECOND),
                SpeedConverter.convert(oldVy.getValue().doubleValue(), oldVy.getUnit(), SpeedUnit.METERS_PER_SECOND),
                SpeedConverter.convert(oldVz.getValue().doubleValue(), oldVz.getUnit(), SpeedUnit.METERS_PER_SECOND),
                result);
    }

    /**
     * Estimates body kinematics (specific force applied to a body and its angular rates).
     *
     * @param timeInterval time interval between epochs.
     * @param frame        body ECEF frame containing current position, velocity and
     *                     body-to-ECEF frame coordinate transformation.
     * @param oldC         previous body-to-ECEF-frame coordinate transformation matrix.
     * @param oldVx        previous velocity of body frame x coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldVy        previous velocity of body frame y coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldVz        previous velocity of body frame z coordinate with respect ECEF
     *                     frame, resolved along EVEF-frame axes.
     * @param result       instance where body kinematics estimation will be stored.
     * @throws IllegalArgumentException if provided time interval is negative or coordinated transformation matrices
     *                                  are not ECEF frame valid.
     */
    public static void estimateKinematics(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/estimators/ECEFKinematicsEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/estimators/ECEFKinematicsEstimator.html#L2319">2319</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/estimators/ECIKinematicsEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/estimators/ECIKinematicsEstimator.html#L1277">1277</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>                                          final ECEFFrame frame,
                                          final CoordinateTransformation oldC,
                                          final Speed oldVx, final Speed oldVy, final Speed oldVz,
                                          final BodyKinematics result) {
        estimateKinematics(timeInterval, frame, oldC,
                SpeedConverter.convert(oldVx.getValue().doubleValue(), oldVx.getUnit(), SpeedUnit.METERS_PER_SECOND),
                SpeedConverter.convert(oldVy.getValue().doubleValue(), oldVy.getUnit(), SpeedUnit.METERS_PER_SECOND),
                SpeedConverter.convert(oldVz.getValue().doubleValue(), oldVz.getUnit(), SpeedUnit.METERS_PER_SECOND),
                result);
    }

    /**
     * Estimates body kinematics (specific force applied to a body and its angular rates).
     *
     * @param timeInterval time interval between epochs.
     * @param frame        body ECEF frame containing current position, velocity and
     *                     body-to-ECEF frame coordinate transformation.
     * @param oldC         previous body-to-ECEF-frame coordinate transformation matrix.
     * @param oldVx        previous velocity of body frame x coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldVy        previous velocity of body frame y coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldVz        previous velocity of body frame z coordinate with respect ECEF
     *                     frame, resolved along EVEF-frame axes.
     * @param result       instance where body kinematics estimation will be stored.
     * @throws IllegalArgumentException if provided time interval is negative or coordinated transformation matrices
     *                                  are not ECEF frame valid.
     */
    public static void estimateKinematics(final Time timeInterval,
                                          final ECEFFrame frame,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/estimators/ECIKinematicsEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/estimators/ECIKinematicsEstimator.html#L1276">1276</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/estimators/ECIKinematicsEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/estimators/ECIKinematicsEstimator.html#L1305">1305</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    public static void estimateKinematics(final double timeInterval,
                                          final ECIFrame frame,
                                          final CoordinateTransformation oldC,
                                          final Speed oldVx, final Speed oldVy, final Speed oldVz,
                                          final BodyKinematics result) {
        estimateKinematics(timeInterval, frame, oldC,
                SpeedConverter.convert(oldVx.getValue().doubleValue(), oldVx.getUnit(), SpeedUnit.METERS_PER_SECOND),
                SpeedConverter.convert(oldVy.getValue().doubleValue(), oldVy.getUnit(), SpeedUnit.METERS_PER_SECOND),
                SpeedConverter.convert(oldVz.getValue().doubleValue(), oldVz.getUnit(), SpeedUnit.METERS_PER_SECOND),
                result);
    }

    /**
     * Estimates body kinematics (specific force applied to a body and its angular rates).
     *
     * @param timeInterval time interval between epochs.
     * @param frame        body ECI frame containing current position, velocity and
     *                     body-to-ECI frame coordinate transformation.
     * @param oldC         previous body-to-ECI-frame coordinate transformation.
     * @param oldVx        x coordinate of previous velocity of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes.
     * @param oldVy        y coordinate of previous velocity of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes.
     * @param oldVz        z coordinate of previous velocity of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes.
     * @param result       instance where estimated body kinematics will be stored.
     * @throws IllegalArgumentException if provided time interval is negative or coordinates transformation matrices
     *                                  are not ECI frame valid.
     */
    public static void estimateKinematics(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L10370">10370</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L10417">10417</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    public static void navigateECEF(final double timeInterval,
                                    final ECEFPosition oldPosition,
                                    final CoordinateTransformation oldC,
                                    final ECEFVelocity oldVelocity,
                                    final double fx,
                                    final double fy,
                                    final double fz,
                                    final AngularSpeed angularRateX,
                                    final AngularSpeed angularRateY,
                                    final AngularSpeed angularRateZ,
                                    final ECEFFrame result)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        navigateECEF(timeInterval, oldPosition.getX(), oldPosition.getY(), oldPosition.getZ(),
                oldC, oldVelocity.getVx(), oldVelocity.getVy(), oldVelocity.getVz(),
                fx, fy, fz, convertAngularSpeedToDouble(angularRateX),
                convertAngularSpeedToDouble(angularRateY),
                convertAngularSpeedToDouble(angularRateZ), result);
    }

    /**
     * Runs precision ECEF-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldPosition  previous cartesian position resolved along ECEF-frame axes.
     * @param oldC         previous body-to-ECEF-frame coordinate transformation.
     * @param oldVelocity  previous body velocity resolved along ECEF-frame axes.
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param result       instance where new estimated ECEF frame containing new body
     *                     position, velocity and coordinate transformation matrix will be stored.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-ECEF-frame coordinate transformation matrix are invalid.
     */
    public static void navigateECEF(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/Utils.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/Utils.html#L2088">2088</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/Utils.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/Utils.html#L2314">2314</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>                }

                @Override
                public int getNumberOfVariables() {
                    return 1;
                }
            };

            final JacobianEstimator jacobianEstimator = new JacobianEstimator(evaluator);

            return MultivariateNormalDist.propagate(new MultivariateNormalDist.JacobianEvaluator() {
                @Override
                public void evaluate(double[] x, double[] y, Matrix jacobian) {

                    try {
                        evaluator.evaluate(x, y);
                        jacobianEstimator.jacobian(x, jacobian);
                    } catch (EvaluationException ignore) {
                        //never happens
                    }
                }

                @Override
                public int getNumberOfVariables() {
                    return 1;
                }
            }, mean, covariance);
        } catch (AlgebraException | StatisticsException e) {
            throw new IndoorException(e);
        }
    }

    /**
     * Propagates provided variances (fingerprint rssi variance, path-loss exponent variance,
     * fingerprint position covariance and radio source position covariance) into
     * rssi variance by considering the 3D 3rd order Taylor expression of received power.
     * Notice that any unknown variance is assumed to be zero.
     * @param fingerprintRssi closest located fingerprint reading RSSI expressed in dBm's.
     * @param pathLossExponent path-loss exponent.
     * @param fingerprintPosition position of closest fingerprint.
     * @param radioSourcePosition radio source position associated to fingerprint reading.
     * @param estimatedPosition  position to be estimated. Usually this is equal to the
     *                           initial position used by a non linear algorithm.
     * @param fingerprintRssiVariance variance of fingerprint RSSI or null if unknown.
     * @param pathLossExponentVariance variance of path-loss exponent or null if unknown.
     * @param fingerprintPositionCovariance covariance of fingerprint position or null if
     *                                      unknown.
     * @param radioSourcePositionCovariance covariance of radio source position or null
     *                                      if unknown.
     * @param estimatedPositionCovariance  covariance of position to be estimated or null
     *                                     if unknown. (This is usually unknown).
     * @return a normal distribution containing expected received RSSI value and its variance.
     * @throws IndoorException if something fails.
     */
    public static MultivariateNormalDist propagateVariancesToRssiVarianceThirdOrderNonLinear3D(</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/calibration/RobustKnownBiasAndFrameAccelerometerCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/RobustKnownBiasAndFrameAccelerometerCalibrator.html#L2746">2746</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/calibration/RobustKnownBiasAndFrameAccelerometerCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/RobustKnownBiasAndFrameAccelerometerCalibrator.html#L3040">3040</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>            final double biasX, final double biasY, final double biasZ,
            final boolean commonAxisUsed, final RobustEstimatorMethod method) {
        switch (method) {
            case RANSAC:
                return new RANSACRobustKnownBiasAndFrameAccelerometerCalibrator(
                        measurements, biasX, biasY, biasZ, commonAxisUsed);
            case LMedS:
                return new LMedSRobustKnownBiasAndFrameAccelerometerCalibrator(
                        measurements, biasX, biasY, biasZ, commonAxisUsed);
            case MSAC:
                return new MSACRobustKnownBiasAndFrameAccelerometerCalibrator(
                        measurements, biasX, biasY, biasZ, commonAxisUsed);
            case PROSAC:
                return new PROSACRobustKnownBiasAndFrameAccelerometerCalibrator(
                        measurements, biasX, biasY, biasZ, commonAxisUsed);
            case PROMedS:
            default:
                return new PROMedSRobustKnownBiasAndFrameAccelerometerCalibrator(
                        measurements, biasX, biasY, biasZ, commonAxisUsed);
        }
    }

    /**
     * Creates a robust accelerometer calibrator.
     *
     * @param measurements   list of body kinematics measurements with standard
     *                       deviations taken at different frames (positions, orientations
     *                       and velocities).
     * @param biasX          known x coordinate of accelerometer bias expressed in meters per
     *                       squared second (m/s^2).
     * @param biasY          known y coordinate of accelerometer bias expressed in meters per
     *                       squared second (m/s^2).
     * @param biasZ          known z coordinate of accelerometer bias expressed in meters per
     *                       squared second (m/s^2).
     * @param commonAxisUsed indicates whether z-axis is assumed to be common for
     *                       accelerometer and gyroscope.
     * @param listener       listener to handle events raised by this calibrator.
     * @param method         robust estimator method.
     * @return a robust accelerometer calibrator.
     */
    public static RobustKnownBiasAndFrameAccelerometerCalibrator create(
            final List&lt;StandardDeviationFrameBodyKinematics&gt; measurements,
            final double biasX, final double biasY, final double biasZ,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/calibration/RobustKnownBiasAndFrameAccelerometerCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/RobustKnownBiasAndFrameAccelerometerCalibrator.html#L3874">3874</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/calibration/RobustKnownBiasAndFrameAccelerometerCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/RobustKnownBiasAndFrameAccelerometerCalibrator.html#L4233">4233</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>            final double biasX, final double biasY, final double biasZ,
            final RobustKnownBiasAndFrameAccelerometerCalibratorListener listener,
            final RobustEstimatorMethod method) {
        switch (method) {
            case RANSAC:
                return new RANSACRobustKnownBiasAndFrameAccelerometerCalibrator(
                        biasX, biasY, biasZ, listener);
            case LMedS:
                return new LMedSRobustKnownBiasAndFrameAccelerometerCalibrator(
                        biasX, biasY, biasZ, listener);
            case MSAC:
                return new MSACRobustKnownBiasAndFrameAccelerometerCalibrator(
                        biasX, biasY, biasZ, listener);
            case PROSAC:
                return new PROSACRobustKnownBiasAndFrameAccelerometerCalibrator(
                        qualityScores, biasX, biasY, biasZ, listener);
            case PROMedS:
            default:
                return new PROMedSRobustKnownBiasAndFrameAccelerometerCalibrator(
                        qualityScores, biasX, biasY, biasZ, listener);
        }
    }

    /**
     * Creates a robust accelerometer calibrator.
     *
     * @param qualityScores quality scores corresponding to each provided
     *                      measurement. The larger the score value the better
     *                      the quality of the sample.
     * @param measurements  list of body kinematics measurements with standard
     *                      deviations taken at different frames (positions, orientations
     *                      and velocities).
     * @param biasX         known x coordinate of accelerometer bias expressed in meters per
     *                      squared second (m/s^2).
     * @param biasY         known y coordinate of accelerometer bias expressed in meters per
     *                      squared second (m/s^2).
     * @param biasZ         known z coordinate of accelerometer bias expressed in meters per
     *                      squared second (m/s^2).
     * @param method        robust estimator method.
     * @return a robust accelerometer calibrator.
     * @throws IllegalArgumentException if provided quality scores length
     *                                  is smaller than 4 samples.
     */
    public static RobustKnownBiasAndFrameAccelerometerCalibrator create(
            final double[] qualityScores,
            final List&lt;StandardDeviationFrameBodyKinematics&gt; measurements,
            final double biasX, final double biasY, final double biasZ,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/LMedSRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/LMedSRobustRangingRadioSourceEstimator2D.html#L305">305</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/LMedSRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/LMedSRobustRssiRadioSourceEstimator2D.html#L542">542</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>                            mListener.onEstimateProgressChange(LMedSRobustRangingRadioSourceEstimator2D.this,
                                    progress);
                        }
                    }
                });

        try {
            mLocked = true;
            mInliersData = null;
            innerEstimator.setConfidence(mConfidence);
            innerEstimator.setMaxIterations(mMaxIterations);
            innerEstimator.setProgressDelta(mProgressDelta);
            Solution&lt;Point2D&gt; result = innerEstimator.estimate();
            mInliersData = innerEstimator.getInliersData();
            attemptRefine(result);

        } catch (com.irurueta.numerical.LockedException e) {
            throw new LockedException(e);
        } catch (com.irurueta.numerical.NotReadyException e) {
            throw new NotReadyException(e);
        } finally {
            mLocked = false;
        }
    }

    /**
     * Returns method being used for robust estimation.
     *
     * @return method being used for robust estimation.
     */
    @Override
    public RobustEstimatorMethod getMethod() {
        return RobustEstimatorMethod.LMedS;
    }
}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/LMedSRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/LMedSRobustRangingRadioSourceEstimator3D.html#L305">305</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/LMedSRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/LMedSRobustRssiRadioSourceEstimator3D.html#L542">542</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>                            mListener.onEstimateProgressChange(LMedSRobustRangingRadioSourceEstimator3D.this,
                                progress);
                        }
                    }
                });

        try {
            mLocked = true;
            mInliersData = null;
            innerEstimator.setConfidence(mConfidence);
            innerEstimator.setMaxIterations(mMaxIterations);
            innerEstimator.setProgressDelta(mProgressDelta);
            Solution&lt;Point3D&gt; result = innerEstimator.estimate();
            mInliersData = innerEstimator.getInliersData();
            attemptRefine(result);

        } catch (com.irurueta.numerical.LockedException e) {
            throw new LockedException(e);
        } catch (com.irurueta.numerical.NotReadyException e) {
            throw new NotReadyException(e);
        } finally {
            mLocked = false;
        }
    }

    /**
     * Returns method being used for robust estimation.
     *
     * @return method being used for robust estimation.
     */
    @Override
    public RobustEstimatorMethod getMethod() {
        return RobustEstimatorMethod.LMedS;
    }
}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRangingAndRssiRadioSourceEstimator2D.html#L485">485</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRangingRadioSourceEstimator2D.html#L264">264</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRssiRadioSourceEstimator2D.html#L496">496</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                                    MSACRobustRangingAndRssiRadioSourceEstimator2D.this, progress);
                        }
                    }
                });

        try {
            mLocked = true;
            mInliersData = null;
            innerEstimator.setConfidence(mConfidence);
            innerEstimator.setMaxIterations(mMaxIterations);
            innerEstimator.setProgressDelta(mProgressDelta);
            Solution&lt;Point2D&gt; result = innerEstimator.estimate();
            mInliersData = innerEstimator.getInliersData();
            attemptRefine(result);

        } catch (com.irurueta.numerical.LockedException e) {
            throw new LockedException(e);
        } catch (com.irurueta.numerical.NotReadyException e) {
            throw new NotReadyException(e);
        } finally {
            mLocked = false;
        }
    }

    /**
     * Returns method being used for robust estimation.
     *
     * @return method being used for robust estimation.
     */
    @Override
    public RobustEstimatorMethod getMethod() {
        return RobustEstimatorMethod.MSAC;
    }
}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRangingAndRssiRadioSourceEstimator3D.html#L485">485</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRangingRadioSourceEstimator3D.html#L264">264</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRssiRadioSourceEstimator3D.html#L496">496</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>                                            MSACRobustRangingAndRssiRadioSourceEstimator3D.this, progress);
                                }
                            }
                        });

        try {
            mLocked = true;
            mInliersData = null;
            innerEstimator.setConfidence(mConfidence);
            innerEstimator.setMaxIterations(mMaxIterations);
            innerEstimator.setProgressDelta(mProgressDelta);
            Solution&lt;Point3D&gt; result = innerEstimator.estimate();
            mInliersData = innerEstimator.getInliersData();
            attemptRefine(result);

        } catch (com.irurueta.numerical.LockedException e) {
            throw new LockedException(e);
        } catch (com.irurueta.numerical.NotReadyException e) {
            throw new NotReadyException(e);
        } finally {
            mLocked = false;
        }
    }

    /**
     * Returns method being used for robust estimation.
     *
     * @return method being used for robust estimation.
     */
    @Override
    public RobustEstimatorMethod getMethod() {
        return RobustEstimatorMethod.MSAC;
    }
}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/MixedRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MixedRadioSourceEstimator.html#L497">497</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RangingAndRssiRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RangingAndRssiRadioSourceEstimator.html#L487">487</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RssiRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RssiRadioSourceEstimator.html#L490">490</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustMixedRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustMixedRadioSourceEstimator.html#L1597">1597</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator.html#L1580">1580</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    }

    /**
     * Gets initial transmitted power to start the estimation of radio source
     * transmitted power (expressed in dBm's).
     * If not defined, average value of received power readings will be used.
     *
     * If transmitted power estimation is enabled, estimation will start at this
     * value and will converte the most appropriate value.
     * If transmitted power estimation is disabled, this value will be assumed to be
     * exact and the estimated transmitted power will be equal to this value
     * (converted to dBm's).
     * @return initial transmitted power to start the estimation of radio source
     * transmitted power.
     */
    public Double getInitialTransmittedPowerdBm() {
        return mInitialTransmittedPowerdBm;
    }

    /**
     * Sets initial transmitted power to start the estimation of radio source
     * transmitted power (expressed in dBm's).
     * If not defined, average value of received power readings will be used.
     *
     * If transmitted power estimation is enabled, estimation will start at this
     * value and will converte the most appropriate value.
     * If transmitted power estimation is disabled, this value will be assumed to be
     * exact and the estimated transmitted power will be equal to this value
     * (converted to dBm's).
     * @param initialTransmittedPowerdBm initial transmitted power to start the
     *                                   estimation of radio source transmitted
     *                                   power.
     * @throws LockedException if estimator is locked.
     */
    public void setInitialTransmittedPowerdBm(Double initialTransmittedPowerdBm)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mInitialTransmittedPowerdBm = initialTransmittedPowerdBm;
    }

    /**
     * Gets initial transmitted power to start the estimation of radio source
     * transmitted power (expressed in mW).
     * If not defined, average value of received power readings will be used.
     *
     * If transmitted power estimation is enabled, estimation will start at this
     * value and will converte the most appropriate value.
     * If transmitted power estimation is disabled, this value will be assumed to be
     * exact and the estimated transmitted power will be equal to this value
     * (converted to dBm's).
     * @return initial transmitted power to start the estimation of radio source
     * transmitted power.
     */
    public Double getInitialTransmittedPower() {
        return mInitialTransmittedPowerdBm != null ?
                Utils.dBmToPower(mInitialTransmittedPowerdBm) : null;
    }

    /**
     * Sets initial transmitted power to start the estimation of radio source
     * transmitted power (expressed in mW).
     * If not defined, average value of received power readings will be used.
     *
     * If transmitted power estimation is enabled, estimation will start at this
     * value and will converte the most appropriate value.
     * If transmitted power estimation is disabled, this value will be assumed to be
     * exact and the estimated transmitted power will be equal to this value
     * (converted to dBm's).
     * @param initialTransmittedPower initial transmitted power to start the
     *                                estimation of radio source transmitted power.
     * @throws LockedException if estimator is locked.
     * @throws IllegalArgumentException if provided value is negative.
     */
    public void setInitialTransmittedPower(Double initialTransmittedPower)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (initialTransmittedPower != null) {
            if (initialTransmittedPower &lt; 0.0) {
                throw new IllegalArgumentException();
            }
            mInitialTransmittedPowerdBm = Utils.powerTodBm(
                    initialTransmittedPower);
        } else {
            mInitialTransmittedPowerdBm = null;
        }
    }

    /**
     * Indicates whether transmitted power estimation is enabled or not.
     * @return true if transmitted power estimation is enabled, false otherwise.
     */
    public boolean isTransmittedPowerEstimationEnabled() {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator2D.html#L2917">2917</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator3D.html#L2891">2891</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>        Point2D initialPosition = result.getEstimatedPosition();
        double initialTransmittedPowerdBm =
                result.getEstimatedTransmittedPowerdBm();
        double initialPathLossExponent = result.getEstimatedPathLossExponent();

        if (mRefineResult &amp;&amp; mInliersData != null) {
            BitSet inliers = mInliersData.getInliers();
            int nSamples = mReadings.size();

            mInnerReadings.clear();

            for (int i = 0; i &lt; nSamples; i++) {
                if (inliers.get(i)) {
                    //sample is inlier
                    mInnerReadings.add(mReadings.get(i));
                }
            }

            try {
                mInnerEstimator.setInitialPosition(initialPosition);
                mInnerEstimator.setInitialTransmittedPowerdBm(initialTransmittedPowerdBm);
                mInnerEstimator.setInitialPathLossExponent(initialPathLossExponent);
                mInnerEstimator.setTransmittedPowerEstimationEnabled(
                        mTransmittedPowerEstimationEnabled);
                mInnerEstimator.setPathLossEstimationEnabled(</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator3D.html#L2919">2919</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator2D.html#L2891">2891</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>        Point3D initialPosition = result.getEstimatedPosition();
        double initialTransmittedPowerdBm =
                result.getEstimatedTransmittedPowerdBm();
        double initialPathLossExponent = result.getEstimatedPathLossExponent();

        if (mRefineResult &amp;&amp; mInliersData != null) {
            BitSet inliers = mInliersData.getInliers();
            int nSamples = mReadings.size();

            mInnerReadings.clear();

            for (int i = 0; i &lt; nSamples; i++) {
                if (inliers.get(i)) {
                    //sample is inlier
                    mInnerReadings.add(mReadings.get(i));
                }
            }

            try {
                mInnerEstimator.setInitialPosition(initialPosition);
                mInnerEstimator.setInitialTransmittedPowerdBm(initialTransmittedPowerdBm);
                mInnerEstimator.setInitialPathLossExponent(initialPathLossExponent);
                mInnerEstimator.setTransmittedPowerEstimationEnabled(
                        mTransmittedPowerEstimationEnabled);
                mInnerEstimator.setPathLossEstimationEnabled(</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRangingAndRssiRadioSourceEstimator2D.html#L425">425</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRssiRadioSourceEstimator2D.html#L436">436</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator2D.html#L502">502</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator2D.html#L274">274</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator2D.html#L513">513</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>                        new MSACRobustEstimatorListener&lt;Solution&lt;Point2D&gt;&gt;() {
                    @Override
                    public double getThreshold() {
                        return mThreshold;
                    }

                    @Override
                    public int getTotalSamples() {
                        return mReadings.size();
                    }

                    @Override
                    public int getSubsetSize() {
                        return Math.max(mPreliminarySubsetSize, getMinReadings());
                    }

                    @Override
                    public void estimatePreliminarSolutions(int[] samplesIndices,
                            List&lt;Solution&lt;Point2D&gt;&gt; solutions) {
                        solvePreliminarSolutions(samplesIndices, solutions);
                    }

                    @Override
                    public double computeResidual(Solution&lt;Point2D&gt; currentEstimation, int i) {
                        return residual(currentEstimation, i);
                    }

                    @Override
                    public boolean isReady() {
                        return MSACRobustRangingAndRssiRadioSourceEstimator2D.this.isReady();</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRangingAndRssiRadioSourceEstimator3D.html#L425">425</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRssiRadioSourceEstimator3D.html#L436">436</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator3D.html#L502">502</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator3D.html#L274">274</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator3D.html#L512">512</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                        new MSACRobustEstimatorListener&lt;Solution&lt;Point3D&gt;&gt;() {
                            @Override
                            public double getThreshold() {
                                return mThreshold;
                            }

                            @Override
                            public int getTotalSamples() {
                                return mReadings.size();
                            }

                            @Override
                            public int getSubsetSize() {
                                return Math.max(mPreliminarySubsetSize, getMinReadings());
                            }

                            @Override
                            public void estimatePreliminarSolutions(int[] samplesIndices,
                                                                    List&lt;Solution&lt;Point3D&gt;&gt; solutions) {
                                solvePreliminarSolutions(samplesIndices, solutions);
                            }

                            @Override
                            public double computeResidual(Solution&lt;Point3D&gt; currentEstimation, int i) {
                                return residual(currentEstimation, i);
                            }

                            @Override
                            public boolean isReady() {
                                return MSACRobustRangingAndRssiRadioSourceEstimator3D.this.isReady();</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/estimators/ECEFKinematicsEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/estimators/ECEFKinematicsEstimator.html#L2319">2319</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/estimators/ECIKinematicsEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/estimators/ECIKinematicsEstimator.html#L1306">1306</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                                          final ECEFFrame frame,
                                          final CoordinateTransformation oldC,
                                          final Speed oldVx, final Speed oldVy, final Speed oldVz,
                                          final BodyKinematics result) {
        estimateKinematics(timeInterval, frame, oldC,
                SpeedConverter.convert(oldVx.getValue().doubleValue(), oldVx.getUnit(), SpeedUnit.METERS_PER_SECOND),
                SpeedConverter.convert(oldVy.getValue().doubleValue(), oldVy.getUnit(), SpeedUnit.METERS_PER_SECOND),
                SpeedConverter.convert(oldVz.getValue().doubleValue(), oldVz.getUnit(), SpeedUnit.METERS_PER_SECOND),
                result);
    }

    /**
     * Estimates body kinematics (specific force applied to a body and its angular rates).
     *
     * @param timeInterval time interval between epochs.
     * @param frame        body ECEF frame containing current position, velocity and
     *                     body-to-ECEF frame coordinate transformation.
     * @param oldC         previous body-to-ECEF-frame coordinate transformation matrix.
     * @param oldVx        previous velocity of body frame x coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldVy        previous velocity of body frame y coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldVz        previous velocity of body frame z coordinate with respect ECEF
     *                     frame, resolved along EVEF-frame axes.
     * @param result       instance where body kinematics estimation will be stored.
     * @throws IllegalArgumentException if provided time interval is negative or coordinated transformation matrices
     *                                  are not ECEF frame valid.
     */
    public static void estimateKinematics(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/estimators/ECEFKinematicsEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/estimators/ECEFKinematicsEstimator.html#L2348">2348</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/estimators/ECIKinematicsEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/estimators/ECIKinematicsEstimator.html#L1277">1277</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                                          final ECEFFrame frame,
                                          final CoordinateTransformation oldC,
                                          final Speed oldVx, final Speed oldVy, final Speed oldVz,
                                          final BodyKinematics result) {
        estimateKinematics(timeInterval, frame, oldC,
                SpeedConverter.convert(oldVx.getValue().doubleValue(), oldVx.getUnit(), SpeedUnit.METERS_PER_SECOND),
                SpeedConverter.convert(oldVy.getValue().doubleValue(), oldVy.getUnit(), SpeedUnit.METERS_PER_SECOND),
                SpeedConverter.convert(oldVz.getValue().doubleValue(), oldVz.getUnit(), SpeedUnit.METERS_PER_SECOND),
                result);
    }

    /**
     * Estimates body kinematics (specific force applied to a body and its angular rates).
     *
     * @param timeInterval time interval between epochs expressed in seconds (s).
     * @param c            body-to-ECEF frame coordinate transformation matrix.
     * @param oldC         previous body-to-ECEF-frame coordinate transformation matrix.
     * @param vx           velocity of body frame x coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per
     *                     second (m/s).
     * @param vy           velocity of body frame y coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per
     *                     second (m/s).
     * @param vz           velocity of body frame z coordinate with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per
     *                     second (m/s).
     * @param oldVx        previous velocity of body frame x coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters
     *                     per second (m/s).
     * @param oldVy        previous velocity of body frame y coordinate with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters
     *                     per second (m/s).
     * @param oldVz        previous velocity of body frame z coordinate with respect ECEF
     *                     frame, resolved along EVEF-frame axes and expressed in meters
     *                     per second (m/s).
     * @param position     body position expressed in meters (m) with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param result       instance where body kinematics estimation will be stored.
     * @throws IllegalArgumentException if provided time interval is negative or coordinated transformation matrices
     *                                  are not ECEF frame valid.
     */
    public static void estimateKinematics(final double timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L9846">9846</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L9900">9900</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public static void navigateECEF(final double timeInterval,
                                    final double oldX,
                                    final double oldY,
                                    final double oldZ,
                                    final CoordinateTransformation oldC,
                                    final ECEFVelocity oldVelocity,
                                    final Acceleration fx,
                                    final Acceleration fy,
                                    final Acceleration fz,
                                    final double angularRateX,
                                    final double angularRateY,
                                    final double angularRateZ,
                                    final ECEFFrame result)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        navigateECEF(timeInterval, oldX, oldY, oldZ, oldC,
                oldVelocity.getVx(), oldVelocity.getVy(), oldVelocity.getVz(),
                convertAccelerationToDouble(fx), convertAccelerationToDouble(fy),
                convertAccelerationToDouble(fz), angularRateX, angularRateY,
                angularRateZ, result);
    }

    /**
     * Runs precision ECEF-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldX         previous cartesian x-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldY         previous cartesian y-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldZ         previous cartesian z-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldC         previous body-to-ECEF-frame coordinate transformation.
     * @param oldVelocity  previous body velocity resolved along ECEF-frame axes.
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param result       instance where new estimated ECEF frame containing new body
     *                     position, velocity and coordinate transformation matrix will be stored.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-ECEF-frame coordinate transformation matrix are invalid.
     */
    public static void navigateECEF(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L10267">10267</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L10321">10321</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public static void navigateECEF(final double timeInterval,
                                    final double oldX,
                                    final double oldY,
                                    final double oldZ,
                                    final CoordinateTransformation oldC,
                                    final ECEFVelocity oldVelocity,
                                    final double fx,
                                    final double fy,
                                    final double fz,
                                    final AngularSpeed angularRateX,
                                    final AngularSpeed angularRateY,
                                    final AngularSpeed angularRateZ,
                                    final ECEFFrame result)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        navigateECEF(timeInterval, oldX, oldY, oldZ, oldC,
                oldVelocity.getVx(), oldVelocity.getVy(), oldVelocity.getVz(),
                fx, fy, fz, convertAngularSpeedToDouble(angularRateX),
                convertAngularSpeedToDouble(angularRateY),
                convertAngularSpeedToDouble(angularRateZ), result);
    }

    /**
     * Runs precision ECEF-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldX         previous cartesian x-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldY         previous cartesian y-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldZ         previous cartesian z-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldC         previous body-to-ECEF-frame coordinate transformation.
     * @param oldVelocity  previous body velocity resolved along ECEF-frame axes.
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param result       instance where new estimated ECEF frame containing new body
     *                     position, velocity and coordinate transformation matrix will be stored.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-ECEF-frame coordinate transformation matrix are invalid.
     */
    public static void navigateECEF(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/LMedSRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/LMedSRobustRangingRadioSourceEstimator2D.html#L305">305</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/LMedSRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/LMedSRobustRssiRadioSourceEstimator2D.html#L542">542</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRangingAndRssiRadioSourceEstimator2D.html#L485">485</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRangingRadioSourceEstimator2D.html#L264">264</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRssiRadioSourceEstimator2D.html#L496">496</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>                            mListener.onEstimateProgressChange(LMedSRobustRangingRadioSourceEstimator2D.this,
                                    progress);
                        }
                    }
                });

        try {
            mLocked = true;
            mInliersData = null;
            innerEstimator.setConfidence(mConfidence);
            innerEstimator.setMaxIterations(mMaxIterations);
            innerEstimator.setProgressDelta(mProgressDelta);
            Solution&lt;Point2D&gt; result = innerEstimator.estimate();
            mInliersData = innerEstimator.getInliersData();
            attemptRefine(result);

        } catch (com.irurueta.numerical.LockedException e) {
            throw new LockedException(e);
        } catch (com.irurueta.numerical.NotReadyException e) {
            throw new NotReadyException(e);
        } finally {
            mLocked = false;
        }
    }

    /**
     * Returns method being used for robust estimation.
     *
     * @return method being used for robust estimation.
     */
    @Override
    public RobustEstimatorMethod getMethod() {
        return RobustEstimatorMethod.LMedS;</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/LMedSRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/LMedSRobustRangingRadioSourceEstimator3D.html#L305">305</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/LMedSRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/LMedSRobustRssiRadioSourceEstimator3D.html#L542">542</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRangingAndRssiRadioSourceEstimator3D.html#L485">485</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRangingRadioSourceEstimator3D.html#L264">264</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRssiRadioSourceEstimator3D.html#L496">496</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                            mListener.onEstimateProgressChange(LMedSRobustRangingRadioSourceEstimator3D.this,
                                progress);
                        }
                    }
                });

        try {
            mLocked = true;
            mInliersData = null;
            innerEstimator.setConfidence(mConfidence);
            innerEstimator.setMaxIterations(mMaxIterations);
            innerEstimator.setProgressDelta(mProgressDelta);
            Solution&lt;Point3D&gt; result = innerEstimator.estimate();
            mInliersData = innerEstimator.getInliersData();
            attemptRefine(result);

        } catch (com.irurueta.numerical.LockedException e) {
            throw new LockedException(e);
        } catch (com.irurueta.numerical.NotReadyException e) {
            throw new NotReadyException(e);
        } finally {
            mLocked = false;
        }
    }

    /**
     * Returns method being used for robust estimation.
     *
     * @return method being used for robust estimation.
     */
    @Override
    public RobustEstimatorMethod getMethod() {
        return RobustEstimatorMethod.LMedS;</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator2D.html#L1039">1039</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingAndRssiRadioSourceEstimator3D.html#L1039">1039</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator2D.html#L535">535</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRangingRadioSourceEstimator3D.html#L534">534</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator2D.html#L1050">1050</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROMedSRobustRssiRadioSourceEstimator3D.html#L1049">1049</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>            Solution&lt;Point2D&gt; result = innerEstimator.estimate();
            mInliersData = innerEstimator.getInliersData();
            attemptRefine(result);

        } catch (com.irurueta.numerical.LockedException e) {
            throw new LockedException(e);
        } catch (com.irurueta.numerical.NotReadyException e) {
            throw new NotReadyException(e);
        } finally {
            mLocked = false;
        }
    }

    /**
     * Returns method being used for robust estimation.
     *
     * @return method being used for robust estimation.
     */
    @Override
    public RobustEstimatorMethod getMethod() {
        return RobustEstimatorMethod.PROMedS;
    }

    /**
     * Sets quality scores corresponding to each provided sample.
     * This method is used internally and does not check whether instance is
     * locked or not.
     *
     * @param qualityScores quality scores to be set.
     * @throws IllegalArgumentException if provided quality scores length
     * is smaller than 3 samples.
     */
    private void internalSetQualityScores(double[] qualityScores) {
        if (qualityScores == null ||
                qualityScores.length &lt; getMinReadings()) {
            throw new IllegalArgumentException();
        }

        mQualityScores = qualityScores;
    }
}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator2D.html#L913">913</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator3D.html#L913">913</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator2D.html#L404">404</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator3D.html#L404">404</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator2D.html#L918">918</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator3D.html#L917">917</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator2D.html#L429">429</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator3D.html#L429">429</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator2D.html#L202">202</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator3D.html#L202">202</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator2D.html#L440">440</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator3D.html#L440">440</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    }

    /**
     * Indicates whether inliers must be computed and kept.
     *
     * @return true if inliers must be computed and kept, false if inliers
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepInliersEnabled() {
        return mComputeAndKeepInliers;
    }

    /**
     * Specifies whether inliers must be computed and kept.
     *
     * @param computeAndKeepInliers true if inliers must be computed and kept,
     *                              false if inliers only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepInliersEnabled(boolean computeAndKeepInliers)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mComputeAndKeepInliers = computeAndKeepInliers;
    }

    /**
     * Indicates whether residuals must be computed and kept.
     *
     * @return true if residuals must be computed and kept, false if residuals
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepResidualsEnabled() {
        return mComputeAndKeepResiduals;
    }

    /**
     * Specifies whether residuals must be computed and kept.
     *
     * @param computeAndKeepResiduals true if residuals must be computed and kept,
     *                                false if residuals only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepResidualsEnabled(boolean computeAndKeepResiduals)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mComputeAndKeepResiduals = computeAndKeepResiduals;
    }

    /**
     * Robustly estimates position, transmitted power and pathloss exponent for a
     * radio source.
     *
     * @throws LockedException if instance is busy during estimation.
     * @throws NotReadyException if estimator is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     * (i.e. numerical instability, no solution available, etc).
     */
    @Override
    public void estimate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator2D.html#L1066">1066</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator3D.html#L1066">1066</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator2D.html#L556">556</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator3D.html#L556">556</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator2D.html#L1071">1071</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator3D.html#L1070">1070</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>            Solution&lt;Point2D&gt; result = innerEstimator.estimate();
            mInliersData = innerEstimator.getInliersData();
            attemptRefine(result);

        } catch (com.irurueta.numerical.LockedException e) {
            throw new LockedException(e);
        } catch (com.irurueta.numerical.NotReadyException e) {
            throw new NotReadyException(e);
        } finally {
            mLocked = false;
        }
    }

    /**
     * Returns method being used for robust estimation.
     *
     * @return method being used for robust estimation.
     */
    @Override
    public RobustEstimatorMethod getMethod() {
        return RobustEstimatorMethod.PROSAC;
    }

    /**
     * Sets quality scores corresponding to each provided sample.
     * This method is used internally and does not check whether instance is
     * locked or not.
     *
     * @param qualityScores quality scores to be set.
     * @throws IllegalArgumentException if provided quality scores length
     * is smaller than required minimum.
     */
    private void internalSetQualityScores(double[] qualityScores) {
        if (qualityScores == null ||
                qualityScores.length &lt; getMinReadings()) {
            throw new IllegalArgumentException();
        }

        mQualityScores = qualityScores;
    }
}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/calibration/RobustKnownBiasAndFrameAccelerometerCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/RobustKnownBiasAndFrameAccelerometerCalibrator.html#L3920">3920</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/calibration/RobustKnownBiasAndFrameAccelerometerCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/RobustKnownBiasAndFrameAccelerometerCalibrator.html#L4276">4276</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>            final double biasX, final double biasY, final double biasZ,
            final RobustEstimatorMethod method) {
        switch (method) {
            case RANSAC:
                return new RANSACRobustKnownBiasAndFrameAccelerometerCalibrator(
                        measurements, biasX, biasY, biasZ);
            case LMedS:
                return new LMedSRobustKnownBiasAndFrameAccelerometerCalibrator(
                        measurements, biasX, biasY, biasZ);
            case MSAC:
                return new MSACRobustKnownBiasAndFrameAccelerometerCalibrator(
                        measurements, biasX, biasY, biasZ);
            case PROSAC:
                return new PROSACRobustKnownBiasAndFrameAccelerometerCalibrator(
                        qualityScores, measurements, biasX, biasY, biasZ);
            case PROMedS:
            default:
                return new PROMedSRobustKnownBiasAndFrameAccelerometerCalibrator(
                        qualityScores, measurements, biasX, biasY, biasZ);
        }
    }

    /**
     * Creates a robust accelerometer calibrator.
     *
     * @param qualityScores quality scores corresponding to each provided
     *                      measurement. The larger the score value the better
     *                      the quality of the sample.
     * @param measurements  list of body kinematics measurements with standard
     *                      deviations taken at different frames (positions, orientations
     *                      and velocities).
     * @param biasX         known x coordinate of accelerometer bias expressed in meters per
     *                      squared second (m/s^2).
     * @param biasY         known y coordinate of accelerometer bias expressed in meters per
     *                      squared second (m/s^2).
     * @param biasZ         known z coordinate of accelerometer bias expressed in meters per
     *                      squared second (m/s^2).
     * @param listener      listener to handle events raised by this calibrator.
     * @param method        robust estimator method.
     * @return a robust accelerometer calibrator.
     * @throws IllegalArgumentException if provided quality scores length
     *                                  is smaller than 4 samples.
     */
    public static RobustKnownBiasAndFrameAccelerometerCalibrator create(
            final double[] qualityScores,
            final List&lt;StandardDeviationFrameBodyKinematics&gt; measurements,
            final double biasX, final double biasY, final double biasZ,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/lateration/PROMedSRobustLateration2DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/PROMedSRobustLateration2DSolver.html#L574">574</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/lateration/PROMedSRobustLateration3DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/PROMedSRobustLateration3DSolver.html#L574">574</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>            Point2D result = innerEstimator.estimate();
            mInliersData = innerEstimator.getInliersData();
            return attemptRefine(result);
        } catch (com.irurueta.numerical.LockedException e) {
            throw new LockedException(e);
        } catch (com.irurueta.numerical.NotReadyException e) {
            throw new NotReadyException(e);
        } finally {
            mLocked = false;
        }
    }

    /**
     * Returns method being used for robust estimation.
     * @return method being used for robust estimation.
     */
    @Override
    public RobustEstimatorMethod getMethod() {
        return RobustEstimatorMethod.PROMedS;
    }

    /**
     * Sets quality scores corresponding to each provided sample.
     * This method is used internally and does not check whether instance is
     * locked or not.
     * @param qualityScores quality scores to be set.
     * @throws IllegalArgumentException if provided quality scores length
     * is smaller than 3 samples.
     */
    private void internalSetQualityScores(double[] qualityScores) {
        if (qualityScores == null ||
                qualityScores.length &lt; getMinRequiredPositionsAndDistances()) {
            throw new IllegalArgumentException();
        }

        mQualityScores = qualityScores;
    }
}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/lateration/PROSACRobustLateration2DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/PROSACRobustLateration2DSolver.html#L450">450</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/lateration/RANSACRobustLateration2DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/RANSACRobustLateration2DSolver.html#L223">223</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    }

    /**
     * Indicates whether inliers must be computed and kept.
     * @return true if inliers must be computed and kept, false if inliers
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepInliersEnabled() {
        return mComputeAndKeepInliers;
    }

    /**
     * Specifies whether inliers must be computed and kept.
     * @param computeAndKeepInliers true if inliers must be computed and kept,
     *                              false if inliers only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepInliersEnabled(boolean computeAndKeepInliers)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mComputeAndKeepInliers = computeAndKeepInliers;
    }

    /**
     * Indicates whether residuals must be computed and kept.
     * @return true if residuals must be computed and kept, false if residuals
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepResiduals() {
        return mComputeAndKeepResiduals;
    }

    /**
     * Specifies whether residuals must be computed and kept.
     * @param computeAndKeepResiduals true if residuals must be computed and kept,
     *                                false if residuals only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepResidualsEnabled(boolean computeAndKeepResiduals)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mComputeAndKeepResiduals = computeAndKeepResiduals;
    }

    /**
     * Solves the lateration problem.
     * @return estimated position.
     * @throws LockedException if instance is busy solving the lateration problem.
     * @throws NotReadyException is solver is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     * (i.e. numerical instability, no solution available, etc).
     */
    @Override
    public Point2D solve() throws LockedException, NotReadyException,
            RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/lateration/PROSACRobustLateration2DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/PROSACRobustLateration2DSolver.html#L594">594</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/lateration/PROSACRobustLateration3DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/PROSACRobustLateration3DSolver.html#L594">594</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>            Point2D result = innerEstimator.estimate();
            mInliersData = innerEstimator.getInliersData();
            return attemptRefine(result);
        } catch (com.irurueta.numerical.LockedException e) {
            throw new LockedException(e);
        } catch (com.irurueta.numerical.NotReadyException e) {
            throw new NotReadyException(e);
        } finally {
            mLocked = false;
        }
    }

    /**
     * Returns method being used for robust estimation.
     * @return method being used for robust estimation.
     */
    @Override
    public RobustEstimatorMethod getMethod() {
        return RobustEstimatorMethod.PROSAC;
    }

    /**
     * Sets quality scores corresponding to each provided sample.
     * This method is used internally and does not check whether instance is
     * locked or not.
     * @param qualityScores quality scores to be set.
     * @throws IllegalArgumentException if provided quality scores length
     * is smaller than 3 samples.
     */
    private void internalSetQualityScores(double[] qualityScores) {
        if (qualityScores == null ||
                qualityScores.length &lt; getMinRequiredPositionsAndDistances()) {
            throw new IllegalArgumentException();
        }

        mQualityScores = qualityScores;
    }
}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/lateration/PROSACRobustLateration3DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/PROSACRobustLateration3DSolver.html#L450">450</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/lateration/RANSACRobustLateration3DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/RANSACRobustLateration3DSolver.html#L223">223</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    }

    /**
     * Indicates whether inliers must be computed and kept.
     * @return true if inliers must be computed and kept, false if inliers
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepInliersEnabled() {
        return mComputeAndKeepInliers;
    }

    /**
     * Specifies whether inliers must be computed and kept.
     * @param computeAndKeepInliers true if inliers must be computed and kept,
     *                              false if inliers only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepInliersEnabled(boolean computeAndKeepInliers)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mComputeAndKeepInliers = computeAndKeepInliers;
    }

    /**
     * Indicates whether residuals must be computed and kept.
     * @return true if residuals must be computed and kept, false if residuals
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepResiduals() {
        return mComputeAndKeepResiduals;
    }

    /**
     * Specifies whether residuals must be computed and kept.
     * @param computeAndKeepResiduals true if residuals must be computed and kept,
     *                                false if residuals only need to be computed but not kept.
     * @throws LockedException if this solver is locked.
     */
    public void setComputeAndKeepResidualsEnabled(boolean computeAndKeepResiduals)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        mComputeAndKeepResiduals = computeAndKeepResiduals;
    }

    /**
     * Solves the lateration problem.
     * @return estimated position.
     * @throws LockedException if instance is busy solving the lateration problem.
     * @throws NotReadyException is solver is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     * (i.e. numerical instability, no solution available, etc).
     */
    @Override
    public Point3D solve() throws LockedException, NotReadyException,
            RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/geodesic/PolygonArea.java</td>
<td><a href="./xref/com/irurueta/navigation/geodesic/PolygonArea.html#L273">273</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/geodesic/PolygonArea.java</td>
<td><a href="./xref/com/irurueta/navigation/geodesic/PolygonArea.html#L339">339</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>        if ((crossings &amp; 1) != 0) {
            tempsum += (tempsum &lt; 0 ? 1 : -1) * mArea0 / 2;
        }

        //area is with the clockwise sense. If !reverse convert to counter-clockwise convention
        if (!reverse) {
            tempsum *= -1;
        }

        //if sign put area in (-area0/2, area0/2], else put area in [0, area0)
        if (sign) {
            if (tempsum &gt; mArea0/2) {
                tempsum -= mArea0;
            } else if (tempsum &lt;= -mArea0/2) {
                tempsum += mArea0;
            }
        } else {
            if (tempsum &gt;= mArea0) {
                tempsum -= mArea0;
            } else if (tempsum &lt; 0) {
                tempsum += mArea0;
            }
        }
        return new PolygonResult(num, perimeter, 0 + tempsum);
    }

    /**
     * Return the results assuming a tentative final test point is added via an azimuth and distance;
     * however, the data for the test point is not saved.
     * This lets you report a running result for the perimeter and area as the user moves the mouse
     * cursor. Ordinary floating point arithmetic is used to accumulate the data for the test point;
     * thus the area and perimeter returned are less accurate than if addPoint and compute are used.
     * @param azi azimuth at current point (degrees).
     * @param s distance from current point to final test point (meters).
     * @param reverse if true then clockwise (instead of counter-clockwise) traversal counts as a
     *                positive area.
     * @param sign if true then return a signed result for the area if the polygon is traversed in
     *             the &quot;wrong&quot; direction instead of returning the area for the rest of the earth.
     * @return PolygonResult(&lt;i&gt;num&lt;/i&gt;, &lt;i&gt;perimeter&lt;/i&gt;, &lt;i&gt;area&lt;/i&gt;) where &lt;i&gt;num&lt;/i&gt; is the
     * number of vertices, &lt;i&gt;perimeter&lt;/i&gt; is the perimeter of the polygon or the length of the
     * polyline (meters), and &lt;i&gt;area&lt;/i&gt; is the area of the polygon (meters&lt;sup&gt;2&lt;/sup&gt;) or
     * Double.NaN of &lt;i&gt;polyline&lt;/i&gt; is true in the constructor.
     */
    public PolygonResult testEdge(double azi, double s, boolean reverse, boolean sign) {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/LMedSRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/LMedSRobustRangingAndRssiRadioSourceEstimator2D.html#L396">396</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/LMedSRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/LMedSRobustRssiRadioSourceEstimator2D.html#L407">407</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>            RobustRangingAndRssiRadioSourceEstimatorListener&lt;S, Point2D&gt; listener) {
        super(readings, initialPosition, initialTransmittedPowerdBm,
                initialPathLossExponent, listener);
    }

    /**
     * Returns threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value, the
     * algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algrithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @return stop threshold to stop the algorithm prematurely when a certain
     * accuracy has been reached.
     */
    public double getStopThreshold() {
        return mStopThreshold;
    }

    /**
     * Sets threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value,
     * the algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algorithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @param stopThreshold stop threshold to stop the algorithm prematurely
     *                      when a certain accuracy has been reached.
     * @throws IllegalArgumentException if provided value is zero or negative.
     * @throws LockedException if this solver is locked.
     */
    public void setStopThreshold(double stopThreshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (stopThreshold &lt;= MIN_STOP_THRESHOLD) {
            throw new IllegalArgumentException();
        }

        mStopThreshold = stopThreshold;
    }

    /**
     * Robustly estimates position, transmitted power and pathloss exponent for a
     * radio source.
     *
     * @throws LockedException if instance is busy during estimation.
     * @throws NotReadyException if estimator is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     * (i.e. numerical instability, no solution available, etc).
     */
    @Override
    public void estimate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        LMedSRobustEstimator&lt;RobustRangingAndRssiRadioSourceEstimator.Solution&lt;Point2D&gt;&gt; innerEstimator =</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/LMedSRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/LMedSRobustRangingAndRssiRadioSourceEstimator2D.html#L396">396</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/LMedSRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/LMedSRobustRangingAndRssiRadioSourceEstimator3D.html#L396">396</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>            RobustRangingAndRssiRadioSourceEstimatorListener&lt;S, Point2D&gt; listener) {
        super(readings, initialPosition, initialTransmittedPowerdBm,
                initialPathLossExponent, listener);
    }

    /**
     * Returns threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value, the
     * algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algrithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @return stop threshold to stop the algorithm prematurely when a certain
     * accuracy has been reached.
     */
    public double getStopThreshold() {
        return mStopThreshold;
    }

    /**
     * Sets threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value,
     * the algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algorithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @param stopThreshold stop threshold to stop the algorithm prematurely
     *                      when a certain accuracy has been reached.
     * @throws IllegalArgumentException if provided value is zero or negative.
     * @throws LockedException if this solver is locked.
     */
    public void setStopThreshold(double stopThreshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (stopThreshold &lt;= MIN_STOP_THRESHOLD) {
            throw new IllegalArgumentException();
        }

        mStopThreshold = stopThreshold;
    }

    /**
     * Robustly estimates position, transmitted power and pathloss exponent for a
     * radio source.
     *
     * @throws LockedException if instance is busy during estimation.
     * @throws NotReadyException if estimator is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     * (i.e. numerical instability, no solution available, etc).
     */
    @Override
    public void estimate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        LMedSRobustEstimator&lt;RobustRangingAndRssiRadioSourceEstimator.Solution&lt;Point2D&gt;&gt; innerEstimator =</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/LMedSRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/LMedSRobustRangingAndRssiRadioSourceEstimator3D.html#L396">396</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/LMedSRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/LMedSRobustRssiRadioSourceEstimator3D.html#L407">407</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>            RobustRangingAndRssiRadioSourceEstimatorListener&lt;S, Point3D&gt; listener) {
        super(readings, initialPosition, initialTransmittedPowerdBm,
                initialPathLossExponent, listener);
    }

    /**
     * Returns threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value, the
     * algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algrithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @return stop threshold to stop the algorithm prematurely when a certain
     * accuracy has been reached.
     */
    public double getStopThreshold() {
        return mStopThreshold;
    }

    /**
     * Sets threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value,
     * the algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algorithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @param stopThreshold stop threshold to stop the algorithm prematurely
     *                      when a certain accuracy has been reached.
     * @throws IllegalArgumentException if provided value is zero or negative.
     * @throws LockedException if this solver is locked.
     */
    public void setStopThreshold(double stopThreshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (stopThreshold &lt;= MIN_STOP_THRESHOLD) {
            throw new IllegalArgumentException();
        }

        mStopThreshold = stopThreshold;
    }

    /**
     * Robustly estimates position, transmitted power and pathloss exponent for a
     * radio source.
     *
     * @throws LockedException if instance is busy during estimation.
     * @throws NotReadyException if estimator is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     * (i.e. numerical instability, no solution available, etc).
     */
    @Override
    public void estimate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        LMedSRobustEstimator&lt;RobustRangingAndRssiRadioSourceEstimator.Solution&lt;Point3D&gt;&gt; innerEstimator =</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/estimators/ECEFKinematicsEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/estimators/ECEFKinematicsEstimator.html#L2050">2050</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/estimators/ECIKinematicsEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/estimators/ECIKinematicsEstimator.html#L1118">1118</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                                          final ECEFFrame frame,
                                          final CoordinateTransformation oldC,
                                          final double oldVx, final double oldVy, final double oldVz,
                                          final BodyKinematics result) {
        estimateKinematics(TimeConverter.convert(timeInterval.getValue().doubleValue(),
                timeInterval.getUnit(), TimeUnit.SECOND),
                frame.getCoordinateTransformation(),
                oldC, frame.getVx(), frame.getVy(), frame.getVz(),
                oldVx, oldVy, oldVz, frame.getX(), frame.getY(), frame.getZ(), result);
    }

    /**
     * Estimates body kinematics (specific force applied to a body and its angular rates).
     *
     * @param timeInterval time interval between epochs expressed in seconds (s).
     * @param frame        body ECEF frame containing current position, velocity and
     *                     body-to-ECEF frame coordinate transformation.
     * @param oldC         previous body-to-ECEF-frame coordinate transformation matrix.
     * @param oldVelocity  previous velocity of body frame with respect ECEF frame.
     * @param result       instance where body kinematics estimation will be stored.
     * @throws IllegalArgumentException if provided time interval is negative or coordinated transformation matrices
     *                                  are not ECEF frame valid.
     */
    public static void estimateKinematics(final double timeInterval,
                                          final ECEFFrame frame,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/PROMedSRobustMixedPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROMedSRobustMixedPositionEstimator2D.html#L358">358</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/PROMedSRobustMixedPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROMedSRobustMixedPositionEstimator3D.html#L358">358</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/PROMedSRobustRangingAndRssiPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROMedSRobustRangingAndRssiPositionEstimator2D.html#L358">358</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/PROMedSRobustRangingAndRssiPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROMedSRobustRangingAndRssiPositionEstimator3D.html#L358">358</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/PROMedSRobustRangingPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROMedSRobustRangingPositionEstimator2D.html#L357">357</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/PROMedSRobustRangingPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROMedSRobustRangingPositionEstimator3D.html#L357">357</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/PROMedSRobustRssiPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROMedSRobustRssiPositionEstimator2D.html#L356">356</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>            RobustMixedPositionEstimatorListener&lt;Point2D&gt; listener) {
        this(sources, fingerprint, listener);
        internalSetSourceQualityScores(sourceQualityScores);
        internalSetFingerprintReadingsQualityScores(fingerprintReadingsQualityScores);
    }

    /**
     * Returns quality scores corresponding to each radio source.
     * The larger the score value the better the quality of the sample.
     *
     * @return quality scores corresponding to each radio source.
     */
    public double[] getSourceQualityScores() {
        return mSourceQualityScores;
    }

    /**
     * Sets quality scores corresponding to each radio source.
     * The larger the score value the better the quality of the radio source.
     *
     * @param sourceQualityScores quality scores corresponding to each radio source.
     * @throws LockedException          if this instance is locked.
     * @throws IllegalArgumentException if provided quality scores length is smaller
     *                                  than minimum required samples.
     */
    public void setSourceQualityScores(double[] sourceQualityScores)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetSourceQualityScores(sourceQualityScores);
    }

    /**
     * Gets quality scores corresponding to each reading within provided fingerprint.
     * The larger the score value the better the quality of the reading.
     * This implementation always returns null.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @return quality scores corresponding to each reading within provided
     * fingerprint.
     */
    public double[] getFingerprintReadingsQualityScores() {
        return mFingerprintReadingsQualityScores;
    }

    /**
     * Sets quality scores corresponding to each reading within provided fingerprint.
     * The larger the score value the better the quality of the reading.
     * This implementation makes no action.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @param fingerprintReadingsQualityScores quality scores corresponding to each
     *                                         reading within provided fingerprint.
     * @throws LockedException          if this instance is locked.
     * @throws IllegalArgumentException if provided quality scores length is smaller
     *                                  than minimum required samples.
     */
    public void setFingerprintReadingsQualityScores(
            double[] fingerprintReadingsQualityScores) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetFingerprintReadingsQualityScores(fingerprintReadingsQualityScores);
    }

    /**
     * Returns threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value, the
     * algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algrithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @return stop threshold to stop the algorithm prematurely when a certain
     * accuracy has been reached.
     */
    public double getStopThreshold() {
        return ((PROMedSRobustLateration2DSolver) mLaterationSolver).</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/PROSACRobustMixedPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROSACRobustMixedPositionEstimator2D.html#L357">357</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/PROSACRobustMixedPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROSACRobustMixedPositionEstimator3D.html#L357">357</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/PROSACRobustRangingAndRssiPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROSACRobustRangingAndRssiPositionEstimator2D.html#L361">361</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/PROSACRobustRangingAndRssiPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROSACRobustRangingAndRssiPositionEstimator3D.html#L361">361</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/PROSACRobustRangingPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROSACRobustRangingPositionEstimator2D.html#L357">357</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/PROSACRobustRangingPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROSACRobustRangingPositionEstimator3D.html#L357">357</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/PROSACRobustRssiPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROSACRobustRssiPositionEstimator2D.html#L359">359</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/PROSACRobustRssiPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROSACRobustRssiPositionEstimator3D.html#L359">359</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>            RobustMixedPositionEstimatorListener&lt;Point2D&gt; listener) {
        this(sources, fingerprint, listener);
        internalSetSourceQualityScores(sourceQualityScores);
        internalSetFingerprintReadingsQualityScores(fingerprintReadingQualityScores);
    }

    /**
     * Returns quality scores corresponding to each radio source.
     * The larger the score value the better the quality of the sample.
     *
     * @return quality scores corresponding to each radio source.
     */
    public double[] getSourceQualityScores() {
        return mSourceQualityScores;
    }

    /**
     * Sets quality scores corresponding to each radio source.
     * The larger the score value the better the quality of the radio source.
     *
     * @param sourceQualityScores quality scores corresponding to each radio source.
     * @throws LockedException          if this instance is locked.
     * @throws IllegalArgumentException if provided quality scores length is smaller
     *                                  than minimum required samples.
     */
    public void setSourceQualityScores(double[] sourceQualityScores)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetSourceQualityScores(sourceQualityScores);
    }

    /**
     * Gets quality scores corresponding to each reading within provided fingerprint.
     * The larger the score value the better the quality of the reading.
     * This implementation always returns null.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @return quality scores corresponding to each reading within provided
     * fingerprint.
     */
    public double[] getFingerprintReadingsQualityScores() {
        return mFingerprintReadingsQualityScores;
    }

    /**
     * Sets quality scores corresponding to each reading within provided fingerprint.
     * The larger the score value the better the quality of the reading.
     * This implementation makes no action.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @param fingerprintReadingsQualityScores quality scores corresponding to each
     *                                         reading within provided fingerprint.
     * @throws LockedException          if this instance is locked.
     * @throws IllegalArgumentException if provided quality scores length is smaller
     *                                  than minimum required samples.
     */
    public void setFingerprintReadingsQualityScores(
            double[] fingerprintReadingsQualityScores) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetFingerprintReadingsQualityScores(fingerprintReadingsQualityScores);
    }

    /**
     * Gets threshold to determine whether samples are inliers or not when testing possible solutions.
     * The threshold refers to the amount of error on distance between estimated position and distances
     * provided for each sample.
     * @return threshold to determine whether samples are inliers or not.
     */
    public double getThreshold() {
        return ((PROSACRobustLateration2DSolver) mLaterationSolver).</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/SequentialRobustMixedPositionEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/SequentialRobustMixedPositionEstimator.html#L1499">1499</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/SequentialRobustRangingAndRssiPositionEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/SequentialRobustRangingAndRssiPositionEstimator.html#L1473">1473</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>            Fingerprint&lt;? extends RadioSource, ? extends Reading&lt;? extends RadioSource&gt;&gt; fingerprint)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }

        internalSetFingerprint(fingerprint);
    }

    /**
     * Returns quality scores corresponding to each radio source.
     * The larger the score value the better the quality of the radio source.
     *
     * @return quality scores corresponding to each radio source.
     */
    public double[] getSourceQualityScores() {
        return mSourceQualityScores;
    }

    /**
     * Sets quality scores corresponding to each radio source.
     * The larger the score value the better the quality of the radio source.
     *
     * @param sourceQualityScores quality scores corresponding to each radio source.
     * @throws LockedException          if this instance is locked.
     * @throws IllegalArgumentException if provided quality scores length is smaller
     *                                  than minimum required samples.
     */
    public void setSourceQualityScores(double[] sourceQualityScores)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetSourceQualityScores(sourceQualityScores);
    }

    /**
     * Gets quality scores corresponding to each reading within provided fingerprint.
     * The larger the score value the better the quality of the reading.
     *
     * @return quality scores corresponding to each reading within provided fingerprint.
     */
    public double[] getFingerprintReadingsQualityScores() {
        return mFingerprintReadingsQualityScores;
    }

    /**
     * Sets quality scores corresponding to each reading within provided fingerprint.
     * The larger the score value the better the quality of the reading.
     *
     * @param fingerprintReadingsQualityScores  quality scores corresponding to each
     *                                          reading within provided fingerprint.
     * @throws LockedException          if this instance is locked.
     * @throws IllegalArgumentException if provided quality scores length is smaller
     *                                  than minimum required samples.
     */
    public void setFingerprintReadingsQualityScores(
            double[] fingerprintReadingsQualityScores) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetFingerprintReadingsQualityScores(fingerprintReadingsQualityScores);
    }

    /**
     * Gets listener to be notified of events raised by this instance.
     *
     * @return listener to be notified of events raised by this instance.
     */
    public SequentialRobustMixedPositionEstimatorListener&lt;P&gt; getListener() {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator3D.html#L2835">2835</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator3D.html#L2812">2812</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RssiRadioSourceEstimator3D.html#L434">434</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator3D.html#L875">875</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>                    source.getFrequency(), accessPoint.getSsid(),
                    getEstimatedTransmittedPowerdBm(),
                    transmittedPowerStandardDeviation,
                    getEstimatedPathLossExponent(),
                    pathlossExponentStandardDeviation,
                    estimatedPosition,
                    estimatedPositionCovariance);
        } else if(source instanceof Beacon) {
            Beacon beacon = (Beacon) source;
            return new BeaconWithPowerAndLocated3D(beacon.getIdentifiers(),
                    getEstimatedTransmittedPowerdBm(), beacon.getFrequency(),
                    beacon.getBluetoothAddress(), beacon.getBeaconTypeCode(),
                    beacon.getManufacturer(), beacon.getServiceUuid(),
                    beacon.getBluetoothName(),
                    getEstimatedPathLossExponent(),
                    transmittedPowerStandardDeviation,
                    pathlossExponentStandardDeviation,
                    estimatedPosition, estimatedPositionCovariance);
        }else {
            return null;
        }
    }</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/calibration/RobustKnownBiasAndFrameAccelerometerCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/RobustKnownBiasAndFrameAccelerometerCalibrator.html#L4728">4728</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/calibration/RobustKnownBiasAndFrameAccelerometerCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/RobustKnownBiasAndFrameAccelerometerCalibrator.html#L5052">5052</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>            final double[] qualityScores, final double[] bias,
            final boolean commonAxisUsed,
            final RobustKnownBiasAndFrameAccelerometerCalibratorListener listener,
            final RobustEstimatorMethod method) {
        switch (method) {
            case RANSAC:
                return new RANSACRobustKnownBiasAndFrameAccelerometerCalibrator(
                        bias, commonAxisUsed, listener);
            case LMedS:
                return new LMedSRobustKnownBiasAndFrameAccelerometerCalibrator(
                        bias, commonAxisUsed, listener);
            case MSAC:
                return new MSACRobustKnownBiasAndFrameAccelerometerCalibrator(
                        bias, commonAxisUsed, listener);
            case PROSAC:
                return new PROSACRobustKnownBiasAndFrameAccelerometerCalibrator(
                        qualityScores, bias, commonAxisUsed, listener);
            case PROMedS:
            default:
                return new PROMedSRobustKnownBiasAndFrameAccelerometerCalibrator(
                        qualityScores, bias, commonAxisUsed, listener);
        }
    }

    /**
     * Creates a robust accelerometer calibrator.
     *
     * @param qualityScores  quality scores corresponding to each provided
     *                       measurement. The larger the score value the better
     *                       the quality of the sample.
     * @param measurements   list of body kinematics measurements with standard
     *                       deviations taken at different frames (positions, orientations
     *                       and velocities).
     * @param bias           known accelerometer bias.
     * @param commonAxisUsed indicates whether z-axis is assumed to be common for
     *                       accelerometer and gyroscope.
     * @param method         robust estimator method.
     * @return a robust accelerometer calibrator.
     * @throws IllegalArgumentException if provided bias array does not have length 3 or
     *                                  if provided quality scores length is smaller than
     *                                  4 samples.
     */
    public static RobustKnownBiasAndFrameAccelerometerCalibrator create(
            final double[] qualityScores,
            final List&lt;StandardDeviationFrameBodyKinematics&gt; measurements,
            final double[] bias, final boolean commonAxisUsed,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L10921">10921</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L10968">10968</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    public static void navigateECEF(final double timeInterval,
                                    final ECEFPosition oldPosition,
                                    final CoordinateTransformation oldC,
                                    final ECEFVelocity oldVelocity,
                                    final Acceleration fx,
                                    final Acceleration fy,
                                    final Acceleration fz,
                                    final AngularSpeed angularRateX,
                                    final AngularSpeed angularRateY,
                                    final AngularSpeed angularRateZ,
                                    final ECEFFrame result)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        navigateECEF(timeInterval, oldPosition, oldC,
                oldVelocity.getVx(), oldVelocity.getVy(), oldVelocity.getVz(),
                convertAccelerationToDouble(fx),
                convertAccelerationToDouble(fy), convertAccelerationToDouble(fz),
                convertAngularSpeedToDouble(angularRateX),
                convertAngularSpeedToDouble(angularRateY),
                convertAngularSpeedToDouble(angularRateZ),
                result);
    }

    /**
     * Runs precision ECEF-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldPosition  previous cartesian position resolved along ECEF-frame axes.
     * @param oldC         previous body-to-ECEF-frame coordinate transformation.
     * @param oldVelocity  previous body velocity resolved along ECEF-frame axes.
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param result       instance where new estimated ECEF frame containing new body
     *                     position, velocity and coordinate transformation matrix will be stored.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-ECEF-frame coordinate transformation matrix are invalid.
     */
    public static void navigateECEF(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/lateration/LMedSRobustLateration2DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/LMedSRobustLateration2DSolver.html#L320">320</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/lateration/MSACRobustLateration2DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/MSACRobustLateration2DSolver.html#L276">276</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>                            mListener.onSolveProgressChange(LMedSRobustLateration2DSolver.this,
                                    progress);
                        }
                    }
                });

        try {
            mLocked = true;
            mInliersData = null;
            innerEstimator.setConfidence(mConfidence);
            innerEstimator.setMaxIterations(mMaxIterations);
            innerEstimator.setProgressDelta(mProgressDelta);
            Point2D result = innerEstimator.estimate();
            mInliersData = innerEstimator.getInliersData();
            return attemptRefine(result);
        } catch (com.irurueta.numerical.LockedException e) {
            throw new LockedException(e);
        } catch (com.irurueta.numerical.NotReadyException e) {
            throw new NotReadyException(e);
        } finally {
            mLocked = false;
        }
    }

    /**
     * Returns method being used for robust estimation.
     * @return method being used for robust estimation.
     */
    @Override
    public RobustEstimatorMethod getMethod() {
        return RobustEstimatorMethod.LMedS;</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/lateration/LMedSRobustLateration3DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/LMedSRobustLateration3DSolver.html#L320">320</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/lateration/MSACRobustLateration3DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/MSACRobustLateration3DSolver.html#L276">276</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>                            mListener.onSolveProgressChange(LMedSRobustLateration3DSolver.this, progress);
                        }
                    }
                });

        try {
            mLocked = true;
            mInliersData = null;
            innerEstimator.setConfidence(mConfidence);
            innerEstimator.setMaxIterations(mMaxIterations);
            innerEstimator.setProgressDelta(mProgressDelta);
            Point3D result = innerEstimator.estimate();
            mInliersData = innerEstimator.getInliersData();
            return attemptRefine(result);
        } catch (com.irurueta.numerical.LockedException e) {
            throw new LockedException(e);
        } catch (com.irurueta.numerical.NotReadyException e) {
            throw new NotReadyException(e);
        } finally {
            mLocked = false;
        }
    }

    /**
     * Returns method being used for robust estimation.
     * @return method being used for robust estimation.
     */
    @Override
    public RobustEstimatorMethod getMethod() {
        return RobustEstimatorMethod.LMedS;</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/LMedSRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/LMedSRobustRssiRadioSourceEstimator2D.html#L407">407</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/LMedSRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/LMedSRobustRssiRadioSourceEstimator3D.html#L407">407</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>            RobustRssiRadioSourceEstimatorListener&lt;S, Point2D&gt; listener) {
        super(readings, initialPosition, initialTransmittedPowerdBm,
                initialPathLossExponent, listener);
    }

    /**
     * Returns threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value, the
     * algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algorithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @return stop threshold to stop the algorithm prematurely when a certain
     * accuracy has been reached.
     */
    public double getStopThreshold() {
        return mStopThreshold;
    }

    /**
     * Sets threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value,
     * the algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algorithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @param stopThreshold stop threshold to stop the algorithm prematurely
     *                      when a certain accuracy has been reached.
     * @throws IllegalArgumentException if provided value is zero or negative.
     * @throws LockedException if this solver is locked.
     */
    public void setStopThreshold(double stopThreshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (stopThreshold &lt;= MIN_STOP_THRESHOLD) {
            throw new IllegalArgumentException();
        }

        mStopThreshold = stopThreshold;
    }

    /**
     * Robustly estimates position, transmitted power and pathloss exponent for a
     * radio source.
     *
     * @throws LockedException if instance is busy during estimation.
     * @throws NotReadyException if estimator is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     * (i.e. numerical instability, no solution available, etc).
     */
    @Override
    public void estimate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        LMedSRobustEstimator&lt;Solution&lt;Point2D&gt;&gt; innerEstimator =</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRangingAndRssiRadioSourceEstimator2D.html#L372">372</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRangingAndRssiRadioSourceEstimator3D.html#L372">372</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRssiRadioSourceEstimator2D.html#L383">383</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRssiRadioSourceEstimator3D.html#L383">383</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>            RobustRangingAndRssiRadioSourceEstimatorListener&lt;S, Point2D&gt; listener) {
        super(readings, initialPosition, initialTransmittedPowerdBm,
                initialPathLossExponent, listener);
    }

    /**
     * Returns threshold to determine whether samples are inliers or not.
     *
     * @return threshold to determine whether samples are inliers or not.
     */
    public double getThreshold() {
        return mThreshold;
    }

    /**
     * Sets threshold to determine whether samples are inliers or not.
     *
     * @param threshold threshold to be set.
     * @throws IllegalArgumentException if provided value is equal or less than
     * zero.
     * @throws LockedException if robust estimator is locked because an
     * estimation is already in progress.
     */
    public void setThreshold(double threshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (threshold &lt;= MIN_THRESHOLD) {
            throw new IllegalArgumentException();
        }
        mThreshold = threshold;
    }

    /**
     * Robustly estimates position, transmitted power and pathloss exponent for a
     * radio source.
     *
     * @throws LockedException if instance is busy during estimation.
     * @throws NotReadyException if estimator is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     * (i.e. numerical instability, no solution available, etc).
     */
    @Override
    public void estimate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        MSACRobustEstimator&lt;Solution&lt;Point2D&gt;&gt; innerEstimator =</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RangingAndRssiRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RangingAndRssiRadioSourceEstimator.html#L1007">1007</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator.html#L2272">2272</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    private RangingReadingLocated&lt;S, P&gt; createRangingReading(RangingAndRssiReadingLocated&lt;S, P&gt; reading) {
        return new RangingReadingLocated&lt;&gt;(reading.getSource(),
                reading.getDistance(), reading.getPosition(),
                reading.getDistanceStandardDeviation(),
                reading.getPositionCovariance());
    }

    /**
     * Creates an RSSI reading from a ranging and RSSI reading.
     * @param reading input reading to convert from.
     * @return an RSSI reading containing only the RSSI data of input reading.
     */
    private RssiReadingLocated&lt;S, P&gt; createRssiReading(RangingAndRssiReadingLocated&lt;S, P&gt; reading) {
        return new RssiReadingLocated&lt;&gt;(reading.getSource(),
                reading.getRssi(), reading.getPosition(),
                reading.getRssiStandardDeviation(),
                reading.getPositionCovariance());
    }
}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/calibration/KnownBiasAndFrameAccelerometerNonLinearLeastSquaresCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/KnownBiasAndFrameAccelerometerNonLinearLeastSquaresCalibrator.html#L2511">2511</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/calibration/KnownFrameAccelerometerNonLinearLeastSquaresCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/KnownFrameAccelerometerNonLinearLeastSquaresCalibrator.html#L2776">2776</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/calibration/RobustKnownBiasAndFrameAccelerometerCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/RobustKnownBiasAndFrameAccelerometerCalibrator.html#L1642">1642</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/calibration/RobustKnownFrameAccelerometerCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/RobustKnownFrameAccelerometerCalibrator.html#L1121">1121</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    public void getInitialMa(final Matrix result) {
        if (result.getRows() != BodyKinematics.COMPONENTS ||
                result.getColumns() != BodyKinematics.COMPONENTS) {
            throw new IllegalArgumentException();
        }
        result.setElementAtIndex(0, mInitialSx);
        result.setElementAtIndex(1, mInitialMyx);
        result.setElementAtIndex(2, mInitialMzx);

        result.setElementAtIndex(3, mInitialMxy);
        result.setElementAtIndex(4, mInitialSy);
        result.setElementAtIndex(5, mInitialMzy);

        result.setElementAtIndex(6, mInitialMxz);
        result.setElementAtIndex(7, mInitialMyz);
        result.setElementAtIndex(8, mInitialSz);
    }</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/calibration/RobustKnownBiasAndFrameAccelerometerCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/RobustKnownBiasAndFrameAccelerometerCalibrator.html#L2627">2627</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/calibration/RobustKnownBiasAndFrameAccelerometerCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/RobustKnownBiasAndFrameAccelerometerCalibrator.html#L2930">2930</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>            final double biasX, final double biasY, final double biasZ,
            final RobustKnownBiasAndFrameAccelerometerCalibratorListener listener,
            final RobustEstimatorMethod method) {
        switch (method) {
            case RANSAC:
                return new RANSACRobustKnownBiasAndFrameAccelerometerCalibrator(
                        measurements, biasX, biasY, biasZ, listener);
            case LMedS:
                return new LMedSRobustKnownBiasAndFrameAccelerometerCalibrator(
                        measurements, biasX, biasY, biasZ, listener);
            case MSAC:
                return new MSACRobustKnownBiasAndFrameAccelerometerCalibrator(
                        measurements, biasX, biasY, biasZ, listener);
            case PROSAC:
                return new PROSACRobustKnownBiasAndFrameAccelerometerCalibrator(
                        measurements, biasX, biasY, biasZ, listener);
            case PROMedS:
            default:
                return new PROMedSRobustKnownBiasAndFrameAccelerometerCalibrator(
                        measurements, biasX, biasY, biasZ, listener);
        }
    }

    /**
     * Creates a robust accelerometer calibrator.
     *
     * @param biasX          known x coordinate of accelerometer bias expressed in meters per
     *                       squared second (m/s^2).
     * @param biasY          known y coordinate of accelerometer bias expressed in meters per
     *                       squared second (m/s^2).
     * @param biasZ          known z coordinate of accelerometer bias expressed in meters per
     *                       squared second (m/s^2).
     * @param commonAxisUsed indicates whether z-axis is assumed to be common for
     *                       accelerometer and gyroscope.
     * @param method         robust estimator method.
     * @return a robust accelerometer calibrator.
     */
    public static RobustKnownBiasAndFrameAccelerometerCalibrator create(
            final double biasX, final double biasY, final double biasZ,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/calibration/RobustKnownBiasAndFrameAccelerometerCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/RobustKnownBiasAndFrameAccelerometerCalibrator.html#L4010">4010</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/calibration/RobustKnownBiasAndFrameAccelerometerCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/RobustKnownBiasAndFrameAccelerometerCalibrator.html#L4360">4360</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>            final double biasX, final double biasY, final double biasZ,
            final boolean commonAxisUsed, final RobustEstimatorMethod method) {
        switch (method) {
            case RANSAC:
                return new RANSACRobustKnownBiasAndFrameAccelerometerCalibrator(
                        biasX, biasY, biasZ, commonAxisUsed);
            case LMedS:
                return new LMedSRobustKnownBiasAndFrameAccelerometerCalibrator(
                        biasX, biasY, biasZ, commonAxisUsed);
            case MSAC:
                return new MSACRobustKnownBiasAndFrameAccelerometerCalibrator(
                        biasX, biasY, biasZ, commonAxisUsed);
            case PROSAC:
                return new PROSACRobustKnownBiasAndFrameAccelerometerCalibrator(
                        qualityScores, biasX, biasY, biasZ, commonAxisUsed);
            case PROMedS:
            default:
                return new PROMedSRobustKnownBiasAndFrameAccelerometerCalibrator(
                        qualityScores, biasX, biasY, biasZ, commonAxisUsed);
        }
    }

    /**
     * Creates a robust accelerometer calibrator.
     *
     * @param qualityScores  quality scores corresponding to each provided
     *                       measurement. The larger the score value the better
     *                       the quality of the sample.
     * @param biasX          known x coordinate of accelerometer bias expressed in meters per
     *                       squared second (m/s^2).
     * @param biasY          known y coordinate of accelerometer bias expressed in meters per
     *                       squared second (m/s^2).
     * @param biasZ          known z coordinate of accelerometer bias expressed in meters per
     *                       squared second (m/s^2).
     * @param commonAxisUsed indicates whether z-axis is assumed to be common for
     *                       accelerometer and gyroscope.
     * @param listener       listener to handle events raised by this calibrator.
     * @param method         robust estimator method.
     * @return a robust accelerometer calibrator.
     * @throws IllegalArgumentException if provided quality scores length
     *                                  is smaller than 4 samples.
     */
    public static RobustKnownBiasAndFrameAccelerometerCalibrator create(
            final double[] qualityScores,
            final double biasX, final double biasY, final double biasZ,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L4599">4599</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L4659">4659</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    public static void navigateECI(final double timeInterval,
                                   final double oldX,
                                   final double oldY,
                                   final double oldZ,
                                   final CoordinateTransformation oldC,
                                   final double oldVx,
                                   final double oldVy,
                                   final double oldVz,
                                   final Acceleration fx,
                                   final Acceleration fy,
                                   final Acceleration fz,
                                   final double angularRateX,
                                   final double angularRateY,
                                   final double angularRateZ,
                                   final ECIFrame result)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        navigateECI(timeInterval, oldX, oldY, oldZ, oldC, oldVx, oldVy, oldVz,
                convertAccelerationToDouble(fx), convertAccelerationToDouble(fy),
                convertAccelerationToDouble(fz), angularRateX, angularRateY,
                angularRateZ, result);
    }

    /**
     * Runs precision ECI-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldX         previous cartesian x-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldY         previous cartesian y-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldZ         previous cartesian z-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldC         previous body-to-ECI-frame coordinate transformation.
     * @param oldVx        previous velocity x-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param oldVy        previous velocity y-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param oldVz        previous velocity z-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param fx           specific force x-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fy           specific force y-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fz           specific force z-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateX angular rate x-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param result       instance where new estimated ECI frame containing new body position,
     *                     velocity and coordinate transformation matrix will be stored.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-ECI-frame coordinate transformation matrix are invalid.
     */
    public static void navigateECI(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/frames/ECEFFrame.java</td>
<td><a href="./xref/com/irurueta/navigation/frames/ECEFFrame.html#L690">690</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/gnss/GNSSMeasurement.java</td>
<td><a href="./xref/com/irurueta/navigation/gnss/GNSSMeasurement.html#L733">733</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>        mVz = velocity.getVz();
    }

    /**
     * Gets cartesian position and velocity.
     *
     * @param result instance where cartesian position and velocity will be stored.
     */
    public void getPositionAndVelocity(final ECEFPositionAndVelocity result) {
        result.setPositionCoordinates(mX, mY, mZ);
        result.setVelocityCoordinates(mVx, mVy, mVz);
    }

    /**
     * Gets cartesian position and velocity.
     *
     * @return cartesian position and velocity.
     */
    public ECEFPositionAndVelocity getPositionAndVelocity() {
        return new ECEFPositionAndVelocity(mX, mY, mZ, mVx, mVy, mVz);
    }

    /**
     * Sets cartesian position and velocity.
     *
     * @param positionAndVelocity cartesian position and velocity.
     */
    public void setPositionAndVelocity(
            final ECEFPositionAndVelocity positionAndVelocity) {
        mX = positionAndVelocity.getX();
        mY = positionAndVelocity.getY();
        mZ = positionAndVelocity.getZ();

        mVx = positionAndVelocity.getVx();
        mVy = positionAndVelocity.getVy();
        mVz = positionAndVelocity.getVz();
    }</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/gnss/GNSSKalmanEpochEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/gnss/GNSSKalmanEpochEstimator.html#L305">305</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/INSTightlyCoupledKalmanEpochEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/INSTightlyCoupledKalmanEpochEstimator.html#L289">289</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>            final double approxRange = Math.sqrt(deltaX * deltaX + deltaY * deltaY + deltaZ * deltaZ);

            // Calculate frame rotation during signal transit time using (8.36)
            final double ceiValue = EARTH_ROTATION_RATE * approxRange / SPEED_OF_LIGHT;
            cei.setElementAt(0, 1, ceiValue);
            cei.setElementAt(1, 0, -ceiValue);

            // Predict pseudo-range using (9.165)
            satellitePosition.setElementAtIndex(0, measX);
            satellitePosition.setElementAtIndex(1, measY);
            satellitePosition.setElementAtIndex(2, measZ);

            cei.multiply(satellitePosition, deltaR);
            for (int i = 0; i &lt; CoordinateTransformation.ROWS; i++) {
                deltaR.setElementAtIndex(i, deltaR.getElementAtIndex(i)
                        - xEstPropagated.getElementAtIndex(i));</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/MixedRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MixedRadioSourceEstimator.html#L1088">1088</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator.html#L2272">2272</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    private RangingReadingLocated&lt;S, P&gt; createRangingReading(RangingAndRssiReadingLocated&lt;S, P&gt; reading) {
        return new RangingReadingLocated&lt;&gt;(reading.getSource(),
                reading.getDistance(), reading.getPosition(),
                reading.getDistanceStandardDeviation(),
                reading.getPositionCovariance());
    }

    /**
     * Creates an RSSI reading from a ranging and RSSI reading.
     * @param reading input reading to convert from.
     * @return an RSSI reading containing only the RSSI data of input reading.
     */
    private RssiReadingLocated&lt;S, P&gt; createRssiReading(RangingAndRssiReadingLocated&lt;S, P&gt; reading) {
        return new RssiReadingLocated&lt;&gt;(reading.getSource(),
                reading.getRssi(), reading.getPosition(),
                reading.getRssiStandardDeviation(),
                reading.getPositionCovariance());
    }</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RangingAndRssiRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RangingAndRssiRadioSourceEstimator.html#L1007">1007</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustMixedRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustMixedRadioSourceEstimator.html#L2400">2400</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    private RangingReadingLocated&lt;S, P&gt; createRangingReading(RangingAndRssiReadingLocated&lt;S, P&gt; reading) {
        return new RangingReadingLocated&lt;&gt;(reading.getSource(),
                reading.getDistance(), reading.getPosition(),
                reading.getDistanceStandardDeviation(),
                reading.getPositionCovariance());
    }

    /**
     * Creates an RSSI reading from a ranging and RSSI reading.
     * @param reading input reading to convert from.
     * @return an RSSI reading containing only the RSSI data of input reading.
     */
    private RssiReadingLocated&lt;S, P&gt; createRssiReading(RangingAndRssiReadingLocated&lt;S, P&gt; reading) {
        return new RssiReadingLocated&lt;&gt;(reading.getSource(),
                reading.getRssi(), reading.getPosition(),
                reading.getRssiStandardDeviation(),
                reading.getPositionCovariance());
    }</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/INSGNSSLooselyCoupledKalmanFilteredEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/INSGNSSLooselyCoupledKalmanFilteredEstimator.html#L1947">1947</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/INSGNSSTightlyCoupledKalmanFilteredEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/INSGNSSTightlyCoupledKalmanFilteredEstimator.html#L1932">1932</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/INSLooselyCoupledKalmanFilteredEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/INSLooselyCoupledKalmanFilteredEstimator.html#L1669">1669</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>            gyroBiasZ = getValueOrZero(mState.getGyroBiasZ());
        } else {
            accelBiasX = 0.0;
            accelBiasY = 0.0;
            accelBiasZ = 0.0;
            gyroBiasX = 0.0;
            gyroBiasY = 0.0;
            gyroBiasZ = 0.0;
        }

        final double fx = kinematics.getFx();
        final double fy = kinematics.getFy();
        final double fz = kinematics.getFz();
        final double angularRateX = kinematics.getAngularRateX();
        final double angularRateY = kinematics.getAngularRateY();
        final double angularRateZ = kinematics.getAngularRateZ();

        mCorrectedKinematics.setSpecificForceCoordinates(
                fx - accelBiasX, fy - accelBiasY, fz - accelBiasZ);
        mCorrectedKinematics.setAngularRateCoordinates(
                angularRateX - gyroBiasX,
                angularRateY - gyroBiasY,
                angularRateZ - gyroBiasZ);
    }</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L8383">8383</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L8419">8419</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public static void navigateECEF(final double timeInterval,
                                    final double oldX,
                                    final double oldY,
                                    final double oldZ,
                                    final CoordinateTransformation oldC,
                                    final ECEFVelocity oldVelocity,
                                    final BodyKinematics kinematics,
                                    final ECEFFrame result)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        navigateECEF(timeInterval, oldX, oldY, oldZ, oldC,
                oldVelocity.getVx(), oldVelocity.getVy(), oldVelocity.getVz(),
                kinematics.getFx(), kinematics.getFy(), kinematics.getFz(),
                kinematics.getAngularRateX(), kinematics.getAngularRateY(),
                kinematics.getAngularRateZ(), result);
    }

    /**
     * Runs precision ECEF-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldX         previous cartesian x-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldY         previous cartesian y-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldZ         previous cartesian z-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldC         previous body-to-ECEF-frame coordinate transformation.
     * @param oldVelocity  previous body velocity resolved along ECEF-frame axes.
     * @param kinematics   body kinematics containing specific forces and angular rates applied to
     *                     the body.
     * @param result       instance where new estimated ECEF frame containing new body
     *                     position, velocity and coordinate transformation matrix will be stored.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-ECEF-frame coordinate transformation matrix are invalid.
     */
    public static void navigateECEF(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/lateration/HomogeneousLinearLeastSquaresLaterationSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/HomogeneousLinearLeastSquaresLaterationSolver.html#L66">66</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/lateration/InhomogeneousLinearLeastSquaresLaterationSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/InhomogeneousLinearLeastSquaresLaterationSolver.html#L70">70</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public HomogeneousLinearLeastSquaresLaterationSolver(P[] positions, double[] distances,
                                                         LaterationSolverListener&lt;P&gt; listener) {
        super(positions, distances, listener);
    }

    /**
     * Solves the lateration problem.
     * @throws LaterationException if lateration fails.
     * @throws NotReadyException if solver is not ready.
     * @throws LockedException if instance is busy solving the lateration problem.
     */
    @Override
    @SuppressWarnings(&quot;Duplicates&quot;)
    public void solve() throws LaterationException, NotReadyException,
            LockedException {
        // The implementation on this method follows the algorithm  bellow.

        // Having 3 2D circles:
        // c1x, c1y, r1
        // c2x, c2y, r2
        // c3x, c3y, r3
        // where (c1x, c1y) are the coordinates of 1st circle center and r1 is its radius.
        // (c2x, c2y) are the coordinates of 2nd circle center and r2 is its radius.
        // (c3x, c3y) are the coordinates of 3rd circle center and r3 is its radius.

        // The equations of the circles are as follows:
        // (x - c1x)^2 + (y - c1y)^2 = r1^2
        // (x - c2x)^2 + (y - c2y)^2 = r2^2
        // (x - c3x)^2 + (y - c3y)^2 = r3^2

        // x^2 - 2*c1x*x + c1x^2 + y^2 - 2*c1y*y + c1y^2 = r1^2
        // x^2 - 2*c2x*x + c2x^2 + y^2 - 2*c2y*y + c2y^2 = r2^2
        // x^2 - 2*c3x*x + c3x^2 + y^2 - 2*c3y*y + c3y^2 = r3^2

        // remove 1st equation from others (we use 1st point as reference)

        // x^2 - 2*c2x*x + c2x^2 + y^2 - 2*c2y*y + c2y^2 - (x^2 - 2*c1x*x + c1x^2 + y^2 - 2*c1y*y + c1y^2) = r2^2 - r1^2
        // x^2 - 2*c3x*x + c3x^2 + y^2 - 2*c3y*y + c3y^2 - (x^2 - 2*c1x*x + c1x^2 + y^2 - 2*c1y*y + c1y^2) = r3^2 - r1^2

        // - 2*c2x*x + c2x^2 - 2*c2y*y + c2y^2 + 2*c1x*x - c1x^2 + 2*c1y*y - c1y^2 = r2^2 - r1^2
        // - 2*c3x*x + c3x^2 - 2*c3y*y + c3y^2 + 2*c1x*x - c1x^2 + 2*c1y*y - c1y^2 = r3^2 - r1^2

        // 2*(c1x - c2x)*x + c2x^2 + 2*(c1y - c2y)*y + c2y^2 - c1x^2 - c1y^2 = r2^2 - r1^2
        // 2*(c1x - c3x)*x + c3x^2 + 2*(c1y - c3y)*y + c3y^2 - c1x^2 - c1y^2 = r3^2 - r1^2

        // 2*(c1x - c2x)*x + 2*(c1y - c2y)*y = r2^2 - r1^2 + c1x^2 + c1y^2 - c2x^2 - c2y^2
        // 2*(c1x - c3x)*x + 2*(c1y - c3y)*y = r3^2 - r1^2 + c1x^2 + c1y^2 - c3x^2 - c3y^2

        // x and y are the inhomogeneous coordinates of the point (x,y) we want to find, we
        // substitute such point by the corresponding homogeneous coordinates (x,y) = (x'/w', y'/w')

        // Hence
        // 2*(c1x - c2x)*x'/w' + 2*(c1y - c2y)*y'/w' = r2^2 - r1^2 + c1x^2 + c1y^2 - c2x^2 - c2y^2
        // 2*(c1x - c3x)*x'/w' + 2*(c1y - c3y)*y'/w' = r3^2 - r1^2 + c1x^2 + c1y^2 - c3x^2 - c3y^2

        // Multiplitying by w' at both sides...
        // 2*(c1x - c2x)*x' + 2*(c1y - c2y)*y' = (r2^2 - r1^2 + c1x^2 + c1y^2 - c2x^2 - c2y^2)*w'
        // 2*(c1x - c3x)*x' + 2*(c1y - c3y)*y' = (r3^2 - r1^2 + c1x^2 + c1y^2 - c3x^2 - c3y^2)*w'

        // Obtaining the following homogeneous equations
        // 2*(c1x - c2x)*x' + 2*(c1y - c2y)*y' - (r2^2 - r1^2 + c1x^2 + c1y^2 - c2x^2 - c2y^2)*w' = 0
        // 2*(c1x - c3x)*x' + 2*(c1y - c3y)*y' - (r3^2 - r1^2 + c1x^2 + c1y^2 - c3x^2 - c3y^2)*w' = 0

        // Fixing signs...
        // 2*(c1x - c2x)*x' + 2*(c1y - c2y)*y' + (r1^2 - r2^2 + c2x^2 + c2y^2 - c1x^2 - c1y^2)*w' = 0
        // 2*(c1x - c3x)*x' + 2*(c1y - c3y)*y' + (r1^2 - r3^2 + c3x^2 + c3y^2 - c1x^2 - c1y^2)*w' = 0


        // The homogeneous equations can be expressed as a linear system of homogeneous equations A*x = 0
        // where the unknowns to be solved are (x', y', w') up to scale.

        // [2*(c1x - c2x)   2*(c1y - c2y)    r1^2 - r2^2 + c2x^2 + c2y^2 - c1x^2 - c1y^2][x'] = 0
        // [2*(c1x - c3x)   2*(c1y - c3y)    r1^2 - r3^2 + c3x^2 + c3y^2 - c1x^2 - c1y^2][y'] = 0
        //                                                                               [w']

        // This can be solved by using the SVD decomposition of matrix A and picking the last column of
        // resulting V matrix. At least 2 equations are required to find a solution, since 1 additional
        // point is used as a reference, at least 3 points are required.

        // For spheres the solution is analogous

        // Having 4 3D spheres:
        // c1x, c1y, c1z, r1
        // c2x, c2y, c2z, r2
        // c3x, c3y, c3z, r3
        // c4x, c4y, c4z, r4
        // where (c1x, c1y, c1z) are the coordinates of 1st sphere center and r1 is its radius.
        // (c2x, c2y, c2z) are the coordinates of 2nd sphere center and r2 is its radius.
        // (c3x, c3y, c3z) are the coordinates of 3rd sphere center and r3 is its radius.
        // (c4x, c4y, c4z) are the coordinates of 4th sphere center and r4 is its radius.

        // The equations of the spheres are as follows:
        // (x - c1x)^2 + (y - c1y)^2 + (z - c1z)^2 = r1^2
        // (x - c2x)^2 + (y - c2y)^2 + (z - c2z)^2 = r2^2
        // (x - c3x)^2 + (y - c3y)^2 + (z - c3z)^2 = r3^2
        // (x - c4x)^2 + (y - c4y)^2 + (z - c4z)^2 = r4^2

        // x^2 - 2*c1x*x + c1x^2 + y^2 - 2*c1y*y + c1y^2 + z^2 - 2*c1z*z + c1z^2 = r1^2
        // x^2 - 2*c2x*x + c2x^2 + y^2 - 2*c2y*y + c2y^2 + z^2 - 2*c2z*z + c2z^2 = r2^2
        // x^2 - 2*c3x*x + c3x^2 + y^2 - 2*c3y*y + c3y^3 + z^2 - 2*c3z*z + c3z^2 = r3^2
        // x^2 - 2*c4x*x + c4x^2 + y^2 - 2*c4y*y + c4y^2 + z^2 - 2*c4z*z + c4z^2 = r4^2

        // remove 1st equation from others (we use 1st point as reference)
        // x^2 - 2*c2x*x + c2x^2 + y^2 - 2*c2y*y + c2y^2 + z^2 - 2*c2z*z + c2z^2 - (x^2 - 2*c1x*x + c1x^2 + y^2 - 2*c1y*y + c1y^2 + z^2 - 2*c1z*z + c1z^2) = r2^2 - r1^2
        // x^2 - 2*c3x*x + c3x^2 + y^2 - 2*c3y*y + c3y^3 + z^2 - 2*c3z*z + c3z^2 - (x^2 - 2*c1x*x + c1x^2 + y^2 - 2*c1y*y + c1y^2 + z^2 - 2*c1z*z + c1z^2) = r3^2 - r1^2
        // x^2 - 2*c4x*x + c4x^2 + y^2 - 2*c4y*y + c4y^2 + z^2 - 2*c4z*z + c4z^2 - (x^2 - 2*c1x*x + c1x^2 + y^2 - 2*c1y*y + c1y^2 + z^2 - 2*c1z*z + c1z^2) = r4^2 - r1^2

        // - 2*c2x*x + c2x^2 - 2*c2y*y + c2y^2 - 2*c2z*z + c2z^2 + 2*c1x*x - c1x^2 + 2*c1y*y - c1y^2 + 2*c1z*z - c1z^2 = r2^2 - r1^2
        // - 2*c3x*x + c3x^2 - 2*c3y*y + c3y^3 - 2*c3z*z + c3z^2 + 2*c1x*x - c1x^2 + 2*c1y*y - c1y^2 + 2*c1z*z - c1z^2 = r3^2 - r1^2
        // - 2*c4x*x + c4x^2 - 2*c4y*y + c4y^2 - 2*c4z*z + c4z^2 + 2*c1x*x - c1x^2 + 2*c1y*y - c1y^2 + 2*c1z*z - c1z^2 = r4^2 - r1^2

        // 2*(c1x - c2x)*x + c2x^2 + 2*(c1y - c2y)*y + c2y^2 + 2*(c1z - c2z)*z + c2z^2 - c1x^2 - c1y^2 - c1z^2 = r2^2 - r1^2
        // 2*(c1x - c3x)*x + c3x^2 + 2*(c1y - c3y)*y + c3y^3 + 2*(c1z - c3z)*z + c3z^2 - c1x^2 - c1y^2 - c1z^2 = r3^2 - r1^2
        // 2*(c1x - c4x)*x + c4x^2 + 2*(c1y - c4y)*y + c4y^2 + 2*(c1z - c4z)*z + c4z^2 - c1x^2 - c1y^2 - c1z^2 = r4^2 - r1^2

        // 2*(c1x - c2x)*x + 2*(c1y - c2y)*y + 2*(c1z - c2z)*z = r2^2 - r1^2 + c1x^2 + c1y^2 + c1z^2 - c2x^2 - c2y^2 - c2z^2
        // 2*(c1x - c3x)*x + 2*(c1y - c3y)*y + 2*(c1z - c3z)*z = r3^2 - r1^2 + c1x^2 + c1y^2 + c1z^2 - c3x^2 - c3y^3 - c3z^2
        // 2*(c1x - c4x)*x + 2*(c1y - c4y)*y + 2*(c1z - c4z)*z = r4^2 - r1^2 + c1x^2 + c1y^2 + c1z^2 - c4x^2 - c4y^2 - c4z^2

        // x, y and z the inhomogeneous coordinates of the point (x,y,z) we want to find,
        // we substitute such point by the corresponding homogeneous coordinates
        // (x, y, z) = (x'/w', y'/w', z'/w')

        // Hence
        // 2*(c1x - c2x)*x'/w' + 2*(c1y - c2y)*y'/w' + 2*(c1z - c2z)*z'/w' = r2^2 - r1^2 + c1x^2 + c1y^2 + c1z^2 - c2x^2 - c2y^2 - c2z^2
        // 2*(c1x - c3x)*x'/w' + 2*(c1y - c3y)*y'/w' + 2*(c1z - c3z)*z'/w' = r3^2 - r1^2 + c1x^2 + c1y^2 + c1z^2 - c3x^2 - c3y^3 - c3z^2
        // 2*(c1x - c4x)*x'/w' + 2*(c1y - c4y)*y'/w' + 2*(c1z - c4z)*z'/w' = r4^2 - r1^2 + c1x^2 + c1y^2 + c1z^2 - c4x^2 - c4y^2 - c4z^2

        // Multipliying by w' at both sides...
        // 2*(c1x - c2x)*x' + 2*(c1y - c2y)*y' + 2*(c1z - c2z)*z' = (r2^2 - r1^2 + c1x^2 + c1y^2 + c1z^2 - c2x^2 - c2y^2 - c2z^2)*w'
        // 2*(c1x - c3x)*x' + 2*(c1y - c3y)*y' + 2*(c1z - c3z)*z' = (r3^2 - r1^2 + c1x^2 + c1y^2 + c1z^2 - c3x^2 - c3y^3 - c3z^2)*w'
        // 2*(c1x - c4x)*x' + 2*(c1y - c4y)*y' + 2*(c1z - c4z)*z' = (r4^2 - r1^2 + c1x^2 + c1y^2 + c1z^2 - c4x^2 - c4y^2 - c4z^2)*w'

        // Obtaining the following homogeneous equations
        // 2*(c1x - c2x)*x' + 2*(c1y - c2y)*y' + 2*(c1z - c2z)*z' - (r2^2 - r1^2 + c1x^2 + c1y^2 + c1z^2 - c2x^2 - c2y^2 - c2z^2)*w' = 0
        // 2*(c1x - c3x)*x' + 2*(c1y - c3y)*y' + 2*(c1z - c3z)*z' - (r3^2 - r1^2 + c1x^2 + c1y^2 + c1z^2 - c3x^2 - c3y^3 - c3z^2)*w' = 0
        // 2*(c1x - c4x)*x' + 2*(c1y - c4y)*y' + 2*(c1z - c4z)*z' - (r4^2 - r1^2 + c1x^2 + c1y^2 + c1z^2 - c4x^2 - c4y^2 - c4z^2)*w' = 0

        // Fixing signs...
        // 2*(c1x - c2x)*x' + 2*(c1y - c2y)*y' + 2*(c1z - c2z)*z' + (r1^2 - r2^2 + c2x^2 + c2y^2 + c2z^2 - c1x^2 - c1y^2 - c1z^2)*w' = 0
        // 2*(c1x - c3x)*x' + 2*(c1y - c3y)*y' + 2*(c1z - c3z)*z' + (r1^2 - r3^2 + c3x^2 + c3y^3 + c3z^2 - c1x^2 - c1y^2 - c1z^2)*w' = 0
        // 2*(c1x - c4x)*x' + 2*(c1y - c4y)*y' + 2*(c1z - c4z)*z' + (r1^2 - r4^2 + c4x^2 + c4y^2 + c4z^2 - c1x^2 - c1y^2 - c1z^2)*w' = 0

        // The homogeneous equastions can be expressed as a linear system of homogeneous equations
        // where the unknowns to be solved are (x', y', z', w') up to scale.

        // [2*(c1x - c2x)   2*(c1y - c2y)   2*(c1z - c2z)   r1^2 - r2^2 + c2x^2 + c2y^2 + c2z^2 - c1x^2 - c1y^2 - c1z^2][x'] = 0
        // [2*(c1x - c3x)   2*(c1y - c3y)   2*(c1z - c3z)   r1^2 - r3^2 + c3x^2 + c3y^3 + c3z^2 - c1x^2 - c1y^2 - c1z^2][y'] = 0
        // [2*(c1x - c4x)   2*(c1y - c4y)   2*(c1z - c4z)   r1^2 - r4^2 + c4x^2 + c4y^2 + c4z^2 - c1x^2 - c1y^2 - c1z^2][z'] = 0
        //                                                                                                              [w']

        // This can be solved by using the SVD decomposition of matrix A and picking the last column of
        // resulting V matrix. At least 3 equations are required to find a solution, since 1 additional
        // point is used as a reference, at least 4 points are required.

        if (!isReady()) {
            throw new NotReadyException();
        }
        if (isLocked()) {
            throw new LockedException();
        }

        try {
            mLocked = true;

            if (mListener != null) {
                mListener.onSolveStart(this);
            }

            int numberOfPositions = mPositions.length;
            int numberOfPositionsMinus1 = numberOfPositions - 1;
            int dims = getNumberOfDimensions();</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/gnss/GNSSMeasurement.java</td>
<td><a href="./xref/com/irurueta/navigation/gnss/GNSSMeasurement.html#L733">733</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/INSLooselyCoupledKalmanState.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/INSLooselyCoupledKalmanState.html#L1634">1634</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/INSTightlyCoupledKalmanState.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/INSTightlyCoupledKalmanState.html#L1807">1807</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>        mVz = ecefVelocity.getVz();
    }

    /**
     * Gets ECEF position and velocity of satellite.
     *
     * @param result instance where position and velocity will be stored.
     */
    public void getPositionAndVelocity(final ECEFPositionAndVelocity result) {
        result.setPositionCoordinates(mX, mY, mZ);
        result.setVelocityCoordinates(mVx, mVy, mVz);
    }

    /**
     * Gets ECEF position and velocity of satellite.
     *
     * @return ECEF position and velocity of satellite.
     */
    public ECEFPositionAndVelocity getPositionAndVelocity() {
        return new ECEFPositionAndVelocity(mX, mY, mZ, mVx, mVy, mVz);
    }

    /**
     * Sets ECEF position and velocity of satellite.
     *
     * @param positionAndVelocity ECEF position and velocity of satellite.
     */
    public void setPositionAndVelocity(final ECEFPositionAndVelocity positionAndVelocity) {
        mX = positionAndVelocity.getX();
        mY = positionAndVelocity.getY();
        mZ = positionAndVelocity.getZ();

        mVx = positionAndVelocity.getVx();
        mVy = positionAndVelocity.getVy();
        mVz = positionAndVelocity.getVz();
    }

    /**
     * Copies this instance data into provided instance.
     *
     * @param output destination instance where data will be copied to.
     */
    public void copyTo(GNSSMeasurement output) {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/LMedSRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/LMedSRobustRangingAndRssiRadioSourceEstimator2D.html#L396">396</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/LMedSRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/LMedSRobustRssiRadioSourceEstimator3D.html#L407">407</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>            RobustRangingAndRssiRadioSourceEstimatorListener&lt;S, Point2D&gt; listener) {
        super(readings, initialPosition, initialTransmittedPowerdBm,
                initialPathLossExponent, listener);
    }

    /**
     * Returns threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value, the
     * algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algrithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @return stop threshold to stop the algorithm prematurely when a certain
     * accuracy has been reached.
     */
    public double getStopThreshold() {
        return mStopThreshold;
    }

    /**
     * Sets threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value,
     * the algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algorithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @param stopThreshold stop threshold to stop the algorithm prematurely
     *                      when a certain accuracy has been reached.
     * @throws IllegalArgumentException if provided value is zero or negative.
     * @throws LockedException if this solver is locked.
     */
    public void setStopThreshold(double stopThreshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (stopThreshold &lt;= MIN_STOP_THRESHOLD) {
            throw new IllegalArgumentException();
        }

        mStopThreshold = stopThreshold;
    }

    /**
     * Robustly estimates position, transmitted power and pathloss exponent for a
     * radio source.
     *
     * @throws LockedException if instance is busy during estimation.
     * @throws NotReadyException if estimator is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     * (i.e. numerical instability, no solution available, etc).
     */
    @Override
    public void estimate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        LMedSRobustEstimator&lt;RobustRangingAndRssiRadioSourceEstimator.Solution&lt;Point2D&gt;&gt; innerEstimator =</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/LMedSRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/LMedSRobustRangingAndRssiRadioSourceEstimator3D.html#L396">396</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/LMedSRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/LMedSRobustRssiRadioSourceEstimator2D.html#L407">407</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>            RobustRangingAndRssiRadioSourceEstimatorListener&lt;S, Point3D&gt; listener) {
        super(readings, initialPosition, initialTransmittedPowerdBm,
                initialPathLossExponent, listener);
    }

    /**
     * Returns threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value, the
     * algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algrithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @return stop threshold to stop the algorithm prematurely when a certain
     * accuracy has been reached.
     */
    public double getStopThreshold() {
        return mStopThreshold;
    }

    /**
     * Sets threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value,
     * the algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algorithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @param stopThreshold stop threshold to stop the algorithm prematurely
     *                      when a certain accuracy has been reached.
     * @throws IllegalArgumentException if provided value is zero or negative.
     * @throws LockedException if this solver is locked.
     */
    public void setStopThreshold(double stopThreshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (stopThreshold &lt;= MIN_STOP_THRESHOLD) {
            throw new IllegalArgumentException();
        }

        mStopThreshold = stopThreshold;
    }

    /**
     * Robustly estimates position, transmitted power and pathloss exponent for a
     * radio source.
     *
     * @throws LockedException if instance is busy during estimation.
     * @throws NotReadyException if estimator is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     * (i.e. numerical instability, no solution available, etc).
     */
    @Override
    public void estimate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        LMedSRobustEstimator&lt;RobustRangingAndRssiRadioSourceEstimator.Solution&lt;Point3D&gt;&gt; innerEstimator =</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RssiRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RssiRadioSourceEstimator.html#L1320">1320</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RssiRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RssiRadioSourceEstimator.html#L1444">1444</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>            }
        });

        int numReadings = mReadings.size();
        try {
            Matrix x = new Matrix(numReadings, dimsPlus1);
            double[] y = new double[numReadings];
            double[] standardDeviations = new double[numReadings];
            for (int i = 0; i &lt; numReadings; i++) {
                reading = mReadings.get(i);
                P position = reading.getPosition();

                for (int j = 0; j &lt; dims; j++) {
                    x.setElementAt(i, j, position.getInhomogeneousCoordinate(j));
                }
                x.setElementAt(i, dims, initialTransmittedPowerdBm);</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/calibration/PROMedSRobustKnownBiasAndFrameAccelerometerCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/PROMedSRobustKnownBiasAndFrameAccelerometerCalibrator.html#L1769">1769</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/calibration/PROSACRobustKnownBiasAndFrameAccelerometerCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/PROSACRobustKnownBiasAndFrameAccelerometerCalibrator.html#L1795">1795</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/calibration/RANSACRobustKnownBiasAndFrameAccelerometerCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/RANSACRobustKnownBiasAndFrameAccelerometerCalibrator.html#L899">899</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>            innerEstimator.setUseInlierThresholds(false);
            innerEstimator.setConfidence(mConfidence);
            innerEstimator.setMaxIterations(mMaxIterations);
            innerEstimator.setProgressDelta(mProgressDelta);
            final Matrix preliminaryResult = innerEstimator.estimate();
            mInliersData = innerEstimator.getInliersData();

            attemptRefine(preliminaryResult);

        } catch (com.irurueta.numerical.LockedException e) {
            throw new LockedException(e);
        } catch (com.irurueta.numerical.NotReadyException e) {
            throw new NotReadyException(e);
        } catch (RobustEstimatorException e) {
            throw new CalibrationException(e);
        } finally {
            mRunning = false;
        }
    }

    /**
     * Returns method being used for robust estimation.
     *
     * @return method being used for robust estimation.
     */
    @Override
    public RobustEstimatorMethod getMethod() {
        return RobustEstimatorMethod.PROMedS;</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/calibration/PROMedSRobustKnownFrameAccelerometerCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/PROMedSRobustKnownFrameAccelerometerCalibrator.html#L541">541</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/calibration/PROSACRobustKnownFrameAccelerometerCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/PROSACRobustKnownFrameAccelerometerCalibrator.html#L564">564</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/calibration/RANSACRobustKnownFrameAccelerometerCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/RANSACRobustKnownFrameAccelerometerCalibrator.html#L359">359</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>            innerEstimator.setUseInlierThresholds(false);
            innerEstimator.setConfidence(mConfidence);
            innerEstimator.setMaxIterations(mMaxIterations);
            innerEstimator.setProgressDelta(mProgressDelta);
            final PreliminaryResult preliminaryResult = innerEstimator.estimate();
            mInliersData = innerEstimator.getInliersData();

            attemptRefine(preliminaryResult);

        } catch (com.irurueta.numerical.LockedException e) {
            throw new LockedException(e);
        } catch (com.irurueta.numerical.NotReadyException e) {
            throw new NotReadyException(e);
        } catch (RobustEstimatorException e) {
            throw new CalibrationException(e);
        } finally {
            mRunning = false;
        }
    }

    /**
     * Returns method being used for robust estimation.
     *
     * @return method being used for robust estimation.
     */
    @Override
    public RobustEstimatorMethod getMethod() {
        return RobustEstimatorMethod.PROMedS;</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/calibration/PROSACRobustKnownBiasAndFrameAccelerometerCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/PROSACRobustKnownBiasAndFrameAccelerometerCalibrator.html#L1645">1645</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/calibration/PROSACRobustKnownFrameAccelerometerCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/PROSACRobustKnownFrameAccelerometerCalibrator.html#L418">418</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/calibration/RANSACRobustKnownBiasAndFrameAccelerometerCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/RANSACRobustKnownBiasAndFrameAccelerometerCalibrator.html#L757">757</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/calibration/RANSACRobustKnownFrameAccelerometerCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/RANSACRobustKnownFrameAccelerometerCalibrator.html#L218">218</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    }

    /**
     * Indicates whether inliers must be computed and kept.
     *
     * @return true if inliers must be computed and kept, false if inliers
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepInliersEnabled() {
        return mComputeAndKeepInliers;
    }

    /**
     * Specifies whether inliers must be computed and kept.
     *
     * @param computeAndKeepInliers true if inliers must be computed and kept,
     *                              false if inliers only need to be computed but not kept.
     * @throws LockedException if calibrator is currently running.
     */
    public void setComputeAndKeepInliersEnabled(boolean computeAndKeepInliers)
            throws LockedException {
        if (mRunning) {
            throw new LockedException();
        }
        mComputeAndKeepInliers = computeAndKeepInliers;
    }

    /**
     * Indicates whether residuals must be computed and kept.
     *
     * @return true if residuals must be computed and kept, false if residuals
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepResiduals() {
        return mComputeAndKeepResiduals;
    }

    /**
     * Specifies whether residuals must be computed and kept.
     *
     * @param computeAndKeepResiduals true if residuals must be computed and kept,
     *                                false if residuals only need to be computed but not kept.
     * @throws LockedException if calibrator is currently running.
     */
    public void setComputeAndKeepResidualsEnabled(boolean computeAndKeepResiduals)
            throws LockedException {
        if (mRunning) {
            throw new LockedException();
        }
        mComputeAndKeepResiduals = computeAndKeepResiduals;
    }

    /**
     * Estimates accelerometer calibration parameters containing scale factors
     * and cross-coupling errors.
     *
     * @throws LockedException      if calibrator is currently running.
     * @throws NotReadyException    if calibrator is not ready.
     * @throws CalibrationException if estimation fails for numerical reasons.
     */
    @Override
    public void calibrate() throws LockedException, NotReadyException, CalibrationException {
        if (mRunning) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        final PROSACRobustEstimator&lt;Matrix&gt; innerEstimator =</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/lateration/MSACRobustLateration2DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/MSACRobustLateration2DSolver.html#L220">220</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/lateration/RANSACRobustLateration2DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/RANSACRobustLateration2DSolver.html#L289">289</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>                new MSACRobustEstimator&lt;&gt;(new MSACRobustEstimatorListener&lt;Point2D&gt;() {
                    @Override
                    public double getThreshold() {
                        return mThreshold;
                    }

                    @Override
                    public int getTotalSamples() {
                        return mDistances.length;
                    }

                    @Override
                    public int getSubsetSize() {
                        return mPreliminarySubsetSize;
                    }

                    @Override
                    public void estimatePreliminarSolutions(int[] samplesIndices, List&lt;Point2D&gt; solutions) {
                        solvePreliminarSolutions(samplesIndices, solutions);
                    }

                    @Override
                    public double computeResidual(Point2D currentEstimation, int i) {
                        return Math.abs(currentEstimation.distanceTo(mPositions[i]) - mDistances[i]);
                    }

                    @Override
                    public boolean isReady() {
                        return MSACRobustLateration2DSolver.this.isReady();</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/lateration/MSACRobustLateration3DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/MSACRobustLateration3DSolver.html#L220">220</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/lateration/RANSACRobustLateration3DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/RANSACRobustLateration3DSolver.html#L289">289</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>            new MSACRobustEstimator&lt;&gt;(new MSACRobustEstimatorListener&lt;Point3D&gt;() {
                @Override
                public double getThreshold() {
                    return mThreshold;
                }

                @Override
                public int getTotalSamples() {
                    return mDistances.length;
                }

                @Override
                public int getSubsetSize() {
                    return mPreliminarySubsetSize;
                }

                @Override
                public void estimatePreliminarSolutions(int[] samplesIndices, List&lt;Point3D&gt; solutions) {
                    solvePreliminarSolutions(samplesIndices, solutions);
                }

                @Override
                public double computeResidual(Point3D currentEstimation, int i) {
                    return Math.abs(currentEstimation.distanceTo(mPositions[i]) - mDistances[i]);
                }

                @Override
                public boolean isReady() {
                    return MSACRobustLateration3DSolver.this.isReady();</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/frames/ECEFFrame.java</td>
<td><a href="./xref/com/irurueta/navigation/frames/ECEFFrame.html#L690">690</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/INSLooselyCoupledKalmanState.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/INSLooselyCoupledKalmanState.html#L1634">1634</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/INSTightlyCoupledKalmanState.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/INSTightlyCoupledKalmanState.html#L1807">1807</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>        mVz = velocity.getVz();
    }

    /**
     * Gets cartesian position and velocity.
     *
     * @param result instance where cartesian position and velocity will be stored.
     */
    public void getPositionAndVelocity(final ECEFPositionAndVelocity result) {
        result.setPositionCoordinates(mX, mY, mZ);
        result.setVelocityCoordinates(mVx, mVy, mVz);
    }

    /**
     * Gets cartesian position and velocity.
     *
     * @return cartesian position and velocity.
     */
    public ECEFPositionAndVelocity getPositionAndVelocity() {
        return new ECEFPositionAndVelocity(mX, mY, mZ, mVx, mVy, mVz);
    }

    /**
     * Sets cartesian position and velocity.
     *
     * @param positionAndVelocity cartesian position and velocity.
     */
    public void setPositionAndVelocity(
            final ECEFPositionAndVelocity positionAndVelocity) {
        mX = positionAndVelocity.getX();
        mY = positionAndVelocity.getY();
        mZ = positionAndVelocity.getZ();

        mVx = positionAndVelocity.getVx();
        mVy = positionAndVelocity.getVy();
        mVz = positionAndVelocity.getVz();
    }</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/Utils.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/Utils.html#L344">344</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/Utils.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/Utils.html#L593">593</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                    y[0] = fingerprintRssi
                            - 10.0 * pathLossExponent * crossDiff / (ln10 * d1a2);

                    //compute gradient (is a jacobian having 1 row and 8 columns)


                    //derivative of rssi respect to fingerprint rssi
                    double derivativeFingerprintRssi = 1.0;

                    //derivative of rssi respect to path-loss exponent

                    //diff(Pr(pi))/diff(n) = -10*(x1 - xa)/(ln(10)*d1a^2)*(xi - x1)
                    //  -10*(y1 - ya)/(ln(10)*d1a^2)*(yi - y1)
                    double derivativePathLossExponent = - 10.0 * crossDiff /
                            (ln10 * d1a2);


                    //derivative of rssi respect to x1

                    //We have
                    //Pr(pi) = Pr(p1) -10*n*((x1 - xa)*(xi - x1) + (y1 - ya)*(yi - y1))/
                    //      (ln(10)*((x1 - xa)^2 + (y1 - ya)^2))

                    //and we know that: (f(x)/g(x))' = (f'(x)*g(x) - f(x)*g'(x))/g(x)^2
                    //and also that (f(x)*g(x))' = f'(x)*g(x) + f(x)*g'(x)

                    //Hence
                    //diff((x1 - xa)*(xi - x1) + (y1 - ya)*(yi - y1))/diff(x1) =
                    //  diff(x1*xi -xa*xi -x1^2 + xa*x1)/diff(x1) =
                    //  diff(-x1^2 + (xi + xa)*x1 - xa*xi)/diff(x1) =
                    //  -2*x1 + xi + xa

                    //diff(Pr(pi))/diff(x1) = -10*n/ln(10)*((-2*x1 + xi + xa)*((x1 - xa)^2 + (y1 - ya)^2) - ((x1 - xa)*(xi - x1) + (y1 - ya)*(yi - y1))*2*(x1 - xa))/((x1 - xa)^2 + (y1 - ya)^2)^2
                    //diff(Pr(pi))/diff(x1) = -10*n/ln(10)*((-2*x1 + xi + xa)*d1a^2 - ((x1 - xa)*(xi - x1) + (y1 - ya)*(yi - y1))*2*(x1 - xa))/d1a^4
                    double tmpX = 2.0 * crossDiff * diffX1a;
                    double derivativeX1 = -10.0 * pathLossExponent / ln10 * ((-2.0 * x1 + xi + xa) * d1a2
                            - tmpX) / d1a4;

                    //derivative of rssi respect to y1

                    //diff((x1 - xa)*(xi - x1) + (y1 - ya)*(yi - y1))/diff(y1) =
                    //  diff(y1*yi -ya*yi -y1^2 + ya*y1)/diff(y1) =
                    //  diff(-y1^2 + (yi + ya)*y1 - ya*yi)/diff(y1) =
                    //  -2*y1 + yi + ya

                    //diff(Pr(pi))/diff(y1) = -10*n/ln(10)*((-2*y1 + yi + ya)*((x1 - xa)^2 + (y1 - ya)^2) - ((x1 - xa)*(xi - x1) + (y1 - ya)*(yi - y1))*2*(y1 - ya))/((x1 - xa)^2 + (y1 - ya)^2)^2
                    //diff(Pr(pi))/diff(y1) = -10*n/ln(10)*((-2*y1 + yi + ya)*d1a^2 - ((x1 - xa)*(xi - x1) + (y1 - ya)*(yi - y1))*2*(y1 - ya))/d1a^4
                    double tmpY = 2.0 * crossDiff * diffY1a;
                    double derivativeY1 = -10.0 * pathLossExponent / ln10 * ((-2.0 * y1 + yi + ya) * d1a2
                            - tmpY) / d1a4;


                    //derivative of rssi respect to xa

                    //diff((x1 - xa)*(xi - x1) + (y1 - ya)*(yi - y1))/diff(xa) =
                    //  diff(x1*xi -xa*xi -x1^2 + xa*x1)/diff(xa) =
                    //  x1 - xi

                    //diff(Pr(pi))/diff(xa) = -10*n/ln(10)*((x1 - xi)*((x1 - xa)^2 + (y1 - ya)^2) - ((x1 - xa)*(xi - x1) + (y1 - ya)*(yi - y1))*-2*(x1 - xa))/((x1 - xa)^2 + (y1 - ya)^2)^2
                    //diff(Pr(pi))/diff(xa) = -10*n/ln(10)*(-(xi - x1)*d1a^2 + ((x1 - xa)*(xi - x1) + (y1 - ya)*(yi - y1))*2*(x1 - xa))/d1a^4
                    double derivativeXa = -10.0 * pathLossExponent / ln10 * (-diffXi1 * d1a2</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/calibration/IMUBiasEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/IMUBiasEstimator.html#L3990">3990</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/calibration/IMUNoiseEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/IMUNoiseEstimator.html#L1254">1254</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    }

    /**
     * Adds a sample of body kinematics (accelerometer + gyroscope readings) obtained
     * from an IMU.
     * If estimator is already finished, provided sample will be ignored.
     *
     * @param kinematics kinematics instance to be added and processed.
     * @return true if provided kinematics instance has been processed, false if it has
     * been ignored.
     * @throws LockedException if estimator is currently running.
     */
    public boolean addBodyKinematics(final BodyKinematics kinematics)
            throws LockedException {

        if (mRunning) {
            throw new LockedException();
        }

        if (isFinished()) {
            return true;
        }

        mRunning = true;

        if (mLastBodyKinematics == null &amp;&amp; mListener != null) {
            mListener.onStart(this);
        }

        final double fx = kinematics.getFx();
        final double fy = kinematics.getFy();
        final double fz = kinematics.getFz();
        final double angularRateX = kinematics.getAngularRateX();
        final double angularRateY = kinematics.getAngularRateY();
        final double angularRateZ = kinematics.getAngularRateZ();</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/calibration/KnownFrameAccelerometerLinearLeastSquaresCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/KnownFrameAccelerometerLinearLeastSquaresCalibrator.html#L852">852</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/calibration/KnownFrameAccelerometerLinearLeastSquaresCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/KnownFrameAccelerometerLinearLeastSquaresCalibrator.html#L965">965</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>            a.setElementAt(i, 5, fTrueZ);

            b.setElementAtIndex(i, fMeasZ - fTrueZ);
            i++;
        }

        final Matrix unknowns = Utils.solve(a, b);

        final double bx = unknowns.getElementAtIndex(0);
        final double by = unknowns.getElementAtIndex(1);
        final double bz = unknowns.getElementAtIndex(2);
        final double sx = unknowns.getElementAtIndex(3);
        final double sy = unknowns.getElementAtIndex(4);
        final double sz = unknowns.getElementAtIndex(5);
        final double mxy = unknowns.getElementAtIndex(6);
        final double mxz = unknowns.getElementAtIndex(7);
        final double myz = unknowns.getElementAtIndex(8);</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/calibration/LMedSRobustKnownBiasAndFrameAccelerometerCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/LMedSRobustKnownBiasAndFrameAccelerometerCalibrator.html#L871">871</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/calibration/MSACRobustKnownBiasAndFrameAccelerometerCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/MSACRobustKnownBiasAndFrameAccelerometerCalibrator.html#L823">823</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/calibration/PROMedSRobustKnownBiasAndFrameAccelerometerCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/PROMedSRobustKnownBiasAndFrameAccelerometerCalibrator.html#L1770">1770</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/calibration/PROSACRobustKnownBiasAndFrameAccelerometerCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/PROSACRobustKnownBiasAndFrameAccelerometerCalibrator.html#L1796">1796</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/calibration/RANSACRobustKnownBiasAndFrameAccelerometerCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/RANSACRobustKnownBiasAndFrameAccelerometerCalibrator.html#L900">900</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>            innerEstimator.setConfidence(mConfidence);
            innerEstimator.setMaxIterations(mMaxIterations);
            innerEstimator.setProgressDelta(mProgressDelta);
            final Matrix preliminaryResult = innerEstimator.estimate();
            mInliersData = innerEstimator.getInliersData();

            attemptRefine(preliminaryResult);

        } catch (com.irurueta.numerical.LockedException e) {
            throw new LockedException(e);
        } catch (com.irurueta.numerical.NotReadyException e) {
            throw new NotReadyException(e);
        } catch (RobustEstimatorException e) {
            throw new CalibrationException(e);
        } finally {
            mRunning = false;
        }
    }

    /**
     * Returns method being used for robust estimation.
     *
     * @return method being used for robust estimation.
     */
    @Override
    public RobustEstimatorMethod getMethod() {
        return RobustEstimatorMethod.LMedS;</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/calibration/LMedSRobustKnownFrameAccelerometerCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/LMedSRobustKnownFrameAccelerometerCalibrator.html#L330">330</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/calibration/MSACRobustKnownFrameAccelerometerCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/MSACRobustKnownFrameAccelerometerCalibrator.html#L283">283</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/calibration/PROMedSRobustKnownFrameAccelerometerCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/PROMedSRobustKnownFrameAccelerometerCalibrator.html#L542">542</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/calibration/PROSACRobustKnownFrameAccelerometerCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/PROSACRobustKnownFrameAccelerometerCalibrator.html#L565">565</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/calibration/RANSACRobustKnownFrameAccelerometerCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/RANSACRobustKnownFrameAccelerometerCalibrator.html#L360">360</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>            innerEstimator.setConfidence(mConfidence);
            innerEstimator.setMaxIterations(mMaxIterations);
            innerEstimator.setProgressDelta(mProgressDelta);
            final PreliminaryResult preliminaryResult = innerEstimator.estimate();
            mInliersData = innerEstimator.getInliersData();

            attemptRefine(preliminaryResult);

        } catch (com.irurueta.numerical.LockedException e) {
            throw new LockedException(e);
        } catch (com.irurueta.numerical.NotReadyException e) {
            throw new NotReadyException(e);
        } catch (RobustEstimatorException e) {
            throw new CalibrationException(e);
        } finally {
            mRunning = false;
        }
    }

    /**
     * Returns method being used for robust estimation.
     *
     * @return method being used for robust estimation.
     */
    @Override
    public RobustEstimatorMethod getMethod() {
        return RobustEstimatorMethod.LMedS;</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/calibration/RobustKnownBiasAndFrameAccelerometerCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/RobustKnownBiasAndFrameAccelerometerCalibrator.html#L2547">2547</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/calibration/RobustKnownBiasAndFrameAccelerometerCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/RobustKnownBiasAndFrameAccelerometerCalibrator.html#L2856">2856</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>            final double biasX, final double biasY, final double biasZ,
            final RobustKnownBiasAndFrameAccelerometerCalibratorListener listener,
            final RobustEstimatorMethod method) {
        switch (method) {
            case RANSAC:
                return new RANSACRobustKnownBiasAndFrameAccelerometerCalibrator(
                        biasX, biasY, biasZ, listener);
            case LMedS:
                return new LMedSRobustKnownBiasAndFrameAccelerometerCalibrator(
                        biasX, biasY, biasZ, listener);
            case MSAC:
                return new MSACRobustKnownBiasAndFrameAccelerometerCalibrator(
                        biasX, biasY, biasZ, listener);
            case PROSAC:
                return new PROSACRobustKnownBiasAndFrameAccelerometerCalibrator(
                        biasX, biasY, biasZ, listener);
            case PROMedS:
            default:
                return new PROMedSRobustKnownBiasAndFrameAccelerometerCalibrator(
                        biasX, biasY, biasZ, listener);
        }
    }

    /**
     * Creates a robust accelerometer calibrator.
     *
     * @param measurements list of body kinematics measurements with standard
     *                     deviations taken at different frames (positions, orientations
     *                     and velocities).
     * @param biasX        known x coordinate of accelerometer bias expressed in meters per
     *                     squared second (m/s^2).
     * @param biasY        known y coordinate of accelerometer bias expressed in meters per
     *                     squared second (m/s^2).
     * @param biasZ        known z coordinate of accelerometer bias expressed in meters per
     *                     squared second (m/s^2).
     * @param method       robust estimator method.
     * @return a robust accelerometer calibrator.
     */
    public static RobustKnownBiasAndFrameAccelerometerCalibrator create(
            final List&lt;StandardDeviationFrameBodyKinematics&gt; measurements,
            final double biasX, final double biasY, final double biasZ,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/calibration/RobustKnownBiasAndFrameAccelerometerCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/RobustKnownBiasAndFrameAccelerometerCalibrator.html#L4773">4773</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/calibration/RobustKnownBiasAndFrameAccelerometerCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/RobustKnownBiasAndFrameAccelerometerCalibrator.html#L5097">5097</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>            final double[] bias, final boolean commonAxisUsed,
            final RobustEstimatorMethod method) {
        switch (method) {
            case RANSAC:
                return new RANSACRobustKnownBiasAndFrameAccelerometerCalibrator(
                        measurements, bias, commonAxisUsed);
            case LMedS:
                return new LMedSRobustKnownBiasAndFrameAccelerometerCalibrator(
                        measurements, bias, commonAxisUsed);
            case MSAC:
                return new MSACRobustKnownBiasAndFrameAccelerometerCalibrator(
                        measurements, bias, commonAxisUsed);
            case PROSAC:
                return new PROSACRobustKnownBiasAndFrameAccelerometerCalibrator(
                        qualityScores, measurements, bias, commonAxisUsed);
            case PROMedS:
            default:
                return new PROMedSRobustKnownBiasAndFrameAccelerometerCalibrator(
                        qualityScores, measurements, bias, commonAxisUsed);
        }
    }

    /**
     * Creates a robust accelerometer calibrator.
     *
     * @param qualityScores  quality scores corresponding to each provided
     *                       measurement. The larger the score value the better
     *                       the quality of the sample.
     * @param measurements   list of body kinematics measurements with standard
     *                       deviations taken at different frames (positions, orientations
     *                       and velocities).
     * @param bias           known accelerometer bias.
     * @param commonAxisUsed indicates whether z-axis is assumed to be common for
     *                       accelerometer and gyroscope.
     * @param listener       listener to handle events raised by this calibrator.
     * @param method         robust estimator method.
     * @return a robust accelerometer calibrator.
     * @throws IllegalArgumentException if provided bias array does not have length 3 or
     *                                  if provided quality scores length is smaller than
     *                                  4 samples.
     */
    public static RobustKnownBiasAndFrameAccelerometerCalibrator create(
            final double[] qualityScores,
            final List&lt;StandardDeviationFrameBodyKinematics&gt; measurements,
            final double[] bias, final boolean commonAxisUsed,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L11823">11823</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L11885">11885</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public static ECEFFrame navigateECEFAndReturnNew(final double timeInterval,
                                                     final double oldX,
                                                     final double oldY,
                                                     final double oldZ,
                                                     final CoordinateTransformation oldC,
                                                     final double oldVx,
                                                     final double oldVy,
                                                     final double oldVz,
                                                     final double fx,
                                                     final double fy,
                                                     final double fz,
                                                     final double angularRateX,
                                                     final double angularRateY,
                                                     final double angularRateZ)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        final ECEFFrame result = new ECEFFrame();
        navigateECEF(timeInterval, oldX, oldY, oldZ, oldC, oldVx, oldVy, oldVz,
                fx, fy, fz, angularRateX, angularRateY, angularRateZ, result);
        return result;
    }

    /**
     * Runs precision ECEF-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldX         previous cartesian x-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldY         previous cartesian y-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldZ         previous cartesian z-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldC         previous body-to-ECEF-frame coordinate transformation.
     * @param oldVx        previous velocity x-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param oldVy        previous velocity y-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param oldVz        previous velocity z-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @return estimated ECEF frame containing new body position, velocity and coordinate
     * transformation matrix.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-ECEF-frame coordinate transformation matrix are invalid.
     */
    public static ECEFFrame navigateECEFAndReturnNew(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L12869">12869</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L12931">12931</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public static ECEFFrame navigateECEFAndReturnNew(final double timeInterval,
                                                     final Distance oldX,
                                                     final Distance oldY,
                                                     final Distance oldZ,
                                                     final CoordinateTransformation oldC,
                                                     final double oldVx,
                                                     final double oldVy,
                                                     final double oldVz,
                                                     final double fx,
                                                     final double fy,
                                                     final double fz,
                                                     final double angularRateX,
                                                     final double angularRateY,
                                                     final double angularRateZ)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        final ECEFFrame result = new ECEFFrame();
        navigateECEF(timeInterval, oldX, oldY, oldZ, oldC, oldVx, oldVy, oldVz, fx, fy, fz,
                angularRateX, angularRateY, angularRateZ, result);
        return result;
    }

    /**
     * Runs precision ECEF-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldX         previous cartesian x-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldY         previous cartesian y-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldZ         previous cartesian z-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldC         previous body-to-ECEF-frame coordinate transformation.
     * @param oldVx        previous velocity x-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param oldVy        previous velocity y-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param oldVz        previous velocity z-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @return estimated ECEF frame containing new body position, velocity and coordinate
     * transformation matrix.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-ECEF-frame coordinate transformation matrix are invalid.
     */
    public static ECEFFrame navigateECEFAndReturnNew(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L13253">13253</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L13315">13315</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public static ECEFFrame navigateECEFAndReturnNew(final double timeInterval,
                                                     final double oldX,
                                                     final double oldY,
                                                     final double oldZ,
                                                     final CoordinateTransformation oldC,
                                                     final Speed oldSpeedX,
                                                     final Speed oldSpeedY,
                                                     final Speed oldSpeedZ,
                                                     final double fx,
                                                     final double fy,
                                                     final double fz,
                                                     final double angularRateX,
                                                     final double angularRateY,
                                                     final double angularRateZ)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        final ECEFFrame result = new ECEFFrame();
        navigateECEF(timeInterval, oldX, oldY, oldZ, oldC, oldSpeedX, oldSpeedY,
                oldSpeedZ, fx, fy, fz, angularRateX, angularRateY, angularRateZ, result);
        return result;
    }

    /**
     * Runs precision ECEF-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldX         previous cartesian x-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldY         previous cartesian y-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldZ         previous cartesian z-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldC         previous body-to-ECEF-frame coordinate transformation.
     * @param oldSpeedX    previous velocity x-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param oldSpeedY    previous velocity y-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param oldSpeedZ    previous velocity z-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @return estimated ECEF frame containing new body position, velocity and coordinate
     * transformation matrix.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-ECEF-frame coordinate transformation matrix are invalid.
     */
    public static ECEFFrame navigateECEFAndReturnNew(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L13636">13636</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L13695">13695</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public static ECEFFrame navigateECEFAndReturnNew(final double timeInterval,
                                                     final double oldX,
                                                     final double oldY,
                                                     final double oldZ,
                                                     final CoordinateTransformation oldC,
                                                     final double oldVx,
                                                     final double oldVy,
                                                     final double oldVz,
                                                     final Acceleration fx,
                                                     final Acceleration fy,
                                                     final Acceleration fz,
                                                     final double angularRateX,
                                                     final double angularRateY,
                                                     final double angularRateZ)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        final ECEFFrame result = new ECEFFrame();
        navigateECEF(timeInterval, oldX, oldY, oldZ, oldC, oldVx, oldVy, oldVz, fx, fy,
                fz, angularRateX, angularRateY, angularRateZ, result);
        return result;
    }

    /**
     * Runs precision ECEF-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldX         previous cartesian x-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldY         previous cartesian y-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldZ         previous cartesian z-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldC         previous body-to-ECEF-frame coordinate transformation.
     * @param oldVx        previous velocity x-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param oldVy        previous velocity y-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param oldVz        previous velocity z-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @return estimated ECEF frame containing new body position, velocity and coordinate
     * transformation matrix.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-ECEF-frame coordinate transformation matrix are invalid.
     */
    public static ECEFFrame navigateECEFAndReturnNew(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L14055">14055</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L14114">14114</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public static ECEFFrame navigateECEFAndReturnNew(final double timeInterval,
                                                     final double oldX,
                                                     final double oldY,
                                                     final double oldZ,
                                                     final CoordinateTransformation oldC,
                                                     final double oldVx,
                                                     final double oldVy,
                                                     final double oldVz,
                                                     final double fx,
                                                     final double fy,
                                                     final double fz,
                                                     final AngularSpeed angularRateX,
                                                     final AngularSpeed angularRateY,
                                                     final AngularSpeed angularRateZ)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        final ECEFFrame result = new ECEFFrame();
        navigateECEF(timeInterval, oldX, oldY, oldZ, oldC, oldVx, oldVy, oldVz, fx, fy,
                fz, angularRateX, angularRateY, angularRateZ, result);
        return result;
    }

    /**
     * Runs precision ECEF-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldX         previous cartesian x-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldY         previous cartesian y-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldZ         previous cartesian z-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldC         previous body-to-ECEF-frame coordinate transformation.
     * @param oldVx        previous velocity x-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param oldVy        previous velocity y-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param oldVz        previous velocity z-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @return estimated ECEF frame containing new body position, velocity and coordinate
     * transformation matrix.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-ECEF-frame coordinate transformation matrix are invalid.
     */
    public static ECEFFrame navigateECEFAndReturnNew(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L14474">14474</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L14537">14537</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public static ECEFFrame navigateECEFAndReturnNew(final double timeInterval,
                                                     final Distance oldX,
                                                     final Distance oldY,
                                                     final Distance oldZ,
                                                     final CoordinateTransformation oldC,
                                                     final Speed oldSpeedX,
                                                     final Speed oldSpeedY,
                                                     final Speed oldSpeedZ,
                                                     final double fx,
                                                     final double fy,
                                                     final double fz,
                                                     final double angularRateX,
                                                     final double angularRateY,
                                                     final double angularRateZ)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        final ECEFFrame result = new ECEFFrame();
        navigateECEF(timeInterval, oldX, oldY, oldZ, oldC, oldSpeedX, oldSpeedY,
                oldSpeedZ, fx, fy, fz, angularRateX, angularRateY, angularRateZ,
                result);
        return result;
    }

    /**
     * Runs precision ECEF-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldX         previous cartesian x-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldY         previous cartesian y-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldZ         previous cartesian z-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldC         previous body-to-ECEF-frame coordinate transformation.
     * @param oldSpeedX    previous velocity x-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param oldSpeedY    previous velocity y-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param oldSpeedZ    previous velocity z-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @return estimated ECEF frame containing new body position, velocity and coordinate
     * transformation matrix.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-ECEF-frame coordinate transformation matrix are invalid.
     */
    public static ECEFFrame navigateECEFAndReturnNew(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L14594">14594</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L14651">14651</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public static ECEFFrame navigateECEFAndReturnNew(final double timeInterval,
                                                     final Distance oldX,
                                                     final Distance oldY,
                                                     final Distance oldZ,
                                                     final CoordinateTransformation oldC,
                                                     final Speed oldSpeedX,
                                                     final Speed oldSpeedY,
                                                     final Speed oldSpeedZ,
                                                     final Acceleration fx,
                                                     final Acceleration fy,
                                                     final Acceleration fz,
                                                     final AngularSpeed angularRateX,
                                                     final AngularSpeed angularRateY,
                                                     final AngularSpeed angularRateZ)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        final ECEFFrame result = new ECEFFrame();
        navigateECEF(timeInterval, oldX, oldY, oldZ, oldC, oldSpeedX, oldSpeedY,
                oldSpeedZ, fx, fy, fz, angularRateX, angularRateY, angularRateZ,
                result);
        return result;
    }

    /**
     * Runs precision ECEF-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldX         previous cartesian x-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldY         previous cartesian y-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldZ         previous cartesian z-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldC         previous body-to-ECEF-frame coordinate transformation.
     * @param oldSpeedX    previous velocity x-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param oldSpeedY    previous velocity y-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param oldSpeedZ    previous velocity z-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @return estimated ECEF frame containing new body position, velocity and coordinate
     * transformation matrix.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-ECEF-frame coordinate transformation matrix are invalid.
     */
    public static ECEFFrame navigateECEFAndReturnNew(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L14988">14988</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L15044">15044</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public static ECEFFrame navigateECEFAndReturnNew(final double timeInterval,
                                                     final double oldX,
                                                     final double oldY,
                                                     final double oldZ,
                                                     final CoordinateTransformation oldC,
                                                     final double oldVx,
                                                     final double oldVy,
                                                     final double oldVz,
                                                     final Acceleration fx,
                                                     final Acceleration fy,
                                                     final Acceleration fz,
                                                     final AngularSpeed angularRateX,
                                                     final AngularSpeed angularRateY,
                                                     final AngularSpeed angularRateZ)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        final ECEFFrame result = new ECEFFrame();
        navigateECEF(timeInterval, oldX, oldY, oldZ, oldC, oldVx, oldVy, oldVz, fx,
                fy, fz, angularRateX, angularRateY, angularRateZ, result);
        return result;
    }

    /**
     * Runs precision ECEF-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldX         previous cartesian x-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldY         previous cartesian y-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldZ         previous cartesian z-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldC         previous body-to-ECEF-frame coordinate transformation.
     * @param oldVx        previous velocity x-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param oldVy        previous velocity y-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param oldVz        previous velocity z-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @return estimated ECEF frame containing new body position, velocity and coordinate
     * transformation matrix.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-ECEF-frame coordinate transformation matrix are invalid.
     */
    public static ECEFFrame navigateECEFAndReturnNew(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L5667">5667</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L5730">5730</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public static ECIFrame navigateECIAndReturnNew(final double timeInterval,
                                                   final double oldX,
                                                   final double oldY,
                                                   final double oldZ,
                                                   final CoordinateTransformation oldC,
                                                   final double oldVx,
                                                   final double oldVy,
                                                   final double oldVz,
                                                   final double fx,
                                                   final double fy,
                                                   final double fz,
                                                   final double angularRateX,
                                                   final double angularRateY,
                                                   final double angularRateZ)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        final ECIFrame result = new ECIFrame();
        navigateECI(timeInterval, oldX, oldY, oldZ, oldC, oldVx, oldVy, oldVz,
                fx, fy, fz, angularRateX, angularRateY, angularRateZ, result);
        return result;
    }

    /**
     * Runs precision ECI-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldX         previous cartesian x-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldY         previous cartesian y-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldZ         previous cartesian z-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldC         previous body-to-ECI-frame coordinate transformation.
     * @param oldVx        previous velocity x-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param oldVy        previous velocity y-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param oldVz        previous velocity z-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param fx           specific force x-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @return estimated ECI frame containing new body position, velocity and coordinate
     * transformation matrix.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-ECI-frame coordinate transformation matrix are
     *                                                       invalid.
     */
    public static ECIFrame navigateECIAndReturnNew(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L6062">6062</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L6124">6124</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public static ECIFrame navigateECIAndReturnNew(final double timeInterval,
                                                   final Distance oldX,
                                                   final Distance oldY,
                                                   final Distance oldZ,
                                                   final CoordinateTransformation oldC,
                                                   final double oldVx,
                                                   final double oldVy,
                                                   final double oldVz,
                                                   final double fx,
                                                   final double fy,
                                                   final double fz,
                                                   final double angularRateX,
                                                   final double angularRateY,
                                                   final double angularRateZ)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        final ECIFrame result = new ECIFrame();
        navigateECI(timeInterval, oldX, oldY, oldZ, oldC, oldVx, oldVy, oldVz,
                fx, fy, fz, angularRateX, angularRateY, angularRateZ, result);
        return result;
    }

    /**
     * Runs precision ECI-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldX         previous cartesian x-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes.
     * @param oldY         previous cartesian y-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes.
     * @param oldZ         previous cartesian z-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes.
     * @param oldC         previous body-to-ECI-frame coordinate transformation.
     * @param oldVx        previous velocity x-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param oldVy        previous velocity y-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param oldVz        previous velocity z-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param fx           specific force x-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @return estimated ECI frame containing new body position, velocity and coordinate
     * transformation matrix.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-ECI-frame coordinate transformation matrix are invalid.
     */
    public static ECIFrame navigateECIAndReturnNew(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L6270">6270</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L6332">6332</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public static ECIFrame navigateECIAndReturnNew(final double timeInterval,
                                                   final double oldX,
                                                   final double oldY,
                                                   final double oldZ,
                                                   final CoordinateTransformation oldC,
                                                   final Speed oldSpeedX,
                                                   final Speed oldSpeedY,
                                                   final Speed oldSpeedZ,
                                                   final double fx,
                                                   final double fy,
                                                   final double fz,
                                                   final double angularRateX,
                                                   final double angularRateY,
                                                   final double angularRateZ)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        final ECIFrame result = new ECIFrame();
        navigateECI(timeInterval, oldX, oldY, oldZ, oldC, oldSpeedX, oldSpeedY, oldSpeedZ,
                fx, fy, fz, angularRateX, angularRateY, angularRateZ, result);
        return result;
    }

    /**
     * Runs precision ECI-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldX         previous cartesian x-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldY         previous cartesian y-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldZ         previous cartesian z-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldC         previous body-to-ECI-frame coordinate transformation.
     * @param oldSpeedX    previous velocity x-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes.
     * @param oldSpeedY    previous velocity y-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes.
     * @param oldSpeedZ    previous velocity z-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes.
     * @param fx           specific force x-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @return estimated ECI frame containing new body position, velocity and coordinate
     * transformation matrix.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-ECI-frame coordinate transformation matrix are invalid.
     */
    public static ECIFrame navigateECIAndReturnNew(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L6475">6475</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L6534">6534</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public static ECIFrame navigateECIAndReturnNew(final double timeInterval,
                                                   final double oldX,
                                                   final double oldY,
                                                   final double oldZ,
                                                   final CoordinateTransformation oldC,
                                                   final double oldVx,
                                                   final double oldVy,
                                                   final double oldVz,
                                                   final Acceleration fx,
                                                   final Acceleration fy,
                                                   final Acceleration fz,
                                                   final double angularRateX,
                                                   final double angularRateY,
                                                   final double angularRateZ)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        final ECIFrame result = new ECIFrame();
        navigateECI(timeInterval, oldX, oldY, oldZ, oldC, oldVx, oldVy, oldVz,
                fx, fy, fz, angularRateX, angularRateY, angularRateZ, result);
        return result;
    }

    /**
     * Runs precision ECI-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldX         previous cartesian x-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldY         previous cartesian y-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldZ         previous cartesian z-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldC         previous body-to-ECI-frame coordinate transformation.
     * @param oldVx        previous velocity x-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param oldVy        previous velocity y-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param oldVz        previous velocity z-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param fx           specific force x-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fy           specific force y-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fz           specific force z-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateX angular rate x-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @return estimated ECI frame containing new body position, velocity and coordinate
     * transformation matrix.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-ECI-frame coordinate transformation matrix are invalid.
     */
    public static ECIFrame navigateECIAndReturnNew(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L6593">6593</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L6652">6652</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public static ECIFrame navigateECIAndReturnNew(final double timeInterval,
                                                   final double oldX,
                                                   final double oldY,
                                                   final double oldZ,
                                                   final CoordinateTransformation oldC,
                                                   final double oldVx,
                                                   final double oldVy,
                                                   final double oldVz,
                                                   final double fx,
                                                   final double fy,
                                                   final double fz,
                                                   final AngularSpeed angularRateX,
                                                   final AngularSpeed angularRateY,
                                                   final AngularSpeed angularRateZ)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        final ECIFrame result = new ECIFrame();
        navigateECI(timeInterval, oldX, oldY, oldZ, oldC, oldVx, oldVy, oldVz,
                fx, fy, fz, angularRateX, angularRateY, angularRateZ, result);
        return result;
    }

    /**
     * Runs precision ECI-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldX         previous cartesian x-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldY         previous cartesian y-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldZ         previous cartesian z-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldC         previous body-to-ECI-frame coordinate transformation.
     * @param oldVx        previous velocity x-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param oldVy        previous velocity y-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param oldVz        previous velocity z-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param fx           specific force x-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateY angular rate y-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @return estimated ECI frame containing new body position, velocity and coordinate
     * transformation matrix.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-ECI-frame coordinate transformation matrix are invalid.
     */
    public static ECIFrame navigateECIAndReturnNew(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L6714">6714</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L6776">6776</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public static ECIFrame navigateECIAndReturnNew(final double timeInterval,
                                                   final Distance oldX,
                                                   final Distance oldY,
                                                   final Distance oldZ,
                                                   final CoordinateTransformation oldC,
                                                   final Speed oldSpeedX,
                                                   final Speed oldSpeedY,
                                                   final Speed oldSpeedZ,
                                                   final double fx,
                                                   final double fy,
                                                   final double fz,
                                                   final double angularRateX,
                                                   final double angularRateY,
                                                   final double angularRateZ)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        final ECIFrame result = new ECIFrame();
        navigateECI(timeInterval, oldX, oldY, oldZ, oldC, oldSpeedX, oldSpeedY, oldSpeedZ,
                fx, fy, fz, angularRateX, angularRateY, angularRateZ, result);
        return result;
    }

    /**
     * Runs precision ECI-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldX         previous cartesian x-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes.
     * @param oldY         previous cartesian y-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes.
     * @param oldZ         previous cartesian z-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes.
     * @param oldC         previous body-to-ECI-frame coordinate transformation.
     * @param oldSpeedX    previous velocity x-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes.
     * @param oldSpeedY    previous velocity y-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes.
     * @param oldSpeedZ    previous velocity z-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes.
     * @param fx           specific force x-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @return estimated ECI frame containing new body position, velocity and coordinate
     * transformation matrix.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-ECI-frame coordinate transformation matrix are invalid.
     */
    public static ECIFrame navigateECIAndReturnNew(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L6832">6832</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L6888">6888</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public static ECIFrame navigateECIAndReturnNew(final double timeInterval,
                                                   final Distance oldX,
                                                   final Distance oldY,
                                                   final Distance oldZ,
                                                   final CoordinateTransformation oldC,
                                                   final Speed oldSpeedX,
                                                   final Speed oldSpeedY,
                                                   final Speed oldSpeedZ,
                                                   final Acceleration fx,
                                                   final Acceleration fy,
                                                   final Acceleration fz,
                                                   final AngularSpeed angularRateX,
                                                   final AngularSpeed angularRateY,
                                                   final AngularSpeed angularRateZ)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        final ECIFrame result = new ECIFrame();
        navigateECI(timeInterval, oldX, oldY, oldZ, oldC, oldSpeedX, oldSpeedY, oldSpeedZ,
                fx, fy, fz, angularRateX, angularRateY, angularRateZ, result);
        return result;
    }

    /**
     * Runs precision ECI-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldX         previous cartesian x-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes.
     * @param oldY         previous cartesian y-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes.
     * @param oldZ         previous cartesian z-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes.
     * @param oldC         previous body-to-ECI-frame coordinate transformation.
     * @param oldSpeedX    previous velocity x-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes.
     * @param oldSpeedY    previous velocity y-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes.
     * @param oldSpeedZ    previous velocity z-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes.
     * @param fx           specific force x-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fy           specific force y-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fz           specific force z-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateX angular rate x-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateY angular rate y-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @return estimated ECI frame containing new body position, velocity and coordinate
     * transformation matrix.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-ECI-frame coordinate transformation matrix are invalid.
     */
    public static ECIFrame navigateECIAndReturnNew(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L6944">6944</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L7000">7000</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public static ECIFrame navigateECIAndReturnNew(final double timeInterval,
                                                   final double oldX,
                                                   final double oldY,
                                                   final double oldZ,
                                                   final CoordinateTransformation oldC,
                                                   final double oldVx,
                                                   final double oldVy,
                                                   final double oldVz,
                                                   final Acceleration fx,
                                                   final Acceleration fy,
                                                   final Acceleration fz,
                                                   final AngularSpeed angularRateX,
                                                   final AngularSpeed angularRateY,
                                                   final AngularSpeed angularRateZ)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        final ECIFrame result = new ECIFrame();
        navigateECI(timeInterval, oldX, oldY, oldZ, oldC, oldVx, oldVy, oldVz,
                fx, fy, fz, angularRateX, angularRateY, angularRateZ, result);
        return result;
    }

    /**
     * Runs precision ECI-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldX         previous cartesian x-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldY         previous cartesian y-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldZ         previous cartesian z-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldC         previous body-to-ECI-frame coordinate transformation.
     * @param oldVx        previous velocity x-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param oldVy        previous velocity y-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param oldVz        previous velocity z-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param fx           specific force x-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fy           specific force y-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fz           specific force z-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateX angular rate x-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateY angular rate y-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @return estimated ECI frame containing new body position, velocity and coordinate
     * transformation matrix.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-ECI-frame coordinate transformation matrix are invalid.
     */
    public static ECIFrame navigateECIAndReturnNew(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L11739">11739</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L11802">11802</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public static NEDFrame navigateNEDAndReturnNew(final double timeInterval,
                                                   final double oldLatitude,
                                                   final double oldLongitude,
                                                   final double oldHeight,
                                                   final CoordinateTransformation oldC,
                                                   final double oldVn,
                                                   final double oldVe,
                                                   final double oldVd,
                                                   final double fx,
                                                   final double fy,
                                                   final double fz,
                                                   final double angularRateX,
                                                   final double angularRateY,
                                                   final double angularRateZ)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        final NEDFrame result = new NEDFrame();
        navigateNED(timeInterval, oldLatitude, oldLongitude, oldHeight, oldC,
                oldVn, oldVe, oldVd, fx, fy, fz, angularRateX, angularRateY,
                angularRateZ, result);
        return result;
    }

    /**
     * Runs precision local-navigation-frame inertial navigation equations.
     * NOTE: only the attitude update and specific force frame transformation
     * phases are precise.
     *
     * @param timeInterval time interval between epochs.
     * @param oldLatitude  previous latitude expressed in radians (rad).
     * @param oldLongitude previous longitude expressed in radians (rad).
     * @param oldHeight    previous height expressed in meters (m).
     * @param oldC         previous body-to-NED coordinate transformation.
     * @param oldVn        previous velocity north-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param oldVe        previous velocity east-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param oldVd        previous velocity down-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @return estimated NED frame containing new body position, velocity and coordinate
     * transformation matrix.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-NED-frame coordinate transformation matrix are
     *                                                       invalid.
     */
    public static NEDFrame navigateNEDAndReturnNew(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L12493">12493</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L12556">12556</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public static NEDFrame navigateNEDAndReturnNew(final double timeInterval,
                                                   final Angle oldLatitude,
                                                   final Angle oldLongitude,
                                                   final Distance oldHeight,
                                                   final CoordinateTransformation oldC,
                                                   final double oldVn,
                                                   final double oldVe,
                                                   final double oldVd,
                                                   final double fx,
                                                   final double fy,
                                                   final double fz,
                                                   final double angularRateX,
                                                   final double angularRateY,
                                                   final double angularRateZ)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        final NEDFrame result = new NEDFrame();
        navigateNED(timeInterval, oldLatitude, oldLongitude, oldHeight, oldC,
                oldVn, oldVe, oldVd, fx, fy, fz, angularRateX, angularRateY, angularRateZ,
                result);
        return result;
    }

    /**
     * Runs precision local-navigation-frame inertial navigation equations.
     * NOTE: only the attitude update and specific force frame transformation
     * phases are precise.
     *
     * @param timeInterval time interval between epochs.
     * @param oldLatitude  previous latitude angle.
     * @param oldLongitude previous longitude angle.
     * @param oldHeight    previous height.
     * @param oldC         previous body-to-NED coordinate transformation.
     * @param oldVn        previous velocity north-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param oldVe        previous velocity east-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param oldVd        previous velocity down-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @return estimated NED frame containing new body position, velocity and coordinate
     * transformation matrix.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-NED-frame coordinate transformation matrix are
     *                                                       invalid.
     */
    public static NEDFrame navigateNEDAndReturnNew(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L12885">12885</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L12948">12948</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public static NEDFrame navigateNEDAndReturnNew(final double timeInterval,
                                                   final double oldLatitude,
                                                   final double oldLongitude,
                                                   final double oldHeight,
                                                   final CoordinateTransformation oldC,
                                                   final Speed oldSpeedN,
                                                   final Speed oldSpeedE,
                                                   final Speed oldSpeedD,
                                                   final double fx,
                                                   final double fy,
                                                   final double fz,
                                                   final double angularRateX,
                                                   final double angularRateY,
                                                   final double angularRateZ)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        final NEDFrame result = new NEDFrame();
        navigateNED(timeInterval, oldLatitude, oldLongitude, oldHeight, oldC,
                oldSpeedN, oldSpeedE, oldSpeedD, fx, fy, fz, angularRateX,
                angularRateY, angularRateZ, result);
        return result;
    }

    /**
     * Runs precision local-navigation-frame inertial navigation equations.
     * NOTE: only the attitude update and specific force frame transformation
     * phases are precise.
     *
     * @param timeInterval time interval between epochs.
     * @param oldLatitude  previous latitude expressed in radians (rad).
     * @param oldLongitude previous longitude expressed in radians (rad).
     * @param oldHeight    previous height expressed in meters (m).
     * @param oldC         previous body-to-NED coordinate transformation.
     * @param oldSpeedN    previous velocity north-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes.
     * @param oldSpeedE    previous velocity east-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes.
     * @param oldSpeedD    previous velocity down-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes.
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @return estimated NED frame containing new body position, velocity and coordinate
     * transformation matrix.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-NED-frame coordinate transformation matrix are
     *                                                       invalid.
     */
    public static NEDFrame navigateNEDAndReturnNew(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L13284">13284</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L13344">13344</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public static NEDFrame navigateNEDAndReturnNew(final double timeInterval,
                                                   final double oldLatitude,
                                                   final double oldLongitude,
                                                   final double oldHeight,
                                                   final CoordinateTransformation oldC,
                                                   final double oldVn,
                                                   final double oldVe,
                                                   final double oldVd,
                                                   final Acceleration fx,
                                                   final Acceleration fy,
                                                   final Acceleration fz,
                                                   final double angularRateX,
                                                   final double angularRateY,
                                                   final double angularRateZ)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        final NEDFrame result = new NEDFrame();
        navigateNED(timeInterval, oldLatitude, oldLongitude, oldHeight, oldC,
                oldVn, oldVe, oldVd, fx, fy, fz,
                angularRateX, angularRateY, angularRateZ, result);
        return result;
    }

    /**
     * Runs precision local-navigation-frame inertial navigation equations.
     * NOTE: only the attitude update and specific force frame transformation
     * phases are precise.
     *
     * @param timeInterval time interval between epochs.
     * @param oldLatitude  previous latitude expressed in radians (rad).
     * @param oldLongitude previous longitude expressed in radians (rad).
     * @param oldHeight    previous height expressed in meters (m).
     * @param oldC         previous body-to-NED coordinate transformation.
     * @param oldVn        previous velocity north-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param oldVe        previous velocity east-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param oldVd        previous velocity down-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @return estimated NED frame containing new body position, velocity and coordinate
     * transformation matrix.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-NED-frame coordinate transformation matrix are
     *                                                       invalid.
     */
    public static NEDFrame navigateNEDAndReturnNew(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L13724">13724</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L13784">13784</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public static NEDFrame navigateNEDAndReturnNew(final double timeInterval,
                                                   final double oldLatitude,
                                                   final double oldLongitude,
                                                   final double oldHeight,
                                                   final CoordinateTransformation oldC,
                                                   final double oldVn,
                                                   final double oldVe,
                                                   final double oldVd,
                                                   final double fx,
                                                   final double fy,
                                                   final double fz,
                                                   final AngularSpeed angularRateX,
                                                   final AngularSpeed angularRateY,
                                                   final AngularSpeed angularRateZ)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        final NEDFrame result = new NEDFrame();
        navigateNED(timeInterval, oldLatitude, oldLongitude, oldHeight, oldC,
                oldVn, oldVe, oldVd, fx, fy, fz,
                angularRateX, angularRateY, angularRateZ, result);
        return result;
    }

    /**
     * Runs precision local-navigation-frame inertial navigation equations.
     * NOTE: only the attitude update and specific force frame transformation
     * phases are precise.
     *
     * @param timeInterval time interval between epochs.
     * @param oldLatitude  previous latitude expressed in radians (rad).
     * @param oldLongitude previous longitude expressed in radians (rad).
     * @param oldHeight    previous height expressed in meters (m).
     * @param oldC         previous body-to-NED coordinate transformation.
     * @param oldVn        previous velocity north-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param oldVe        previous velocity east-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param oldVd        previous velocity down-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @return estimated NED frame containing new body position, velocity and coordinate
     * transformation matrix.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-NED-frame coordinate transformation matrix are
     *                                                       invalid.
     */
    public static NEDFrame navigateNEDAndReturnNew(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L14167">14167</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L14230">14230</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public static NEDFrame navigateNEDAndReturnNew(final double timeInterval,
                                                   final Angle oldLatitude,
                                                   final Angle oldLongitude,
                                                   final Distance oldHeight,
                                                   final CoordinateTransformation oldC,
                                                   final Speed oldSpeedN,
                                                   final Speed oldSpeedE,
                                                   final Speed oldSpeedD,
                                                   final double fx,
                                                   final double fy,
                                                   final double fz,
                                                   final double angularRateX,
                                                   final double angularRateY,
                                                   final double angularRateZ)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        final NEDFrame result = new NEDFrame();
        navigateNED(timeInterval, oldLatitude, oldLongitude, oldHeight,
                oldC, oldSpeedN, oldSpeedE, oldSpeedD, fx, fy, fz,
                angularRateX, angularRateY, angularRateZ, result);
        return result;
    }

    /**
     * Runs precision local-navigation-frame inertial navigation equations.
     * NOTE: only the attitude update and specific force frame transformation
     * phases are precise.
     *
     * @param timeInterval time interval between epochs.
     * @param oldLatitude  previous latitude angle.
     * @param oldLongitude previous longitude angle.
     * @param oldHeight    previous height.
     * @param oldC         previous body-to-NED coordinate transformation.
     * @param oldSpeedN    previous velocity north-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes.
     * @param oldSpeedE    previous velocity east-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes.
     * @param oldSpeedD    previous velocity down-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes.
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @return estimated NED frame containing new body position, velocity and coordinate
     * transformation matrix.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-NED-frame coordinate transformation matrix are
     *                                                       invalid.
     */
    public static NEDFrame navigateNEDAndReturnNew(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L14287">14287</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L14344">14344</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public static NEDFrame navigateNEDAndReturnNew(final double timeInterval,
                                                   final Angle oldLatitude,
                                                   final Angle oldLongitude,
                                                   final Distance oldHeight,
                                                   final CoordinateTransformation oldC,
                                                   final Speed oldSpeedN,
                                                   final Speed oldSpeedE,
                                                   final Speed oldSpeedD,
                                                   final Acceleration fx,
                                                   final Acceleration fy,
                                                   final Acceleration fz,
                                                   final AngularSpeed angularRateX,
                                                   final AngularSpeed angularRateY,
                                                   final AngularSpeed angularRateZ)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        final NEDFrame result = new NEDFrame();
        navigateNED(timeInterval, oldLatitude, oldLongitude, oldHeight,
                oldC, oldSpeedN, oldSpeedE, oldSpeedD, fx, fy, fz,
                angularRateX, angularRateY, angularRateZ, result);
        return result;
    }

    /**
     * Runs precision local-navigation-frame inertial navigation equations.
     * NOTE: only the attitude update and specific force frame transformation
     * phases are precise.
     *
     * @param timeInterval time interval between epochs.
     * @param oldLatitude  previous latitude angle.
     * @param oldLongitude previous longitude angle.
     * @param oldHeight    previous height.
     * @param oldC         previous body-to-NED coordinate transformation.
     * @param oldSpeedN    previous velocity north-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes.
     * @param oldSpeedE    previous velocity east-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes.
     * @param oldSpeedD    previous velocity down-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes.
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @return estimated NED frame containing new body position, velocity and coordinate
     * transformation matrix.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-NED-frame coordinate transformation matrix are
     *                                                       invalid.
     */
    public static NEDFrame navigateNEDAndReturnNew(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L14401">14401</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L14458">14458</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public static NEDFrame navigateNEDAndReturnNew(final double timeInterval,
                                                   final double oldLatitude,
                                                   final double oldLongitude,
                                                   final double oldHeight,
                                                   final CoordinateTransformation oldC,
                                                   final Speed oldSpeedN,
                                                   final Speed oldSpeedE,
                                                   final Speed oldSpeedD,
                                                   final Acceleration fx,
                                                   final Acceleration fy,
                                                   final Acceleration fz,
                                                   final AngularSpeed angularRateX,
                                                   final AngularSpeed angularRateY,
                                                   final AngularSpeed angularRateZ)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        final NEDFrame result = new NEDFrame();
        navigateNED(timeInterval, oldLatitude, oldLongitude, oldHeight, oldC,
                oldSpeedN, oldSpeedE, oldSpeedD, fx, fy, fz, angularRateX,
                angularRateY, angularRateZ, result);
        return result;
    }

    /**
     * Runs precision local-navigation-frame inertial navigation equations.
     * NOTE: only the attitude update and specific force frame transformation
     * phases are precise.
     *
     * @param timeInterval time interval between epochs.
     * @param oldLatitude  previous latitude expressed in radians (rad).
     * @param oldLongitude previous longitude expressed in radians (rad).
     * @param oldHeight    previous height expressed in meters (m).
     * @param oldC         previous body-to-NED coordinate transformation.
     * @param oldSpeedN    previous velocity north-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes.
     * @param oldSpeedE    previous velocity east-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes.
     * @param oldSpeedD    previous velocity down-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes.
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @return estimated NED frame containing new body position, velocity and coordinate
     * transformation matrix.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-NED-frame coordinate transformation matrix are
     *                                                       invalid.
     */
    public static NEDFrame navigateNEDAndReturnNew(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L14817">14817</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L14874">14874</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public static NEDFrame navigateNEDAndReturnNew(final double timeInterval,
                                                   final Angle oldLatitude,
                                                   final Angle oldLongitude,
                                                   final Distance oldHeight,
                                                   final CoordinateTransformation oldC,
                                                   final double oldVn,
                                                   final double oldVe,
                                                   final double oldVd,
                                                   final Acceleration fx,
                                                   final Acceleration fy,
                                                   final Acceleration fz,
                                                   final AngularSpeed angularRateX,
                                                   final AngularSpeed angularRateY,
                                                   final AngularSpeed angularRateZ)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        final NEDFrame result = new NEDFrame();
        navigateNED(timeInterval, oldLatitude, oldLongitude, oldHeight,
                oldC, oldVn, oldVe, oldVd, fx, fy, fz,
                angularRateX, angularRateY, angularRateZ, result);
        return result;
    }

    /**
     * Runs precision local-navigation-frame inertial navigation equations.
     * NOTE: only the attitude update and specific force frame transformation
     * phases are precise.
     *
     * @param timeInterval time interval between epochs.
     * @param oldLatitude  previous latitude angle.
     * @param oldLongitude previous longitude angle.
     * @param oldHeight    previous height.
     * @param oldC         previous body-to-NED coordinate transformation.
     * @param oldVn        previous velocity north-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param oldVe        previous velocity east-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param oldVd        previous velocity down-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @return estimated NED frame containing new body position, velocity and coordinate
     * transformation matrix.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-NED-frame coordinate transformation matrix are
     *                                                       invalid.
     */
    public static NEDFrame navigateNEDAndReturnNew(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L15037">15037</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L15094">15094</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public static NEDFrame navigateNEDAndReturnNew(final double timeInterval,
                                                   final double oldLatitude,
                                                   final double oldLongitude,
                                                   final double oldHeight,
                                                   final CoordinateTransformation oldC,
                                                   final double oldVn,
                                                   final double oldVe,
                                                   final double oldVd,
                                                   final Acceleration fx,
                                                   final Acceleration fy,
                                                   final Acceleration fz,
                                                   final AngularSpeed angularRateX,
                                                   final AngularSpeed angularRateY,
                                                   final AngularSpeed angularRateZ)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        final NEDFrame result = new NEDFrame();
        navigateNED(timeInterval, oldLatitude, oldLongitude, oldHeight, oldC,
                oldVn, oldVe, oldVd, fx, fy, fz, angularRateX, angularRateY, angularRateZ,
                result);
        return result;
    }

    /**
     * Runs precision local-navigation-frame inertial navigation equations.
     * NOTE: only the attitude update and specific force frame transformation
     * phases are precise.
     *
     * @param timeInterval time interval between epochs.
     * @param oldLatitude  previous latitude expressed in radians (rad).
     * @param oldLongitude previous longitude expressed in radians (rad).
     * @param oldHeight    previous height expressed in meters (m).
     * @param oldC         previous body-to-NED coordinate transformation.
     * @param oldVn        previous velocity north-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param oldVe        previous velocity east-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param oldVd        previous velocity down-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @return estimated NED frame containing new body position, velocity and coordinate
     * transformation matrix.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-NED-frame coordinate transformation matrix are
     *                                                       invalid.
     */
    public static NEDFrame navigateNEDAndReturnNew(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/lateration/LaterationSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/LaterationSolver.html#L223">223</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/lateration/RobustLaterationSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/RobustLaterationSolver.html#L738">738</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public abstract int getMinRequiredPositionsAndDistances();

    /**
     * Internally sets known positions and euclidean distances.
     * If any distance value is zero or negative, it will be fixed assuming an EPSILON value.
     * @param positions known positios of static nodes.
     * @param distances euclidean distances from static nodes to mobile node.
     * @throws IllegalArgumentException if either positions or distances are null, don't have the same length or their
     * length is smaller than required (2 points).
     */
    protected void internalSetPositionsAndDistances(P[] positions, double[] distances) {
        if(positions == null || distances == null) {
            throw new IllegalArgumentException();
        }

        if (positions.length &lt; getMinRequiredPositionsAndDistances()) {
            throw new IllegalArgumentException();
        }

        if (positions.length != distances.length) {
            throw new IllegalArgumentException();
        }

        mPositions = positions;
        mDistances = distances;

        //fix distances if needed
        for (int i = 0; i &lt; mDistances.length; i++) {
            if (mDistances[i] &lt; EPSILON) {
                mDistances[i] = EPSILON;
            }
        }
    }</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/PROMedSRobustRssiPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROMedSRobustRssiPositionEstimator3D.html#L361">361</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/PROSACRobustMixedPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROSACRobustMixedPositionEstimator3D.html#L357">357</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/PROSACRobustRangingAndRssiPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROSACRobustRangingAndRssiPositionEstimator3D.html#L361">361</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/PROSACRobustRangingPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROSACRobustRangingPositionEstimator3D.html#L357">357</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>            RobustRssiPositionEstimatorListener&lt;Point3D&gt; listener) {
        this(sources, fingerprint, listener);
        internalSetSourceQualityScores(sourceQualityScores);
        internalSetFingerprintReadingsQualityScores(fingerprintReadingQualityScores);
    }

    /**
     * Returns quality scores corresponding to each radio source.
     * The larger the score value the better the quality of the sample.
     *
     * @return quality scores corresponding to each radio source.
     */
    public double[] getSourceQualityScores() {
        return mSourceQualityScores;
    }

    /**
     * Sets quality scores corresponding to each radio source.
     * The larger the score value the better the quality of the radio source.
     *
     * @param sourceQualityScores quality scores corresponding to each radio source.
     * @throws LockedException          if this instance is locked.
     * @throws IllegalArgumentException if provided quality scores length is smaller
     *                                  than minimum required samples.
     */
    public void setSourceQualityScores(double[] sourceQualityScores)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetSourceQualityScores(sourceQualityScores);
    }

    /**
     * Gets quality scores corresponding to each reading within provided fingerprint.
     * The larger the score value the better the quality of the reading.
     * This implementation always returns null.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @return quality scores corresponding to each reading within provided
     * fingerprint.
     */
    public double[] getFingerprintReadingsQualityScores() {
        return mFingerprintReadingsQualityScores;
    }

    /**
     * Sets quality scores corresponding to each reading within provided fingerprint.
     * The larger the score value the better the quality of the reading.
     * This implementation makes no action.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @param fingerprintReadingsQualityScores quality scores corresponding to each
     *                                         reading within provided fingerprint.
     * @throws LockedException          if this instance is locked.
     * @throws IllegalArgumentException if provided quality scores length is smaller
     *                                  than minimum required samples.
     */
    public void setFingerprintReadingsQualityScores(
            double[] fingerprintReadingsQualityScores) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetFingerprintReadingsQualityScores(fingerprintReadingsQualityScores);
    }

    /**
     * Returns threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value, the
     * algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algrithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @return stop threshold to stop the algorithm prematurely when a certain
     * accuracy has been reached.
     */
    public double getStopThreshold() {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/LMedSRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/LMedSRobustRangingRadioSourceEstimator2D.html#L174">174</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/LMedSRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/LMedSRobustRangingRadioSourceEstimator3D.html#L174">174</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>            RobustRangingRadioSourceEstimatorListener&lt;S, Point2D&gt; listener) {
        super(readings, initialPosition, listener);
    }

    /**
     * Returns threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value, the
     * algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algrithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @return stop threshold to stop the algorithm prematurely when a certain
     * accuracy has been reached.
     */
    public double getStopThreshold() {
        return mStopThreshold;
    }

    /**
     * Sets threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value,
     * the algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algorithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @param stopThreshold stop threshold to stop the algorithm prematurely
     *                      when a certain accuracy has been reached.
     * @throws IllegalArgumentException if provided value is zero or negative.
     * @throws LockedException if this solver is locked.
     */
    public void setStopThreshold(double stopThreshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (stopThreshold &lt;= MIN_STOP_THRESHOLD) {
            throw new IllegalArgumentException();
        }

        mStopThreshold = stopThreshold;
    }

    /**
     * Robustly estimates position for a radio source.
     *
     * @throws LockedException if instance is busy during estimation.
     * @throws NotReadyException if estimator is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     * (i.e. numerical instability, no solution available, etc).
     */
    @Override
    public void estimate() throws LockedException, NotReadyException,
            RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        LMedSRobustEstimator&lt;Solution&lt;Point2D&gt;&gt; innerEstimator =</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRangingAndRssiRadioSourceEstimator2D.html#L426">426</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRssiRadioSourceEstimator2D.html#L437">437</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator2D.html#L992">992</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator2D.html#L482">482</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator2D.html#L997">997</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator2D.html#L503">503</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator2D.html#L275">275</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator2D.html#L514">514</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                    @Override
                    public double getThreshold() {
                        return mThreshold;
                    }

                    @Override
                    public int getTotalSamples() {
                        return mReadings.size();
                    }

                    @Override
                    public int getSubsetSize() {
                        return Math.max(mPreliminarySubsetSize, getMinReadings());
                    }

                    @Override
                    public void estimatePreliminarSolutions(int[] samplesIndices,
                            List&lt;Solution&lt;Point2D&gt;&gt; solutions) {
                        solvePreliminarSolutions(samplesIndices, solutions);
                    }

                    @Override
                    public double computeResidual(Solution&lt;Point2D&gt; currentEstimation, int i) {
                        return residual(currentEstimation, i);
                    }

                    @Override
                    public boolean isReady() {
                        return MSACRobustRangingAndRssiRadioSourceEstimator2D.this.isReady();</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRangingAndRssiRadioSourceEstimator3D.html#L426">426</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRssiRadioSourceEstimator3D.html#L437">437</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingAndRssiRadioSourceEstimator3D.html#L992">992</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRangingRadioSourceEstimator3D.html#L482">482</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/PROSACRobustRssiRadioSourceEstimator3D.html#L996">996</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingAndRssiRadioSourceEstimator3D.html#L503">503</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRangingRadioSourceEstimator3D.html#L275">275</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RANSACRobustRssiRadioSourceEstimator3D.html#L513">513</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                            @Override
                            public double getThreshold() {
                                return mThreshold;
                            }

                            @Override
                            public int getTotalSamples() {
                                return mReadings.size();
                            }

                            @Override
                            public int getSubsetSize() {
                                return Math.max(mPreliminarySubsetSize, getMinReadings());
                            }

                            @Override
                            public void estimatePreliminarSolutions(int[] samplesIndices,
                                                                    List&lt;Solution&lt;Point3D&gt;&gt; solutions) {
                                solvePreliminarSolutions(samplesIndices, solutions);
                            }

                            @Override
                            public double computeResidual(Solution&lt;Point3D&gt; currentEstimation, int i) {
                                return residual(currentEstimation, i);
                            }

                            @Override
                            public boolean isReady() {
                                return MSACRobustRangingAndRssiRadioSourceEstimator3D.this.isReady();</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRangingRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRangingRadioSourceEstimator2D.html#L150">150</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/MSACRobustRangingRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MSACRobustRangingRadioSourceEstimator3D.html#L150">150</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>            RobustRangingRadioSourceEstimatorListener&lt;S, Point2D&gt; listener) {
        super(readings, initialPosition, listener);
    }

    /**
     * Returns threshold to determine whether samples are inliers or not.
     *
     * @return threshold to determine whether samples are inliers or not.
     */
    public double getThreshold() {
        return mThreshold;
    }

    /**
     * Sets threshold to determine whether samples are inliers or not.
     *
     * @param threshold threshold to be set.
     * @throws IllegalArgumentException if provided value is equal or less than
     * zero.
     * @throws LockedException if robust estimator is locked because an
     * estimation is already in progress.
     */
    public void setThreshold(double threshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (threshold &lt;= MIN_THRESHOLD) {
            throw new IllegalArgumentException();
        }
        mThreshold = threshold;
    }

    /**
     * Robustly estimates position for a radio source.
     *
     * @throws LockedException if instance is busy during estimation.
     * @throws NotReadyException if estimator is not ready.
     * @throws RobustEstimatorException if estimation fails for any reason
     * (i.e. numerical instability, no solution available, etc).
     */
    @Override
    public void estimate() throws LockedException, NotReadyException,
            RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        MSACRobustEstimator&lt;Solution&lt;Point2D&gt;&gt; innerEstimator =</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/INSLooselyCoupledKalmanState.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/INSLooselyCoupledKalmanState.html#L1974">1974</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/INSTightlyCoupledKalmanState.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/INSTightlyCoupledKalmanState.html#L2247">2247</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public void copyFrom(final INSLooselyCoupledKalmanState input) {
        // copy coordinate transformation matrix
        if (input.mBodyToEcefCoordinateTransformationMatrix == null) {
            mBodyToEcefCoordinateTransformationMatrix = null;
        } else {
            if (mBodyToEcefCoordinateTransformationMatrix == null) {
                mBodyToEcefCoordinateTransformationMatrix =
                        new Matrix(input.mBodyToEcefCoordinateTransformationMatrix);
            } else {
                mBodyToEcefCoordinateTransformationMatrix.copyFrom(
                        input.mBodyToEcefCoordinateTransformationMatrix);
            }
        }

        mVx = input.mVx;
        mVy = input.mVy;
        mVz = input.mVz;

        mX = input.mX;
        mY = input.mY;
        mZ = input.mZ;

        mAccelerationBiasX = input.mAccelerationBiasX;
        mAccelerationBiasY = input.mAccelerationBiasY;
        mAccelerationBiasZ = input.mAccelerationBiasZ;

        mGyroBiasX = input.mGyroBiasX;
        mGyroBiasY = input.mGyroBiasY;
        mGyroBiasZ = input.mGyroBiasZ;</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/calibration/KnownBiasAndFrameAccelerometerLinearLeastSquaresCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/KnownBiasAndFrameAccelerometerLinearLeastSquaresCalibrator.html#L1293">1293</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/calibration/KnownBiasAndFrameAccelerometerLinearLeastSquaresCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/KnownBiasAndFrameAccelerometerLinearLeastSquaresCalibrator.html#L1404">1404</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/calibration/KnownBiasAndFrameAccelerometerNonLinearLeastSquaresCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/KnownBiasAndFrameAccelerometerNonLinearLeastSquaresCalibrator.html#L3309">3309</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/calibration/KnownFrameAccelerometerLinearLeastSquaresCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/KnownFrameAccelerometerLinearLeastSquaresCalibrator.html#L819">819</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/calibration/KnownFrameAccelerometerLinearLeastSquaresCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/KnownFrameAccelerometerLinearLeastSquaresCalibrator.html#L929">929</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/calibration/KnownFrameAccelerometerNonLinearLeastSquaresCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/KnownFrameAccelerometerNonLinearLeastSquaresCalibrator.html#L3837">3837</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>        for (final FrameBodyKinematics measurement : mMeasurements) {
            final BodyKinematics measuredKinematics = measurement.getKinematics();
            final ECEFFrame ecefFrame = measurement.getFrame();
            final ECEFFrame previousEcefFrame = measurement.getPreviousFrame();
            final double timeInterval = measurement.getTimeInterval();

            ECEFKinematicsEstimator.estimateKinematics(timeInterval, ecefFrame,
                    previousEcefFrame, expectedKinematics);

            final double fMeasX = measuredKinematics.getFx();
            final double fMeasY = measuredKinematics.getFy();
            final double fMeasZ = measuredKinematics.getFz();

            final double fTrueX = expectedKinematics.getFx();
            final double fTrueY = expectedKinematics.getFy();
            final double fTrueZ = expectedKinematics.getFz();</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/calibration/MSACRobustKnownBiasAndFrameAccelerometerCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/MSACRobustKnownBiasAndFrameAccelerometerCalibrator.html#L754">754</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/calibration/RANSACRobustKnownBiasAndFrameAccelerometerCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/RANSACRobustKnownBiasAndFrameAccelerometerCalibrator.html#L827">827</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                new MSACRobustEstimator&lt;&gt;(new MSACRobustEstimatorListener&lt;Matrix&gt;() {
                    @Override
                    public double getThreshold() {
                        return mThreshold;
                    }

                    @Override
                    public int getTotalSamples() {
                        return mMeasurements.size();
                    }

                    @Override
                    public int getSubsetSize() {
                        return mPreliminarySubsetSize;
                    }

                    @Override
                    public void estimatePreliminarSolutions(final int[] samplesIndices,
                                                            final List&lt;Matrix&gt; solutions) {
                        computePreliminarySolutions(samplesIndices, solutions);
                    }

                    @Override
                    public double computeResidual(final Matrix currentEstimation, final int i) {
                        return computeError(mMeasurements.get(i), currentEstimation);
                    }

                    @Override
                    public boolean isReady() {
                        return MSACRobustKnownBiasAndFrameAccelerometerCalibrator.super.isReady();</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/calibration/MSACRobustKnownFrameAccelerometerCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/MSACRobustKnownFrameAccelerometerCalibrator.html#L215">215</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/calibration/RANSACRobustKnownFrameAccelerometerCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/RANSACRobustKnownFrameAccelerometerCalibrator.html#L288">288</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                new MSACRobustEstimator&lt;&gt;(new MSACRobustEstimatorListener&lt;PreliminaryResult&gt;() {
                    @Override
                    public double getThreshold() {
                        return mThreshold;
                    }

                    @Override
                    public int getTotalSamples() {
                        return mMeasurements.size();
                    }

                    @Override
                    public int getSubsetSize() {
                        return mPreliminarySubsetSize;
                    }

                    @Override
                    public void estimatePreliminarSolutions(final int[] samplesIndices,
                                                            final List&lt;PreliminaryResult&gt; solutions) {
                        computePreliminarySolutions(samplesIndices, solutions);
                    }

                    @Override
                    public double computeResidual(final PreliminaryResult currentEstimation, final int i) {
                        return computeError(mMeasurements.get(i), currentEstimation);
                    }

                    @Override
                    public boolean isReady() {
                        return MSACRobustKnownFrameAccelerometerCalibrator.super.isReady();</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L11431">11431</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L11565">11565</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                                    final double fz,
                                    final double angularRateX,
                                    final double angularRateY,
                                    final double angularRateZ,
                                    final ECEFFrame result)
            throws InertialNavigatorException {
        try {
            navigateECEF(timeInterval, oldFrame.getX(), oldFrame.getY(), oldFrame.getZ(),
                    oldFrame.getCoordinateTransformation(),
                    oldFrame.getVx(), oldFrame.getVy(), oldFrame.getVz(), fx, fy, fz,
                    angularRateX, angularRateY, angularRateZ, result);
        } catch (final InvalidSourceAndDestinationFrameTypeException ignore) {
            // never happens
        }
    }

    /**
     * Runs precision ECEF-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldFrame     previous ECEF frame containing body position, velocity and
     *                     coordinate transformation matrix.
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param result       instance where new estimated ECEF frame containing new body
     *                     position, velocity and coordinate transformation matrix will be stored.
     * @throws InertialNavigatorException if navigation fails due to numerical instabilities.
     */
    public static void navigateECEF(final Time timeInterval,
                                    final ECEFFrame oldFrame,
                                    final double fx,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L11434">11434</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L11652">11652</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                                    final double angularRateZ,
                                    final ECEFFrame result)
            throws InertialNavigatorException {
        try {
            navigateECEF(timeInterval, oldFrame.getX(), oldFrame.getY(), oldFrame.getZ(),
                    oldFrame.getCoordinateTransformation(),
                    oldFrame.getVx(), oldFrame.getVy(), oldFrame.getVz(), fx, fy, fz,
                    angularRateX, angularRateY, angularRateZ, result);
        } catch (final InvalidSourceAndDestinationFrameTypeException ignore) {
            // never happens
        }
    }

    /**
     * Runs precision ECEF-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldFrame     previous ECEF frame containing body position, velocity and
     *                     coordinate transformation matrix.
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param result       instance where new estimated ECEF frame containing new body
     *                     position, velocity and coordinate transformation matrix will be stored.
     * @throws InertialNavigatorException if navigation fails due to numerical instabilities.
     */
    public static void navigateECEF(final Time timeInterval,
                                    final ECEFFrame oldFrame,
                                    final double fx,
                                    final double fy,
                                    final double fz,
                                    final double angularRateX,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L11568">11568</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L11733">11733</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                                    final double angularRateZ,
                                    final ECEFFrame result)
            throws InertialNavigatorException {
        try {
            navigateECEF(timeInterval, oldFrame.getX(), oldFrame.getY(), oldFrame.getZ(),
                    oldFrame.getCoordinateTransformation(),
                    oldFrame.getVx(), oldFrame.getVy(), oldFrame.getVz(), fx, fy, fz,
                    angularRateX, angularRateY, angularRateZ, result);
        } catch (final InvalidSourceAndDestinationFrameTypeException ignore) {
            // never happens
        }
    }

    /**
     * Runs precision ECEF-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldFrame     previous ECEF frame containing body position, velocity and
     *                     coordinate transformation matrix.
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param result       instance where new estimated ECEF frame containing new body
     *                     position, velocity and coordinate transformation matrix will be stored.
     * @throws InertialNavigatorException if navigation fails due to numerical instabilities.
     */
    public static void navigateECEF(final Time timeInterval,
                                    final ECEFFrame oldFrame,
                                    final Acceleration fx,
                                    final Acceleration fy,
                                    final Acceleration fz,
                                    final double angularRateX,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L11649">11649</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L11730">11730</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                                    final double fz,
                                    final AngularSpeed angularRateX,
                                    final AngularSpeed angularRateY,
                                    final AngularSpeed angularRateZ,
                                    final ECEFFrame result)
            throws InertialNavigatorException {
        try {
            navigateECEF(timeInterval, oldFrame.getX(), oldFrame.getY(), oldFrame.getZ(),
                    oldFrame.getCoordinateTransformation(),
                    oldFrame.getVx(), oldFrame.getVy(), oldFrame.getVz(), fx, fy, fz,
                    angularRateX, angularRateY, angularRateZ, result);
        } catch (final InvalidSourceAndDestinationFrameTypeException ignore) {
            // never happens
        }
    }

    /**
     * Runs precision ECEF-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldFrame     previous ECEF frame containing body position, velocity and
     *                     coordinate transformation matrix.
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param result       instance where new estimated ECEF frame containing new body
     *                     position, velocity and coordinate transformation matrix will be stored.
     * @throws InertialNavigatorException if navigation fails due to numerical instabilities.
     */
    public static void navigateECEF(final Time timeInterval,
                                    final ECEFFrame oldFrame,
                                    final double fx,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L5275">5275</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L5409">5409</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                                   final double fz,
                                   final double angularRateX,
                                   final double angularRateY,
                                   final double angularRateZ,
                                   final ECIFrame result)
            throws InertialNavigatorException {
        try {
            navigateECI(timeInterval, oldFrame.getX(), oldFrame.getY(), oldFrame.getZ(),
                    oldFrame.getCoordinateTransformation(),
                    oldFrame.getVx(), oldFrame.getVy(), oldFrame.getVz(), fx, fy, fz,
                    angularRateX, angularRateY, angularRateZ, result);
        } catch (final InvalidSourceAndDestinationFrameTypeException ignore) {
            // never happens
        }
    }

    /**
     * Runs precision ECI-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldFrame     previous ECI frame containing body position, velocity and
     *                     coordinate transformation matrix.
     * @param fx           specific force x-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param result       instance where new estimated ECI frame containing new body position,
     *                     velocity and coordinate transformation matrix will be stored.
     * @throws InertialNavigatorException if navigation fails due to numerical instabilities.
     */
    public static void navigateECI(final Time timeInterval,
                                   final ECIFrame oldFrame,
                                   final double fx,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L5278">5278</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L5496">5496</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                                   final double angularRateZ,
                                   final ECIFrame result)
            throws InertialNavigatorException {
        try {
            navigateECI(timeInterval, oldFrame.getX(), oldFrame.getY(), oldFrame.getZ(),
                    oldFrame.getCoordinateTransformation(),
                    oldFrame.getVx(), oldFrame.getVy(), oldFrame.getVz(), fx, fy, fz,
                    angularRateX, angularRateY, angularRateZ, result);
        } catch (final InvalidSourceAndDestinationFrameTypeException ignore) {
            // never happens
        }
    }

    /**
     * Runs precision ECI-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldFrame     previous ECI frame containing body position, velocity and
     *                     coordinate transformation matrix.
     * @param fx           specific force x-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param result       instance where new estimated ECI frame containing new body position,
     *                     velocity and coordinate transformation matrix will be stored.
     * @throws InertialNavigatorException if navigation fails due to numerical instabilities.
     */
    public static void navigateECI(final Time timeInterval,
                                   final ECIFrame oldFrame,
                                   final double fx,
                                   final double fy,
                                   final double fz,
                                   final double angularRateX,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L5412">5412</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L5577">5577</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                                   final double angularRateZ,
                                   final ECIFrame result)
            throws InertialNavigatorException {
        try {
            navigateECI(timeInterval, oldFrame.getX(), oldFrame.getY(), oldFrame.getZ(),
                    oldFrame.getCoordinateTransformation(),
                    oldFrame.getVx(), oldFrame.getVy(), oldFrame.getVz(), fx, fy, fz,
                    angularRateX, angularRateY, angularRateZ, result);
        } catch (final InvalidSourceAndDestinationFrameTypeException ignore) {
            // never happens
        }
    }

    /**
     * Runs precision ECI-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldFrame     previous ECI frame containing body position, velocity and
     *                     coordinate transformation matrix.
     * @param fx           specific force x-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fy           specific force y-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fz           specific force z-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateX angular rate x-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param result       instance where new estimated ECI frame containing new body position,
     *                     velocity and coordinate transformation matrix will be stored.
     * @throws InertialNavigatorException if navigation fails due to numerical instabilities.
     */
    public static void navigateECI(final Time timeInterval,
                                   final ECIFrame oldFrame,
                                   final Acceleration fx,
                                   final Acceleration fy,
                                   final Acceleration fz,
                                   final double angularRateX,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L5493">5493</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L5574">5574</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                                   final double fz,
                                   final AngularSpeed angularRateX,
                                   final AngularSpeed angularRateY,
                                   final AngularSpeed angularRateZ,
                                   final ECIFrame result)
            throws InertialNavigatorException {
        try {
            navigateECI(timeInterval, oldFrame.getX(), oldFrame.getY(), oldFrame.getZ(),
                    oldFrame.getCoordinateTransformation(),
                    oldFrame.getVx(), oldFrame.getVy(), oldFrame.getVz(), fx, fy, fz,
                    angularRateX, angularRateY, angularRateZ, result);
        } catch (final InvalidSourceAndDestinationFrameTypeException ignore) {
            // never happens
        }
    }

    /**
     * Runs precision ECI-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldFrame     previous ECI frame containing body position, velocity and
     *                     coordinate transformation matrix.
     * @param fx           specific force x-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateY angular rate y-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param result       instance where new estimated ECI frame containing new body position,
     *                     velocity and coordinate transformation matrix will be stored.
     * @throws InertialNavigatorException if navigation fails due to numerical instabilities.
     */
    public static void navigateECI(final Time timeInterval,
                                   final ECIFrame oldFrame,
                                   final double fx,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L11320">11320</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L11462">11462</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                                   final double fz,
                                   final double angularRateX,
                                   final double angularRateY,
                                   final double angularRateZ,
                                   final NEDFrame result)
            throws InertialNavigatorException {
        try {
            navigateNED(timeInterval, oldFrame.getLatitude(), oldFrame.getLongitude(),
                    oldFrame.getHeight(), oldFrame.getCoordinateTransformation(),
                    oldFrame.getVn(), oldFrame.getVe(), oldFrame.getVd(),
                    fx, fy, fz, angularRateX, angularRateY, angularRateZ, result);
        } catch (final InvalidSourceAndDestinationFrameTypeException ignore) {
            // never happens
        }
    }

    /**
     * Runs precision local-navigation-frame inertial navigation equations.
     * NOTE: only the attitude update and specific force frame transformation
     * phases are precise.
     *
     * @param timeInterval time interval between epochs.
     * @param oldFrame     previous NED frame containing body position, velocity and
     *                     coordinate transformation matrix.
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param result       instance where new estimated NED frame containing new body position,
     *                     velocity and coordinate transformation matrix will be stored.
     * @throws InertialNavigatorException if navigation fails due to numerical instabilities.
     */
    public static void navigateNED(final Time timeInterval,
                                   final NEDFrame oldFrame,
                                   final double fx,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L11323">11323</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L11553">11553</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                                   final double angularRateZ,
                                   final NEDFrame result)
            throws InertialNavigatorException {
        try {
            navigateNED(timeInterval, oldFrame.getLatitude(), oldFrame.getLongitude(),
                    oldFrame.getHeight(), oldFrame.getCoordinateTransformation(),
                    oldFrame.getVn(), oldFrame.getVe(), oldFrame.getVd(),
                    fx, fy, fz, angularRateX, angularRateY, angularRateZ, result);
        } catch (final InvalidSourceAndDestinationFrameTypeException ignore) {
            // never happens
        }
    }

    /**
     * Runs precision local-navigation-frame inertial navigation equations.
     * NOTE: only the attitude update and specific force frame transformation
     * phases are precise.
     *
     * @param timeInterval time interval between epochs.
     * @param oldFrame     previous NED frame containing body position, velocity and
     *                     coordinate transformation matrix.
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param result       instance where new estimated NED frame containing new body position,
     *                     velocity and coordinate transformation matrix will be stored.
     * @throws InertialNavigatorException if navigation fails due to numerical instabilities.
     */
    public static void navigateNED(final Time timeInterval,
                                   final NEDFrame oldFrame,
                                   final double fx,
                                   final double fy,
                                   final double fz,
                                   final double angularRateX,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/gnss/GNSSKalmanFilteredEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/gnss/GNSSKalmanFilteredEstimator.html#L458">458</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/INSGNSSTightlyCoupledKalmanFilteredEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/INSGNSSTightlyCoupledKalmanFilteredEstimator.html#L1497">1497</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/INSLooselyCoupledKalmanFilteredEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/INSLooselyCoupledKalmanFilteredEstimator.html#L1344">1344</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    public boolean getState(final GNSSKalmanState result) {
        if (mState != null) {
            result.copyFrom(mState);
            return true;
        } else {
            return false;
        }
    }

    /**
     * Gets timestamp expressed in seconds since epoch time when Kalman filter state
     * was last propagated.
     *
     * @return timestamp expressed in seconds since epoch time when Kalman filter
     * state was last propagated.
     */
    public Double getLastStateTimestamp() {
        return mLastStateTimestamp;
    }

    /**
     * Gets timestamp since epoch time when Kalman filter state was last propageted.
     *
     * @param result instance where timestamp since epoch time when Kalman filter
     *               state was last propagated will be stored.
     * @return true if result instance is updated, false otherwise.
     */
    public boolean getLastStateTimestampAsTime(final Time result) {
        if (mLastStateTimestamp != null) {
            result.setValue(mLastStateTimestamp);
            result.setUnit(TimeUnit.SECOND);
            return true;
        } else {
            return false;
        }
    }

    /**
     * Gets timestamp since epoch time when Kalman filter state was last propagated.
     *
     * @return timestamp since epoch time when Kalman filter state was last
     * propagated.
     */
    public Time getLastStateTimestampAsTime() {
        return mLastStateTimestamp != null ?
                new Time(mLastStateTimestamp, TimeUnit.SECOND) : null;
    }

    /**
     * Indicates whether this estimator is running or not.
     *
     * @return true if this estimator is running, false otherwise.
     */
    public boolean isRunning() {
        return mRunning;
    }

    /**
     * Indicates whether provided measurements are ready to
     * be used for an update.
     *
     * @param measurements measurements to be checked.
     * @return true if estimator is ready, false otherwise.
     */
    public static boolean isUpdateMeasurementsReady(</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/calibration/RobustKnownBiasAndFrameAccelerometerCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/RobustKnownBiasAndFrameAccelerometerCalibrator.html#L5172">5172</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/calibration/RobustKnownFrameAccelerometerCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/RobustKnownFrameAccelerometerCalibrator.html#L2677">2677</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>                                  final Matrix preliminaryMa) {
        // We know that measured specific force is:
        // fmeas = ba + (I + Ma) * ftrue

        // Hence:
        //  [fmeasx] = [bx] + ( [1  0   0] + [sx    mxy mxz])   [ftruex]
        //  [fmeasy] = [by]     [0  1   0]   [myx   sy  myz]    [ftruey]
        //  [fmeasz] = [bz]     [0  0   1]   [mzx   mzy sz ]    [ftruez]

        final BodyKinematics measuredKinematics = measurement.getKinematics();
        final ECEFFrame ecefFrame = measurement.getFrame();
        final ECEFFrame previousEcefFrame = measurement.getPreviousFrame();
        final double timeInterval = measurement.getTimeInterval();

        final BodyKinematics expectedKinematics = ECEFKinematicsEstimator
                .estimateKinematicsAndReturnNew(timeInterval, ecefFrame,
                        previousEcefFrame);

        final double fMeasX1 = measuredKinematics.getFx();
        final double fMeasY1 = measuredKinematics.getFy();
        final double fMeasZ1 = measuredKinematics.getFz();

        final double fTrueX = expectedKinematics.getFx();
        final double fTrueY = expectedKinematics.getFy();
        final double fTrueZ = expectedKinematics.getFz();</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L7937">7937</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L7992">7992</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    public static void navigateECEF(final double timeInterval,
                                    final ECEFPosition oldPosition,
                                    final CoordinateTransformation oldC,
                                    final double oldVx,
                                    final double oldVy,
                                    final double oldVz,
                                    final double fx,
                                    final double fy,
                                    final double fz,
                                    final double angularRateX,
                                    final double angularRateY,
                                    final double angularRateZ,
                                    final ECEFFrame result)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        navigateECEF(timeInterval, oldPosition.getX(), oldPosition.getY(), oldPosition.getZ(),
                oldC, oldVx, oldVy, oldVz, fx, fy, fz,
                angularRateX, angularRateY, angularRateZ, result);
    }

    /**
     * Runs precision ECEF-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldPosition  previous cartesian position resolved along ECEF-frame axes.
     * @param oldC         previous body-to-ECEF-frame coordinate transformation.
     * @param oldVx        previous velocity x-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param oldVy        previous velocity y-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param oldVz        previous velocity z-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param result       instance where new estimated ECEF frame containing new body
     *                     position, velocity and coordinate transformation matrix will be stored.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-ECEF-frame coordinate transformation matrix are invalid.
     */
    public static void navigateECEF(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L8047">8047</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L8102">8102</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    public static void navigateECEF(final double timeInterval,
                                    final double oldX,
                                    final double oldY,
                                    final double oldZ,
                                    final CoordinateTransformation oldC,
                                    final ECEFVelocity oldVelocity,
                                    final double fx,
                                    final double fy,
                                    final double fz,
                                    final double angularRateX,
                                    final double angularRateY,
                                    final double angularRateZ,
                                    final ECEFFrame result)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        navigateECEF(timeInterval, oldX, oldY, oldZ, oldC,
                oldVelocity.getVx(), oldVelocity.getVy(), oldVelocity.getVz(),
                fx, fy, fz, angularRateX, angularRateY, angularRateZ, result);
    }

    /**
     * Runs precision ECEF-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldX         previous cartesian x-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldY         previous cartesian y-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldZ         previous cartesian z-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldC         previous body-to-ECEF-frame coordinate transformation.
     * @param oldVelocity  previous body velocity resolved along ECEF-frame axes.
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param result       instance where new estimated ECEF frame containing new body
     *                     position, velocity and coordinate transformation matrix will be stored.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-ECEF-frame coordinate transformation matrix are invalid.
     */
    public static void navigateECEF(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L8524">8524</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L8579">8579</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    public static void navigateECEF(final double timeInterval,
                                    final Point3D oldPosition,
                                    final CoordinateTransformation oldC,
                                    final double oldVx,
                                    final double oldVy,
                                    final double oldVz,
                                    final double fx,
                                    final double fy,
                                    final double fz,
                                    final double angularRateX,
                                    final double angularRateY,
                                    final double angularRateZ,
                                    final ECEFFrame result)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        navigateECEF(timeInterval, oldPosition.getInhomX(), oldPosition.getInhomY(), oldPosition.getInhomZ(),
                oldC, oldVx, oldVy, oldVz, fx, fy, fz, angularRateX, angularRateY, angularRateZ, result);
    }

    /**
     * Runs precision ECEF-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldPosition  previous cartesian position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldC         previous body-to-ECEF-frame coordinate transformation.
     * @param oldVx        previous velocity x-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param oldVy        previous velocity y-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param oldVz        previous velocity z-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param result       instance where new estimated ECEF frame containing new body
     *                     position, velocity and coordinate transformation matrix will be stored.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-ECEF-frame coordinate transformation matrix are invalid.
     */
    public static void navigateECEF(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L8980">8980</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L9035">9035</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    public static void navigateECEF(final double timeInterval,
                                    final Distance oldX,
                                    final Distance oldY,
                                    final Distance oldZ,
                                    final CoordinateTransformation oldC,
                                    final ECEFVelocity oldVelocity,
                                    final double fx,
                                    final double fy,
                                    final double fz,
                                    final double angularRateX,
                                    final double angularRateY,
                                    final double angularRateZ,
                                    final ECEFFrame result)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        navigateECEF(timeInterval, oldX, oldY, oldZ, oldC,
                oldVelocity.getVx(), oldVelocity.getVy(), oldVelocity.getVz(),
                fx, fy, fz, angularRateX, angularRateY, angularRateZ, result);
    }

    /**
     * Runs precision ECEF-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldX         previous cartesian x-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldY         previous cartesian y-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldZ         previous cartesian z-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldC         previous body-to-ECEF-frame coordinate transformation.
     * @param oldVelocity  previous body velocity resolved along ECEF-frame axes.
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param result       instance where new estimated ECEF frame containing new body
     *                     position, velocity and coordinate transformation matrix will be stored.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-ECEF-frame coordinate transformation matrix are invalid.
     */
    public static void navigateECEF(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L9079">9079</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L9121">9121</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    public static void navigateECEF(final double timeInterval,
                                    final Distance oldX,
                                    final Distance oldY,
                                    final Distance oldZ,
                                    final CoordinateTransformation oldC,
                                    final double oldVx,
                                    final double oldVy,
                                    final double oldVz,
                                    final BodyKinematics kinematics,
                                    final ECEFFrame result)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        navigateECEF(timeInterval, oldX, oldY, oldZ, oldC, oldVx, oldVy, oldVz,
                kinematics.getFx(), kinematics.getFy(), kinematics.getFz(),
                kinematics.getAngularRateX(), kinematics.getAngularRateY(),
                kinematics.getAngularRateZ(), result);
    }

    /**
     * Runs precision ECEF-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldX         previous cartesian x-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldY         previous cartesian y-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldZ         previous cartesian z-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldC         previous body-to-ECEF-frame coordinate transformation.
     * @param oldVx        previous velocity x-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param oldVy        previous velocity y-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param oldVz        previous velocity z-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param kinematics   body kinematics containing specific forces and angular rates applied to
     *                     the body.
     * @param result       instance where new estimated ECEF frame containing new body
     *                     position, velocity and coordinate transformation matrix will be stored.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-ECEF-frame coordinate transformation matrix are invalid.
     */
    public static void navigateECEF(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L9367">9367</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L9422">9422</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    public static void navigateECEF(final double timeInterval,
                                    final ECEFPosition oldPosition,
                                    final CoordinateTransformation oldC,
                                    final Speed oldSpeedX,
                                    final Speed oldSpeedY,
                                    final Speed oldSpeedZ,
                                    final double fx,
                                    final double fy,
                                    final double fz,
                                    final double angularRateX,
                                    final double angularRateY,
                                    final double angularRateZ,
                                    final ECEFFrame result)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        navigateECEF(timeInterval, oldPosition.getX(), oldPosition.getY(), oldPosition.getZ(),
                oldC, oldSpeedX, oldSpeedY, oldSpeedZ, fx, fy, fz,
                angularRateX, angularRateY, angularRateZ, result);
    }

    /**
     * Runs precision ECEF-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldPosition  previous cartesian position resolved along ECEF-frame axes.
     * @param oldC         previous body-to-ECEF-frame coordinate transformation.
     * @param oldSpeedX    previous velocity x-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param oldSpeedY    previous velocity y-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param oldSpeedZ    previous velocity z-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param result       instance where new estimated ECEF frame containing new body
     *                     position, velocity and coordinate transformation matrix will be stored.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-ECEF-frame coordinate transformation matrix are invalid.
     */
    public static void navigateECEF(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L9742">9742</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L9794">9794</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    public static void navigateECEF(final double timeInterval,
                                    final ECEFPosition oldPosition,
                                    final CoordinateTransformation oldC,
                                    final double oldVx,
                                    final double oldVy,
                                    final double oldVz,
                                    final Acceleration fx,
                                    final Acceleration fy,
                                    final Acceleration fz,
                                    final double angularRateX,
                                    final double angularRateY,
                                    final double angularRateZ,
                                    final ECEFFrame result)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        navigateECEF(timeInterval, oldPosition.getX(), oldPosition.getY(), oldPosition.getZ(),
                oldC, oldVx, oldVy, oldVz, fx, fy, fz, angularRateX, angularRateY, angularRateZ,
                result);
    }

    /**
     * Runs precision ECEF-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldPosition  previous cartesian position resolved along ECEF-frame axes.
     * @param oldC         previous body-to-ECEF-frame coordinate transformation.
     * @param oldVx        previous velocity x-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param oldVy        previous velocity y-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param oldVz        previous velocity z-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param result       instance where new estimated ECEF frame containing new body
     *                     position, velocity and coordinate transformation matrix will be stored.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-ECEF-frame coordinate transformation matrix are invalid.
     */
    public static void navigateECEF(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L10163">10163</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L10215">10215</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    public static void navigateECEF(final double timeInterval,
                                    final ECEFPosition oldPosition,
                                    final CoordinateTransformation oldC,
                                    final double oldVx,
                                    final double oldVy,
                                    final double oldVz,
                                    final double fx,
                                    final double fy,
                                    final double fz,
                                    final AngularSpeed angularRateX,
                                    final AngularSpeed angularRateY,
                                    final AngularSpeed angularRateZ,
                                    final ECEFFrame result)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        navigateECEF(timeInterval, oldPosition.getX(), oldPosition.getY(), oldPosition.getZ(),
                oldC, oldVx, oldVy, oldVz, fx, fy, fz,
                angularRateX, angularRateY, angularRateZ, result);
    }

    /**
     * Runs precision ECEF-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldPosition  previous cartesian position resolved along ECEF-frame axes.
     * @param oldC         previous body-to-ECEF-frame coordinate transformation.
     * @param oldVx        previous velocity x-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param oldVy        previous velocity y-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param oldVz        previous velocity z-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param result       instance where new estimated ECEF frame containing new body
     *                     position, velocity and coordinate transformation matrix will be stored.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-ECEF-frame coordinate transformation matrix are invalid.
     */
    public static void navigateECEF(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L3995">3995</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L4051">4051</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    public static void navigateECI(final double timeInterval,
                                   final Point3D oldPosition,
                                   final CoordinateTransformation oldC,
                                   final double oldVx,
                                   final double oldVy,
                                   final double oldVz,
                                   final double fx,
                                   final double fy,
                                   final double fz,
                                   final double angularRateX,
                                   final double angularRateY,
                                   final double angularRateZ,
                                   final ECIFrame result)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        navigateECI(timeInterval, oldPosition.getInhomX(), oldPosition.getInhomY(), oldPosition.getInhomZ(),
                oldC, oldVx, oldVy, oldVz, fx, fy, fz, angularRateX, angularRateY, angularRateZ, result);
    }

    /**
     * Runs precision ECI-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldPosition  previous cartesian position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldC         previous body-to-ECI-frame coordinate transformation.
     * @param oldVx        previous velocity x-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param oldVy        previous velocity y-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param oldVz        previous velocity z-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param fx           specific force x-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param result       instance where new estimated ECI frame containing new body position,
     *                     velocity and coordinate transformation matrix will be stored.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-ECI-frame coordinate transformation matrix are
     *                                                       invalid.
     */
    public static void navigateECI(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L4292">4292</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L4335">4335</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    public static void navigateECI(final double timeInterval,
                                   final Distance oldX,
                                   final Distance oldY,
                                   final Distance oldZ,
                                   final CoordinateTransformation oldC,
                                   final double oldVx,
                                   final double oldVy,
                                   final double oldVz,
                                   final BodyKinematics kinematics,
                                   final ECIFrame result)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        navigateECI(timeInterval, oldX, oldY, oldZ, oldC, oldVx, oldVy, oldVz,
                kinematics.getFx(), kinematics.getFy(), kinematics.getFz(),
                kinematics.getAngularRateX(), kinematics.getAngularRateY(),
                kinematics.getAngularRateZ(), result);
    }

    /**
     * Runs precision ECI-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldX         previous cartesian x-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes.
     * @param oldY         previous cartesian y-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes.
     * @param oldZ         previous cartesian z-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes.
     * @param oldC         previous body-to-ECI-frame coordinate transformation.
     * @param oldVx        previous velocity x-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param oldVy        previous velocity y-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param oldVz        previous velocity z-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param kinematics   body kinematics containing specific forces and angular rates applied to
     *                     the body.
     * @param result       instance where new estimated ECI frame containing new body position,
     *                     velocity and coordinate transformation matrix will be stored.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-ECI-frame coordinate transformation matrix are
     *                                                       invalid.
     */
    public static void navigateECI(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/lateration/HomogeneousLinearLeastSquaresLateration2DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/HomogeneousLinearLeastSquaresLateration2DSolver.html#L154">154</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/lateration/InhomogeneousLinearLeastSquaresLateration2DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/InhomogeneousLinearLeastSquaresLateration2DSolver.html#L154">154</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/lateration/RobustLateration2DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/RobustLateration2DSolver.html#L1346">1346</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    }

    /**
     * Internally sets circles defining positions and euclidean distances.
     * @param circles circles defining positions and distances.
     * @throws IllegalArgumentException if circles is null or length of array of circles
     * is less than 3.
     */
    private void internalSetCircles(Circle[] circles) {
        if (circles == null || circles.length &lt; getMinRequiredPositionsAndDistances()) {
            throw new IllegalArgumentException();
        }

        Point2D[] positions = new Point2D[circles.length];
        double[] distances = new double[circles.length];
        for (int i = 0; i &lt; circles.length; i++) {
            Circle circle = circles[i];
            positions[i] = circle.getCenter();
            distances[i] = circle.getRadius();
        }

        internalSetPositionsAndDistances(positions, distances);
    }</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/lateration/HomogeneousLinearLeastSquaresLateration3DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/HomogeneousLinearLeastSquaresLateration3DSolver.html#L154">154</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/lateration/InhomogeneousLinearLeastSquaresLateration3DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/InhomogeneousLinearLeastSquaresLateration3DSolver.html#L154">154</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/lateration/RobustLateration3DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/RobustLateration3DSolver.html#L1345">1345</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    }

    /**
     * Internally sets spheres defining positions and euclidean distances.
     * @param spheres spheres defining positions and distances.
     * @throws IllegalArgumentException if spheres is null or length of array of spheres
     * is less than 4.
     */
    private void internalSetSpheres(Sphere[] spheres) {
        if (spheres == null || spheres.length &lt; getMinRequiredPositionsAndDistances()) {
            throw new IllegalArgumentException();
        }

        Point3D[] positions = new Point3D[spheres.length];
        double[] distances = new double[spheres.length];
        for (int i = 0; i &lt; spheres.length; i++) {
            Sphere sphere = spheres[i];
            positions[i] = sphere.getCenter();
            distances[i] = sphere.getRadius();
        }

        internalSetPositionsAndDistances(positions, distances);
    }</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/PROMedSRobustRssiPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROMedSRobustRssiPositionEstimator3D.html#L361">361</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/PROSACRobustMixedPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROSACRobustMixedPositionEstimator2D.html#L357">357</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/PROSACRobustRangingAndRssiPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROSACRobustRangingAndRssiPositionEstimator2D.html#L361">361</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/PROSACRobustRangingPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROSACRobustRangingPositionEstimator2D.html#L357">357</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/PROSACRobustRssiPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/PROSACRobustRssiPositionEstimator2D.html#L359">359</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>            RobustRssiPositionEstimatorListener&lt;Point3D&gt; listener) {
        this(sources, fingerprint, listener);
        internalSetSourceQualityScores(sourceQualityScores);
        internalSetFingerprintReadingsQualityScores(fingerprintReadingQualityScores);
    }

    /**
     * Returns quality scores corresponding to each radio source.
     * The larger the score value the better the quality of the sample.
     *
     * @return quality scores corresponding to each radio source.
     */
    public double[] getSourceQualityScores() {
        return mSourceQualityScores;
    }

    /**
     * Sets quality scores corresponding to each radio source.
     * The larger the score value the better the quality of the radio source.
     *
     * @param sourceQualityScores quality scores corresponding to each radio source.
     * @throws LockedException          if this instance is locked.
     * @throws IllegalArgumentException if provided quality scores length is smaller
     *                                  than minimum required samples.
     */
    public void setSourceQualityScores(double[] sourceQualityScores)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetSourceQualityScores(sourceQualityScores);
    }

    /**
     * Gets quality scores corresponding to each reading within provided fingerprint.
     * The larger the score value the better the quality of the reading.
     * This implementation always returns null.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @return quality scores corresponding to each reading within provided
     * fingerprint.
     */
    public double[] getFingerprintReadingsQualityScores() {
        return mFingerprintReadingsQualityScores;
    }

    /**
     * Sets quality scores corresponding to each reading within provided fingerprint.
     * The larger the score value the better the quality of the reading.
     * This implementation makes no action.
     * Subclasses using quality scores must implement proper behavior.
     *
     * @param fingerprintReadingsQualityScores quality scores corresponding to each
     *                                         reading within provided fingerprint.
     * @throws LockedException          if this instance is locked.
     * @throws IllegalArgumentException if provided quality scores length is smaller
     *                                  than minimum required samples.
     */
    public void setFingerprintReadingsQualityScores(
            double[] fingerprintReadingsQualityScores) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetFingerprintReadingsQualityScores(fingerprintReadingsQualityScores);
    }

    /**
     * Returns threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value, the
     * algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algrithm to iterate
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @return stop threshold to stop the algorithm prematurely when a certain
     * accuracy has been reached.
     */
    public double getStopThreshold() {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator2D.html#L1092">1092</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator2D.html#L1900">1900</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>            List&lt;? extends RangingAndRssiReadingLocated&lt;S, Point2D&gt;&gt; readings,
            Point2D initialPosition, Double initialTransmittedPowerdBm,
            double initialPathLossExponent,
            RobustRangingAndRssiRadioSourceEstimatorListener&lt;S, Point2D&gt; listener,
            RobustEstimatorMethod method) {
        switch (method) {
            case RANSAC:
                return new RANSACRobustRangingAndRssiRadioSourceEstimator2D&lt;&gt;(
                        readings, initialPosition, initialTransmittedPowerdBm,
                        initialPathLossExponent, listener);
            case LMedS:
                return new LMedSRobustRangingAndRssiRadioSourceEstimator2D&lt;&gt;(
                        readings, initialPosition, initialTransmittedPowerdBm,
                        initialPathLossExponent, listener);
            case MSAC:
                return new MSACRobustRangingAndRssiRadioSourceEstimator2D&lt;&gt;(
                        readings, initialPosition, initialTransmittedPowerdBm,
                        initialPathLossExponent, listener);
            case PROSAC:
                return new PROSACRobustRangingAndRssiRadioSourceEstimator2D&lt;&gt;(</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator3D.html#L1092">1092</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRangingAndRssiRadioSourceEstimator3D.html#L1900">1900</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>            List&lt;? extends RangingAndRssiReadingLocated&lt;S, Point3D&gt;&gt; readings,
            Point3D initialPosition, Double initialTransmittedPowerdBm,
            double initialPathLossExponent,
            RobustRangingAndRssiRadioSourceEstimatorListener&lt;S, Point3D&gt; listener,
            RobustEstimatorMethod method) {
        switch (method) {
            case RANSAC:
                return new RANSACRobustRangingAndRssiRadioSourceEstimator3D&lt;&gt;(
                        readings, initialPosition, initialTransmittedPowerdBm,
                        initialPathLossExponent, listener);
            case LMedS:
                return new LMedSRobustRangingAndRssiRadioSourceEstimator3D&lt;&gt;(
                        readings, initialPosition, initialTransmittedPowerdBm,
                        initialPathLossExponent, listener);
            case MSAC:
                return new MSACRobustRangingAndRssiRadioSourceEstimator3D&lt;&gt;(
                        readings, initialPosition, initialTransmittedPowerdBm,
                        initialPathLossExponent, listener);
            case PROSAC:
                return new PROSACRobustRangingAndRssiRadioSourceEstimator3D&lt;&gt;(</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator2D.html#L1095">1095</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator2D.html#L1903">1903</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>            List&lt;? extends RssiReadingLocated&lt;S, Point2D&gt;&gt; readings,
            Point2D initialPosition, Double initialTransmittedPowerdBm,
            double initialPathLossExponent,
            RobustRssiRadioSourceEstimatorListener&lt;S, Point2D&gt; listener,
            RobustEstimatorMethod method) {
        switch (method) {
            case RANSAC:
                return new RANSACRobustRssiRadioSourceEstimator2D&lt;&gt;(
                        readings, initialPosition, initialTransmittedPowerdBm,
                        initialPathLossExponent, listener);
            case LMedS:
                return new LMedSRobustRssiRadioSourceEstimator2D&lt;&gt;(
                        readings, initialPosition, initialTransmittedPowerdBm,
                        initialPathLossExponent, listener);
            case MSAC:
                return new MSACRobustRssiRadioSourceEstimator2D&lt;&gt;(
                        readings, initialPosition, initialTransmittedPowerdBm,
                        initialPathLossExponent, listener);
            case PROSAC:
                return new PROSACRobustRssiRadioSourceEstimator2D&lt;&gt;(</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator3D.html#L1095">1095</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RobustRssiRadioSourceEstimator3D.html#L1903">1903</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>            List&lt;? extends RssiReadingLocated&lt;S, Point3D&gt;&gt; readings,
            Point3D initialPosition, Double initialTransmittedPowerdBm,
            double initialPathLossExponent,
            RobustRssiRadioSourceEstimatorListener&lt;S, Point3D&gt; listener,
            RobustEstimatorMethod method) {
        switch (method) {
            case RANSAC:
                return new RANSACRobustRssiRadioSourceEstimator3D&lt;&gt;(
                        readings, initialPosition, initialTransmittedPowerdBm,
                        initialPathLossExponent, listener);
            case LMedS:
                return new LMedSRobustRssiRadioSourceEstimator3D&lt;&gt;(
                        readings, initialPosition, initialTransmittedPowerdBm,
                        initialPathLossExponent, listener);
            case MSAC:
                return new MSACRobustRssiRadioSourceEstimator3D&lt;&gt;(
                        readings, initialPosition, initialTransmittedPowerdBm,
                        initialPathLossExponent, listener);
            case PROSAC:
                return new PROSACRobustRssiRadioSourceEstimator3D&lt;&gt;(</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/calibration/RobustKnownBiasAndFrameAccelerometerCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/RobustKnownBiasAndFrameAccelerometerCalibrator.html#L3354">3354</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/calibration/RobustKnownBiasAndFrameAccelerometerCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/RobustKnownBiasAndFrameAccelerometerCalibrator.html#L3628">3628</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>            final double[] bias, final boolean commonAxisUsed,
            final RobustKnownBiasAndFrameAccelerometerCalibratorListener listener,
            final RobustEstimatorMethod method) {
        switch (method) {
            case RANSAC:
                return new RANSACRobustKnownBiasAndFrameAccelerometerCalibrator(
                        measurements, bias, commonAxisUsed, listener);
            case LMedS:
                return new LMedSRobustKnownBiasAndFrameAccelerometerCalibrator(
                        measurements, bias, commonAxisUsed, listener);
            case MSAC:
                return new MSACRobustKnownBiasAndFrameAccelerometerCalibrator(
                        measurements, bias, commonAxisUsed, listener);
            case PROSAC:
                return new PROSACRobustKnownBiasAndFrameAccelerometerCalibrator(
                        measurements, bias, commonAxisUsed, listener);
            case PROMedS:
            default:
                return new PROMedSRobustKnownBiasAndFrameAccelerometerCalibrator(
                        measurements, bias, commonAxisUsed, listener);
        }
    }

    /**
     * Creates a robust accelerometer calibrator.
     *
     * @param bias   known accelerometer bias.
     * @param method robust estimator method.
     * @return a robust accelerometer calibrator.
     * @throws IllegalArgumentException if provided matrix is not 3x1.
     */
    public static RobustKnownBiasAndFrameAccelerometerCalibrator create(
            final Matrix bias, final RobustEstimatorMethod method) {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L2394">2394</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L2446">2446</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public void navigate(final double timeInterval,
                         final ECEFPosition oldPosition,
                         final CoordinateTransformation oldC,
                         final double oldVx,
                         final double oldVy,
                         final double oldVz,
                         final double fx,
                         final double fy,
                         final double fz,
                         final AngularSpeed angularRateX,
                         final AngularSpeed angularRateY,
                         final AngularSpeed angularRateZ,
                         final ECEFFrame result)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        navigateECEF(timeInterval, oldPosition.getX(), oldPosition.getY(), oldPosition.getZ(),
                oldC, oldVx, oldVy, oldVz, fx, fy, fz,
                angularRateX, angularRateY, angularRateZ, result);
    }

    /**
     * Runs precision ECEF-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldPosition  previous cartesian position resolved along ECEF-frame axes.
     * @param oldC         previous body-to-ECEF-frame coordinate transformation.
     * @param oldVx        previous velocity x-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param oldVy        previous velocity y-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param oldVz        previous velocity z-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param result       instance where new estimated ECEF frame containing new body
     *                     position, velocity and coordinate transformation matrix will be stored.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-ECEF-frame coordinate transformation matrix are invalid.
     */
    public void navigate(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/MixedRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MixedRadioSourceEstimator.html#L857">857</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/RangingAndRssiRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RangingAndRssiRadioSourceEstimator.html#L803">803</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>        return areValidReadings(mReadings);
    }

    /**
     * Estimate position, transmitted power and path loss exponent.
     * @throws RadioSourceEstimationException if estimation fails.
     * @throws NotReadyException if estimator is not ready.
     * @throws LockedException if estimator is locked.
     */
    @Override
    public void estimate() throws RadioSourceEstimationException, NotReadyException,
            LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        try {
            mLocked = true;

            if (mListener != null) {
                mListener.onEstimateStart(this);
            }

            createInnerEstimatorsIfNeeded();

            List&lt;RangingReadingLocated&lt;S, P&gt;&gt; rangingReadings = new ArrayList&lt;&gt;();
            List&lt;RssiReadingLocated&lt;S, P&gt;&gt; rssiReadings = new ArrayList&lt;&gt;();
            for (ReadingLocated&lt;P&gt; reading : mReadings) {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/calibration/RobustKnownBiasAndFrameAccelerometerCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/RobustKnownBiasAndFrameAccelerometerCalibrator.html#L2587">2587</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/calibration/RobustKnownBiasAndFrameAccelerometerCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/RobustKnownBiasAndFrameAccelerometerCalibrator.html#L2893">2893</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>            final double biasX, final double biasY, final double biasZ,
            final RobustEstimatorMethod method) {
        switch (method) {
            case RANSAC:
                return new RANSACRobustKnownBiasAndFrameAccelerometerCalibrator(
                        measurements, biasX, biasY, biasZ);
            case LMedS:
                return new LMedSRobustKnownBiasAndFrameAccelerometerCalibrator(
                        measurements, biasX, biasY, biasZ);
            case MSAC:
                return new MSACRobustKnownBiasAndFrameAccelerometerCalibrator(
                        measurements, biasX, biasY, biasZ);
            case PROSAC:
                return new PROSACRobustKnownBiasAndFrameAccelerometerCalibrator(
                        measurements, biasX, biasY, biasZ);
            case PROMedS:
            default:
                return new PROMedSRobustKnownBiasAndFrameAccelerometerCalibrator(
                        measurements, biasX, biasY, biasZ);
        }
    }

    /**
     * Creates a robust accelerometer calibrator.
     *
     * @param measurements list of body kinematics measurements with standard
     *                     deviations taken at different frames (positions, orientations
     *                     and velocities).
     * @param biasX        known x coordinate of accelerometer bias expressed in meters per
     *                     squared second (m/s^2).
     * @param biasY        known y coordinate of accelerometer bias expressed in meters per
     *                     squared second (m/s^2).
     * @param biasZ        known z coordinate of accelerometer bias expressed in meters per
     *                     squared second (m/s^2).
     * @param listener     listener to handle events raised by this calibrator.
     * @param method       robust estimator method.
     * @return a robust accelerometer calibrator.
     */
    public static RobustKnownBiasAndFrameAccelerometerCalibrator create(
            final List&lt;StandardDeviationFrameBodyKinematics&gt; measurements,
            final double biasX, final double biasY, final double biasZ,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L2394">2394</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L10163">10163</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public void navigate(final double timeInterval,
                         final ECEFPosition oldPosition,
                         final CoordinateTransformation oldC,
                         final double oldVx,
                         final double oldVy,
                         final double oldVz,
                         final double fx,
                         final double fy,
                         final double fz,
                         final AngularSpeed angularRateX,
                         final AngularSpeed angularRateY,
                         final AngularSpeed angularRateZ,
                         final ECEFFrame result)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        navigateECEF(timeInterval, oldPosition.getX(), oldPosition.getY(), oldPosition.getZ(),
                oldC, oldVx, oldVy, oldVz, fx, fy, fz,
                angularRateX, angularRateY, angularRateZ, result);
    }

    /**
     * Runs precision ECEF-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldPosition  previous cartesian position resolved along ECEF-frame axes.
     * @param oldC         previous body-to-ECEF-frame coordinate transformation.
     * @param oldVx        previous velocity x-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param oldVy        previous velocity y-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param oldVz        previous velocity z-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param result       instance where new estimated ECEF frame containing new body
     *                     position, velocity and coordinate transformation matrix will be stored.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-ECEF-frame coordinate transformation matrix are invalid.
     */
    public void navigate(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L2446">2446</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L10215">10215</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public void navigate(final Time timeInterval,
                         final ECEFPosition oldPosition,
                         final CoordinateTransformation oldC,
                         final double oldVx,
                         final double oldVy,
                         final double oldVz,
                         final double fx,
                         final double fy,
                         final double fz,
                         final AngularSpeed angularRateX,
                         final AngularSpeed angularRateY,
                         final AngularSpeed angularRateZ,
                         final ECEFFrame result)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        navigateECEF(timeInterval, oldPosition.getX(), oldPosition.getY(), oldPosition.getZ(),
                oldC, oldVx, oldVy, oldVz, fx, fy, fz,
                angularRateX, angularRateY, angularRateZ, result);
    }

    /**
     * Runs precision ECEF-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs expressed in seconds (s).
     * @param oldX         previous cartesian x-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldY         previous cartesian y-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldZ         previous cartesian z-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldC         previous body-to-ECEF-frame coordinate transformation.
     * @param oldVelocity  previous body velocity resolved along ECEF-frame axes.
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param result       instance where new estimated ECEF frame containing new body
     *                     position, velocity and coordinate transformation matrix will be stored.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-ECEF-frame coordinate transformation matrix are invalid.
     */
    public void navigate(final double timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/lateration/HomogeneousLinearLeastSquaresLateration3DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/HomogeneousLinearLeastSquaresLateration3DSolver.html#L162">162</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/lateration/InhomogeneousLinearLeastSquaresLateration3DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/InhomogeneousLinearLeastSquaresLateration3DSolver.html#L162">162</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/lateration/NonLinearLeastSquaresLateration3DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/NonLinearLeastSquaresLateration3DSolver.html#L359">359</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    private void internalSetSpheres(Sphere[] spheres) {
        if (spheres == null || spheres.length &lt; getMinRequiredPositionsAndDistances()) {
            throw new IllegalArgumentException();
        }

        Point3D[] positions = new Point3D[spheres.length];
        double[] distances = new double[spheres.length];
        for (int i = 0; i &lt; spheres.length; i++) {
            Sphere sphere = spheres[i];
            positions[i] = sphere.getCenter();
            distances[i] = sphere.getRadius();
        }

        internalSetPositionsAndDistances(positions, distances);
    }</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/gnss/GNSSKalmanEpochEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/gnss/GNSSKalmanEpochEstimator.html#L366">366</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/INSTightlyCoupledKalmanEpochEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/INSTightlyCoupledKalmanEpochEstimator.html#L350">350</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>            h.setElementAt(j2, 7, 1.0);
        }

        // 6. Set-up measurement noise covariance matrix assuming all measurements are independent
        // and have equal variance for a given measurement type
        final double pseudoRangeSD = config.getPseudoRangeSD();
        final double pseudoRangeSD2 = pseudoRangeSD * pseudoRangeSD;
        final double rangeRateSD = config.getRangeRateSD();
        final double rangeRateSD2 = rangeRateSD * rangeRateSD;
        final Matrix r = new Matrix(2 * numberOfMeasurements, 2 * numberOfMeasurements);
        for (int i1 = 0, i2 = numberOfMeasurements; i1 &lt; numberOfMeasurements; i1++, i2++) {
            r.setElementAt(i1, i1, pseudoRangeSD2);
            r.setElementAt(i2, i2, rangeRateSD2);
        }

        // 7. Calculate Kalman gain using (3.21)
        final Matrix hTransposed = h.transposeAndReturnNew();
        final Matrix tmp8 = h.multiplyAndReturnNew(</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/NonLinearMixedPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/NonLinearMixedPositionEstimator2D.html#L324">324</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/NonLinearMixedPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/NonLinearMixedPositionEstimator3D.html#L327">327</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/NonLinearRangingAndRssiPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/NonLinearRangingAndRssiPositionEstimator2D.html#L323">323</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/NonLinearRangingAndRssiPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/NonLinearRangingAndRssiPositionEstimator3D.html#L327">327</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/NonLinearRangingPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/NonLinearRangingPositionEstimator2D.html#L324">324</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/NonLinearRangingPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/NonLinearRangingPositionEstimator3D.html#L324">324</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/position/NonLinearRssiPositionEstimator2D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/NonLinearRssiPositionEstimator2D.html#L325">325</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/position/NonLinearRssiPositionEstimator3D.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/position/NonLinearRssiPositionEstimator3D.html#L326">326</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>        Point2D[] positionsArray = new InhomogeneousPoint2D[size];
        positionsArray = positions.toArray(positionsArray);

        double[] distancesArray = new double[size];
        double[] distanceStandardDeviationsArray = new double[size];
        for (int i = 0; i &lt; size; i++) {
            distancesArray[i] = distances.get(i);
            distanceStandardDeviationsArray[i] = distanceStandardDeviations.get(i);
        }

        try {
            mTrilaterationSolver.setPositionsDistancesAndStandardDeviations(
                    positionsArray, distancesArray, distanceStandardDeviationsArray);
        } catch (LockedException e) {
            throw new IllegalArgumentException(e);
        }
    }

    /**
     * Initializes lateration solver.
     */
    private void init() {
        mTrilaterationSolver = new NonLinearLeastSquaresLateration2DSolver(</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/calibration/RobustKnownBiasAndFrameAccelerometerCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/RobustKnownBiasAndFrameAccelerometerCalibrator.html#L4817">4817</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/calibration/RobustKnownBiasAndFrameAccelerometerCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/RobustKnownBiasAndFrameAccelerometerCalibrator.html#L5141">5141</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>            final double[] bias, final boolean commonAxisUsed,
            final RobustKnownBiasAndFrameAccelerometerCalibratorListener listener,
            final RobustEstimatorMethod method) {
        switch (method) {
            case RANSAC:
                return new RANSACRobustKnownBiasAndFrameAccelerometerCalibrator(
                        measurements, bias, commonAxisUsed, listener);
            case LMedS:
                return new LMedSRobustKnownBiasAndFrameAccelerometerCalibrator(
                        measurements, bias, commonAxisUsed, listener);
            case MSAC:
                return new MSACRobustKnownBiasAndFrameAccelerometerCalibrator(
                        measurements, bias, commonAxisUsed, listener);
            case PROSAC:
                return new PROSACRobustKnownBiasAndFrameAccelerometerCalibrator(
                        qualityScores, measurements, bias, commonAxisUsed,
                        listener);
            case PROMedS:
            default:
                return new PROMedSRobustKnownBiasAndFrameAccelerometerCalibrator(
                        qualityScores, measurements, bias, commonAxisUsed,
                        listener);
        }
    }</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L3714">3714</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L7812">7812</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>            final Matrix skewAlpha = Utils.skewMatrix(alphaIbb);

            // Obtain coordinate transformation matrix from the new attitude to the old
            // using Rodrigues' formula, (5.73)
            final Matrix cNewOld = Matrix.identity(ROWS, ROWS);
            if (magAlpha &gt; ALPHA_THRESHOLD) {
                final double magAlpha2 = magAlpha * magAlpha;
                final double value1 = Math.sin(magAlpha) / magAlpha;
                final double value2 = (1.0 - Math.cos(magAlpha)) / magAlpha2;

                final Matrix tmp1 = skewAlpha.multiplyByScalarAndReturnNew(value1);
                final Matrix tmp2 = skewAlpha.multiplyByScalarAndReturnNew(value2);
                tmp2.multiply(skewAlpha);

                cNewOld.add(tmp1);
                cNewOld.add(tmp2);
            } else {
                cNewOld.add(skewAlpha);
            }</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/lateration/MSACRobustLateration2DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/MSACRobustLateration2DSolver.html#L221">221</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/lateration/PROSACRobustLateration2DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/PROSACRobustLateration2DSolver.html#L523">523</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/lateration/RANSACRobustLateration2DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/RANSACRobustLateration2DSolver.html#L291">291</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                    @Override
                    public double getThreshold() {
                        return mThreshold;
                    }

                    @Override
                    public int getTotalSamples() {
                        return mDistances.length;
                    }

                    @Override
                    public int getSubsetSize() {
                        return mPreliminarySubsetSize;
                    }

                    @Override
                    public void estimatePreliminarSolutions(int[] samplesIndices, List&lt;Point2D&gt; solutions) {
                        solvePreliminarSolutions(samplesIndices, solutions);
                    }

                    @Override
                    public double computeResidual(Point2D currentEstimation, int i) {
                        return Math.abs(currentEstimation.distanceTo(mPositions[i]) - mDistances[i]);
                    }

                    @Override
                    public boolean isReady() {
                        return MSACRobustLateration2DSolver.this.isReady();</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/lateration/MSACRobustLateration3DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/MSACRobustLateration3DSolver.html#L221">221</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/lateration/PROSACRobustLateration3DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/PROSACRobustLateration3DSolver.html#L523">523</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/lateration/RANSACRobustLateration3DSolver.java</td>
<td><a href="./xref/com/irurueta/navigation/lateration/RANSACRobustLateration3DSolver.html#L291">291</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>                @Override
                public double getThreshold() {
                    return mThreshold;
                }

                @Override
                public int getTotalSamples() {
                    return mDistances.length;
                }

                @Override
                public int getSubsetSize() {
                    return mPreliminarySubsetSize;
                }

                @Override
                public void estimatePreliminarSolutions(int[] samplesIndices, List&lt;Point3D&gt; solutions) {
                    solvePreliminarSolutions(samplesIndices, solutions);
                }

                @Override
                public double computeResidual(Point3D currentEstimation, int i) {
                    return Math.abs(currentEstimation.distanceTo(mPositions[i]) - mDistances[i]);
                }

                @Override
                public boolean isReady() {
                    return MSACRobustLateration3DSolver.this.isReady();</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/gnss/ECEFPositionAndVelocity.java</td>
<td><a href="./xref/com/irurueta/navigation/gnss/ECEFPositionAndVelocity.html#L344">344</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/gnss/GNSSEstimation.java</td>
<td><a href="./xref/com/irurueta/navigation/gnss/GNSSEstimation.html#L255">255</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    public ECEFPositionAndVelocity(final ECEFPositionAndVelocity input) {
        copyFrom(input);
    }

    /**
     * Gets cartesian x coordinate of position resolved in ECEF axes and
     * expressed in meters (m).
     *
     * @return cartesian x coordinate of position resolved in ECEF axes
     * and expressed in meters (m).
     */
    public double getX() {
        return mX;
    }

    /**
     * Sets cartesian x coordinate of position resolved in ECEF axes and
     * expressed in meters (m).
     *
     * @param x cartesian x coordinate of position resolved in ECEF axes
     *          and expressed in meters (m).
     */
    public void setX(final double x) {
        mX = x;
    }

    /**
     * Gets cartesian y coordinate of position resolved in ECEF axes and
     * expressed in meters (m).
     *
     * @return cartesian y coordinate of position resolved in ECEF axes
     * and expressed in meters (m).
     */
    public double getY() {
        return mY;
    }

    /**
     * Sets cartesian y coordinate of position resolved in ECEF axes and
     * expressed in meters (m).
     *
     * @param y cartesian y coordinate of position resolved in ECEF axes
     *          and expressed in meters (m).
     */
    public void setY(final double y) {
        mY = y;
    }

    /**
     * Gets cartesian z coordinate of position resolved in ECEF axes and
     * expressed in meters (m).
     *
     * @return cartesian z coordinate of position resolved in ECEF axes
     * and expressed in meters (m).
     */
    public double getZ() {
        return mZ;
    }

    /**
     * Sets cartesian z coordinate of position resolved in ECEF axes and
     * expressed in meters (m).
     *
     * @param z cartesian z coordinate of position resolved in ECEF axes
     *          and expressed in meters (m).
     */
    public void setZ(final double z) {
        mZ = z;
    }

    /**
     * Sets ECEF position expressed in meters (m).
     *
     * @param x cartesian x coordinate of position.
     * @param y cartesian y coordinate of position.
     * @param z cartesian z coordinate of position.
     */
    public void setPositionCoordinates(final double x, final double y, final double z) {
        mX = x;
        mY = y;
        mZ = z;
    }

    /**
     * Gets cartesian x coordinate of position resolved in ECEF axes.
     *
     * @param result instance where cartesian x coordinate of position will
     *               be stored.
     */
    public void getXDistance(final Distance result) {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/Utils.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/Utils.html#L450">450</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/Utils.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/Utils.html#L1146">1146</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>                    jacobian.setElementAtIndex(0, derivativeFingerprintRssi);
                    jacobian.setElementAtIndex(1, derivativePathLossExponent);
                    jacobian.setElementAtIndex(2, derivativeX1);
                    jacobian.setElementAtIndex(3, derivativeY1);
                    jacobian.setElementAtIndex(4, derivativeXa);
                    jacobian.setElementAtIndex(5, derivativeYa);
                    jacobian.setElementAtIndex(6, derivativeXi);
                    jacobian.setElementAtIndex(7, derivativeYi);
                }

                @Override
                public int getNumberOfVariables() {
                    return 1;
                }
            }, mean, covariance);
        } catch (AlgebraException | StatisticsException e) {
            throw new IndoorException(e);
        }
    }

    /**
     * Propagates provided variances (fingerprint rssi variance, path-loss exponent variance,
     * fingerprint position covariance and radio source position covariance) into
     * rssi variance by considering the 3D 1st order Taylor expression of received power.
     * Notice that any unknown variance is assumed to be zero.
     * @param fingerprintRssi closest located fingerprint reading RSSI expressed in dBm's.
     * @param pathLossExponent path-loss exponent.
     * @param fingerprintPosition position of closest fingerprint.
     * @param radioSourcePosition radio source position associated to fingerprint reading.
     * @param estimatedPosition  position to be estimated. Usually this is equal to the
     *                           initial position used by a non linear algorithm.
     * @param fingerprintRssiVariance variance of fingerprint RSSI or null if unknown.
     * @param pathLossExponentVariance variance of path-loss exponent or null if unknown.
     * @param fingerprintPositionCovariance covariance of fingerprint position or null if
     *                                      unknown.
     * @param radioSourcePositionCovariance covariance of radio source position or null
     *                                      if unknown.
     * @param estimatedPositionCovariance  covariance of position to be estimated or null
     *                                     if unknown. (This is usually unknown).
     * @return a normal distribution containing expected received RSSI value and its variance.
     * @throws IndoorException if something fails.
     */
    public static MultivariateNormalDist propagateVariancesToRssiVarianceFirstOrderNonLinear3D(</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/MixedRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/MixedRadioSourceEstimator.html#L980">980</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/RangingAndRssiRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/RangingAndRssiRadioSourceEstimator.html#L900">900</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>                    Matrix rssiCov = mRssiInnerEstimator.getEstimatedCovariance();
                    if (mEstimatedPositionCovariance != null &amp;&amp; rssiCov != null) {
                        int dims = getNumberOfDimensions();
                        int n = dims;
                        if (mTransmittedPowerEstimationEnabled) {
                            n++;
                        }
                        if (mPathLossEstimationEnabled) {
                            n++;
                        }

                        int dimsMinus1 = dims - 1;
                        int nMinus1 = n - 1;
                        mEstimatedCovariance = new Matrix(n, n);
                        mEstimatedCovariance.setSubmatrix(0, 0,
                                dimsMinus1, dimsMinus1,
                                mEstimatedPositionCovariance);
                        mEstimatedCovariance.setSubmatrix(dims, dims,
                                nMinus1, nMinus1, rssiCov);
                    } else {
                        mEstimatedCovariance = null;
                    }
                }</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustMixedRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustMixedRadioSourceEstimator.html#L2118">2118</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/indoor/radiosource/SequentialRobustRangingAndRssiRadioSourceEstimator.html#L2021">2021</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>                    Matrix rssiCov = mRssiEstimator.getCovariance();
                    if (mEstimatedPositionCovariance != null &amp;&amp; rssiCov != null) {
                        int dims = getNumberOfDimensions();
                        int n = dims;
                        if (mTransmittedPowerEstimationEnabled) {
                            n++;
                        }
                        if (mPathLossEstimationEnabled) {
                            n++;
                        }

                        int dimsMinus1 = dims - 1;
                        int nMinus1 = n - 1;
                        mCovariance = new Matrix(n, n);
                        mCovariance.setSubmatrix(0, 0,
                                dimsMinus1, dimsMinus1,
                                mEstimatedPositionCovariance);
                        mCovariance.setSubmatrix(dims, dims,
                                nMinus1, nMinus1, rssiCov);
                    } else {
                        mCovariance = null;
                    }
                }</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/INSGNSSTightlyCoupledKalmanFilteredEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/INSGNSSTightlyCoupledKalmanFilteredEstimator.html#L1394">1394</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/INSLooselyCoupledKalmanFilteredEstimator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/INSLooselyCoupledKalmanFilteredEstimator.html#L1269">1269</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    }

    /**
     * Gets last provided user kinematics containing applied specific force and
     * angular rates resolved in body axes.
     *
     * @return last provided user kinematics.
     */
    public BodyKinematics getKinematics() {
        return mKinematics != null ? new BodyKinematics(mKinematics) : null;
    }

    /**
     * Gets last provided user kinematics containing applied specific force and
     * angular rates resolved in body axes.
     *
     * @param result instance where last provided body kinematics will be stored.
     * @return true if provided result instance was updated, false otherwise.
     */
    public boolean getKinematics(final BodyKinematics result) {
        if (mKinematics != null) {
            result.copyFrom(mKinematics);
            return true;
        } else {
            return false;
        }
    }

    /**
     * Gets corrected kinematics which are the last provided user kinematics after
     * removal of the biases estimated by the Kalman filter.
     *
     * @return corrected kinematics.
     * @see #getKinematics()
     */
    public BodyKinematics getCorrectedKinematics() {
        return mCorrectedKinematics != null ?
                new BodyKinematics(mCorrectedKinematics) : null;
    }

    /**
     * Gets corrected kinematics which are the last provided user kinematics after
     * removal of the biases estimated by the Kalman filter.
     *
     * @param result instance where corrected body kinematics will be stored.
     * @return true if provided result instance was updated, false otherwise.
     */
    public boolean getCorrectedKinematics(final BodyKinematics result) {
        if (mCorrectedKinematics != null) {
            result.copyFrom(mCorrectedKinematics);
            return true;
        } else {
            return false;
        }
    }

    /**
     * Gets current estimation containing user ECEF position, user ECEF velocity,
     * clock offset and clock drift.
     *
     * @return current estimation containing user ECEF position, user ECEF velocity,
     * clock offset and clock drift.
     */
    public GNSSEstimation getEstimation() {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/calibration/RobustKnownBiasAndFrameAccelerometerCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/RobustKnownBiasAndFrameAccelerometerCalibrator.html#L3278">3278</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/calibration/RobustKnownBiasAndFrameAccelerometerCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/RobustKnownBiasAndFrameAccelerometerCalibrator.html#L3552">3552</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>            final double[] bias, final boolean commonAxisUsed,
            final RobustKnownBiasAndFrameAccelerometerCalibratorListener listener,
            final RobustEstimatorMethod method) {
        switch (method) {
            case RANSAC:
                return new RANSACRobustKnownBiasAndFrameAccelerometerCalibrator(
                        bias, commonAxisUsed, listener);
            case LMedS:
                return new LMedSRobustKnownBiasAndFrameAccelerometerCalibrator(
                        bias, commonAxisUsed, listener);
            case MSAC:
                return new MSACRobustKnownBiasAndFrameAccelerometerCalibrator(
                        bias, commonAxisUsed, listener);
            case PROSAC:
                return new PROSACRobustKnownBiasAndFrameAccelerometerCalibrator(
                        bias, commonAxisUsed, listener);
            case PROMedS:
            default:
                return new PROMedSRobustKnownBiasAndFrameAccelerometerCalibrator(
                        bias, commonAxisUsed, listener);
        }
    }

    /**
     * Creates a robust accelerometer calibrator.
     *
     * @param measurements   list of body kinematics measurements with standard
     *                       deviations taken at different frames (positions, orientations
     *                       and velocities).
     * @param bias           known accelerometer bias.
     * @param commonAxisUsed indicates whether z-axis is assumed to be common for
     *                       accelerometer and gyroscope.
     * @param method         robust estimator method.
     * @return a robust accelerometer calibrator.
     * @throws IllegalArgumentException if provided array does not have length 3.
     */
    public static RobustKnownBiasAndFrameAccelerometerCalibrator create(
            final List&lt;StandardDeviationFrameBodyKinematics&gt; measurements,
            final double[] bias, final boolean commonAxisUsed,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L8205">8205</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L10000">10000</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>                                    final double fz,
                                    final double angularRateX,
                                    final double angularRateY,
                                    final double angularRateZ,
                                    final ECEFFrame result)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        navigateECEF(timeInterval, oldPosition.getX(), oldPosition.getY(), oldPosition.getZ(),
                oldC, oldVelocity, fx, fy, fz, angularRateX, angularRateY, angularRateZ, result);
    }

    /**
     * Runs precision ECEF-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs expressed in seconds (s).
     * @param oldX         previous cartesian x-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldY         previous cartesian y-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldZ         previous cartesian z-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldC         previous body-to-ECEF-frame coordinate transformation.
     * @param oldVx        previous velocity x-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param oldVy        previous velocity y-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param oldVz        previous velocity z-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param kinematics   body kinematics containing specific forces and angular rates applied to
     *                     the body.
     * @param result       instance where new estimated ECEF frame containing new body
     *                     position, velocity and coordinate transformation matrix will be stored.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-ECEF-frame coordinate transformation matrix are invalid.
     */
    public static void navigateECEF(final double timeInterval,
                                    final double oldX,
                                    final double oldY,
                                    final double oldZ,
                                    final CoordinateTransformation oldC,
                                    final double oldVx,
                                    final double oldVy,
                                    final double oldVz,
                                    final BodyKinematics kinematics,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/calibration/MSACRobustKnownBiasAndFrameAccelerometerCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/MSACRobustKnownBiasAndFrameAccelerometerCalibrator.html#L755">755</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/calibration/PROSACRobustKnownBiasAndFrameAccelerometerCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/PROSACRobustKnownBiasAndFrameAccelerometerCalibrator.html#L1721">1721</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/calibration/RANSACRobustKnownBiasAndFrameAccelerometerCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/RANSACRobustKnownBiasAndFrameAccelerometerCalibrator.html#L828">828</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>                    @Override
                    public double getThreshold() {
                        return mThreshold;
                    }

                    @Override
                    public int getTotalSamples() {
                        return mMeasurements.size();
                    }

                    @Override
                    public int getSubsetSize() {
                        return mPreliminarySubsetSize;
                    }

                    @Override
                    public void estimatePreliminarSolutions(final int[] samplesIndices,
                                                            final List&lt;Matrix&gt; solutions) {
                        computePreliminarySolutions(samplesIndices, solutions);
                    }

                    @Override
                    public double computeResidual(final Matrix currentEstimation, final int i) {
                        return computeError(mMeasurements.get(i), currentEstimation);
                    }

                    @Override
                    public boolean isReady() {
                        return MSACRobustKnownBiasAndFrameAccelerometerCalibrator.super.isReady();</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/calibration/MSACRobustKnownFrameAccelerometerCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/MSACRobustKnownFrameAccelerometerCalibrator.html#L216">216</a></td></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/calibration/PROSACRobustKnownFrameAccelerometerCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/PROSACRobustKnownFrameAccelerometerCalibrator.html#L494">494</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/calibration/RANSACRobustKnownFrameAccelerometerCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/RANSACRobustKnownFrameAccelerometerCalibrator.html#L289">289</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>                    @Override
                    public double getThreshold() {
                        return mThreshold;
                    }

                    @Override
                    public int getTotalSamples() {
                        return mMeasurements.size();
                    }

                    @Override
                    public int getSubsetSize() {
                        return mPreliminarySubsetSize;
                    }

                    @Override
                    public void estimatePreliminarSolutions(final int[] samplesIndices,
                                                            final List&lt;PreliminaryResult&gt; solutions) {
                        computePreliminarySolutions(samplesIndices, solutions);
                    }

                    @Override
                    public double computeResidual(final PreliminaryResult currentEstimation, final int i) {
                        return computeError(mMeasurements.get(i), currentEstimation);
                    }

                    @Override
                    public boolean isReady() {
                        return MSACRobustKnownFrameAccelerometerCalibrator.super.isReady();</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/calibration/RobustKnownBiasAndFrameAccelerometerCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/RobustKnownBiasAndFrameAccelerometerCalibrator.html#L2665">2665</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/calibration/RobustKnownBiasAndFrameAccelerometerCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/RobustKnownBiasAndFrameAccelerometerCalibrator.html#L2965">2965</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>            final double biasX, final double biasY, final double biasZ,
            final boolean commonAxisUsed, final RobustEstimatorMethod method) {
        switch (method) {
            case RANSAC:
                return new RANSACRobustKnownBiasAndFrameAccelerometerCalibrator(
                        biasX, biasY, biasZ, commonAxisUsed);
            case LMedS:
                return new LMedSRobustKnownBiasAndFrameAccelerometerCalibrator(
                        biasX, biasY, biasZ, commonAxisUsed);
            case MSAC:
                return new MSACRobustKnownBiasAndFrameAccelerometerCalibrator(
                        biasX, biasY, biasZ, commonAxisUsed);
            case PROSAC:
                return new PROSACRobustKnownBiasAndFrameAccelerometerCalibrator(
                        biasX, biasY, biasZ, commonAxisUsed);
            case PROMedS:
            default:
                return new PROMedSRobustKnownBiasAndFrameAccelerometerCalibrator(
                        biasX, biasY, biasZ, commonAxisUsed);
        }
    }

    /**
     * Creates a robust accelerometer calibrator.
     *
     * @param biasX          known x coordinate of accelerometer bias expressed in meters per
     *                       squared second (m/s^2).
     * @param biasY          known y coordinate of accelerometer bias expressed in meters per
     *                       squared second (m/s^2).
     * @param biasZ          known z coordinate of accelerometer bias expressed in meters per
     *                       squared second (m/s^2).
     * @param commonAxisUsed indicates whether z-axis is assumed to be common for
     *                       accelerometer and gyroscope.
     * @param listener       listener to handle events raised by this calibrator.
     * @param method         robust estimator method.
     * @return a robust accelerometer calibrator.
     */
    public static RobustKnownBiasAndFrameAccelerometerCalibrator create(
            final double biasX, final double biasY, final double biasZ,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/calibration/RobustKnownBiasAndFrameAccelerometerCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/RobustKnownBiasAndFrameAccelerometerCalibrator.html#L2787">2787</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/calibration/RobustKnownBiasAndFrameAccelerometerCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/RobustKnownBiasAndFrameAccelerometerCalibrator.html#L4150">4150</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>            final List&lt;StandardDeviationFrameBodyKinematics&gt; measurements,
            final double biasX, final double biasY, final double biasZ,
            final boolean commonAxisUsed,
            final RobustKnownBiasAndFrameAccelerometerCalibratorListener listener,
            final RobustEstimatorMethod method) {
        switch (method) {
            case RANSAC:
                return new RANSACRobustKnownBiasAndFrameAccelerometerCalibrator(
                        measurements, biasX, biasY, biasZ, commonAxisUsed, listener);
            case LMedS:
                return new LMedSRobustKnownBiasAndFrameAccelerometerCalibrator(
                        measurements, biasX, biasY, biasZ, commonAxisUsed, listener);
            case MSAC:
                return new MSACRobustKnownBiasAndFrameAccelerometerCalibrator(
                        measurements, biasX, biasY, biasZ, commonAxisUsed, listener);
            case PROSAC:
                return new PROSACRobustKnownBiasAndFrameAccelerometerCalibrator(</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/calibration/RobustKnownBiasAndFrameAccelerometerCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/RobustKnownBiasAndFrameAccelerometerCalibrator.html#L3078">3078</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/calibration/RobustKnownBiasAndFrameAccelerometerCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/RobustKnownBiasAndFrameAccelerometerCalibrator.html#L4491">4491</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>            final List&lt;StandardDeviationFrameBodyKinematics&gt; measurements,
            final Acceleration biasX, final Acceleration biasY, final Acceleration biasZ,
            final boolean commonAxisUsed,
            final RobustKnownBiasAndFrameAccelerometerCalibratorListener listener,
            final RobustEstimatorMethod method) {
        switch (method) {
            case RANSAC:
                return new RANSACRobustKnownBiasAndFrameAccelerometerCalibrator(
                        measurements, biasX, biasY, biasZ, commonAxisUsed, listener);
            case LMedS:
                return new LMedSRobustKnownBiasAndFrameAccelerometerCalibrator(
                        measurements, biasX, biasY, biasZ, commonAxisUsed, listener);
            case MSAC:
                return new MSACRobustKnownBiasAndFrameAccelerometerCalibrator(
                        measurements, biasX, biasY, biasZ, commonAxisUsed, listener);
            case PROSAC:
                return new PROSACRobustKnownBiasAndFrameAccelerometerCalibrator(</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/calibration/RobustKnownBiasAndFrameAccelerometerCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/RobustKnownBiasAndFrameAccelerometerCalibrator.html#L4650">4650</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/calibration/RobustKnownBiasAndFrameAccelerometerCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/RobustKnownBiasAndFrameAccelerometerCalibrator.html#L4974">4974</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>            final double[] bias,
            final RobustKnownBiasAndFrameAccelerometerCalibratorListener listener,
            final RobustEstimatorMethod method) {
        switch (method) {
            case RANSAC:
                return new RANSACRobustKnownBiasAndFrameAccelerometerCalibrator(
                        measurements, bias, listener);
            case LMedS:
                return new LMedSRobustKnownBiasAndFrameAccelerometerCalibrator(
                        measurements, bias, listener);
            case MSAC:
                return new MSACRobustKnownBiasAndFrameAccelerometerCalibrator(
                        measurements, bias, listener);
            case PROSAC:
                return new PROSACRobustKnownBiasAndFrameAccelerometerCalibrator(
                        qualityScores, measurements, bias, listener);
            case PROMedS:
            default:
                return new PROMedSRobustKnownBiasAndFrameAccelerometerCalibrator(
                        qualityScores, measurements, bias, listener);
        }
    }

    /**
     * Creates a robust accelerometer calibrator.
     *
     * @param qualityScores  quality scores corresponding to each provided
     *                       measurement. The larger the score value the better
     *                       the quality of the sample.
     * @param bias           known accelerometer bias.
     * @param commonAxisUsed indicates whether z-axis is assumed to be common for
     *                       accelerometer and gyroscope.
     * @param method         robust estimator method.
     * @return a robust accelerometer calibrator.
     * @throws IllegalArgumentException if provided bias array does not have length 3 or
     *                                  if provided quality scores length is smaller than
     *                                  4 samples.
     */
    public static RobustKnownBiasAndFrameAccelerometerCalibrator create(
            final double[] qualityScores, final double[] bias,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L100">100</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L161">161</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    public void navigate(final double timeInterval,
                         final double oldX,
                         final double oldY,
                         final double oldZ,
                         final CoordinateTransformation oldC,
                         final double oldVx,
                         final double oldVy,
                         final double oldVz,
                         final double fx,
                         final double fy,
                         final double fz,
                         final double angularRateX,
                         final double angularRateY,
                         final double angularRateZ,
                         final ECEFFrame result) throws InertialNavigatorException,
            InvalidSourceAndDestinationFrameTypeException {
        navigateECEF(timeInterval, oldX, oldY, oldZ, oldC, oldVx, oldVy, oldVz,
                fx, fy, fz, angularRateX, angularRateY, angularRateZ, result);
    }

    /**
     * Runs precision ECEF-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldX         previous cartesian x-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldY         previous cartesian y-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldZ         previous cartesian z-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldC         previous body-to-ECEF-frame coordinate transformation.
     * @param oldVx        previous velocity x-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param oldVy        previous velocity y-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param oldVz        previous velocity z-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param result       instance where new estimated ECEF frame containing new body
     *                     position, velocity and coordinate transformation matrix will be stored.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-ECEF-frame coordinate transformation matrix are invalid.
     */
    public void navigate(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L1122">1122</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L1183">1183</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    public void navigate(final double timeInterval,
                         final Distance oldX,
                         final Distance oldY,
                         final Distance oldZ,
                         final CoordinateTransformation oldC,
                         final double oldVx,
                         final double oldVy,
                         final double oldVz,
                         final double fx,
                         final double fy,
                         final double fz,
                         final double angularRateX,
                         final double angularRateY,
                         final double angularRateZ,
                         final ECEFFrame result) throws InertialNavigatorException,
            InvalidSourceAndDestinationFrameTypeException {
        navigateECEF(timeInterval, oldX, oldY, oldZ, oldC, oldVx, oldVy, oldVz,
                fx, fy, fz, angularRateX, angularRateY, angularRateZ, result);
    }

    /**
     * Runs precision ECEF-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldX         previous cartesian x-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldY         previous cartesian y-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldZ         previous cartesian z-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldC         previous body-to-ECEF-frame coordinate transformation.
     * @param oldVx        previous velocity x-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param oldVy        previous velocity y-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param oldVz        previous velocity z-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param result       instance where new estimated ECEF frame containing new body
     *                     position, velocity and coordinate transformation matrix will be stored.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-ECEF-frame coordinate transformation matrix are invalid.
     */
    public void navigate(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L1498">1498</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L1560">1560</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    public void navigate(final double timeInterval,
                         final double oldX,
                         final double oldY,
                         final double oldZ,
                         final CoordinateTransformation oldC,
                         final Speed oldSpeedX,
                         final Speed oldSpeedY,
                         final Speed oldSpeedZ,
                         final double fx,
                         final double fy,
                         final double fz,
                         final double angularRateX,
                         final double angularRateY,
                         final double angularRateZ,
                         final ECEFFrame result) throws InertialNavigatorException,
            InvalidSourceAndDestinationFrameTypeException {
        navigateECEF(timeInterval, oldX, oldY, oldZ, oldC, oldSpeedX, oldSpeedY,
                oldSpeedZ, fx, fy, fz, angularRateX, angularRateY, angularRateZ,
                result);
    }

    /**
     * Runs precision ECEF-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldX         previous cartesian x-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldY         previous cartesian y-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldZ         previous cartesian z-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldC         previous body-to-ECEF-frame coordinate transformation.
     * @param oldSpeedX    previous velocity x-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param oldSpeedY    previous velocity y-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param oldSpeedZ    previous velocity z-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param result       instance where new estimated ECEF frame containing new body
     *                     position, velocity and coordinate transformation matrix will be stored.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-ECEF-frame coordinate transformation matrix are invalid.
     */
    public void navigate(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L1875">1875</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L1933">1933</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    public void navigate(final double timeInterval,
                         final double oldX,
                         final double oldY,
                         final double oldZ,
                         final CoordinateTransformation oldC,
                         final double oldVx,
                         final double oldVy,
                         final double oldVz,
                         final Acceleration fx,
                         final Acceleration fy,
                         final Acceleration fz,
                         final double angularRateX,
                         final double angularRateY,
                         final double angularRateZ,
                         final ECEFFrame result) throws InertialNavigatorException,
            InvalidSourceAndDestinationFrameTypeException {
        navigateECEF(timeInterval, oldX, oldY, oldZ, oldC, oldVx, oldVy, oldVz,
                fx, fy, fz, angularRateX, angularRateY, angularRateZ, result);
    }

    /**
     * Runs precision ECEF-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldX         previous cartesian x-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldY         previous cartesian y-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldZ         previous cartesian z-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldC         previous body-to-ECEF-frame coordinate transformation.
     * @param oldVx        previous velocity x-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param oldVy        previous velocity y-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param oldVz        previous velocity z-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param result       instance where new estimated ECEF frame containing new body
     *                     position, velocity and coordinate transformation matrix will be stored.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-ECEF-frame coordinate transformation matrix are invalid.
     */
    public void navigate(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L2283">2283</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L2341">2341</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    public void navigate(final double timeInterval,
                         final double oldX,
                         final double oldY,
                         final double oldZ,
                         final CoordinateTransformation oldC,
                         final double oldVx,
                         final double oldVy,
                         final double oldVz,
                         final double fx,
                         final double fy,
                         final double fz,
                         final AngularSpeed angularRateX,
                         final AngularSpeed angularRateY,
                         final AngularSpeed angularRateZ,
                         final ECEFFrame result) throws InertialNavigatorException,
            InvalidSourceAndDestinationFrameTypeException {
        navigateECEF(timeInterval, oldX, oldY, oldZ, oldC, oldVx, oldVy, oldVz,
                fx, fy, fz, angularRateX, angularRateY, angularRateZ, result);
    }

    /**
     * Runs precision ECEF-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldX         previous cartesian x-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldY         previous cartesian y-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldZ         previous cartesian z-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldC         previous body-to-ECEF-frame coordinate transformation.
     * @param oldVx        previous velocity x-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param oldVy        previous velocity y-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param oldVz        previous velocity z-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param result       instance where new estimated ECEF frame containing new body
     *                     position, velocity and coordinate transformation matrix will be stored.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-ECEF-frame coordinate transformation matrix are invalid.
     */
    public void navigate(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L2394">2394</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L10215">10215</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    public void navigate(final double timeInterval,
                         final ECEFPosition oldPosition,
                         final CoordinateTransformation oldC,
                         final double oldVx,
                         final double oldVy,
                         final double oldVz,
                         final double fx,
                         final double fy,
                         final double fz,
                         final AngularSpeed angularRateX,
                         final AngularSpeed angularRateY,
                         final AngularSpeed angularRateZ,
                         final ECEFFrame result)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        navigateECEF(timeInterval, oldPosition.getX(), oldPosition.getY(), oldPosition.getZ(),
                oldC, oldVx, oldVy, oldVz, fx, fy, fz,
                angularRateX, angularRateY, angularRateZ, result);
    }

    /**
     * Runs precision ECEF-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldPosition  previous cartesian position resolved along ECEF-frame axes.
     * @param oldC         previous body-to-ECEF-frame coordinate transformation.
     * @param oldVx        previous velocity x-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param oldVy        previous velocity y-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param oldVz        previous velocity z-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param result       instance where new estimated ECEF frame containing new body
     *                     position, velocity and coordinate transformation matrix will be stored.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-ECEF-frame coordinate transformation matrix are invalid.
     */
    public void navigate(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L2446">2446</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L10163">10163</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    public void navigate(final Time timeInterval,
                         final ECEFPosition oldPosition,
                         final CoordinateTransformation oldC,
                         final double oldVx,
                         final double oldVy,
                         final double oldVz,
                         final double fx,
                         final double fy,
                         final double fz,
                         final AngularSpeed angularRateX,
                         final AngularSpeed angularRateY,
                         final AngularSpeed angularRateZ,
                         final ECEFFrame result)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        navigateECEF(timeInterval, oldPosition.getX(), oldPosition.getY(), oldPosition.getZ(),
                oldC, oldVx, oldVy, oldVz, fx, fy, fz,
                angularRateX, angularRateY, angularRateZ, result);
    }

    /**
     * Runs precision ECEF-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs expressed in seconds (s).
     * @param oldX         previous cartesian x-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldY         previous cartesian y-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldZ         previous cartesian z-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldC         previous body-to-ECEF-frame coordinate transformation.
     * @param oldVelocity  previous body velocity resolved along ECEF-frame axes.
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param result       instance where new estimated ECEF frame containing new body
     *                     position, velocity and coordinate transformation matrix will be stored.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-ECEF-frame coordinate transformation matrix are invalid.
     */
    public void navigate(final double timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L2696">2696</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L2758">2758</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    public void navigate(final double timeInterval,
                         final Distance oldX,
                         final Distance oldY,
                         final Distance oldZ,
                         final CoordinateTransformation oldC,
                         final Speed oldSpeedX,
                         final Speed oldSpeedY,
                         final Speed oldSpeedZ,
                         final double fx,
                         final double fy,
                         final double fz,
                         final double angularRateX,
                         final double angularRateY,
                         final double angularRateZ,
                         final ECEFFrame result) throws InertialNavigatorException,
            InvalidSourceAndDestinationFrameTypeException {
        navigateECEF(timeInterval, oldX, oldY, oldZ, oldC, oldSpeedX, oldSpeedY,
                oldSpeedZ, fx, fy, fz, angularRateX, angularRateY, angularRateZ,
                result);
    }

    /**
     * Runs precision ECEF-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldX         previous cartesian x-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldY         previous cartesian y-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldZ         previous cartesian z-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldC         previous body-to-ECEF-frame coordinate transformation.
     * @param oldSpeedX    previous velocity x-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param oldSpeedY    previous velocity y-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param oldSpeedZ    previous velocity z-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param result       instance where new estimated ECEF frame containing new body
     *                     position, velocity and coordinate transformation matrix will be stored.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-ECEF-frame coordinate transformation matrix are invalid.
     */
    public void navigate(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L2814">2814</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L2870">2870</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    public void navigate(final double timeInterval,
                         final Distance oldX,
                         final Distance oldY,
                         final Distance oldZ,
                         final CoordinateTransformation oldC,
                         final Speed oldSpeedX,
                         final Speed oldSpeedY,
                         final Speed oldSpeedZ,
                         final Acceleration fx,
                         final Acceleration fy,
                         final Acceleration fz,
                         final AngularSpeed angularRateX,
                         final AngularSpeed angularRateY,
                         final AngularSpeed angularRateZ,
                         final ECEFFrame result) throws InertialNavigatorException,
            InvalidSourceAndDestinationFrameTypeException {
        navigateECEF(timeInterval, oldX, oldY, oldZ, oldC, oldSpeedX, oldSpeedY,
                oldSpeedZ, fx, fy, fz, angularRateX, angularRateY, angularRateZ,
                result);
    }

    /**
     * Runs precision ECEF-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldX         previous cartesian x-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldY         previous cartesian y-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldZ         previous cartesian z-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes.
     * @param oldC         previous body-to-ECEF-frame coordinate transformation.
     * @param oldSpeedX    previous velocity x-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param oldSpeedY    previous velocity y-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param oldSpeedZ    previous velocity z-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param result       instance where new estimated ECEF frame containing new body
     *                     position, velocity and coordinate transformation matrix will be stored.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-ECEF-frame coordinate transformation matrix are invalid.
     */
    public void navigate(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L3200">3200</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L3255">3255</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    public void navigate(final double timeInterval,
                         final double oldX,
                         final double oldY,
                         final double oldZ,
                         final CoordinateTransformation oldC,
                         final double oldVx,
                         final double oldVy,
                         final double oldVz,
                         final Acceleration fx,
                         final Acceleration fy,
                         final Acceleration fz,
                         final AngularSpeed angularRateX,
                         final AngularSpeed angularRateY,
                         final AngularSpeed angularRateZ,
                         final ECEFFrame result) throws InertialNavigatorException,
            InvalidSourceAndDestinationFrameTypeException {
        navigateECEF(timeInterval, oldX, oldY, oldZ, oldC, oldVx, oldVy, oldVz,
                fx, fy, fz, angularRateX, angularRateY, angularRateZ, result);
    }

    /**
     * Runs precision ECEF-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldX         previous cartesian x-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldY         previous cartesian y-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldZ         previous cartesian z-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldC         previous body-to-ECEF-frame coordinate transformation.
     * @param oldVx        previous velocity x-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param oldVy        previous velocity y-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param oldVz        previous velocity z-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param result       instance where new estimated ECEF frame containing new body
     *                     position, velocity and coordinate transformation matrix will be stored.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-ECEF-frame coordinate transformation matrix are invalid.
     */
    public void navigate(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L91">91</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L153">153</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    public void navigate(final double timeInterval,
                         final double oldX,
                         final double oldY,
                         final double oldZ,
                         final CoordinateTransformation oldC,
                         final double oldVx,
                         final double oldVy,
                         final double oldVz,
                         final double fx,
                         final double fy,
                         final double fz,
                         final double angularRateX,
                         final double angularRateY,
                         final double angularRateZ,
                         final ECIFrame result)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        navigateECI(timeInterval, oldX, oldY, oldZ, oldC, oldVx, oldVy, oldVz,
                fx, fy, fz, angularRateX, angularRateY, angularRateZ, result);
    }

    /**
     * Runs precision ECI-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldX         previous cartesian x-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldY         previous cartesian y-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldZ         previous cartesian z-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldC         previous body-to-ECI-frame coordinate transformation.
     * @param oldVx        previous velocity x-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param oldVy        previous velocity y-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param oldVz        previous velocity z-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param fx           specific force x-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param result       instance where new estimated ECI frame containing new body position,
     *                     velocity and coordinate transformation matrix will be stored.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-ECI-frame coordinate transformation matrix are
     *                                                       invalid.
     */
    public void navigate(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L478">478</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L539">539</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    public void navigate(final double timeInterval,
                         final Distance oldX,
                         final Distance oldY,
                         final Distance oldZ,
                         final CoordinateTransformation oldC,
                         final double oldVx,
                         final double oldVy,
                         final double oldVz,
                         final double fx,
                         final double fy,
                         final double fz,
                         final double angularRateX,
                         final double angularRateY,
                         final double angularRateZ,
                         final ECIFrame result)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        navigateECI(timeInterval, oldX, oldY, oldZ, oldC, oldVx, oldVy, oldVz,
                fx, fy, fz, angularRateX, angularRateY, angularRateZ, result);
    }

    /**
     * Runs precision ECI-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldX         previous cartesian x-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes.
     * @param oldY         previous cartesian y-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes.
     * @param oldZ         previous cartesian z-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes.
     * @param oldC         previous body-to-ECI-frame coordinate transformation.
     * @param oldVx        previous velocity x-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param oldVy        previous velocity y-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param oldVz        previous velocity z-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param fx           specific force x-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param result       instance where new estimated ECI frame containing new body position,
     *                     velocity and coordinate transformation matrix will be stored.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-ECI-frame coordinate transformation matrix are invalid.
     */
    public void navigate(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L682">682</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L744">744</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    public void navigate(final double timeInterval,
                         final double oldX,
                         final double oldY,
                         final double oldZ,
                         final CoordinateTransformation oldC,
                         final Speed oldSpeedX,
                         final Speed oldSpeedY,
                         final Speed oldSpeedZ,
                         final double fx,
                         final double fy,
                         final double fz,
                         final double angularRateX,
                         final double angularRateY,
                         final double angularRateZ,
                         final ECIFrame result)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        navigateECI(timeInterval, oldX, oldY, oldZ, oldC,
                oldSpeedX, oldSpeedY, oldSpeedZ, fx, fy, fz,
                angularRateX, angularRateY, angularRateZ, result);
    }

    /**
     * Runs precision ECI-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldX         previous cartesian x-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldY         previous cartesian y-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldZ         previous cartesian z-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldC         previous body-to-ECI-frame coordinate transformation.
     * @param oldSpeedX    previous velocity x-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes.
     * @param oldSpeedY    previous velocity y-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes.
     * @param oldSpeedZ    previous velocity z-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes.
     * @param fx           specific force x-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param result       instance where new estimated ECI frame containing new body position,
     *                     velocity and coordinate transformation matrix will be stored.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-ECI-frame coordinate transformation matrix are invalid.
     */
    public void navigate(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L885">885</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L943">943</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    public void navigate(final double timeInterval,
                         final double oldX,
                         final double oldY,
                         final double oldZ,
                         final CoordinateTransformation oldC,
                         final double oldVx,
                         final double oldVy,
                         final double oldVz,
                         final Acceleration fx,
                         final Acceleration fy,
                         final Acceleration fz,
                         final double angularRateX,
                         final double angularRateY,
                         final double angularRateZ,
                         final ECIFrame result)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        navigateECI(timeInterval, oldX, oldY, oldZ, oldC, oldVx, oldVy, oldVz,
                fx, fy, fz, angularRateX, angularRateY, angularRateZ, result);
    }

    /**
     * Runs precision ECI-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldX         previous cartesian x-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldY         previous cartesian y-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldZ         previous cartesian z-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldC         previous body-to-ECI-frame coordinate transformation.
     * @param oldVx        previous velocity x-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param oldVy        previous velocity y-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param oldVz        previous velocity z-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param fx           specific force x-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fy           specific force y-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fz           specific force z-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateX angular rate x-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param result       instance where new estimated ECI frame containing new body position,
     *                     velocity and coordinate transformation matrix will be stored.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-ECI-frame coordinate transformation matrix are invalid.
     */
    public void navigate(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L1001">1001</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L1059">1059</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    public void navigate(final double timeInterval,
                         final double oldX,
                         final double oldY,
                         final double oldZ,
                         final CoordinateTransformation oldC,
                         final double oldVx,
                         final double oldVy,
                         final double oldVz,
                         final double fx,
                         final double fy,
                         final double fz,
                         final AngularSpeed angularRateX,
                         final AngularSpeed angularRateY,
                         final AngularSpeed angularRateZ,
                         final ECIFrame result)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        navigateECI(timeInterval, oldX, oldY, oldZ, oldC, oldVx, oldVy, oldVz,
                fx, fy, fz, angularRateX, angularRateY, angularRateZ, result);
    }

    /**
     * Runs precision ECI-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldX         previous cartesian x-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldY         previous cartesian y-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldZ         previous cartesian z-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldC         previous body-to-ECI-frame coordinate transformation.
     * @param oldVx        previous velocity x-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param oldVy        previous velocity y-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param oldVz        previous velocity z-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param fx           specific force x-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateY angular rate y-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param result       instance where new estimated ECI frame containing new body position,
     *                     velocity and coordinate transformation matrix will be stored.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-ECI-frame coordinate transformation matrix are invalid.
     */
    public void navigate(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L1120">1120</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L1182">1182</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    public void navigate(final double timeInterval,
                         final Distance oldX,
                         final Distance oldY,
                         final Distance oldZ,
                         final CoordinateTransformation oldC,
                         final Speed oldSpeedX,
                         final Speed oldSpeedY,
                         final Speed oldSpeedZ,
                         final double fx,
                         final double fy,
                         final double fz,
                         final double angularRateX,
                         final double angularRateY,
                         final double angularRateZ,
                         final ECIFrame result)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        navigateECI(timeInterval, oldX, oldY, oldZ, oldC,
                oldSpeedX, oldSpeedY, oldSpeedZ, fx, fy, fz,
                angularRateX, angularRateY, angularRateZ, result);
    }

    /**
     * Runs precision ECI-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldX         previous cartesian x-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes.
     * @param oldY         previous cartesian y-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes.
     * @param oldZ         previous cartesian z-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes.
     * @param oldC         previous body-to-ECI-frame coordinate transformation.
     * @param oldSpeedX    previous velocity x-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes.
     * @param oldSpeedY    previous velocity y-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes.
     * @param oldSpeedZ    previous velocity z-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes.
     * @param fx           specific force x-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param result       instance where new estimated ECI frame containing new body position,
     *                     velocity and coordinate transformation matrix will be stored.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-ECI-frame coordinate transformation matrix are invalid.
     */
    public void navigate(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L1238">1238</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L1294">1294</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    public void navigate(final double timeInterval,
                         final Distance oldX,
                         final Distance oldY,
                         final Distance oldZ,
                         final CoordinateTransformation oldC,
                         final Speed oldSpeedX,
                         final Speed oldSpeedY,
                         final Speed oldSpeedZ,
                         final Acceleration fx,
                         final Acceleration fy,
                         final Acceleration fz,
                         final AngularSpeed angularRateX,
                         final AngularSpeed angularRateY,
                         final AngularSpeed angularRateZ,
                         final ECIFrame result)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        navigateECI(timeInterval, oldX, oldY, oldZ, oldC,
                oldSpeedX, oldSpeedY, oldSpeedZ, fx, fy, fz,
                angularRateX, angularRateY, angularRateZ, result);
    }

    /**
     * Runs precision ECI-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldX         previous cartesian x-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes.
     * @param oldY         previous cartesian y-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes.
     * @param oldZ         previous cartesian z-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes.
     * @param oldC         previous body-to-ECI-frame coordinate transformation.
     * @param oldSpeedX    previous velocity x-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes.
     * @param oldSpeedY    previous velocity y-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes.
     * @param oldSpeedZ    previous velocity z-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes.
     * @param fx           specific force x-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fy           specific force y-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fz           specific force z-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateX angular rate x-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateY angular rate y-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param result       instance where new estimated ECI frame containing new body position,
     *                     velocity and coordinate transformation matrix will be stored.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-ECI-frame coordinate transformation matrix are invalid.
     */
    public void navigate(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L1350">1350</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L1405">1405</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    public void navigate(final double timeInterval,
                         final double oldX,
                         final double oldY,
                         final double oldZ,
                         final CoordinateTransformation oldC,
                         final double oldVx,
                         final double oldVy,
                         final double oldVz,
                         final Acceleration fx,
                         final Acceleration fy,
                         final Acceleration fz,
                         final AngularSpeed angularRateX,
                         final AngularSpeed angularRateY,
                         final AngularSpeed angularRateZ,
                         final ECIFrame result)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        navigateECI(timeInterval, oldX, oldY, oldZ, oldC, oldVx, oldVy, oldVz,
                fx, fy, fz, angularRateX, angularRateY, angularRateZ, result);
    }

    /**
     * Runs precision ECI-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldX         previous cartesian x-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldY         previous cartesian y-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldZ         previous cartesian z-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldC         previous body-to-ECI-frame coordinate transformation.
     * @param oldVx        previous velocity x-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param oldVy        previous velocity y-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param oldVz        previous velocity z-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param fx           specific force x-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fy           specific force y-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fz           specific force z-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateX angular rate x-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateY angular rate y-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param result       instance where new estimated ECI frame containing new body position,
     *                     velocity and coordinate transformation matrix will be stored.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-ECI-frame coordinate transformation matrix are invalid.
     */
    public void navigate(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L101">101</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L163">163</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    public void navigate(final double timeInterval,
                         final double oldLatitude,
                         final double oldLongitude,
                         final double oldHeight,
                         final CoordinateTransformation oldC,
                         final double oldVn,
                         final double oldVe,
                         final double oldVd,
                         final double fx,
                         final double fy,
                         final double fz,
                         final double angularRateX,
                         final double angularRateY,
                         final double angularRateZ,
                         final NEDFrame result)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        navigateNED(timeInterval, oldLatitude, oldLongitude, oldHeight, oldC,
                oldVn, oldVe, oldVd, fx, fy, fz,
                angularRateX, angularRateY, angularRateZ, result);
    }

    /**
     * Runs precision local-navigation-frame inertial navigation equations.
     * NOTE: only the attitude update and specific force frame transformation
     * phases are precise.
     *
     * @param timeInterval time interval between epochs.
     * @param oldLatitude  previous latitude expressed in radians (rad).
     * @param oldLongitude previous longitude expressed in radians (rad).
     * @param oldHeight    previous height expressed in meters (m).
     * @param oldC         previous body-to-NED coordinate transformation.
     * @param oldVn        previous velocity north-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param oldVe        previous velocity east-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param oldVd        previous velocity down-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param result       instance where new estimated NED frame containing new body position,
     *                     velocity and coordinate transformation matrix will be stored.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-NED-frame coordinate transformation matrix are
     *                                                       invalid.
     */
    public void navigate(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L841">841</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L903">903</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    public void navigate(final double timeInterval,
                         final Angle oldLatitude,
                         final Angle oldLongitude,
                         final Distance oldHeight,
                         final CoordinateTransformation oldC,
                         final double oldVn,
                         final double oldVe,
                         final double oldVd,
                         final double fx,
                         final double fy,
                         final double fz,
                         final double angularRateX,
                         final double angularRateY,
                         final double angularRateZ,
                         final NEDFrame result)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        navigateNED(timeInterval, oldLatitude, oldLongitude, oldHeight, oldC,
                oldVn, oldVe, oldVd, fx, fy, fz,
                angularRateX, angularRateY, angularRateZ, result);
    }

    /**
     * Runs precision local-navigation-frame inertial navigation equations.
     * NOTE: only the attitude update and specific force frame transformation
     * phases are precise.
     *
     * @param timeInterval time interval between epochs.
     * @param oldLatitude  previous latitude angle.
     * @param oldLongitude previous longitude angle.
     * @param oldHeight    previous height.
     * @param oldC         previous body-to-NED coordinate transformation.
     * @param oldVn        previous velocity north-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param oldVe        previous velocity east-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param oldVd        previous velocity down-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param result       instance where new estimated NED frame containing new body position,
     *                     velocity and coordinate transformation matrix will be stored.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-NED-frame coordinate transformation matrix are
     *                                                       invalid.
     */
    public void navigate(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L1225">1225</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L1287">1287</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    public void navigate(final double timeInterval,
                         final double oldLatitude,
                         final double oldLongitude,
                         final double oldHeight,
                         final CoordinateTransformation oldC,
                         final Speed oldSpeedN,
                         final Speed oldSpeedE,
                         final Speed oldSpeedD,
                         final double fx,
                         final double fy,
                         final double fz,
                         final double angularRateX,
                         final double angularRateY,
                         final double angularRateZ,
                         final NEDFrame result)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        navigateNED(timeInterval, oldLatitude, oldLongitude, oldHeight, oldC,
                oldSpeedN, oldSpeedE, oldSpeedD, fx, fy, fz,
                angularRateX, angularRateY, angularRateZ, result);
    }

    /**
     * Runs precision local-navigation-frame inertial navigation equations.
     * NOTE: only the attitude update and specific force frame transformation
     * phases are precise.
     *
     * @param timeInterval time interval between epochs.
     * @param oldLatitude  previous latitude expressed in radians (rad).
     * @param oldLongitude previous longitude expressed in radians (rad).
     * @param oldHeight    previous height expressed in meters (m).
     * @param oldC         previous body-to-NED coordinate transformation.
     * @param oldSpeedN    previous velocity north-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes.
     * @param oldSpeedE    previous velocity east-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes.
     * @param oldSpeedD    previous velocity down-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes.
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param result       instance where new estimated NED frame containing new body position,
     *                     velocity and coordinate transformation matrix will be stored.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-NED-frame coordinate transformation matrix are
     *                                                       invalid.
     */
    public void navigate(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L1616">1616</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L1675">1675</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    public void navigate(final double timeInterval,
                         final double oldLatitude,
                         final double oldLongitude,
                         final double oldHeight,
                         final CoordinateTransformation oldC,
                         final double oldVn,
                         final double oldVe,
                         final double oldVd,
                         final Acceleration fx,
                         final Acceleration fy,
                         final Acceleration fz,
                         final double angularRateX,
                         final double angularRateY,
                         final double angularRateZ,
                         final NEDFrame result)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        navigateNED(timeInterval, oldLatitude, oldLongitude, oldHeight, oldC,
                oldVn, oldVe, oldVd, fx, fy, fz,
                angularRateX, angularRateY, angularRateZ, result);
    }

    /**
     * Runs precision local-navigation-frame inertial navigation equations.
     * NOTE: only the attitude update and specific force frame transformation
     * phases are precise.
     *
     * @param timeInterval time interval between epochs.
     * @param oldLatitude  previous latitude expressed in radians (rad).
     * @param oldLongitude previous longitude expressed in radians (rad).
     * @param oldHeight    previous height expressed in meters (m).
     * @param oldC         previous body-to-NED coordinate transformation.
     * @param oldVn        previous velocity north-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param oldVe        previous velocity east-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param oldVd        previous velocity down-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param result       instance where new estimated NED frame containing new body position,
     *                     velocity and coordinate transformation matrix will be stored.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-NED-frame coordinate transformation matrix are
     *                                                       invalid.
     */
    public void navigate(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L2048">2048</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L2107">2107</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    public void navigate(final double timeInterval,
                         final double oldLatitude,
                         final double oldLongitude,
                         final double oldHeight,
                         final CoordinateTransformation oldC,
                         final double oldVn,
                         final double oldVe,
                         final double oldVd,
                         final double fx,
                         final double fy,
                         final double fz,
                         final AngularSpeed angularRateX,
                         final AngularSpeed angularRateY,
                         final AngularSpeed angularRateZ,
                         final NEDFrame result)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        navigateNED(timeInterval, oldLatitude, oldLongitude, oldHeight, oldC,
                oldVn, oldVe, oldVd, fx, fy, fz,
                angularRateX, angularRateY, angularRateZ, result);
    }

    /**
     * Runs precision local-navigation-frame inertial navigation equations.
     * NOTE: only the attitude update and specific force frame transformation
     * phases are precise.
     *
     * @param timeInterval time interval between epochs.
     * @param oldLatitude  previous latitude expressed in radians (rad).
     * @param oldLongitude previous longitude expressed in radians (rad).
     * @param oldHeight    previous height expressed in meters (m).
     * @param oldC         previous body-to-NED coordinate transformation.
     * @param oldVn        previous velocity north-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param oldVe        previous velocity east-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param oldVd        previous velocity down-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param result       instance where new estimated NED frame containing new body position,
     *                     velocity and coordinate transformation matrix will be stored.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-NED-frame coordinate transformation matrix are
     *                                                       invalid.
     */
    public void navigate(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L2483">2483</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L2545">2545</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    public void navigate(final double timeInterval,
                         final Angle oldLatitude,
                         final Angle oldLongitude,
                         final Distance oldHeight,
                         final CoordinateTransformation oldC,
                         final Speed oldSpeedN,
                         final Speed oldSpeedE,
                         final Speed oldSpeedD,
                         final double fx,
                         final double fy,
                         final double fz,
                         final double angularRateX,
                         final double angularRateY,
                         final double angularRateZ,
                         final NEDFrame result)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        navigateNED(timeInterval, oldLatitude, oldLongitude, oldHeight, oldC,
                oldSpeedN, oldSpeedE, oldSpeedD, fx, fy, fz,
                angularRateX, angularRateY, angularRateZ, result);
    }

    /**
     * Runs precision local-navigation-frame inertial navigation equations.
     * NOTE: only the attitude update and specific force frame transformation
     * phases are precise.
     *
     * @param timeInterval time interval between epochs.
     * @param oldLatitude  previous latitude angle.
     * @param oldLongitude previous longitude angle.
     * @param oldHeight    previous height.
     * @param oldC         previous body-to-NED coordinate transformation.
     * @param oldSpeedN    previous velocity north-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes.
     * @param oldSpeedE    previous velocity east-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes.
     * @param oldSpeedD    previous velocity down-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes.
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param result       instance where new estimated NED frame containing new body position,
     *                     velocity and coordinate transformation matrix will be stored.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-NED-frame coordinate transformation matrix are
     *                                                       invalid.
     */
    public void navigate(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L2601">2601</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L2657">2657</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    public void navigate(final double timeInterval,
                         final Angle oldLatitude,
                         final Angle oldLongitude,
                         final Distance oldHeight,
                         final CoordinateTransformation oldC,
                         final Speed oldSpeedN,
                         final Speed oldSpeedE,
                         final Speed oldSpeedD,
                         final Acceleration fx,
                         final Acceleration fy,
                         final Acceleration fz,
                         final AngularSpeed angularRateX,
                         final AngularSpeed angularRateY,
                         final AngularSpeed angularRateZ,
                         final NEDFrame result)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        navigateNED(timeInterval, oldLatitude, oldLongitude, oldHeight, oldC,
                oldSpeedN, oldSpeedE, oldSpeedD, fx, fy, fz,
                angularRateX, angularRateY, angularRateZ, result);
    }

    /**
     * Runs precision local-navigation-frame inertial navigation equations.
     * NOTE: only the attitude update and specific force frame transformation
     * phases are precise.
     *
     * @param timeInterval time interval between epochs.
     * @param oldLatitude  previous latitude angle.
     * @param oldLongitude previous longitude angle.
     * @param oldHeight    previous height.
     * @param oldC         previous body-to-NED coordinate transformation.
     * @param oldSpeedN    previous velocity north-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes.
     * @param oldSpeedE    previous velocity east-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes.
     * @param oldSpeedD    previous velocity down-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes.
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param result       instance where new estimated NED frame containing new body position,
     *                     velocity and coordinate transformation matrix will be stored.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-NED-frame coordinate transformation matrix are
     *                                                       invalid.
     */
    public void navigate(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L2713">2713</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L2769">2769</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    public void navigate(final double timeInterval,
                         final double oldLatitude,
                         final double oldLongitude,
                         final double oldHeight,
                         final CoordinateTransformation oldC,
                         final Speed oldSpeedN,
                         final Speed oldSpeedE,
                         final Speed oldSpeedD,
                         final Acceleration fx,
                         final Acceleration fy,
                         final Acceleration fz,
                         final AngularSpeed angularRateX,
                         final AngularSpeed angularRateY,
                         final AngularSpeed angularRateZ,
                         final NEDFrame result)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        navigateNED(timeInterval, oldLatitude, oldLongitude, oldHeight, oldC,
                oldSpeedN, oldSpeedE, oldSpeedD, fx, fy, fz,
                angularRateX, angularRateY, angularRateZ, result);
    }

    /**
     * Runs precision local-navigation-frame inertial navigation equations.
     * NOTE: only the attitude update and specific force frame transformation
     * phases are precise.
     *
     * @param timeInterval time interval between epochs.
     * @param oldLatitude  previous latitude expressed in radians (rad).
     * @param oldLongitude previous longitude expressed in radians (rad).
     * @param oldHeight    previous height expressed in meters (m).
     * @param oldC         previous body-to-NED coordinate transformation.
     * @param oldSpeedN    previous velocity north-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes.
     * @param oldSpeedE    previous velocity east-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes.
     * @param oldSpeedD    previous velocity down-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes.
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param result       instance where new estimated NED frame containing new body position,
     *                     velocity and coordinate transformation matrix will be stored.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-NED-frame coordinate transformation matrix are
     *                                                       invalid.
     */
    public void navigate(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L3121">3121</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L3177">3177</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    public void navigate(final double timeInterval,
                         final Angle oldLatitude,
                         final Angle oldLongitude,
                         final Distance oldHeight,
                         final CoordinateTransformation oldC,
                         final double oldVn,
                         final double oldVe,
                         final double oldVd,
                         final Acceleration fx,
                         final Acceleration fy,
                         final Acceleration fz,
                         final AngularSpeed angularRateX,
                         final AngularSpeed angularRateY,
                         final AngularSpeed angularRateZ,
                         final NEDFrame result)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        navigateNED(timeInterval, oldLatitude, oldLongitude, oldHeight, oldC,
                oldVn, oldVe, oldVd, fx, fy, fz,
                angularRateX, angularRateY, angularRateZ, result);
    }

    /**
     * Runs precision local-navigation-frame inertial navigation equations.
     * NOTE: only the attitude update and specific force frame transformation
     * phases are precise.
     *
     * @param timeInterval time interval between epochs.
     * @param oldLatitude  previous latitude angle.
     * @param oldLongitude previous longitude angle.
     * @param oldHeight    previous height.
     * @param oldC         previous body-to-NED coordinate transformation.
     * @param oldVn        previous velocity north-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param oldVe        previous velocity east-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param oldVd        previous velocity down-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param result       instance where new estimated NED frame containing new body position,
     *                     velocity and coordinate transformation matrix will be stored.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-NED-frame coordinate transformation matrix are
     *                                                       invalid.
     */
    public void navigate(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L3337">3337</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L3393">3393</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    public void navigate(final double timeInterval,
                         final double oldLatitude,
                         final double oldLongitude,
                         final double oldHeight,
                         final CoordinateTransformation oldC,
                         final double oldVn,
                         final double oldVe,
                         final double oldVd,
                         final Acceleration fx,
                         final Acceleration fy,
                         final Acceleration fz,
                         final AngularSpeed angularRateX,
                         final AngularSpeed angularRateY,
                         final AngularSpeed angularRateZ,
                         final NEDFrame result)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        navigateNED(timeInterval, oldLatitude, oldLongitude, oldHeight, oldC,
                oldVn, oldVe, oldVd, fx, fy, fz,
                angularRateX, angularRateY, angularRateZ, result);
    }

    /**
     * Runs precision local-navigation-frame inertial navigation equations.
     * NOTE: only the attitude update and specific force frame transformation
     * phases are precise.
     *
     * @param timeInterval time interval between epochs.
     * @param oldLatitude  previous latitude expressed in radians (rad).
     * @param oldLongitude previous longitude expressed in radians (rad).
     * @param oldHeight    previous height expressed in meters (m).
     * @param oldC         previous body-to-NED coordinate transformation.
     * @param oldVn        previous velocity north-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param oldVe        previous velocity east-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param oldVd        previous velocity down-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param result       instance where new estimated NED frame containing new body position,
     *                     velocity and coordinate transformation matrix will be stored.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-NED-frame coordinate transformation matrix are
     *                                                       invalid.
     */
    public void navigate(final Time timeInterval,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/calibration/KnownFrameAccelerometerNonLinearLeastSquaresCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/KnownFrameAccelerometerNonLinearLeastSquaresCalibrator.html#L3488">3488</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/calibration/KnownFrameAccelerometerNonLinearLeastSquaresCalibrator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/calibration/KnownFrameAccelerometerNonLinearLeastSquaresCalibrator.html#L3724">3724</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>                result[2] = bz + ftruez + sz * ftruez;

                jacobian.setElementAt(0, 0, 1.0);
                jacobian.setElementAt(0, 1, 0.0);
                jacobian.setElementAt(0, 2, 0.0);
                jacobian.setElementAt(0, 3, ftruex);
                jacobian.setElementAt(0, 4, 0.0);
                jacobian.setElementAt(0, 5, 0.0);
                jacobian.setElementAt(0, 6, ftruey);
                jacobian.setElementAt(0, 7, ftruez);
                jacobian.setElementAt(0, 8, 0.0);

                jacobian.setElementAt(1, 0, 0.0);</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L11826">11826</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L12872">12872</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>                                                     final double oldZ,
                                                     final CoordinateTransformation oldC,
                                                     final double oldVx,
                                                     final double oldVy,
                                                     final double oldVz,
                                                     final double fx,
                                                     final double fy,
                                                     final double fz,
                                                     final double angularRateX,
                                                     final double angularRateY,
                                                     final double angularRateZ)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        final ECEFFrame result = new ECEFFrame();
        navigateECEF(timeInterval, oldX, oldY, oldZ, oldC, oldVx, oldVy, oldVz,
                fx, fy, fz, angularRateX, angularRateY, angularRateZ, result);
        return result;
    }

    /**
     * Runs precision ECEF-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldX         previous cartesian x-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldY         previous cartesian y-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldZ         previous cartesian z-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldC         previous body-to-ECEF-frame coordinate transformation.
     * @param oldVx        previous velocity x-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param oldVy        previous velocity y-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param oldVz        previous velocity z-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @return estimated ECEF frame containing new body position, velocity and coordinate
     * transformation matrix.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-ECEF-frame coordinate transformation matrix are invalid.
     */
    public static ECEFFrame navigateECEFAndReturnNew(final Time timeInterval,
                                                     final double oldX,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L11833">11833</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L13646">13646</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>                                                     final double fz,
                                                     final double angularRateX,
                                                     final double angularRateY,
                                                     final double angularRateZ)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        final ECEFFrame result = new ECEFFrame();
        navigateECEF(timeInterval, oldX, oldY, oldZ, oldC, oldVx, oldVy, oldVz,
                fx, fy, fz, angularRateX, angularRateY, angularRateZ, result);
        return result;
    }

    /**
     * Runs precision ECEF-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldX         previous cartesian x-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldY         previous cartesian y-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldZ         previous cartesian z-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldC         previous body-to-ECEF-frame coordinate transformation.
     * @param oldVx        previous velocity x-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param oldVy        previous velocity y-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param oldVz        previous velocity z-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @return estimated ECEF frame containing new body position, velocity and coordinate
     * transformation matrix.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-ECEF-frame coordinate transformation matrix are invalid.
     */
    public static ECEFFrame navigateECEFAndReturnNew(final Time timeInterval,
                                                     final double oldX,
                                                     final double oldY,
                                                     final double oldZ,
                                                     final CoordinateTransformation oldC,
                                                     final double oldVx,
                                                     final double oldVy,
                                                     final double oldVz,
                                                     final double fx,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L11836">11836</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L14068">14068</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>                                                     final double angularRateZ)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        final ECEFFrame result = new ECEFFrame();
        navigateECEF(timeInterval, oldX, oldY, oldZ, oldC, oldVx, oldVy, oldVz,
                fx, fy, fz, angularRateX, angularRateY, angularRateZ, result);
        return result;
    }

    /**
     * Runs precision ECEF-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldX         previous cartesian x-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldY         previous cartesian y-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldZ         previous cartesian z-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldC         previous body-to-ECEF-frame coordinate transformation.
     * @param oldVx        previous velocity x-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param oldVy        previous velocity y-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param oldVz        previous velocity z-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @return estimated ECEF frame containing new body position, velocity and coordinate
     * transformation matrix.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-ECEF-frame coordinate transformation matrix are invalid.
     */
    public static ECEFFrame navigateECEFAndReturnNew(final Time timeInterval,
                                                     final double oldX,
                                                     final double oldY,
                                                     final double oldZ,
                                                     final CoordinateTransformation oldC,
                                                     final double oldVx,
                                                     final double oldVy,
                                                     final double oldVz,
                                                     final double fx,
                                                     final double fy,
                                                     final double fz,
                                                     final double angularRateX,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L11888">11888</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L12934">12934</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>                                                     final double oldZ,
                                                     final CoordinateTransformation oldC,
                                                     final double oldVx,
                                                     final double oldVy,
                                                     final double oldVz,
                                                     final double fx,
                                                     final double fy,
                                                     final double fz,
                                                     final double angularRateX,
                                                     final double angularRateY,
                                                     final double angularRateZ)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        final ECEFFrame result = new ECEFFrame();
        navigateECEF(timeInterval, oldX, oldY, oldZ, oldC, oldVx, oldVy, oldVz,
                fx, fy, fz, angularRateX, angularRateY, angularRateZ, result);
        return result;
    }

    /**
     * Runs precision ECEF-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs expressed in seconds (s).
     * @param oldPosition  previous cartesian position resolved along ECEF-frame axes.
     * @param oldC         previous body-to-ECEF-frame coordinate transformation.
     * @param oldVx        previous velocity x-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param oldVy        previous velocity y-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param oldVz        previous velocity z-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @return estimated ECEF frame containing new body position, velocity and coordinate
     * transformation matrix.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-ECEF-frame coordinate transformation matrix are invalid.
     */
    public static ECEFFrame navigateECEFAndReturnNew(final double timeInterval,
                                                     final ECEFPosition oldPosition,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L13256">13256</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L14477">14477</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>                                                     final double oldZ,
                                                     final CoordinateTransformation oldC,
                                                     final Speed oldSpeedX,
                                                     final Speed oldSpeedY,
                                                     final Speed oldSpeedZ,
                                                     final double fx,
                                                     final double fy,
                                                     final double fz,
                                                     final double angularRateX,
                                                     final double angularRateY,
                                                     final double angularRateZ)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        final ECEFFrame result = new ECEFFrame();
        navigateECEF(timeInterval, oldX, oldY, oldZ, oldC, oldSpeedX, oldSpeedY,
                oldSpeedZ, fx, fy, fz, angularRateX, angularRateY, angularRateZ, result);
        return result;
    }

    /**
     * Runs precision ECEF-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldX         previous cartesian x-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldY         previous cartesian y-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldZ         previous cartesian z-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldC         previous body-to-ECEF-frame coordinate transformation.
     * @param oldSpeedX    previous velocity x-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param oldSpeedY    previous velocity y-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param oldSpeedZ    previous velocity z-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @return estimated ECEF frame containing new body position, velocity and coordinate
     * transformation matrix.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-ECEF-frame coordinate transformation matrix are invalid.
     */
    public static ECEFFrame navigateECEFAndReturnNew(final Time timeInterval,
                                                     final double oldX,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L13318">13318</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L14540">14540</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>                                                     final double oldZ,
                                                     final CoordinateTransformation oldC,
                                                     final Speed oldSpeedX,
                                                     final Speed oldSpeedY,
                                                     final Speed oldSpeedZ,
                                                     final double fx,
                                                     final double fy,
                                                     final double fz,
                                                     final double angularRateX,
                                                     final double angularRateY,
                                                     final double angularRateZ)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        final ECEFFrame result = new ECEFFrame();
        navigateECEF(timeInterval, oldX, oldY, oldZ, oldC, oldSpeedX, oldSpeedY,
                oldSpeedZ, fx, fy, fz, angularRateX, angularRateY, angularRateZ, result);
        return result;
    }

    /**
     * Runs precision ECEF-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs expressed in seconds (s).
     * @param oldPosition  previous cartesian position resolved along ECEF-frame axes.
     * @param oldC         previous body-to-ECEF-frame coordinate transformation.
     * @param oldSpeedX    previous velocity x-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param oldSpeedY    previous velocity y-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param oldSpeedZ    previous velocity z-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes.
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @return estimated ECEF frame containing new body position, velocity and coordinate
     * transformation matrix.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-ECEF-frame coordinate transformation matrix are invalid.
     */
    public static ECEFFrame navigateECEFAndReturnNew(final double timeInterval,
                                                     final ECEFPosition oldPosition,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L13649">13649</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L15001">15001</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>                                                     final double angularRateZ)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        final ECEFFrame result = new ECEFFrame();
        navigateECEF(timeInterval, oldX, oldY, oldZ, oldC, oldVx, oldVy, oldVz, fx, fy,
                fz, angularRateX, angularRateY, angularRateZ, result);
        return result;
    }

    /**
     * Runs precision ECEF-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldX         previous cartesian x-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldY         previous cartesian y-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldZ         previous cartesian z-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldC         previous body-to-ECEF-frame coordinate transformation.
     * @param oldVx        previous velocity x-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param oldVy        previous velocity y-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param oldVz        previous velocity z-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @return estimated ECEF frame containing new body position, velocity and coordinate
     * transformation matrix.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-ECEF-frame coordinate transformation matrix are invalid.
     */
    public static ECEFFrame navigateECEFAndReturnNew(final Time timeInterval,
                                                     final double oldX,
                                                     final double oldY,
                                                     final double oldZ,
                                                     final CoordinateTransformation oldC,
                                                     final double oldVx,
                                                     final double oldVy,
                                                     final double oldVz,
                                                     final Acceleration fx,
                                                     final Acceleration fy,
                                                     final Acceleration fz,
                                                     final double angularRateX,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L14065">14065</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECEFInertialNavigator.html#L14998">14998</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>                                                     final double fz,
                                                     final AngularSpeed angularRateX,
                                                     final AngularSpeed angularRateY,
                                                     final AngularSpeed angularRateZ)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        final ECEFFrame result = new ECEFFrame();
        navigateECEF(timeInterval, oldX, oldY, oldZ, oldC, oldVx, oldVy, oldVz, fx, fy,
                fz, angularRateX, angularRateY, angularRateZ, result);
        return result;
    }

    /**
     * Runs precision ECEF-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldX         previous cartesian x-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldY         previous cartesian y-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldZ         previous cartesian z-coordinate position of body frame with respect ECEF
     *                     frame, resolved along ECEF-frame axes and expressed in meters (m).
     * @param oldC         previous body-to-ECEF-frame coordinate transformation.
     * @param oldVx        previous velocity x-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param oldVy        previous velocity y-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param oldVz        previous velocity z-coordinate of body frame with respect ECEF frame,
     *                     resolved along ECEF-frame axes and expressed in meters per second (m/s).
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @return estimated ECEF frame containing new body position, velocity and coordinate
     * transformation matrix.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-ECEF-frame coordinate transformation matrix are invalid.
     */
    public static ECEFFrame navigateECEFAndReturnNew(final Time timeInterval,
                                                     final double oldX,
                                                     final double oldY,
                                                     final double oldZ,
                                                     final CoordinateTransformation oldC,
                                                     final double oldVx,
                                                     final double oldVy,
                                                     final double oldVz,
                                                     final double fx,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L5670">5670</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L6065">6065</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>                                                   final double oldZ,
                                                   final CoordinateTransformation oldC,
                                                   final double oldVx,
                                                   final double oldVy,
                                                   final double oldVz,
                                                   final double fx,
                                                   final double fy,
                                                   final double fz,
                                                   final double angularRateX,
                                                   final double angularRateY,
                                                   final double angularRateZ)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        final ECIFrame result = new ECIFrame();
        navigateECI(timeInterval, oldX, oldY, oldZ, oldC, oldVx, oldVy, oldVz,
                fx, fy, fz, angularRateX, angularRateY, angularRateZ, result);
        return result;
    }

    /**
     * Runs precision ECI-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldX         previous cartesian x-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldY         previous cartesian y-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldZ         previous cartesian z-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldC         previous body-to-ECI-frame coordinate transformation.
     * @param oldVx        previous velocity x-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param oldVy        previous velocity y-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param oldVz        previous velocity z-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param fx           specific force x-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @return estimated ECI frame containing new body position, velocity and coordinate
     * transformation matrix.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-ECI-frame coordinate transformation matrix are
     *                                                       invalid.
     */
    public static ECIFrame navigateECIAndReturnNew(final Time timeInterval,
                                                   final double oldX,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L5677">5677</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L6485">6485</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>                                                   final double fz,
                                                   final double angularRateX,
                                                   final double angularRateY,
                                                   final double angularRateZ)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        final ECIFrame result = new ECIFrame();
        navigateECI(timeInterval, oldX, oldY, oldZ, oldC, oldVx, oldVy, oldVz,
                fx, fy, fz, angularRateX, angularRateY, angularRateZ, result);
        return result;
    }

    /**
     * Runs precision ECI-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldX         previous cartesian x-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldY         previous cartesian y-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldZ         previous cartesian z-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldC         previous body-to-ECI-frame coordinate transformation.
     * @param oldVx        previous velocity x-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param oldVy        previous velocity y-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param oldVz        previous velocity z-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param fx           specific force x-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @return estimated ECI frame containing new body position, velocity and coordinate
     * transformation matrix.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-ECI-frame coordinate transformation matrix are
     *                                                       invalid.
     */
    public static ECIFrame navigateECIAndReturnNew(final Time timeInterval,
                                                   final double oldX,
                                                   final double oldY,
                                                   final double oldZ,
                                                   final CoordinateTransformation oldC,
                                                   final double oldVx,
                                                   final double oldVy,
                                                   final double oldVz,
                                                   final double fx,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L5680">5680</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L6606">6606</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>                                                   final double angularRateZ)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        final ECIFrame result = new ECIFrame();
        navigateECI(timeInterval, oldX, oldY, oldZ, oldC, oldVx, oldVy, oldVz,
                fx, fy, fz, angularRateX, angularRateY, angularRateZ, result);
        return result;
    }

    /**
     * Runs precision ECI-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldX         previous cartesian x-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldY         previous cartesian y-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldZ         previous cartesian z-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldC         previous body-to-ECI-frame coordinate transformation.
     * @param oldVx        previous velocity x-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param oldVy        previous velocity y-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param oldVz        previous velocity z-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param fx           specific force x-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @return estimated ECI frame containing new body position, velocity and coordinate
     * transformation matrix.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-ECI-frame coordinate transformation matrix are
     *                                                       invalid.
     */
    public static ECIFrame navigateECIAndReturnNew(final Time timeInterval,
                                                   final double oldX,
                                                   final double oldY,
                                                   final double oldZ,
                                                   final CoordinateTransformation oldC,
                                                   final double oldVx,
                                                   final double oldVy,
                                                   final double oldVz,
                                                   final double fx,
                                                   final double fy,
                                                   final double fz,
                                                   final double angularRateX,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L5733">5733</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L6127">6127</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>                                                   final double oldZ,
                                                   final CoordinateTransformation oldC,
                                                   final double oldVx,
                                                   final double oldVy,
                                                   final double oldVz,
                                                   final double fx,
                                                   final double fy,
                                                   final double fz,
                                                   final double angularRateX,
                                                   final double angularRateY,
                                                   final double angularRateZ)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        final ECIFrame result = new ECIFrame();
        navigateECI(timeInterval, oldX, oldY, oldZ, oldC, oldVx, oldVy, oldVz,
                fx, fy, fz, angularRateX, angularRateY, angularRateZ, result);
        return result;
    }

    /**
     * Runs precision ECI-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs expressed in seconds (s).
     * @param oldX         previous cartesian x-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldY         previous cartesian y-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldZ         previous cartesian z-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldC         previous body-to-ECI-frame coordinate transformation.
     * @param oldVx        previous velocity x-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param oldVy        previous velocity y-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param oldVz        previous velocity z-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param kinematics   body kinematics containing specific forces and angular rates applied to
     *                     the body.
     * @return estimated ECI frame containing new body position, velocity and coordinate
     * transformation matrix.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-ECI-frame coordinate transformation matrix are
     *                                                       invalid.
     */
    public static ECIFrame navigateECIAndReturnNew(final double timeInterval,
                                                   final double oldX,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L5740">5740</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L6544">6544</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>                                                   final double fz,
                                                   final double angularRateX,
                                                   final double angularRateY,
                                                   final double angularRateZ)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        final ECIFrame result = new ECIFrame();
        navigateECI(timeInterval, oldX, oldY, oldZ, oldC, oldVx, oldVy, oldVz,
                fx, fy, fz, angularRateX, angularRateY, angularRateZ, result);
        return result;
    }

    /**
     * Runs precision ECI-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs expressed in seconds (s).
     * @param oldX         previous cartesian x-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldY         previous cartesian y-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldZ         previous cartesian z-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldC         previous body-to-ECI-frame coordinate transformation.
     * @param oldVx        previous velocity x-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param oldVy        previous velocity y-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param oldVz        previous velocity z-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param kinematics   body kinematics containing specific forces and angular rates applied to
     *                     the body.
     * @return estimated ECI frame containing new body position, velocity and coordinate
     * transformation matrix.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-ECI-frame coordinate transformation matrix are
     *                                                       invalid.
     */
    public static ECIFrame navigateECIAndReturnNew(final double timeInterval,
                                                   final double oldX,
                                                   final double oldY,
                                                   final double oldZ,
                                                   final CoordinateTransformation oldC,
                                                   final double oldVx,
                                                   final double oldVy,
                                                   final double oldVz,
                                                   final BodyKinematics kinematics)</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L6273">6273</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L6717">6717</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>                                                   final double oldZ,
                                                   final CoordinateTransformation oldC,
                                                   final Speed oldSpeedX,
                                                   final Speed oldSpeedY,
                                                   final Speed oldSpeedZ,
                                                   final double fx,
                                                   final double fy,
                                                   final double fz,
                                                   final double angularRateX,
                                                   final double angularRateY,
                                                   final double angularRateZ)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        final ECIFrame result = new ECIFrame();
        navigateECI(timeInterval, oldX, oldY, oldZ, oldC, oldSpeedX, oldSpeedY, oldSpeedZ,
                fx, fy, fz, angularRateX, angularRateY, angularRateZ, result);
        return result;
    }

    /**
     * Runs precision ECI-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldX         previous cartesian x-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldY         previous cartesian y-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldZ         previous cartesian z-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldC         previous body-to-ECI-frame coordinate transformation.
     * @param oldSpeedX    previous velocity x-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes.
     * @param oldSpeedY    previous velocity y-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes.
     * @param oldSpeedZ    previous velocity z-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes.
     * @param fx           specific force x-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @return estimated ECI frame containing new body position, velocity and coordinate
     * transformation matrix.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-ECI-frame coordinate transformation matrix are invalid.
     */
    public static ECIFrame navigateECIAndReturnNew(final Time timeInterval,
                                                   final double oldX,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L6335">6335</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L6779">6779</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>                                                   final double oldZ,
                                                   final CoordinateTransformation oldC,
                                                   final Speed oldSpeedX,
                                                   final Speed oldSpeedY,
                                                   final Speed oldSpeedZ,
                                                   final double fx,
                                                   final double fy,
                                                   final double fz,
                                                   final double angularRateX,
                                                   final double angularRateY,
                                                   final double angularRateZ)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        final ECIFrame result = new ECIFrame();
        navigateECI(timeInterval, oldX, oldY, oldZ, oldC, oldSpeedX, oldSpeedY, oldSpeedZ,
                fx, fy, fz, angularRateX, angularRateY, angularRateZ, result);
        return result;
    }

    /**
     * Runs precision ECI-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs expressed in seconds (s).
     * @param oldX         previous cartesian x-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldY         previous cartesian y-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldZ         previous cartesian z-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldC         previous body-to-ECI-frame coordinate transformation.
     * @param oldSpeedX    previous velocity x-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes.
     * @param oldSpeedY    previous velocity y-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes.
     * @param oldSpeedZ    previous velocity z-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes.
     * @param kinematics   body kinematics containing specific forces and angular rates applied to
     *                     the body.
     * @return estimated ECI frame containing new body position, velocity and coordinate
     * transformation matrix.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-ECI-frame coordinate transformation matrix are
     *                                                       invalid.
     */
    public static ECIFrame navigateECIAndReturnNew(final double timeInterval,
                                                   final double oldX,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L6488">6488</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L6957">6957</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>                                                   final double angularRateZ)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        final ECIFrame result = new ECIFrame();
        navigateECI(timeInterval, oldX, oldY, oldZ, oldC, oldVx, oldVy, oldVz,
                fx, fy, fz, angularRateX, angularRateY, angularRateZ, result);
        return result;
    }

    /**
     * Runs precision ECI-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldX         previous cartesian x-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldY         previous cartesian y-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldZ         previous cartesian z-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldC         previous body-to-ECI-frame coordinate transformation.
     * @param oldVx        previous velocity x-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param oldVy        previous velocity y-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param oldVz        previous velocity z-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param fx           specific force x-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fy           specific force y-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fz           specific force z-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateX angular rate x-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @return estimated ECI frame containing new body position, velocity and coordinate
     * transformation matrix.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-ECI-frame coordinate transformation matrix are invalid.
     */
    public static ECIFrame navigateECIAndReturnNew(final Time timeInterval,
                                                   final double oldX,
                                                   final double oldY,
                                                   final double oldZ,
                                                   final CoordinateTransformation oldC,
                                                   final double oldVx,
                                                   final double oldVy,
                                                   final double oldVz,
                                                   final Acceleration fx,
                                                   final Acceleration fy,
                                                   final Acceleration fz,
                                                   final double angularRateX,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L6603">6603</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L6954">6954</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>                                                   final double fz,
                                                   final AngularSpeed angularRateX,
                                                   final AngularSpeed angularRateY,
                                                   final AngularSpeed angularRateZ)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        final ECIFrame result = new ECIFrame();
        navigateECI(timeInterval, oldX, oldY, oldZ, oldC, oldVx, oldVy, oldVz,
                fx, fy, fz, angularRateX, angularRateY, angularRateZ, result);
        return result;
    }

    /**
     * Runs precision ECI-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs.
     * @param oldX         previous cartesian x-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldY         previous cartesian y-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldZ         previous cartesian z-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes and expressed in meters (m).
     * @param oldC         previous body-to-ECI-frame coordinate transformation.
     * @param oldVx        previous velocity x-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param oldVy        previous velocity y-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param oldVz        previous velocity z-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes and expressed in meters per second (m/s).
     * @param fx           specific force x-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateY angular rate y-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @return estimated ECI frame containing new body position, velocity and coordinate
     * transformation matrix.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-ECI-frame coordinate transformation matrix are invalid.
     */
    public static ECIFrame navigateECIAndReturnNew(final Time timeInterval,
                                                   final double oldX,
                                                   final double oldY,
                                                   final double oldZ,
                                                   final CoordinateTransformation oldC,
                                                   final double oldVx,
                                                   final double oldVy,
                                                   final double oldVz,
                                                   final double fx,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L6662">6662</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/ECIInertialNavigator.html#L7010">7010</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>                                                   final double fz,
                                                   final AngularSpeed angularRateX,
                                                   final AngularSpeed angularRateY,
                                                   final AngularSpeed angularRateZ)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        final ECIFrame result = new ECIFrame();
        navigateECI(timeInterval, oldX, oldY, oldZ, oldC, oldVx, oldVy, oldVz,
                fx, fy, fz, angularRateX, angularRateY, angularRateZ, result);
        return result;
    }

    /**
     * Runs precision ECI-frame inertial navigation equations.
     *
     * @param timeInterval time interval between epochs expressed in seconds (s).
     * @param oldX         previous cartesian x-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes.
     * @param oldY         previous cartesian y-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes.
     * @param oldZ         previous cartesian z-coordinate position of body frame with respect ECI
     *                     frame, resolved along ECI-frame axes.
     * @param oldC         previous body-to-ECI-frame coordinate transformation.
     * @param oldSpeedX    previous velocity x-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes.
     * @param oldSpeedY    previous velocity y-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes.
     * @param oldSpeedZ    previous velocity z-coordinate of body frame with respect ECI frame,
     *                     resolved along ECI-frame axes.
     * @param fx           specific force x-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECI frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @return estimated ECI frame containing new body position, velocity and coordinate
     * transformation matrix.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-ECI-frame coordinate transformation matrix are invalid.
     */
    public static ECIFrame navigateECIAndReturnNew(final double timeInterval,
                                                   final Distance oldX,
                                                   final Distance oldY,
                                                   final Distance oldZ,
                                                   final CoordinateTransformation oldC,
                                                   final Speed oldSpeedX,
                                                   final Speed oldSpeedY,
                                                   final Speed oldSpeedZ,
                                                   final double fx,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L11742">11742</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L12496">12496</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>                                                   final double oldHeight,
                                                   final CoordinateTransformation oldC,
                                                   final double oldVn,
                                                   final double oldVe,
                                                   final double oldVd,
                                                   final double fx,
                                                   final double fy,
                                                   final double fz,
                                                   final double angularRateX,
                                                   final double angularRateY,
                                                   final double angularRateZ)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        final NEDFrame result = new NEDFrame();
        navigateNED(timeInterval, oldLatitude, oldLongitude, oldHeight, oldC,
                oldVn, oldVe, oldVd, fx, fy, fz, angularRateX, angularRateY,
                angularRateZ, result);
        return result;
    }

    /**
     * Runs precision local-navigation-frame inertial navigation equations.
     * NOTE: only the attitude update and specific force frame transformation
     * phases are precise.
     *
     * @param timeInterval time interval between epochs.
     * @param oldLatitude  previous latitude expressed in radians (rad).
     * @param oldLongitude previous longitude expressed in radians (rad).
     * @param oldHeight    previous height expressed in meters (m).
     * @param oldC         previous body-to-NED coordinate transformation.
     * @param oldVn        previous velocity north-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param oldVe        previous velocity east-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param oldVd        previous velocity down-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @return estimated NED frame containing new body position, velocity and coordinate
     * transformation matrix.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-NED-frame coordinate transformation matrix are
     *                                                       invalid.
     */
    public static NEDFrame navigateNEDAndReturnNew(final Time timeInterval,
                                                   final double oldLatitude,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L11749">11749</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L13294">13294</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>                                                   final double fz,
                                                   final double angularRateX,
                                                   final double angularRateY,
                                                   final double angularRateZ)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        final NEDFrame result = new NEDFrame();
        navigateNED(timeInterval, oldLatitude, oldLongitude, oldHeight, oldC,
                oldVn, oldVe, oldVd, fx, fy, fz, angularRateX, angularRateY,
                angularRateZ, result);
        return result;
    }

    /**
     * Runs precision local-navigation-frame inertial navigation equations.
     * NOTE: only the attitude update and specific force frame transformation
     * phases are precise.
     *
     * @param timeInterval time interval between epochs.
     * @param oldLatitude  previous latitude expressed in radians (rad).
     * @param oldLongitude previous longitude expressed in radians (rad).
     * @param oldHeight    previous height expressed in meters (m).
     * @param oldC         previous body-to-NED coordinate transformation.
     * @param oldVn        previous velocity north-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param oldVe        previous velocity east-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param oldVd        previous velocity down-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @return estimated NED frame containing new body position, velocity and coordinate
     * transformation matrix.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-NED-frame coordinate transformation matrix are
     *                                                       invalid.
     */
    public static NEDFrame navigateNEDAndReturnNew(final Time timeInterval,
                                                   final double oldLatitude,
                                                   final double oldLongitude,
                                                   final double oldHeight,
                                                   final CoordinateTransformation oldC,
                                                   final double oldVn,
                                                   final double oldVe,
                                                   final double oldVd,
                                                   final double fx,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L11752">11752</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L13737">13737</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>                                                   final double angularRateZ)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        final NEDFrame result = new NEDFrame();
        navigateNED(timeInterval, oldLatitude, oldLongitude, oldHeight, oldC,
                oldVn, oldVe, oldVd, fx, fy, fz, angularRateX, angularRateY,
                angularRateZ, result);
        return result;
    }

    /**
     * Runs precision local-navigation-frame inertial navigation equations.
     * NOTE: only the attitude update and specific force frame transformation
     * phases are precise.
     *
     * @param timeInterval time interval between epochs.
     * @param oldLatitude  previous latitude expressed in radians (rad).
     * @param oldLongitude previous longitude expressed in radians (rad).
     * @param oldHeight    previous height expressed in meters (m).
     * @param oldC         previous body-to-NED coordinate transformation.
     * @param oldVn        previous velocity north-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param oldVe        previous velocity east-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param oldVd        previous velocity down-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @return estimated NED frame containing new body position, velocity and coordinate
     * transformation matrix.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-NED-frame coordinate transformation matrix are
     *                                                       invalid.
     */
    public static NEDFrame navigateNEDAndReturnNew(final Time timeInterval,
                                                   final double oldLatitude,
                                                   final double oldLongitude,
                                                   final double oldHeight,
                                                   final CoordinateTransformation oldC,
                                                   final double oldVn,
                                                   final double oldVe,
                                                   final double oldVd,
                                                   final double fx,
                                                   final double fy,
                                                   final double fz,
                                                   final double angularRateX,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L11805">11805</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L12559">12559</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>                                                   final double oldHeight,
                                                   final CoordinateTransformation oldC,
                                                   final double oldVn,
                                                   final double oldVe,
                                                   final double oldVd,
                                                   final double fx,
                                                   final double fy,
                                                   final double fz,
                                                   final double angularRateX,
                                                   final double angularRateY,
                                                   final double angularRateZ)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        final NEDFrame result = new NEDFrame();
        navigateNED(timeInterval, oldLatitude, oldLongitude, oldHeight,
                oldC, oldVn, oldVe, oldVd, fx, fy, fz, angularRateX, angularRateY, angularRateZ,
                result);
        return result;
    }

    /**
     * Runs precision local-navigation-frame inertial navigation equations.
     * NOTE: only the attitude update and specific force frame transformation
     * phases are precise.
     *
     * @param timeInterval time interval between epochs expressed in seconds (s).
     * @param oldPosition  previous curvilinear position expressed in terms of latitude,
     *                     longitude and height.
     * @param oldC         previous body-to-NED coordinate transformation.
     * @param oldVn        previous velocity north-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param oldVe        previous velocity east-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param oldVd        previous velocity down-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @return estimated NED frame containing new body position, velocity and coordinate
     * transformation matrix.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-NED-frame coordinate transformation matrix are
     *                                                       invalid.
     */
    public static NEDFrame navigateNEDAndReturnNew(final double timeInterval,
                                                   final NEDPosition oldPosition,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L12888">12888</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L14170">14170</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>                                                   final double oldHeight,
                                                   final CoordinateTransformation oldC,
                                                   final Speed oldSpeedN,
                                                   final Speed oldSpeedE,
                                                   final Speed oldSpeedD,
                                                   final double fx,
                                                   final double fy,
                                                   final double fz,
                                                   final double angularRateX,
                                                   final double angularRateY,
                                                   final double angularRateZ)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        final NEDFrame result = new NEDFrame();
        navigateNED(timeInterval, oldLatitude, oldLongitude, oldHeight, oldC,
                oldSpeedN, oldSpeedE, oldSpeedD, fx, fy, fz, angularRateX,
                angularRateY, angularRateZ, result);
        return result;
    }

    /**
     * Runs precision local-navigation-frame inertial navigation equations.
     * NOTE: only the attitude update and specific force frame transformation
     * phases are precise.
     *
     * @param timeInterval time interval between epochs.
     * @param oldLatitude  previous latitude expressed in radians (rad).
     * @param oldLongitude previous longitude expressed in radians (rad).
     * @param oldHeight    previous height expressed in meters (m).
     * @param oldC         previous body-to-NED coordinate transformation.
     * @param oldSpeedN    previous velocity north-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes.
     * @param oldSpeedE    previous velocity east-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes.
     * @param oldSpeedD    previous velocity down-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes.
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @return estimated NED frame containing new body position, velocity and coordinate
     * transformation matrix.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-NED-frame coordinate transformation matrix are
     *                                                       invalid.
     */
    public static NEDFrame navigateNEDAndReturnNew(final Time timeInterval,
                                                   final double oldLatitude,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L12951">12951</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L14233">14233</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>                                                   final double oldHeight,
                                                   final CoordinateTransformation oldC,
                                                   final Speed oldSpeedN,
                                                   final Speed oldSpeedE,
                                                   final Speed oldSpeedD,
                                                   final double fx,
                                                   final double fy,
                                                   final double fz,
                                                   final double angularRateX,
                                                   final double angularRateY,
                                                   final double angularRateZ)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        final NEDFrame result = new NEDFrame();
        navigateNED(timeInterval, oldLatitude, oldLongitude, oldHeight,
                oldC, oldSpeedN, oldSpeedE, oldSpeedD, fx, fy, fz, angularRateX,
                angularRateY, angularRateZ, result);
        return result;
    }

    /**
     * Runs precision local-navigation-frame inertial navigation equations.
     * NOTE: only the attitude update and specific force frame transformation
     * phases are precise.
     *
     * @param timeInterval time interval between epochs expressed in seconds (s).
     * @param oldPosition  previous curvilinear position expressed in terms of latitude,
     *                     longitude and height.
     * @param oldC         previous body-to-NED coordinate transformation.
     * @param oldSpeedN    previous velocity north-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes.
     * @param oldSpeedE    previous velocity east-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes.
     * @param oldSpeedD    previous velocity down-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes.
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @return estimated NED frame containing new body position, velocity and coordinate
     * transformation matrix.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-NED-frame coordinate transformation matrix are
     *                                                       invalid.
     */
    public static NEDFrame navigateNEDAndReturnNew(final double timeInterval,
                                                   final NEDPosition oldPosition,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L13297">13297</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L15050">15050</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>                                                   final double angularRateZ)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        final NEDFrame result = new NEDFrame();
        navigateNED(timeInterval, oldLatitude, oldLongitude, oldHeight, oldC,
                oldVn, oldVe, oldVd, fx, fy, fz,
                angularRateX, angularRateY, angularRateZ, result);
        return result;
    }

    /**
     * Runs precision local-navigation-frame inertial navigation equations.
     * NOTE: only the attitude update and specific force frame transformation
     * phases are precise.
     *
     * @param timeInterval time interval between epochs.
     * @param oldLatitude  previous latitude expressed in radians (rad).
     * @param oldLongitude previous longitude expressed in radians (rad).
     * @param oldHeight    previous height expressed in meters (m).
     * @param oldC         previous body-to-NED coordinate transformation.
     * @param oldVn        previous velocity north-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param oldVe        previous velocity east-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param oldVd        previous velocity down-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in radians per second (rad/s).
     * @return estimated NED frame containing new body position, velocity and coordinate
     * transformation matrix.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-NED-frame coordinate transformation matrix are
     *                                                       invalid.
     */
    public static NEDFrame navigateNEDAndReturnNew(final Time timeInterval,
                                                   final double oldLatitude,
                                                   final double oldLongitude,
                                                   final double oldHeight,
                                                   final CoordinateTransformation oldC,
                                                   final double oldVn,
                                                   final double oldVe,
                                                   final double oldVd,
                                                   final Acceleration fx,
                                                   final Acceleration fy,
                                                   final Acceleration fz,
                                                   final double angularRateX,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L13734">13734</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L15047">15047</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>                                                   final double fz,
                                                   final AngularSpeed angularRateX,
                                                   final AngularSpeed angularRateY,
                                                   final AngularSpeed angularRateZ)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        final NEDFrame result = new NEDFrame();
        navigateNED(timeInterval, oldLatitude, oldLongitude, oldHeight, oldC,
                oldVn, oldVe, oldVd, fx, fy, fz,
                angularRateX, angularRateY, angularRateZ, result);
        return result;
    }

    /**
     * Runs precision local-navigation-frame inertial navigation equations.
     * NOTE: only the attitude update and specific force frame transformation
     * phases are precise.
     *
     * @param timeInterval time interval between epochs.
     * @param oldLatitude  previous latitude expressed in radians (rad).
     * @param oldLongitude previous longitude expressed in radians (rad).
     * @param oldHeight    previous height expressed in meters (m).
     * @param oldC         previous body-to-NED coordinate transformation.
     * @param oldVn        previous velocity north-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param oldVe        previous velocity east-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param oldVd        previous velocity down-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval and
     *                     expressed in meters per squared second (m/s^2).
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @return estimated NED frame containing new body position, velocity and coordinate
     * transformation matrix.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-NED-frame coordinate transformation matrix are
     *                                                       invalid.
     */
    public static NEDFrame navigateNEDAndReturnNew(final Time timeInterval,
                                                   final double oldLatitude,
                                                   final double oldLongitude,
                                                   final double oldHeight,
                                                   final CoordinateTransformation oldC,
                                                   final double oldVn,
                                                   final double oldVe,
                                                   final double oldVd,
                                                   final double fx,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L14290">14290</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L14404">14404</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>                                                   final Distance oldHeight,
                                                   final CoordinateTransformation oldC,
                                                   final Speed oldSpeedN,
                                                   final Speed oldSpeedE,
                                                   final Speed oldSpeedD,
                                                   final Acceleration fx,
                                                   final Acceleration fy,
                                                   final Acceleration fz,
                                                   final AngularSpeed angularRateX,
                                                   final AngularSpeed angularRateY,
                                                   final AngularSpeed angularRateZ)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        final NEDFrame result = new NEDFrame();
        navigateNED(timeInterval, oldLatitude, oldLongitude, oldHeight,
                oldC, oldSpeedN, oldSpeedE, oldSpeedD, fx, fy, fz,
                angularRateX, angularRateY, angularRateZ, result);
        return result;
    }

    /**
     * Runs precision local-navigation-frame inertial navigation equations.
     * NOTE: only the attitude update and specific force frame transformation
     * phases are precise.
     *
     * @param timeInterval time interval between epochs.
     * @param oldLatitude  previous latitude angle.
     * @param oldLongitude previous longitude angle.
     * @param oldHeight    previous height.
     * @param oldC         previous body-to-NED coordinate transformation.
     * @param oldSpeedN    previous velocity north-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes.
     * @param oldSpeedE    previous velocity east-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes.
     * @param oldSpeedD    previous velocity down-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes.
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @return estimated NED frame containing new body position, velocity and coordinate
     * transformation matrix.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-NED-frame coordinate transformation matrix are
     *                                                       invalid.
     */
    public static NEDFrame navigateNEDAndReturnNew(final Time timeInterval,
                                                   final Angle oldLatitude,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L14347">14347</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L14461">14461</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>                                                   final Distance oldHeight,
                                                   final CoordinateTransformation oldC,
                                                   final Speed oldSpeedN,
                                                   final Speed oldSpeedE,
                                                   final Speed oldSpeedD,
                                                   final Acceleration fx,
                                                   final Acceleration fy,
                                                   final Acceleration fz,
                                                   final AngularSpeed angularRateX,
                                                   final AngularSpeed angularRateY,
                                                   final AngularSpeed angularRateZ)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        final NEDFrame result = new NEDFrame();
        navigateNED(timeInterval, oldLatitude, oldLongitude, oldHeight,
                oldC, oldSpeedN, oldSpeedE, oldSpeedD, fx, fy, fz, angularRateX,
                angularRateY, angularRateZ, result);
        return result;
    }

    /**
     * Runs precision local-navigation-frame inertial navigation equations.
     * NOTE: only the attitude update and specific force frame transformation
     * phases are precise.
     *
     * @param timeInterval time interval between epochs expressed in seconds (s).
     * @param oldLatitude  previous latitude expressed in radians (rad).
     * @param oldLongitude previous longitude expressed in radians (rad).
     * @param oldHeight    previous height expressed in meters (m).
     * @param oldC         previous body-to-NED coordinate transformation.
     * @param oldSpeedN    previous velocity north-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes.
     * @param oldSpeedE    previous velocity east-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes.
     * @param oldSpeedD    previous velocity down-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes.
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @return estimated NED frame containing new body position, velocity and coordinate
     * transformation matrix.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-NED-frame coordinate transformation matrix are
     *                                                       invalid.
     */
    public static NEDFrame navigateNEDAndReturnNew(final double timeInterval,
                                                   final double oldLatitude,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L14820">14820</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L15040">15040</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>                                                   final Distance oldHeight,
                                                   final CoordinateTransformation oldC,
                                                   final double oldVn,
                                                   final double oldVe,
                                                   final double oldVd,
                                                   final Acceleration fx,
                                                   final Acceleration fy,
                                                   final Acceleration fz,
                                                   final AngularSpeed angularRateX,
                                                   final AngularSpeed angularRateY,
                                                   final AngularSpeed angularRateZ)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        final NEDFrame result = new NEDFrame();
        navigateNED(timeInterval, oldLatitude, oldLongitude, oldHeight,
                oldC, oldVn, oldVe, oldVd, fx, fy, fz,
                angularRateX, angularRateY, angularRateZ, result);
        return result;
    }

    /**
     * Runs precision local-navigation-frame inertial navigation equations.
     * NOTE: only the attitude update and specific force frame transformation
     * phases are precise.
     *
     * @param timeInterval time interval between epochs.
     * @param oldLatitude  previous latitude angle.
     * @param oldLongitude previous longitude angle.
     * @param oldHeight    previous height.
     * @param oldC         previous body-to-NED coordinate transformation.
     * @param oldVn        previous velocity north-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param oldVe        previous velocity east-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param oldVd        previous velocity down-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @return estimated NED frame containing new body position, velocity and coordinate
     * transformation matrix.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-NED-frame coordinate transformation matrix are
     *                                                       invalid.
     */
    public static NEDFrame navigateNEDAndReturnNew(final Time timeInterval,
                                                   final Angle oldLatitude,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L14877">14877</a></td></tr>
<tr class="b">
<td>com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.java</td>
<td><a href="./xref/com/irurueta/navigation/inertial/navigators/NEDInertialNavigator.html#L15097">15097</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>                                                   final Distance oldHeight,
                                                   final CoordinateTransformation oldC,
                                                   final double oldVn,
                                                   final double oldVe,
                                                   final double oldVd,
                                                   final Acceleration fx,
                                                   final Acceleration fy,
                                                   final Acceleration fz,
                                                   final AngularSpeed angularRateX,
                                                   final AngularSpeed angularRateY,
                                                   final AngularSpeed angularRateZ)
            throws InertialNavigatorException, InvalidSourceAndDestinationFrameTypeException {
        final NEDFrame result = new NEDFrame();
        navigateNED(timeInterval, oldLatitude, oldLongitude, oldHeight,
                oldC, oldVn, oldVe, oldVd, fx, fy, fz, angularRateX, angularRateY,
                angularRateZ, result);
        return result;
    }

    /**
     * Runs precision local-navigation-frame inertial navigation equations.
     * NOTE: only the attitude update and specific force frame transformation
     * phases are precise.
     *
     * @param timeInterval time interval between epochs expressed in seconds (s).
     * @param oldPosition  previous curvilinear position expressed in terms of latitude,
     *                     longitude and height.
     * @param oldC         previous body-to-NED coordinate transformation.
     * @param oldVn        previous velocity north-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param oldVe        previous velocity east-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param oldVd        previous velocity down-coordinate of body frame with respect ECEF frame,
     *                     resolved along NED-frame axes and expressed in meters per second (m/s).
     * @param fx           specific force x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fy           specific force y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param fz           specific force z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateX angular rate x-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateY angular rate y-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @param angularRateZ angular rate z-coordinate of body frame with respect ECEF frame,
     *                     resolved along body-frame axes, averaged over time interval.
     * @return estimated NED frame containing new body position, velocity and coordinate
     * transformation matrix.
     * @throws InertialNavigatorException                    if navigation fails due to numerical instabilities.
     * @throws InvalidSourceAndDestinationFrameTypeException if source or destination frame types of previous
     *                                                       body-to-NED-frame coordinate transformation matrix are
     *                                                       invalid.
     */
    public static NEDFrame navigateNEDAndReturnNew(final double timeInterval,
                                                   final NEDPosition oldPosition,</pre></div></td></tr></table></div>
      </div>
    </div>
    <div class="clear">
      <hr/>
    </div>
    <div id="footer">
      <div class="xright">
        Copyright &#169;      2018&#x2013;2020.All rights reserved.      </div>
      <div class="clear">
        <hr/>
      </div>
    </div>
  </body>
</html>
